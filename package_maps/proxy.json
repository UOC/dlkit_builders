{
   "name": "proxy", 
   "version": "3.0.0", 
   "title": "Proxy Open Service Interface Definitions", 
   "copyright": "Copyright (c) 2008 Massachusetts Institute of Technology.\n\nCopyright (c) 2010 Ingenescus. All Rights Reserved.", 
   "license": "This Work is being provided by the copyright holder(s) subject to the\nfollowing license. By obtaining, using and/or copying this Work, you\nagree that you have read, understand, and will comply with the following\nterms and conditions.\n\nPermission to use, copy and distribute unmodified versions of this Work,\nfor any purpose, without fee or royalty is hereby granted, provided that\nyou include the above copyright notices and the terms of this license on\nALL copies of the Work or portions thereof.\n\nYou may nodify or create Derivatives of this Work only for your internal\npurposes. You shall not distribute or transfer any such Derivative of\nthis Work to any location or to any third party. For the purposes of\nthis license, \"Derivative\" shall mean any derivative of the Work as\ndefined in the United States Copyright Act of 1976, such as a\ntranslation or modification.\n\nThis Work and the information contained herein is provided on an \"AS IS\"\nbasis WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT\nNOT LIMITED TO WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR\nPURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\nHOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN\nAN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\nCONNECTION WITH THE WORK OR THE USE OR OTHER DEALINGS IN THE WORK.\n\nThe export of software employing encryption technology may require a\nspecific license from the United States Government. It is the\nresponsibility of any person or organization contemplating export to\nobtain such a license before exporting this Work.", 
   "summary": "The Proxy OSID helps a consumer map external data, such as that received\nvia a server request, into a Proxy that can be used with OSID proxy\nmanagers. Then purpose of this OSID is to modularize assumptions made\nabout the input data into another OSID Provider, such as the\nauthentication or localization information.\n\nThe ``Proxy`` represents the ``OsidResult`` of an evaluation of the\ninput ``OsidCondition`` performed by the Proxy OSID Provider. The\nresulting Proxy is meant to be passed to ``OsidProxyManagers``. The\nProxy OSID is the glue between the application server environment and\nthe OSID services.\n\nThe input data may be anything acceptable to a ``ProxyCondition`` record\nType. The ``ProxyCondition`` record ``Types`` are aligned with the\napplication server environment while the ``Proxy`` record ``Types`` are\naligned with OSID Providers. This alignment poses various\ninteroperability issues and as such it might be helpful to be very broad\nin what may be specified in a ``ProxyCondition`` so that this service\nmay produce the variety of ``Proxy`` records needed by the services in\nthe OSID environment.\n\nSome data is defined in the ``ProxyCondition``. This in no way implies\nsupport of this input by an OSID Provider. The resulting ``OsidSession``\nindicates what actually happened.\n\nExample\n\nAn example using a specifier record for an http request:\n  ProxyCondition condition = proxySession.getProxyCondition();\n  HttpRequestRecord record = condition.getProxyConditionRecord(httpRequestRecordType);\n  record.setHttpRequest(servletRequest);\n  \n  Proxy proxy = proxySession.getProxy(condition);\n\n", 
   "interfaces": [
      {
         "fullname": "osid.proxy.ProxyProfile", 
         "shortname": "ProxyProfile", 
         "category": "managers", 
         "doc": {
            "headline": "The ``ProxyProfile`` describes the interoperability among proxy services.", 
            "body": ""
         }, 
         "inherit_fullnames": [
            "osid.OsidProfile"
         ], 
         "inherit_shortnames": [
            "OsidProfile"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidProfile"
            }
         ], 
         "method_names": [
            "supports_proxy", 
            "get_proxy_record_types", 
            "supports_proxy_record_type", 
            "get_proxy_condition_record_types", 
            "supports_proxy_condition_record_type"
         ], 
         "methods": [
            {
               "name": "supports_proxy", 
               "doc": {
                  "headline": "Tests if a proxy session is supported.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if proxy is supported ``,``\n                ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if proxy is supported ``,``  ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "get_proxy_record_types", 
               "doc": {
                  "headline": "Gets the supported ``Proxy`` record interface types.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.type.TypeList) - a list containing the supported\n                ``Proxy`` record types", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: a list containing the supported ``Proxy`` record types\n        :rtype: ``osid.type.TypeList``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.type.TypeList", 
               "errors": {}
            }, 
            {
               "name": "supports_proxy_record_type", 
               "doc": {
                  "headline": "Tests if the given ``Proxy`` record interface type is supported.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    proxy_record_type (osid.type.Type): a ``Type``\n                indicating a ``Proxy`` record type\n", 
               "return_doc": "        return: (boolean) - ``true`` if the given type is supported,\n                ``false`` otherwise", 
               "error_doc": "        raise:  NullArgument - ``proxy_record_type`` is ``null``", 
               "sphinx_param_doc": "        :param proxy_record_type: a ``Type`` indicating a ``Proxy`` record type\n        :type proxy_record_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "        :return: ``true`` if the given type is supported, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``proxy_record_type`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "proxy_record_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "boolean", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "get_proxy_condition_record_types", 
               "doc": {
                  "headline": "Gets the supported ``ProxyCondition`` record interface types.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.type.TypeList) - a list containing the supported\n                ``ProxyCondition`` record types", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: a list containing the supported ``ProxyCondition`` record types\n        :rtype: ``osid.type.TypeList``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.type.TypeList", 
               "errors": {}
            }, 
            {
               "name": "supports_proxy_condition_record_type", 
               "doc": {
                  "headline": "Tests if the given ``ProxyCondition`` record interface type is supported.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    proxy_condition_record_type (osid.type.Type): a ``Type``\n                indicating a ``ProxyCondition`` record type\n", 
               "return_doc": "        return: (boolean) - ``true`` if the given type is supported,\n                ``false`` otherwise", 
               "error_doc": "        raise:  NullArgument - ``proxy_condition_record_type`` is\n                ``null``", 
               "sphinx_param_doc": "        :param proxy_condition_record_type: a ``Type`` indicating a ``ProxyCondition`` record type\n        :type proxy_condition_record_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "        :return: ``true`` if the given type is supported, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``proxy_condition_record_type`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "proxy_condition_record_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "boolean", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.proxy.ProxyManager", 
         "shortname": "ProxyManager", 
         "category": "managers", 
         "doc": {
            "headline": "The proxy manager provides access to proxy sessions and provides interoperability tests for various aspects of this service.", 
            "body": "    The sessions included in this manager are:\n\n      * ``ProxySession:`` a session to acquire proxy interfaces\n"
         }, 
         "inherit_fullnames": [
            "osid.OsidManager", 
            "osid.proxy.ProxyProfile"
         ], 
         "inherit_shortnames": [
            "OsidManager", 
            "ProxyProfile"
         ], 
         "inherit_pkg_names": [
            "osid", 
            "proxy"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidManager"
            }, 
            {
               "pkg_name": "proxy", 
               "name": "ProxyProfile"
            }
         ], 
         "method_names": [
            "get_proxy_session"
         ], 
         "methods": [
            {
               "name": "get_proxy_session", 
               "doc": {
                  "headline": "Gets a ``ProxySession`` which is responsible for acquiring authentication credentials on behalf of a service client.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.proxy.ProxySession) - a proxy session for this\n                service", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_proxy()`` is ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: a proxy session for this service\n        :rtype: ``osid.proxy.ProxySession``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_proxy()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_proxy()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.proxy.ProxySession", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.proxy.ProxyProxyManager", 
         "shortname": "ProxyProxyManager", 
         "category": "managers", 
         "doc": {
            "headline": "The proxy proxy manager provides access to proxy sessions and provides interoperability tests for various aspects of this service.", 
            "body": "    Methods in this manager support the passing of a ``Proxy``. The\n    sessions included in this manager are:\n\n      * ``ProxySession:`` a session to acquire proxies\n"
         }, 
         "inherit_fullnames": [
            "osid.OsidProxyManager", 
            "osid.proxy.ProxyProfile"
         ], 
         "inherit_shortnames": [
            "OsidProxyManager", 
            "ProxyProfile"
         ], 
         "inherit_pkg_names": [
            "osid", 
            "proxy"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidProxyManager"
            }, 
            {
               "pkg_name": "proxy", 
               "name": "ProxyProfile"
            }
         ], 
         "method_names": [
            "get_proxy_session"
         ], 
         "methods": [
            {
               "name": "get_proxy_session", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` associated with the ``ProxySession`` using the supplied ``Proxy``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    proxy (osid.proxy.Proxy): proxy\n", 
               "return_doc": "        return: (osid.proxy.ProxySession) - a ``ProxySession``", 
               "error_doc": "        raise:  NullArgument - ``proxy`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_proxy()`` is ``false``", 
               "sphinx_param_doc": "        :param proxy: proxy\n        :type proxy: ``osid.proxy.Proxy``\n", 
               "sphinx_return_doc": "        :return: a ``ProxySession``\n        :rtype: ``osid.proxy.ProxySession``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``proxy`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_proxy()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_proxy()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.proxy.Proxy", 
                     "var_name": "proxy", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.proxy.Proxy"
               ], 
               "return_type": "osid.proxy.ProxySession", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.proxy.ProxySession", 
         "shortname": "ProxySession", 
         "category": "sessions", 
         "doc": {
            "headline": "This session converts external data into a proxy for use in OSID proxy managers.", 
            "body": "    The external data is specified in the form of a ``ProxyCondition``."
         }, 
         "inherit_fullnames": [
            "osid.OsidSession"
         ], 
         "inherit_shortnames": [
            "OsidSession"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidSession"
            }
         ], 
         "method_names": [
            "get_proxy_condition", 
            "get_proxy"
         ], 
         "methods": [
            {
               "name": "get_proxy_condition", 
               "doc": {
                  "headline": "Gets a proxy condition for acquiring a proxy.", 
                  "body": "        A new proxy condition should be acquired for each proxy request."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.proxy.ProxyCondition) - a proxy condiiton", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: a proxy condiiton\n        :rtype: ``osid.proxy.ProxyCondition``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.proxy.ProxyCondition", 
               "errors": {}
            }, 
            {
               "name": "get_proxy", 
               "doc": {
                  "headline": "Gets a proxy.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    input (osid.proxy.ProxyCondition): a proxy condition\n", 
               "return_doc": "        return: (osid.proxy.Proxy) - a proxy", 
               "error_doc": "        raise:  NullArgument - ``input`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        raise:  Unsupported - ``input`` is not of this service", 
               "sphinx_param_doc": "        :param input: a proxy condition\n        :type input: ``osid.proxy.ProxyCondition``\n", 
               "sphinx_return_doc": "        :return: a proxy\n        :rtype: ``osid.proxy.Proxy``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``input`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure\n        :raise: ``Unsupported`` -- ``input`` is not of this service", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.proxy.ProxyCondition", 
                     "var_name": "input", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.proxy.ProxyCondition"
               ], 
               "return_type": "osid.proxy.Proxy", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.proxy.Proxy", 
         "shortname": "Proxy", 
         "category": "rules", 
         "doc": {
            "headline": "A ``Proxy`` is used to transfer external information from an application server into an OSID Provider.", 
            "body": ""
         }, 
         "inherit_fullnames": [
            "osid.OsidResult"
         ], 
         "inherit_shortnames": [
            "OsidResult"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidResult"
            }
         ], 
         "method_names": [
            "has_authentication", 
            "get_authentication", 
            "has_effective_agent", 
            "get_effective_agent_id", 
            "get_effective_agent", 
            "has_effective_date", 
            "get_effective_date", 
            "get_effective_clock_rate", 
            "get_locale", 
            "has_format_type", 
            "get_format_type", 
            "get_proxy_record"
         ], 
         "methods": [
            {
               "name": "has_authentication", 
               "doc": {
                  "headline": "Tests if an authentication is available.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if an ``Authentication`` is\n                available, ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if an ``Authentication`` is available, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "get_authentication", 
               "doc": {
                  "headline": "Gets the ``Authentication`` for this proxy.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.authentication.process.Authentication) - the\n                authentication", 
               "error_doc": "        raise:  IllegalState - ``has_authentication()`` is ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the authentication\n        :rtype: ``osid.authentication.process.Authentication``", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- ``has_authentication()`` is ``false``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.authentication.process.Authentication", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract"
               }
            }, 
            {
               "name": "has_effective_agent", 
               "doc": {
                  "headline": "Tests if an effective agent is available.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if an effective agent is available,\n                ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if an effective agent is available, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "get_effective_agent_id", 
               "doc": {
                  "headline": "Gets the effective ``Agent Id`` for this proxy.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.id.Id) - the effective agent ``Id``", 
               "error_doc": "        raise:  IllegalState - ``has_effective_agent()`` is ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the effective agent ``Id``\n        :rtype: ``osid.id.Id``", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- ``has_effective_agent()`` is ``false``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.id.Id", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract"
               }
            }, 
            {
               "name": "get_effective_agent", 
               "doc": {
                  "headline": "Gets the effective ``Agent`` for this proxy.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.authentication.Agent) - the effective agent", 
               "error_doc": "        raise:  IllegalState - ``has_effective_agent()`` is ``false``\n        raise:  OperationFailed - unable to complete request", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the effective agent\n        :rtype: ``osid.authentication.Agent``", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- ``has_effective_agent()`` is ``false``\n        :raise: ``OperationFailed`` -- unable to complete request", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.authentication.Agent", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational"
               }
            }, 
            {
               "name": "has_effective_date", 
               "doc": {
                  "headline": "Tests if an effective date is available.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if an effective date is available,\n                ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if an effective date is available, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "get_effective_date", 
               "doc": {
                  "headline": "Gets the effective date.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (timestamp) - the effective date", 
               "error_doc": "        raise:  IllegalState - ``has_effective_date()`` is ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the effective date\n        :rtype: ``timestamp``", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- ``has_effective_date()`` is ``false``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "timestamp", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract"
               }
            }, 
            {
               "name": "get_effective_clock_rate", 
               "doc": {
                  "headline": "Gets the rate of the clock.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (decimal) - the rate", 
               "error_doc": "        raise:  IllegalState - ``has_effective_date()`` is ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the rate\n        :rtype: ``decimal``", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- ``has_effective_date()`` is ``false``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "decimal", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract"
               }
            }, 
            {
               "name": "get_locale", 
               "doc": {
                  "headline": "Gets the locale.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.locale.Locale) - a locale", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: a locale\n        :rtype: ``osid.locale.Locale``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.locale.Locale", 
               "errors": {}
            }, 
            {
               "name": "has_format_type", 
               "doc": {
                  "headline": "Tests if a ``DisplayText`` format ``Type`` is available.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if a format type is available,\n                ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if a format type is available, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "get_format_type", 
               "doc": {
                  "headline": "Gets the ``DisplayText`` format ``Type``.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.type.Type) - the format ``Type``", 
               "error_doc": "        raise:  IllegalState - ``has_format_type()`` is ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the format ``Type``\n        :rtype: ``osid.type.Type``", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- ``has_format_type()`` is ``false``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.type.Type", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract"
               }
            }, 
            {
               "name": "get_proxy_record", 
               "doc": {
                  "headline": "Gets the proxy record corresponding to the given ``Proxy`` record ``Type``.", 
                  "body": "        This method is used to retrieve an object implementing the\n        requested record. The ``proxy_record_type`` may be the ``Type``\n        returned in ``get_record_types()`` or any of its parents in a\n        ``Type`` hierarchy where ``has_record_type(proxy_record_type)``\n        is ``true`` ."
               }, 
               "arg_doc": "        arg:    proxy_record_type (osid.type.Type): the type of proxy\n                record to retrieve\n", 
               "return_doc": "        return: (osid.proxy.records.ProxyRecord) - the proxy record", 
               "error_doc": "        raise:  NullArgument - ``proxy_record_type`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unsupported - ``has_record_type(proxy_record_type)`` is\n                ``false``", 
               "sphinx_param_doc": "        :param proxy_record_type: the type of proxy record to retrieve\n        :type proxy_record_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "        :return: the proxy record\n        :rtype: ``osid.proxy.records.ProxyRecord``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``proxy_record_type`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unsupported`` -- ``has_record_type(proxy_record_type)`` is ``false``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "proxy_record_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "osid.proxy.records.ProxyRecord", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.proxy.records.ProxyRecord", 
         "shortname": "ProxyRecord", 
         "category": "records", 
         "doc": {
            "headline": "A record for a ``Proxy``.", 
            "body": "    The methods specified by the record type are available through the\n    underlying object."
         }, 
         "inherit_fullnames": [
            "osid.OsidRecord"
         ], 
         "inherit_shortnames": [
            "OsidRecord"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidRecord"
            }
         ], 
         "method_names": [], 
         "methods": []
      }, 
      {
         "fullname": "osid.proxy.ProxyCondition", 
         "shortname": "ProxyCondition", 
         "category": "rules", 
         "doc": {
            "headline": "A ``ProxyCondition`` is used to transfer external information into a proxy.", 
            "body": ""
         }, 
         "inherit_fullnames": [
            "osid.OsidCondition"
         ], 
         "inherit_shortnames": [
            "OsidCondition"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidCondition"
            }
         ], 
         "method_names": [
            "set_effective_agent_id", 
            "set_effective_date", 
            "set_language_type", 
            "set_script_type", 
            "set_calendar_type", 
            "set_time_type", 
            "set_currency_type", 
            "set_unit_system_type", 
            "set_format_type", 
            "get_proxy_condition_record"
         ], 
         "methods": [
            {
               "name": "set_effective_agent_id", 
               "doc": {
                  "headline": "Sets the effective agent ``Id`` to indicate acting on behalf of.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    agent_id (osid.id.Id): an agent ``Id``\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``agent_id`` is ``null``", 
               "sphinx_param_doc": "        :param agent_id: an agent ``Id``\n        :type agent_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``agent_id`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "agent_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "set_effective_date", 
               "doc": {
                  "headline": "Sets the effective date.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    date (timestamp): a date\n        arg:    rate (decimal): the rate at which the clock should tick\n                from the given effective date. 0 is a clock that is\n                fixed\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``date`` is ``null``", 
               "sphinx_param_doc": "        :param date: a date\n        :type date: ``timestamp``\n        :param rate: the rate at which the clock should tick from the given effective date. 0 is a clock that is fixed\n        :type rate: ``decimal``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``date`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "timestamp", 
                     "var_name": "date", 
                     "array": false
                  }, 
                  {
                     "arg_type": "decimal", 
                     "var_name": "rate", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "timestamp", 
                  "decimal"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "set_language_type", 
               "doc": {
                  "headline": "Sets the language type.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    language_type (osid.type.Type): the language type\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``language_type`` is ``null``", 
               "sphinx_param_doc": "        :param language_type: the language type\n        :type language_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``language_type`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "language_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "set_script_type", 
               "doc": {
                  "headline": "Sets the script type.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    script_type (osid.type.Type): the script type\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``script_type`` is ``null``", 
               "sphinx_param_doc": "        :param script_type: the script type\n        :type script_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``script_type`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "script_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "set_calendar_type", 
               "doc": {
                  "headline": "Sets the calendar type.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    calendar_type (osid.type.Type): the calendar type\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``calendar_type`` is ``null``", 
               "sphinx_param_doc": "        :param calendar_type: the calendar type\n        :type calendar_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``calendar_type`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "calendar_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "set_time_type", 
               "doc": {
                  "headline": "Sets the time type.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    time_type (osid.type.Type): the time type\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``time_type`` is ``null``", 
               "sphinx_param_doc": "        :param time_type: the time type\n        :type time_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``time_type`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "time_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "set_currency_type", 
               "doc": {
                  "headline": "Sets the currency type.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    currency_type (osid.type.Type): the currency type\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``currency_type`` is ``null``", 
               "sphinx_param_doc": "        :param currency_type: the currency type\n        :type currency_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``currency_type`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "currency_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "set_unit_system_type", 
               "doc": {
                  "headline": "Sets the unit system type.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    unit_system_type (osid.type.Type): the unit system type\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``unit_system_type`` is ``null``", 
               "sphinx_param_doc": "        :param unit_system_type: the unit system type\n        :type unit_system_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``unit_system_type`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "unit_system_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "set_format_type", 
               "doc": {
                  "headline": "Sets the ``DisplayText`` format type.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    format_type (osid.type.Type): the format type\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``format_type`` is ``null``", 
               "sphinx_param_doc": "        :param format_type: the format type\n        :type format_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``format_type`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "format_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "get_proxy_condition_record", 
               "doc": {
                  "headline": "Gets the proxy condition record corresponding to the given ``Proxy`` record ``Type``.", 
                  "body": "        This method is used to retrieve an object implementing the\n        requested record. The ``proxy_record_type`` may be the ``Type``\n        returned in ``get_record_types()`` or any of its parents in a\n        ``Type`` hierarchy where ``has_record_type(proxy_record_type)``\n        is ``true`` ."
               }, 
               "arg_doc": "        arg:    proxy_condition_type (osid.type.Type): the type of proxy\n                condition record to retrieve\n", 
               "return_doc": "        return: (osid.proxy.records.ProxyConditionRecord) - the proxy\n                condition record", 
               "error_doc": "        raise:  NullArgument - ``proxy_condition_record_type`` is\n                ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unsupported -\n                ``has_record_type(proxy_condition_record_type)`` is\n                ``false``", 
               "sphinx_param_doc": "        :param proxy_condition_type: the type of proxy condition record to retrieve\n        :type proxy_condition_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "        :return: the proxy condition record\n        :rtype: ``osid.proxy.records.ProxyConditionRecord``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``proxy_condition_record_type`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unsupported`` -- ``has_record_type(proxy_condition_record_type)`` is ``false``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "proxy_condition_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "osid.proxy.records.ProxyConditionRecord", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.proxy.records.ProxyConditionRecord", 
         "shortname": "ProxyConditionRecord", 
         "category": "records", 
         "doc": {
            "headline": "A record for a ``ProxyCondition``.", 
            "body": "    The methods specified by the record type are available through the\n    underlying object."
         }, 
         "inherit_fullnames": [
            "osid.OsidRecord"
         ], 
         "inherit_shortnames": [
            "OsidRecord"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidRecord"
            }
         ], 
         "method_names": [], 
         "methods": []
      }
   ], 
   "full_name": "osid.proxy"
}
{
   "name": "assessment.authoring", 
   "version": "3.0.0", 
   "title": "Assessment Authoring Open Service Interface Definitions", 
   "copyright": "Copyright (c) 2011 Ingenescus. All Rights Reserved.", 
   "license": "This Work is being provided by the copyright holder(s) subject to the\nfollowing license. By obtaining, using and/or copying this Work, you\nagree that you have read, understand, and will comply with the following\nterms and conditions.\n\nPermission to use, copy and distribute unmodified versions of this Work,\nfor any purpose, without fee or royalty is hereby granted, provided that\nyou include the above copyright notices and the terms of this license on\nALL copies of the Work or portions thereof.\n\nYou may nodify or create Derivatives of this Work only for your internal\npurposes. You shall not distribute or transfer any such Derivative of\nthis Work to any location or to any third party. For the purposes of\nthis license, \"Derivative\" shall mean any derivative of the Work as\ndefined in the United States Copyright Act of 1976, such as a\ntranslation or modification.\n\nThis Work and the information contained herein is provided on an \"AS IS\"\nbasis WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT\nNOT LIMITED TO WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR\nPURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\nHOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN\nAN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\nCONNECTION WITH THE WORK OR THE USE OR OTHER DEALINGS IN THE WORK.\n\nThe export of software employing encryption technology may require a\nspecific license from the United States Government. It is the\nresponsibility of any person or organization contemplating export to\nobtain such a license before exporting this Work.", 
   "summary": "The Assessment OSID provides the means to create, access, and take\nassessments. An ``Assessment`` may represent a quiz, survey, or other\nevaluation that includes assessment ``Items``. The OSID defines methods\nto describe the flow of control and the relationships among the objects.\nAssessment ``Items`` are extensible objects to capture various types of\nquestions, such as a multiple choice or asset submission.\n\nThe Assessment service can br broken down into several distinct\nservices:\n\n  * Assessment Taking\n  * Assessment and Item authoring\n  * Accessing and managing banks of assessments and items\n\n\nEach of these service areas are covered by different session and object\ninterfaces. The object interfaces describe both the structure of the\nassessment and follow an assessment management workflow. They are:\n\n  * ``Item`` : a question and answer pair\n  * ``Response:`` a response to an ``Item`` question\n  * ``Assessment`` : a set of ``Items``\n  * ``AssessmentPart:`` A grouped set of ``Items`` for fancier\n    assessment sequencing\n  * ``AssessmentOffering:`` An ``Assessment`` available for taking\n  * ``AssessmentTaken:`` An ``AssessmentOffering`` that has been\n    completed or in progress\n\n\nThe ``AssessmentSession`` is used to take an assessment and review the\nresults. It captures various ways an assessment can be taken which may\ninclude time constraints, the ability to suspend and resume,\navailability of an answer key, or access to a score or other evaluation.\nCare should be taken to understand the various interoperability issues\nin using this interface.\n\nAn ``AssessmentSession`` may be created using an ``AssessmentOffered``\nor ``AssessmentTaken``  ``Id``. If instantiated with an\n``AssessmentOffered``  ``Id,`` an ``AssessmentTaken`` is implicitly\ncreated and further references to its state should be performed using\nthe ``AssessmentTaken``  ``Id``.\n\nAn ``AssessmentSession`` is a mapping of an ``AssessmentOffered`` to an\n``Agent`` at a point in time. The resulting ``AssessmentTaken`` is an\nidentifier representing this relationship.\n\nOn the authoring side, Items map to ``Assessments``. An ``Item`` may\nappear in more than one ``Assessment``. Item banks may be used to\ncatalog sets of Items and/or sets of ``Assessments``.", 
   "interfaces": [
      {
         "fullname": "osid.assessment.authoring.AssessmentAuthoringProfile", 
         "shortname": "AssessmentAuthoringProfile", 
         "category": "managers", 
         "doc": {
            "headline": "The ``AssessmentAuthoringProfile`` describes the interoperability among assessment authoring services.", 
            "body": ""
         }, 
         "inherit_fullnames": [
            "osid.OsidProfile"
         ], 
         "inherit_shortnames": [
            "OsidProfile"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidProfile"
            }
         ], 
         "method_names": [
            "supports_visible_federation", 
            "supports_assessment_part_lookup", 
            "supports_assessment_part_query", 
            "supports_assessment_part_search", 
            "supports_assessment_part_admin", 
            "supports_assessment_part_notification", 
            "supports_assessment_part_bank", 
            "supports_assessment_part_bank_assignment", 
            "supports_assessment_part_smart_bank", 
            "supports_assessment_part_item", 
            "supports_assessment_part_item_design", 
            "supports_sequence_rule_lookup", 
            "supports_sequence_rule_query", 
            "supports_sequence_rule_search", 
            "supports_sequence_rule_admin", 
            "supports_sequence_rule_notification", 
            "supports_sequence_rule_bank", 
            "supports_sequence_rule_bank_assignment", 
            "supports_sequence_rule_smart_bank", 
            "supports_sequence_rule_enabler_lookup", 
            "supports_sequence_rule_enabler_query", 
            "supports_sequence_rule_enabler_search", 
            "supports_sequence_rule_enabler_admin", 
            "supports_sequence_rule_enabler_notification", 
            "supports_sequence_rule_enabler_bank", 
            "supports_sequence_rule_enabler_bank_assignment", 
            "supports_sequence_rule_enabler_smart_bank", 
            "supports_sequence_rule_enabler_rule_lookup", 
            "supports_sequence_rule_enabler_rule_application", 
            "get_assessment_part_record_types", 
            "supports_assessment_part_record_type", 
            "get_assessment_part_search_record_types", 
            "supports_assessment_part_search_record_type", 
            "get_sequence_rule_record_types", 
            "supports_sequence_rule_record_type", 
            "get_sequence_rule_search_record_types", 
            "supports_sequence_rule_search_record_type", 
            "get_sequence_rule_enabler_record_types", 
            "supports_sequence_rule_enabler_record_type", 
            "get_sequence_rule_enabler_search_record_types", 
            "supports_sequence_rule_enabler_search_record_type"
         ], 
         "methods": [
            {
               "name": "supports_visible_federation", 
               "doc": {
                  "headline": "Tests if federation is visible.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if visible federation is supported\n                ``,``  ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if visible federation is supported ``,``  ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "supports_assessment_part_lookup", 
               "doc": {
                  "headline": "Tests if looking up assessment part is supported.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if assessment part lookup is\n                supported, ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if assessment part lookup is supported, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "supports_assessment_part_query", 
               "doc": {
                  "headline": "Tests if querying assessment part is supported.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if assessment part query is\n                supported, ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if assessment part query is supported, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "supports_assessment_part_search", 
               "doc": {
                  "headline": "Tests if searching assessment part is supported.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if assessment part search is\n                supported, ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if assessment part search is supported, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "supports_assessment_part_admin", 
               "doc": {
                  "headline": "Tests if an assessment part administrative service is supported.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if assessment part administration\n                is supported, ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if assessment part administration is supported, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "supports_assessment_part_notification", 
               "doc": {
                  "headline": "Tests if an assessment part notification service is supported.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if assessment part notification is\n                supported, ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if assessment part notification is supported, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "supports_assessment_part_bank", 
               "doc": {
                  "headline": "Tests if an assessment part bank lookup service is supported.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if an assessment part bank lookup\n                service is supported, ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if an assessment part bank lookup service is supported, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "supports_assessment_part_bank_assignment", 
               "doc": {
                  "headline": "Tests if an assessment part bank service is supported.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if assessment part bank assignment\n                service is supported, ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if assessment part bank assignment service is supported, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "supports_assessment_part_smart_bank", 
               "doc": {
                  "headline": "Tests if an assessment part bank lookup service is supported.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if an assessment part bank service\n                is supported, ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if an assessment part bank service is supported, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "supports_assessment_part_item", 
               "doc": {
                  "headline": "Tests if an assessment part item service is supported for looking up assessment part and item mappings.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if assessment part item service is\n                supported, ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if assessment part item service is supported, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "supports_assessment_part_item_design", 
               "doc": {
                  "headline": "Tests if an assessment part item design session is supported.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if an assessment part item design\n                service is supported, ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if an assessment part item design service is supported, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "supports_sequence_rule_lookup", 
               "doc": {
                  "headline": "Tests if looking up sequence rule is supported.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if sequence rule lookup is\n                supported, ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if sequence rule lookup is supported, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "supports_sequence_rule_query", 
               "doc": {
                  "headline": "Tests if querying sequence rule is supported.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if sequence rule query is\n                supported, ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if sequence rule query is supported, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "supports_sequence_rule_search", 
               "doc": {
                  "headline": "Tests if searching sequence rule is supported.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if sequence rule search is\n                supported, ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if sequence rule search is supported, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "supports_sequence_rule_admin", 
               "doc": {
                  "headline": "Tests if a sequence rule administrative service is supported.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if sequence rule administration is\n                supported, ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if sequence rule administration is supported, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "supports_sequence_rule_notification", 
               "doc": {
                  "headline": "Tests if a sequence rule notification service is supported.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if sequence rule notification is\n                supported, ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if sequence rule notification is supported, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "supports_sequence_rule_bank", 
               "doc": {
                  "headline": "Tests if a sequence rule bank lookup service is supported.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if a sequence rule bank lookup\n                service is supported, ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if a sequence rule bank lookup service is supported, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "supports_sequence_rule_bank_assignment", 
               "doc": {
                  "headline": "Tests if a sequence rule bank service is supported.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if sequence rule bank assignment\n                service is supported, ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if sequence rule bank assignment service is supported, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "supports_sequence_rule_smart_bank", 
               "doc": {
                  "headline": "Tests if a sequence rule bank lookup service is supported.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if a sequence rule bank service is\n                supported, ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if a sequence rule bank service is supported, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "supports_sequence_rule_enabler_lookup", 
               "doc": {
                  "headline": "Tests if looking up sequence rule enablers is supported.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if sequence rule enabler lookup is\n                supported, ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if sequence rule enabler lookup is supported, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "supports_sequence_rule_enabler_query", 
               "doc": {
                  "headline": "Tests if querying sequence rule enablers is supported.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if sequence rule enabler query is\n                supported, ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if sequence rule enabler query is supported, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "supports_sequence_rule_enabler_search", 
               "doc": {
                  "headline": "Tests if searching sequence rule enablers is supported.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if sequence rule enabler search is\n                supported, ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if sequence rule enabler search is supported, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "supports_sequence_rule_enabler_admin", 
               "doc": {
                  "headline": "Tests if a sequence rule enabler administrative service is supported.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if sequence rule enabler\n                administration is supported, ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if sequence rule enabler administration is supported, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "supports_sequence_rule_enabler_notification", 
               "doc": {
                  "headline": "Tests if a sequence rule enabler notification service is supported.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if sequence rule enabler\n                notification is supported, ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if sequence rule enabler notification is supported, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "supports_sequence_rule_enabler_bank", 
               "doc": {
                  "headline": "Tests if a sequence rule enabler bank lookup service is supported.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if a sequence rule enabler bank\n                lookup service is supported, ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if a sequence rule enabler bank lookup service is supported, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "supports_sequence_rule_enabler_bank_assignment", 
               "doc": {
                  "headline": "Tests if a sequence rule enabler bank service is supported.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if sequence rule enabler bank\n                assignment service is supported, ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if sequence rule enabler bank assignment service is supported, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "supports_sequence_rule_enabler_smart_bank", 
               "doc": {
                  "headline": "Tests if a sequence rule enabler bank lookup service is supported.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if a sequence rule enabler bank\n                service is supported, ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if a sequence rule enabler bank service is supported, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "supports_sequence_rule_enabler_rule_lookup", 
               "doc": {
                  "headline": "Tests if a sequence rule enabler rule lookup service is supported.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if a sequence rule enabler rule\n                lookup service is supported, ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if a sequence rule enabler rule lookup service is supported, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "supports_sequence_rule_enabler_rule_application", 
               "doc": {
                  "headline": "Tests if a sequence rule enabler rule application service is supported.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if sequence rule enabler rule\n                application service is supported, ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if sequence rule enabler rule application service is supported, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "get_assessment_part_record_types", 
               "doc": {
                  "headline": "Gets the supported ``AssessmentPart`` record types.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.type.TypeList) - a list containing the supported\n                ``AssessmentPart`` record types", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: a list containing the supported ``AssessmentPart`` record types\n        :rtype: ``osid.type.TypeList``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.type.TypeList", 
               "errors": {}
            }, 
            {
               "name": "supports_assessment_part_record_type", 
               "doc": {
                  "headline": "Tests if the given ``AssessmentPart`` record type is supported.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    assessment_part_record_type (osid.type.Type): a ``Type``\n                indicating an ``AssessmentPart`` record type\n", 
               "return_doc": "        return: (boolean) - ``true`` if the given record type is\n                supported, ``false`` otherwise", 
               "error_doc": "        raise:  NullArgument - ``assessment_part_record_type`` is\n                ``null``", 
               "sphinx_param_doc": "        :param assessment_part_record_type: a ``Type`` indicating an ``AssessmentPart`` record type\n        :type assessment_part_record_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "        :return: ``true`` if the given record type is supported, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``assessment_part_record_type`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "assessment_part_record_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "boolean", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "get_assessment_part_search_record_types", 
               "doc": {
                  "headline": "Gets the supported ``AssessmentPart`` search record types.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.type.TypeList) - a list containing the supported\n                ``AssessmentPart`` search record types", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: a list containing the supported ``AssessmentPart`` search record types\n        :rtype: ``osid.type.TypeList``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.type.TypeList", 
               "errors": {}
            }, 
            {
               "name": "supports_assessment_part_search_record_type", 
               "doc": {
                  "headline": "Tests if the given ``AssessmentPart`` search record type is supported.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    assessment_part_search_record_type (osid.type.Type): a\n                ``Type`` indicating an ``AssessmentPart`` search record\n                type\n", 
               "return_doc": "        return: (boolean) - ``true`` if the given search record type is\n                supported, ``false`` otherwise", 
               "error_doc": "        raise:  NullArgument - ``assessment_part_search_record_type`` is\n                ``null``", 
               "sphinx_param_doc": "        :param assessment_part_search_record_type: a ``Type`` indicating an ``AssessmentPart`` search record type\n        :type assessment_part_search_record_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "        :return: ``true`` if the given search record type is supported, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``assessment_part_search_record_type`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "assessment_part_search_record_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "boolean", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "get_sequence_rule_record_types", 
               "doc": {
                  "headline": "Gets the supported ``SequenceRule`` record types.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.type.TypeList) - a list containing the supported\n                ``SequenceRule`` record types", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: a list containing the supported ``SequenceRule`` record types\n        :rtype: ``osid.type.TypeList``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.type.TypeList", 
               "errors": {}
            }, 
            {
               "name": "supports_sequence_rule_record_type", 
               "doc": {
                  "headline": "Tests if the given ``SequenceRule`` record type is supported.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    sequence_rule_record_type (osid.type.Type): a ``Type``\n                indicating a ``SequenceRule`` record type\n", 
               "return_doc": "        return: (boolean) - ``true`` if the given record type is\n                supported, ``false`` otherwise", 
               "error_doc": "        raise:  NullArgument - ``sequence_rule_record_type`` is ``null``", 
               "sphinx_param_doc": "        :param sequence_rule_record_type: a ``Type`` indicating a ``SequenceRule`` record type\n        :type sequence_rule_record_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "        :return: ``true`` if the given record type is supported, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``sequence_rule_record_type`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "sequence_rule_record_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "boolean", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "get_sequence_rule_search_record_types", 
               "doc": {
                  "headline": "Gets the supported ``SequenceRule`` search record types.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.type.TypeList) - a list containing the supported\n                ``SequenceRule`` search record types", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: a list containing the supported ``SequenceRule`` search record types\n        :rtype: ``osid.type.TypeList``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.type.TypeList", 
               "errors": {}
            }, 
            {
               "name": "supports_sequence_rule_search_record_type", 
               "doc": {
                  "headline": "Tests if the given ``SequenceRule`` search record type is supported.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    sequence_rule_search_record_type (osid.type.Type): a\n                ``Type`` indicating a ``SequenceRule`` search record\n                type\n", 
               "return_doc": "        return: (boolean) - ``true`` if the given search record type is\n                supported, ``false`` otherwise", 
               "error_doc": "        raise:  NullArgument - ``sequence_rule_search_record_type`` is\n                ``null``", 
               "sphinx_param_doc": "        :param sequence_rule_search_record_type: a ``Type`` indicating a ``SequenceRule`` search record type\n        :type sequence_rule_search_record_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "        :return: ``true`` if the given search record type is supported, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``sequence_rule_search_record_type`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "sequence_rule_search_record_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "boolean", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "get_sequence_rule_enabler_record_types", 
               "doc": {
                  "headline": "Gets the supported ``SequenceRuleEnabler`` record types.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.type.TypeList) - a list containing the supported\n                ``SequenceRuleEnabler`` record types", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: a list containing the supported ``SequenceRuleEnabler`` record types\n        :rtype: ``osid.type.TypeList``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.type.TypeList", 
               "errors": {}
            }, 
            {
               "name": "supports_sequence_rule_enabler_record_type", 
               "doc": {
                  "headline": "Tests if the given ``SequenceRuleEnabler`` record type is supported.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    sequence_rule_enabler_record_type (osid.type.Type): a\n                ``Type`` indicating a ``SequenceRuleEnabler`` record\n                type\n", 
               "return_doc": "        return: (boolean) - ``true`` if the given record type is\n                supported, ``false`` otherwise", 
               "error_doc": "        raise:  NullArgument - ``sequence_rule_enabler_record_type`` is\n                ``null``", 
               "sphinx_param_doc": "        :param sequence_rule_enabler_record_type: a ``Type`` indicating a ``SequenceRuleEnabler`` record type\n        :type sequence_rule_enabler_record_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "        :return: ``true`` if the given record type is supported, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``sequence_rule_enabler_record_type`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "sequence_rule_enabler_record_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "boolean", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "get_sequence_rule_enabler_search_record_types", 
               "doc": {
                  "headline": "Gets the supported ``SequenceRuleEnabler`` search record types.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.type.TypeList) - a list containing the supported\n                ``SequenceRuleEnabler`` search record types", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: a list containing the supported ``SequenceRuleEnabler`` search record types\n        :rtype: ``osid.type.TypeList``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.type.TypeList", 
               "errors": {}
            }, 
            {
               "name": "supports_sequence_rule_enabler_search_record_type", 
               "doc": {
                  "headline": "Tests if the given ``SequenceRuleEnabler`` search record type is supported.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    sequence_rule_enabler_search_record_type\n                (osid.type.Type): a ``Type`` indicating a\n                ``SequenceRuleEnabler`` search record type\n", 
               "return_doc": "        return: (boolean) - ``true`` if the given search record type is\n                supported, ``false`` otherwise", 
               "error_doc": "        raise:  NullArgument -\n                ``sequence_rule_enabler_search_record_type`` is ``null``", 
               "sphinx_param_doc": "        :param sequence_rule_enabler_search_record_type: a ``Type`` indicating a ``SequenceRuleEnabler`` search record type\n        :type sequence_rule_enabler_search_record_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "        :return: ``true`` if the given search record type is supported, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``sequence_rule_enabler_search_record_type`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "sequence_rule_enabler_search_record_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "boolean", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.assessment.authoring.AssessmentAuthoringManager", 
         "shortname": "AssessmentAuthoringManager", 
         "category": "managers", 
         "doc": {
            "headline": "The assessment authoring manager provides access to assessment authoring sessions and provides interoperability tests for various aspects of this service.", 
            "body": "    The sessions included in this manager are:\n\n      * ``AssessmentPartLookupSession:`` a session to retrieve\n        assessment part\n      * ``AssessmentPartQuerySession:`` a session to query for\n        assessment part\n      * ``AssessmentPartSearchSession:`` a session to search for\n        assessment part\n      * ``AssessmentPartAdminSession:`` a session to create and delete\n        assessment part\n      * ``AssessmentPartNotificationSession:`` a session to receive\n        notifications pertaining to assessment part changes\n      * ``AssessmentPartBankSession:`` a session to look up assessment\n        part bank mappings\n      * ``AssessmentPartBankAssignmentSession:`` a session to manage\n        assessment part to bank mappings\n      * ``AssessmentPartSmartBankSession:`` a session to manage dynamic\n        bank of assessment part\n      * ``AssessmentPartItemSession:`` a session to look up assessment\n        part to item mappings\n      * ``AssessmentPartItemDesignSession:`` a session to map items to\n        assessment parts\n    \n      * ``SequenceRuleLookupSession:`` a session to retrieve sequence\n        rule\n      * ``SequenceRuleQuerySession:`` a session to query for sequence\n        rule\n      * ``SequenceRuleSearchSession:`` a session to search for sequence\n        rule\n      * ``SequenceRuleAdminSession:`` a session to create and delete\n        sequence rule\n      * ``SequenceRuleNotificationSession:`` a session to receive\n        notifications pertaining to sequence rule changes\n      * ``SequenceRuleBankSession:`` a session to look up sequence rule\n        bank mappings\n      * ``SequenceRuleBankAssignmentSession:`` a session to manage\n        sequence rule to bank mappings\n      * ``SequenceRuleSmartBankSession:`` a session to manage dynamic\n        bank of sequence rule\n    \n      * ``SequenceRuleEnablerLookupSession:`` a session to retrieve\n        sequence rule enablers\n      * ``SequenceRuleEnablerQuerySession:`` a session to query for\n        sequence rule enablers\n      * ``SequenceRuleEnablerSearchSession:`` a session to search for\n        sequence rule enablers\n      * ``SequenceRuleEnablerAdminSession:`` a session to create and\n        delete sequence rule enablers\n      * ``SequenceRuleEnablerNotificationSession:`` a session to receive\n        notifications pertaining to sequence rule enabler changes\n      * ``SequenceRuleEnablerBankSession:`` a session to look up\n        sequence rule enabler bank mappings\n      * ``SequenceRuleEnablerBankAssignmentSession:`` a session to\n        manage sequence rule enabler to bank mappings\n      * ``SequenceRuleEnablerSmartBankSession:`` a session to manage\n        dynamic bank of sequence rule enablers\n      * ``SequenceRuleEnableRuleLookupSession:`` a session to look up\n        sequence rule enabler mappings\n      * ``SequenceRuleEnablerRuleApplicationSession:`` a session to\n        apply sequence rule enablers\n"
         }, 
         "inherit_fullnames": [
            "osid.OsidManager", 
            "osid.assessment.authoring.AssessmentAuthoringProfile"
         ], 
         "inherit_shortnames": [
            "OsidManager", 
            "AssessmentAuthoringProfile"
         ], 
         "inherit_pkg_names": [
            "osid", 
            "authoring"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidManager"
            }, 
            {
               "pkg_name": "assessment.authoring", 
               "name": "AssessmentAuthoringProfile"
            }
         ], 
         "method_names": [
            "get_assessment_part_lookup_session", 
            "get_assessment_part_lookup_session_for_bank", 
            "get_assessment_part_query_session", 
            "get_assessment_part_query_session_for_bank", 
            "get_assessment_part_search_session", 
            "get_assessment_part_search_session_for_bank", 
            "get_assessment_part_admin_session", 
            "get_assessment_part_admin_session_for_bank", 
            "get_assessment_part_notification_session", 
            "get_assessment_part_notification_session_for_bank", 
            "get_assessment_part_bank_session", 
            "get_assessment_part_bank_assignment_session", 
            "get_assessment_part_smart_bank_session", 
            "get_sequence_rule_lookup_session", 
            "get_sequence_rule_lookup_session_for_bank", 
            "get_sequence_rule_query_session", 
            "get_sequence_rule_query_session_for_bank", 
            "get_sequence_rule_search_session", 
            "get_sequence_rule_search_session_for_bank", 
            "get_sequence_rule_admin_session", 
            "get_sequence_rule_admin_session_for_bank", 
            "get_sequence_rule_notification_session", 
            "get_sequence_rule_notification_session_for_bank", 
            "get_sequence_rule_bank_session", 
            "get_sequence_rule_bank_assignment_session", 
            "get_sequence_rule_smart_bank_session", 
            "get_sequence_rule_enabler_lookup_session", 
            "get_sequence_rule_enabler_lookup_session_for_bank", 
            "get_sequence_rule_enabler_query_session", 
            "get_sequence_rule_enabler_query_session_for_bank", 
            "get_sequence_rule_enabler_search_session", 
            "get_sequence_rule_enabler_search_session_for_bank", 
            "get_sequence_rule_enabler_admin_session", 
            "get_sequence_rule_enabler_admin_session_for_bank", 
            "get_sequence_rule_enabler_notification_session", 
            "get_sequence_rule_enabler_notification_session_for_bank", 
            "get_sequence_rule_enabler_bank_session", 
            "get_sequence_rule_enabler_bank_assignment_session", 
            "get_sequence_rule_enabler_smart_bank_session", 
            "get_sequence_rule_enabler_rule_lookup_session", 
            "get_sequence_rule_enabler_rule_lookup_session_for_bank", 
            "get_sequence_rule_enabler_rule_application_session", 
            "get_sequence_rule_enabler_rule_application_session_for_bank"
         ], 
         "methods": [
            {
               "name": "get_assessment_part_lookup_session", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` associated with the assessment part lookup service.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.assessment.authoring.AssessmentPartLookupSession)\n                - an ``AssessmentPartLookupSession``", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_assessment_part_lookup()`` is\n                ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: an ``AssessmentPartLookupSession``\n        :rtype: ``osid.assessment.authoring.AssessmentPartLookupSession``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_assessment_part_lookup()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_assessment_part_lookup()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.assessment.authoring.AssessmentPartLookupSession", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_assessment_part_lookup_session_for_bank", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` associated with the assessment part lookup service for the given bank.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    bank_id (osid.id.Id): the ``Id`` of the ``Bank``\n", 
               "return_doc": "        return: (osid.assessment.authoring.AssessmentPartLookupSession)\n                - an ``AssessmentPartLookupSession``", 
               "error_doc": "        raise:  NotFound - no ``Bank`` found by the given ``Id``\n        raise:  NullArgument - ``bank_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_assessment_part_lookup()`` or\n                ``supports_visible_federation()`` is ``false``", 
               "sphinx_param_doc": "        :param bank_id: the ``Id`` of the ``Bank``\n        :type bank_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: an ``AssessmentPartLookupSession``\n        :rtype: ``osid.assessment.authoring.AssessmentPartLookupSession``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- no ``Bank`` found by the given ``Id``\n        :raise: ``NullArgument`` -- ``bank_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_assessment_part_lookup()`` or ``supports_visible_federation()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_assessment_part_lookup()`` and ``supports_visible_federation()`` are ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "bank_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "osid.assessment.authoring.AssessmentPartLookupSession", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_assessment_part_query_session", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` associated with the assessment part query service.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.assessment.authoring.AssessmentPartQuerySession) -\n                an ``AssessmentPartQuerySession``", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_assessment_part_query()`` is\n                ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: an ``AssessmentPartQuerySession``\n        :rtype: ``osid.assessment.authoring.AssessmentPartQuerySession``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_assessment_part_query()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_assessment_part_query()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.assessment.authoring.AssessmentPartQuerySession", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_assessment_part_query_session_for_bank", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` associated with the assessment part query service for the given bank.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    bank_id (osid.id.Id): the ``Id`` of the ``Bank``\n", 
               "return_doc": "        return: (osid.assessment.authoring.AssessmentPartQuerySession) -\n                an ``AssessmentPartQuerySession``", 
               "error_doc": "        raise:  NotFound - no ``Bank`` found by the given ``Id``\n        raise:  NullArgument - ``bank_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_assessment_part_query()`` or\n                ``supports_visible_federation()`` is ``false``", 
               "sphinx_param_doc": "        :param bank_id: the ``Id`` of the ``Bank``\n        :type bank_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: an ``AssessmentPartQuerySession``\n        :rtype: ``osid.assessment.authoring.AssessmentPartQuerySession``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- no ``Bank`` found by the given ``Id``\n        :raise: ``NullArgument`` -- ``bank_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_assessment_part_query()`` or ``supports_visible_federation()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_assessment_part_query()`` and ``supports_visible_federation()`` are ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "bank_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "osid.assessment.authoring.AssessmentPartQuerySession", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_assessment_part_search_session", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` associated with the assessment part search service.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.assessment.authoring.AssessmentPartSearchSession)\n                - an ``AssessmentPartSearchSession``", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_assessment_part_search()`` is\n                ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: an ``AssessmentPartSearchSession``\n        :rtype: ``osid.assessment.authoring.AssessmentPartSearchSession``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_assessment_part_search()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_assessment_part_search()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.assessment.authoring.AssessmentPartSearchSession", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_assessment_part_search_session_for_bank", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` associated with the assessment part earch service for the given bank.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    bank_id (osid.id.Id): the ``Id`` of the ``Bank``\n", 
               "return_doc": "        return: (osid.assessment.authoring.AssessmentPartSearchSession)\n                - an ``AssessmentPartSearchSession``", 
               "error_doc": "        raise:  NotFound - no ``Bank`` found by the given ``Id``\n        raise:  NullArgument - ``bank_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_assessment_part_search()`` or\n                ``supports_visible_federation()`` is ``false``", 
               "sphinx_param_doc": "        :param bank_id: the ``Id`` of the ``Bank``\n        :type bank_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: an ``AssessmentPartSearchSession``\n        :rtype: ``osid.assessment.authoring.AssessmentPartSearchSession``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- no ``Bank`` found by the given ``Id``\n        :raise: ``NullArgument`` -- ``bank_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_assessment_part_search()`` or ``supports_visible_federation()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_assessment_part_search()`` and ``supports_visible_federation()`` are ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "bank_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "osid.assessment.authoring.AssessmentPartSearchSession", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_assessment_part_admin_session", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` associated with the assessment part administration service.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.assessment.authoring.AssessmentPartAdminSession) -\n                an ``AssessmentPartAdminSession``", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_assessment_part_admin()`` is\n                ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: an ``AssessmentPartAdminSession``\n        :rtype: ``osid.assessment.authoring.AssessmentPartAdminSession``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_assessment_part_admin()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_assessment_part_admin()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.assessment.authoring.AssessmentPartAdminSession", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_assessment_part_admin_session_for_bank", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` associated with the assessment part administration service for the given bank.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    bank_id (osid.id.Id): the ``Id`` of the ``Bank``\n", 
               "return_doc": "        return: (osid.assessment.authoring.AssessmentPartAdminSession) -\n                an ``AssessmentPartAdminSession``", 
               "error_doc": "        raise:  NotFound - no ``Bank`` found by the given ``Id``\n        raise:  NullArgument - ``bank_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_assessment_part_admin()`` or\n                ``supports_visible_federation()`` is ``false``", 
               "sphinx_param_doc": "        :param bank_id: the ``Id`` of the ``Bank``\n        :type bank_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: an ``AssessmentPartAdminSession``\n        :rtype: ``osid.assessment.authoring.AssessmentPartAdminSession``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- no ``Bank`` found by the given ``Id``\n        :raise: ``NullArgument`` -- ``bank_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_assessment_part_admin()`` or ``supports_visible_federation()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_assessment_part_admin()`` and ``supports_visible_federation()`` are ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "bank_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "osid.assessment.authoring.AssessmentPartAdminSession", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_assessment_part_notification_session", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` associated with the assessment part notification service.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    assessment_part_receiver\n                (osid.assessment.authoring.AssessmentPartReceiver): the\n                notification callback\n", 
               "return_doc": "        return:\n                (osid.assessment.authoring.AssessmentPartNotificationSes\n                sion) - an ``AssessmentPartNotificationSession``", 
               "error_doc": "        raise:  NullArgument - ``assessment_part_receiver`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented -\n                ``supports_assessment_part_notification()`` is ``false``", 
               "sphinx_param_doc": "        :param assessment_part_receiver: the notification callback\n        :type assessment_part_receiver: ``osid.assessment.authoring.AssessmentPartReceiver``\n", 
               "sphinx_return_doc": "        :return: an ``AssessmentPartNotificationSession``\n        :rtype: ``osid.assessment.authoring.AssessmentPartNotificationSession``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``assessment_part_receiver`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_assessment_part_notification()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_assessment_part_notification()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.assessment.authoring.AssessmentPartReceiver", 
                     "var_name": "assessment_part_receiver", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.assessment.authoring.AssessmentPartReceiver"
               ], 
               "return_type": "osid.assessment.authoring.AssessmentPartNotificationSession", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_assessment_part_notification_session_for_bank", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` associated with the assessment part notification service for the given bank.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    assessment_part_receiver\n                (osid.assessment.authoring.AssessmentPartReceiver): the\n                notification callback\n        arg:    bank_id (osid.id.Id): the ``Id`` of the ``Bank``\n", 
               "return_doc": "        return:\n                (osid.assessment.authoring.AssessmentPartNotificationSes\n                sion) - an ``AssessmentPartNotificationSession``", 
               "error_doc": "        raise:  NotFound - no bank found by the given ``Id``\n        raise:  NullArgument - ``assessment_part_receiver`` or\n                ``bank_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented -\n                ``supports_assessment_part_notification()`` or\n                ``supports_visible_federation()`` is ``false``", 
               "sphinx_param_doc": "        :param assessment_part_receiver: the notification callback\n        :type assessment_part_receiver: ``osid.assessment.authoring.AssessmentPartReceiver``\n        :param bank_id: the ``Id`` of the ``Bank``\n        :type bank_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: an ``AssessmentPartNotificationSession``\n        :rtype: ``osid.assessment.authoring.AssessmentPartNotificationSession``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- no bank found by the given ``Id``\n        :raise: ``NullArgument`` -- ``assessment_part_receiver`` or ``bank_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_assessment_part_notification()`` or ``supports_visible_federation()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_assessment_part_notification()`` and ``supports_visible_federation()`` are ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.assessment.authoring.AssessmentPartReceiver", 
                     "var_name": "assessment_part_receiver", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "bank_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.assessment.authoring.AssessmentPartReceiver", 
                  "osid.id.Id"
               ], 
               "return_type": "osid.assessment.authoring.AssessmentPartNotificationSession", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_assessment_part_bank_session", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` to lookup assessment part/bank mappings for assessment parts.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.assessment.authoring.AssessmentPartBankSession) -\n                an ``AssessmentPartBankSession``", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_assessment_part_bank()`` is\n                ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: an ``AssessmentPartBankSession``\n        :rtype: ``osid.assessment.authoring.AssessmentPartBankSession``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_assessment_part_bank()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_assessment_part_bank()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.assessment.authoring.AssessmentPartBankSession", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_assessment_part_bank_assignment_session", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` associated with assigning assessment part to bank.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return:\n                (osid.assessment.authoring.AssessmentPartBankAssignmentS\n                ession) - an ``AssessmentPartBankAssignmentSession``", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented -\n                ``supports_assessment_part_bank_assignment()`` is\n                ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: an ``AssessmentPartBankAssignmentSession``\n        :rtype: ``osid.assessment.authoring.AssessmentPartBankAssignmentSession``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_assessment_part_bank_assignment()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_assessment_part_bank_assignment()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.assessment.authoring.AssessmentPartBankAssignmentSession", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_assessment_part_smart_bank_session", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` to manage assessment part smart bank.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    bank_id (osid.id.Id): the ``Id`` of the ``Bank``\n", 
               "return_doc": "        return:\n                (osid.assessment.authoring.AssessmentPartSmartBankSessio\n                n) - an ``AssessmentPartSmartBankSession``", 
               "error_doc": "        raise:  NotFound - no ``Bank`` found by the given ``Id``\n        raise:  NullArgument - ``bank_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented -\n                ``supports_assessment_part_smart_bank()`` is ``false``", 
               "sphinx_param_doc": "        :param bank_id: the ``Id`` of the ``Bank``\n        :type bank_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: an ``AssessmentPartSmartBankSession``\n        :rtype: ``osid.assessment.authoring.AssessmentPartSmartBankSession``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- no ``Bank`` found by the given ``Id``\n        :raise: ``NullArgument`` -- ``bank_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_assessment_part_smart_bank()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_assessment_part_smart_bank()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "bank_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "osid.assessment.authoring.AssessmentPartSmartBankSession", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_sequence_rule_lookup_session", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` associated with the sequence rule lookup service.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.assessment.authoring.SequenceRuleLookupSession) -\n                a ``SequenceRuleLookupSession``", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_sequence_rule_lookup()`` is\n                ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: a ``SequenceRuleLookupSession``\n        :rtype: ``osid.assessment.authoring.SequenceRuleLookupSession``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_sequence_rule_lookup()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_sequence_rule_lookup()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.assessment.authoring.SequenceRuleLookupSession", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_sequence_rule_lookup_session_for_bank", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` associated with the sequence rule lookup service for the given bank.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    bank_id (osid.id.Id): the ``Id`` of the ``Bank``\n", 
               "return_doc": "        return: (osid.assessment.authoring.SequenceRuleLookupSession) -\n                a ``SequenceRuleLookupSession``", 
               "error_doc": "        raise:  NotFound - no ``Bank`` found by the given ``Id``\n        raise:  NullArgument - ``bank_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_sequence_rule_lookup()`` or\n                ``supports_visible_federation()`` is ``false``", 
               "sphinx_param_doc": "        :param bank_id: the ``Id`` of the ``Bank``\n        :type bank_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: a ``SequenceRuleLookupSession``\n        :rtype: ``osid.assessment.authoring.SequenceRuleLookupSession``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- no ``Bank`` found by the given ``Id``\n        :raise: ``NullArgument`` -- ``bank_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_sequence_rule_lookup()`` or ``supports_visible_federation()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_sequence_rule_lookup()`` and ``supports_visible_federation()`` are ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "bank_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "osid.assessment.authoring.SequenceRuleLookupSession", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_sequence_rule_query_session", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` associated with the sequence rule query service.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.assessment.authoring.SequenceRuleQuerySession) - a\n                ``SequenceRuleQuerySession``", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_sequence_rule_query()`` is\n                ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: a ``SequenceRuleQuerySession``\n        :rtype: ``osid.assessment.authoring.SequenceRuleQuerySession``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_sequence_rule_query()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_sequence_rule_query()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.assessment.authoring.SequenceRuleQuerySession", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_sequence_rule_query_session_for_bank", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` associated with the sequence rule query service for the given bank.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    bank_id (osid.id.Id): the ``Id`` of the ``Bank``\n", 
               "return_doc": "        return: (osid.assessment.authoring.SequenceRuleQuerySession) - a\n                ``SequenceRuleQuerySession``", 
               "error_doc": "        raise:  NotFound - no ``Bank`` found by the given ``Id``\n        raise:  NullArgument - ``bank_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_sequence_rule_query()`` or\n                ``supports_visible_federation()`` is ``false``", 
               "sphinx_param_doc": "        :param bank_id: the ``Id`` of the ``Bank``\n        :type bank_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: a ``SequenceRuleQuerySession``\n        :rtype: ``osid.assessment.authoring.SequenceRuleQuerySession``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- no ``Bank`` found by the given ``Id``\n        :raise: ``NullArgument`` -- ``bank_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_sequence_rule_query()`` or ``supports_visible_federation()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_sequence_rule_query()`` and ``supports_visible_federation()`` are ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "bank_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "osid.assessment.authoring.SequenceRuleQuerySession", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_sequence_rule_search_session", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` associated with the sequence rule search service.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.assessment.authoring.SequenceRuleSearchSession) -\n                a ``SequenceRuleSearchSession``", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_sequence_rule_search()`` is\n                ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: a ``SequenceRuleSearchSession``\n        :rtype: ``osid.assessment.authoring.SequenceRuleSearchSession``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_sequence_rule_search()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_sequence_rule_search()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.assessment.authoring.SequenceRuleSearchSession", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_sequence_rule_search_session_for_bank", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` associated with the sequence rule earch service for the given bank.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    bank_id (osid.id.Id): the ``Id`` of the ``Bank``\n", 
               "return_doc": "        return: (osid.assessment.authoring.SequenceRuleSearchSession) -\n                a ``SequenceRuleSearchSession``", 
               "error_doc": "        raise:  NotFound - no ``Bank`` found by the given ``Id``\n        raise:  NullArgument - ``bank_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_sequence_rule_search()`` or\n                ``supports_visible_federation()`` is ``false``", 
               "sphinx_param_doc": "        :param bank_id: the ``Id`` of the ``Bank``\n        :type bank_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: a ``SequenceRuleSearchSession``\n        :rtype: ``osid.assessment.authoring.SequenceRuleSearchSession``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- no ``Bank`` found by the given ``Id``\n        :raise: ``NullArgument`` -- ``bank_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_sequence_rule_search()`` or ``supports_visible_federation()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_sequence_rule_search()`` and ``supports_visible_federation()`` are ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "bank_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "osid.assessment.authoring.SequenceRuleSearchSession", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_sequence_rule_admin_session", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` associated with the sequence rule administration service.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.assessment.authoring.SequenceRuleAdminSession) - a\n                ``SequenceRuleAdminSession``", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_sequence_rule_admin()`` is\n                ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: a ``SequenceRuleAdminSession``\n        :rtype: ``osid.assessment.authoring.SequenceRuleAdminSession``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_sequence_rule_admin()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_sequence_rule_admin()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.assessment.authoring.SequenceRuleAdminSession", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_sequence_rule_admin_session_for_bank", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` associated with the sequence rule administration service for the given bank.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    bank_id (osid.id.Id): the ``Id`` of the ``Bank``\n", 
               "return_doc": "        return: (osid.assessment.authoring.SequenceRuleAdminSession) - a\n                ``SequenceRuleAdminSession``", 
               "error_doc": "        raise:  NotFound - no ``Bank`` found by the given ``Id``\n        raise:  NullArgument - ``bank_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_sequence_rule_admin()`` or\n                ``supports_visible_federation()`` is ``false``", 
               "sphinx_param_doc": "        :param bank_id: the ``Id`` of the ``Bank``\n        :type bank_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: a ``SequenceRuleAdminSession``\n        :rtype: ``osid.assessment.authoring.SequenceRuleAdminSession``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- no ``Bank`` found by the given ``Id``\n        :raise: ``NullArgument`` -- ``bank_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_sequence_rule_admin()`` or ``supports_visible_federation()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_sequence_rule_admin()`` and ``supports_visible_federation()`` are ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "bank_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "osid.assessment.authoring.SequenceRuleAdminSession", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_sequence_rule_notification_session", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` associated with the sequence rule notification service.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    sequence_rule_receiver\n                (osid.assessment.authoring.SequenceRuleReceiver): the\n                notification callback\n", 
               "return_doc": "        return:\n                (osid.assessment.authoring.SequenceRuleNotificationSessi\n                on) - a ``SequenceRuleNotificationSession``", 
               "error_doc": "        raise:  NullArgument - ``sequence_rule_receiver`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented -\n                ``supports_sequence_rule_notification()`` is ``false``", 
               "sphinx_param_doc": "        :param sequence_rule_receiver: the notification callback\n        :type sequence_rule_receiver: ``osid.assessment.authoring.SequenceRuleReceiver``\n", 
               "sphinx_return_doc": "        :return: a ``SequenceRuleNotificationSession``\n        :rtype: ``osid.assessment.authoring.SequenceRuleNotificationSession``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``sequence_rule_receiver`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_sequence_rule_notification()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_sequence_rule_notification()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.assessment.authoring.SequenceRuleReceiver", 
                     "var_name": "sequence_rule_receiver", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.assessment.authoring.SequenceRuleReceiver"
               ], 
               "return_type": "osid.assessment.authoring.SequenceRuleNotificationSession", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_sequence_rule_notification_session_for_bank", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` associated with the sequence rule notification service for the given bank.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    sequence_rule_receiver\n                (osid.assessment.authoring.SequenceRuleReceiver): the\n                notification callback\n        arg:    bank_id (osid.id.Id): the ``Id`` of the ``Bank``\n", 
               "return_doc": "        return:\n                (osid.assessment.authoring.SequenceRuleNotificationSessi\n                on) - a ``SequenceRuleNotificationSession``", 
               "error_doc": "        raise:  NotFound - no bank found by the given ``Id``\n        raise:  NullArgument - ``sequence_rule_receiver`` or ``bank_id``\n                is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented -\n                ``supports_sequence_rule_notification()`` or\n                ``supports_visible_federation()`` is ``false``", 
               "sphinx_param_doc": "        :param sequence_rule_receiver: the notification callback\n        :type sequence_rule_receiver: ``osid.assessment.authoring.SequenceRuleReceiver``\n        :param bank_id: the ``Id`` of the ``Bank``\n        :type bank_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: a ``SequenceRuleNotificationSession``\n        :rtype: ``osid.assessment.authoring.SequenceRuleNotificationSession``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- no bank found by the given ``Id``\n        :raise: ``NullArgument`` -- ``sequence_rule_receiver`` or ``bank_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_sequence_rule_notification()`` or ``supports_visible_federation()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_sequence_rule_notification()`` and ``supports_visible_federation()`` are ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.assessment.authoring.SequenceRuleReceiver", 
                     "var_name": "sequence_rule_receiver", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "bank_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.assessment.authoring.SequenceRuleReceiver", 
                  "osid.id.Id"
               ], 
               "return_type": "osid.assessment.authoring.SequenceRuleNotificationSession", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_sequence_rule_bank_session", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` to lookup sequence rule/bank mappings for sequence rules.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.assessment.authoring.SequenceRuleBankSession) - a\n                ``SequenceRuleBankSession``", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_sequence_rule_bank()`` is\n                ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: a ``SequenceRuleBankSession``\n        :rtype: ``osid.assessment.authoring.SequenceRuleBankSession``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_sequence_rule_bank()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_sequence_rule_bank()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.assessment.authoring.SequenceRuleBankSession", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_sequence_rule_bank_assignment_session", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` associated with assigning sequence rule to bank.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return:\n                (osid.assessment.authoring.SequenceRuleBankAssignmentSes\n                sion) - a ``SequenceRuleBankAssignmentSession``", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented -\n                ``supports_sequence_rule_bank_assignment()`` is\n                ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: a ``SequenceRuleBankAssignmentSession``\n        :rtype: ``osid.assessment.authoring.SequenceRuleBankAssignmentSession``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_sequence_rule_bank_assignment()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_sequence_rule_bank_assignment()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.assessment.authoring.SequenceRuleBankAssignmentSession", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_sequence_rule_smart_bank_session", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` to manage sequence rule smart bank.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    bank_id (osid.id.Id): the ``Id`` of the ``Bank``\n", 
               "return_doc": "        return: (osid.assessment.authoring.SequenceRuleSmartBankSession)\n                - a ``SequenceRuleSmartBankSession``", 
               "error_doc": "        raise:  NotFound - no ``Bank`` found by the given ``Id``\n        raise:  NullArgument - ``bank_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_sequence_rule_smart_bank()``\n                is ``false``", 
               "sphinx_param_doc": "        :param bank_id: the ``Id`` of the ``Bank``\n        :type bank_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: a ``SequenceRuleSmartBankSession``\n        :rtype: ``osid.assessment.authoring.SequenceRuleSmartBankSession``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- no ``Bank`` found by the given ``Id``\n        :raise: ``NullArgument`` -- ``bank_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_sequence_rule_smart_bank()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_sequence_rule_smart_bank()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "bank_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "osid.assessment.authoring.SequenceRuleSmartBankSession", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_sequence_rule_enabler_lookup_session", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` associated with the sequence rule enabler lookup service.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return:\n                (osid.assessment.authoring.SequenceRuleEnablerLookupSess\n                ion) - a ``SequenceRuleEnablerLookupSession``", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented -\n                ``supports_sequence_rule_enabler_lookup()`` is ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: a ``SequenceRuleEnablerLookupSession``\n        :rtype: ``osid.assessment.authoring.SequenceRuleEnablerLookupSession``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_sequence_rule_enabler_lookup()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_sequence_rule_enabler_lookup()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.assessment.authoring.SequenceRuleEnablerLookupSession", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_sequence_rule_enabler_lookup_session_for_bank", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` associated with the sequence rule enabler lookup service for the given bank.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    bank_id (osid.id.Id): the ``Id`` of the ``Bank``\n", 
               "return_doc": "        return:\n                (osid.assessment.authoring.SequenceRuleEnablerLookupSess\n                ion) - a ``SequenceRuleEnablerLookupSession``", 
               "error_doc": "        raise:  NotFound - no ``Bank`` found by the given ``Id``\n        raise:  NullArgument - ``bank_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented -\n                ``supports_sequence_rule_enabler_lookup()`` or\n                ``supports_visible_federation()`` is ``false``", 
               "sphinx_param_doc": "        :param bank_id: the ``Id`` of the ``Bank``\n        :type bank_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: a ``SequenceRuleEnablerLookupSession``\n        :rtype: ``osid.assessment.authoring.SequenceRuleEnablerLookupSession``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- no ``Bank`` found by the given ``Id``\n        :raise: ``NullArgument`` -- ``bank_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_sequence_rule_enabler_lookup()`` or ``supports_visible_federation()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_sequence_rule_enabler_lookup()`` and ``supports_visible_federation()`` are ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "bank_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "osid.assessment.authoring.SequenceRuleEnablerLookupSession", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_sequence_rule_enabler_query_session", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` associated with the sequence rule enabler query service.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return:\n                (osid.assessment.authoring.SequenceRuleEnablerQuerySessi\n                on) - a ``SequenceRuleEnablerQuerySession``", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented -\n                ``supports_sequence_rule_enabler_query()`` is ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: a ``SequenceRuleEnablerQuerySession``\n        :rtype: ``osid.assessment.authoring.SequenceRuleEnablerQuerySession``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_sequence_rule_enabler_query()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_sequence_rule_enabler_query()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.assessment.authoring.SequenceRuleEnablerQuerySession", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_sequence_rule_enabler_query_session_for_bank", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` associated with the sequence rule enabler query service for the given bank.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    bank_id (osid.id.Id): the ``Id`` of the ``Bank``\n", 
               "return_doc": "        return:\n                (osid.assessment.authoring.SequenceRuleEnablerQuerySessi\n                on) - a ``SequenceRuleEnablerQuerySession``", 
               "error_doc": "        raise:  NotFound - no ``Bank`` found by the given ``Id``\n        raise:  NullArgument - ``bank_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented -\n                ``supports_sequence_rule_enabler_query()`` or\n                ``supports_visible_federation()`` is ``false``", 
               "sphinx_param_doc": "        :param bank_id: the ``Id`` of the ``Bank``\n        :type bank_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: a ``SequenceRuleEnablerQuerySession``\n        :rtype: ``osid.assessment.authoring.SequenceRuleEnablerQuerySession``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- no ``Bank`` found by the given ``Id``\n        :raise: ``NullArgument`` -- ``bank_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_sequence_rule_enabler_query()`` or ``supports_visible_federation()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_sequence_rule_enabler_query()`` and ``supports_visible_federation()`` are ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "bank_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "osid.assessment.authoring.SequenceRuleEnablerQuerySession", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_sequence_rule_enabler_search_session", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` associated with the sequence rule enabler search service.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return:\n                (osid.assessment.authoring.SequenceRuleEnablerSearchSess\n                ion) - a ``SequenceRuleEnablerSearchSession``", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented -\n                ``supports_sequence_rule_enabler_search()`` is ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: a ``SequenceRuleEnablerSearchSession``\n        :rtype: ``osid.assessment.authoring.SequenceRuleEnablerSearchSession``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_sequence_rule_enabler_search()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_sequence_rule_enabler_search()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.assessment.authoring.SequenceRuleEnablerSearchSession", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_sequence_rule_enabler_search_session_for_bank", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` associated with the sequence rule enablers earch service for the given bank.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    bank_id (osid.id.Id): the ``Id`` of the ``Bank``\n", 
               "return_doc": "        return:\n                (osid.assessment.authoring.SequenceRuleEnablerSearchSess\n                ion) - a ``SequenceRuleEnablerSearchSession``", 
               "error_doc": "        raise:  NotFound - no ``Bank`` found by the given ``Id``\n        raise:  NullArgument - ``bank_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented -\n                ``supports_sequence_rule_enabler_search()`` or\n                ``supports_visible_federation()`` is ``false``", 
               "sphinx_param_doc": "        :param bank_id: the ``Id`` of the ``Bank``\n        :type bank_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: a ``SequenceRuleEnablerSearchSession``\n        :rtype: ``osid.assessment.authoring.SequenceRuleEnablerSearchSession``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- no ``Bank`` found by the given ``Id``\n        :raise: ``NullArgument`` -- ``bank_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_sequence_rule_enabler_search()`` or ``supports_visible_federation()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_sequence_rule_enabler_search()`` and ``supports_visible_federation()`` are ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "bank_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "osid.assessment.authoring.SequenceRuleEnablerSearchSession", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_sequence_rule_enabler_admin_session", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` associated with the sequence rule enabler administration service.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return:\n                (osid.assessment.authoring.SequenceRuleEnablerAdminSessi\n                on) - a ``SequenceRuleEnablerAdminSession``", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented -\n                ``supports_sequence_rule_enabler_admin()`` is ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: a ``SequenceRuleEnablerAdminSession``\n        :rtype: ``osid.assessment.authoring.SequenceRuleEnablerAdminSession``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_sequence_rule_enabler_admin()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_sequence_rule_enabler_admin()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.assessment.authoring.SequenceRuleEnablerAdminSession", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_sequence_rule_enabler_admin_session_for_bank", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` associated with the sequence rule enabler administration service for the given bank.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    bank_id (osid.id.Id): the ``Id`` of the ``Bank``\n", 
               "return_doc": "        return:\n                (osid.assessment.authoring.SequenceRuleEnablerAdminSessi\n                on) - a ``SequenceRuleEnablerAdminSession``", 
               "error_doc": "        raise:  NotFound - no ``Bank`` found by the given ``Id``\n        raise:  NullArgument - ``bank_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented -\n                ``supports_sequence_rule_enabler_admin()`` or\n                ``supports_visible_federation()`` is ``false``", 
               "sphinx_param_doc": "        :param bank_id: the ``Id`` of the ``Bank``\n        :type bank_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: a ``SequenceRuleEnablerAdminSession``\n        :rtype: ``osid.assessment.authoring.SequenceRuleEnablerAdminSession``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- no ``Bank`` found by the given ``Id``\n        :raise: ``NullArgument`` -- ``bank_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_sequence_rule_enabler_admin()`` or ``supports_visible_federation()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_sequence_rule_enabler_admin()`` and ``supports_visible_federation()`` are ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "bank_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "osid.assessment.authoring.SequenceRuleEnablerAdminSession", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_sequence_rule_enabler_notification_session", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` associated with the sequence rule enabler notification service.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    sequence_rule_enabler_receiver\n                (osid.assessment.authoring.SequenceRuleEnablerReceiver):\n                the notification callback\n", 
               "return_doc": "        return: (osid.assessment.authoring.SequenceRuleEnablerNotificati\n                onSession) - a\n                ``SequenceRuleEnablerNotificationSession``", 
               "error_doc": "        raise:  NullArgument - ``sequence_rule_enabler_receiver`` is\n                ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented -\n                ``supports_sequence_rule_enabler_notification()`` is\n                ``false``", 
               "sphinx_param_doc": "        :param sequence_rule_enabler_receiver: the notification callback\n        :type sequence_rule_enabler_receiver: ``osid.assessment.authoring.SequenceRuleEnablerReceiver``\n", 
               "sphinx_return_doc": "        :return: a ``SequenceRuleEnablerNotificationSession``\n        :rtype: ``osid.assessment.authoring.SequenceRuleEnablerNotificationSession``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``sequence_rule_enabler_receiver`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_sequence_rule_enabler_notification()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_sequence_rule_enabler_notification()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.assessment.authoring.SequenceRuleEnablerReceiver", 
                     "var_name": "sequence_rule_enabler_receiver", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.assessment.authoring.SequenceRuleEnablerReceiver"
               ], 
               "return_type": "osid.assessment.authoring.SequenceRuleEnablerNotificationSession", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_sequence_rule_enabler_notification_session_for_bank", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` associated with the sequence rule enabler notification service for the given bank.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    sequence_rule_enabler_receiver\n                (osid.assessment.authoring.SequenceRuleEnablerReceiver):\n                the notification callback\n        arg:    bank_id (osid.id.Id): the ``Id`` of the ``Bank``\n", 
               "return_doc": "        return: (osid.assessment.authoring.SequenceRuleEnablerNotificati\n                onSession) - a\n                ``SequenceRuleEnablerNotificationSession``", 
               "error_doc": "        raise:  NotFound - no bank found by the given ``Id``\n        raise:  NullArgument - ``sequence_rule_enabler_receiver`` or\n                ``bank_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented -\n                ``supports_sequence_rule_enabler_notification()`` or\n                ``supports_visible_federation()`` is ``false``", 
               "sphinx_param_doc": "        :param sequence_rule_enabler_receiver: the notification callback\n        :type sequence_rule_enabler_receiver: ``osid.assessment.authoring.SequenceRuleEnablerReceiver``\n        :param bank_id: the ``Id`` of the ``Bank``\n        :type bank_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: a ``SequenceRuleEnablerNotificationSession``\n        :rtype: ``osid.assessment.authoring.SequenceRuleEnablerNotificationSession``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- no bank found by the given ``Id``\n        :raise: ``NullArgument`` -- ``sequence_rule_enabler_receiver`` or ``bank_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_sequence_rule_enabler_notification()`` or ``supports_visible_federation()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_sequence_rule_enabler_notification()`` and ``supports_visible_federation()`` are ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.assessment.authoring.SequenceRuleEnablerReceiver", 
                     "var_name": "sequence_rule_enabler_receiver", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "bank_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.assessment.authoring.SequenceRuleEnablerReceiver", 
                  "osid.id.Id"
               ], 
               "return_type": "osid.assessment.authoring.SequenceRuleEnablerNotificationSession", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_sequence_rule_enabler_bank_session", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` to lookup sequence rule enabler/bank mappings for sequence rule enablers.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return:\n                (osid.assessment.authoring.SequenceRuleEnablerBankSessio\n                n) - a ``SequenceRuleEnablerBankSession``", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented -\n                ``supports_sequence_rule_enabler_bank()`` is ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: a ``SequenceRuleEnablerBankSession``\n        :rtype: ``osid.assessment.authoring.SequenceRuleEnablerBankSession``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_sequence_rule_enabler_bank()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_sequence_rule_enabler_bank()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.assessment.authoring.SequenceRuleEnablerBankSession", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_sequence_rule_enabler_bank_assignment_session", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` associated with assigning sequence rule enablers to bank.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.assessment.authoring.SequenceRuleEnablerBankAssign\n                mentSession) - a\n                ``SequenceRuleEnablerBankAssignmentSession``", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented -\n                ``supports_sequence_rule_enabler_bank_assignment()`` is\n                ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: a ``SequenceRuleEnablerBankAssignmentSession``\n        :rtype: ``osid.assessment.authoring.SequenceRuleEnablerBankAssignmentSession``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_sequence_rule_enabler_bank_assignment()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_sequence_rule_enabler_bank_assignment()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.assessment.authoring.SequenceRuleEnablerBankAssignmentSession", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_sequence_rule_enabler_smart_bank_session", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` to manage sequence rule enabler smart bank.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    bank_id (osid.id.Id): the ``Id`` of the ``Bank``\n", 
               "return_doc": "        return:\n                (osid.assessment.authoring.SequenceRuleEnablerSmartBankS\n                ession) - a ``SequenceRuleEnablerSmartBankSession``", 
               "error_doc": "        raise:  NotFound - no ``Bank`` found by the given ``Id``\n        raise:  NullArgument - ``bank_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented -\n                ``supports_sequence_rule_enabler_smart_bank()`` is\n                ``false``", 
               "sphinx_param_doc": "        :param bank_id: the ``Id`` of the ``Bank``\n        :type bank_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: a ``SequenceRuleEnablerSmartBankSession``\n        :rtype: ``osid.assessment.authoring.SequenceRuleEnablerSmartBankSession``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- no ``Bank`` found by the given ``Id``\n        :raise: ``NullArgument`` -- ``bank_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_sequence_rule_enabler_smart_bank()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_sequence_rule_enabler_smart_bank()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "bank_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "osid.assessment.authoring.SequenceRuleEnablerSmartBankSession", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_sequence_rule_enabler_rule_lookup_session", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` associated with the sequence rule enabler mapping lookup service.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return:\n                (osid.assessment.authoring.SequenceRuleEnablerRuleLookup\n                Session) - a ``SequenceRuleEnablerRuleLookupSession``", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented -\n                ``supports_sequence_rule_enabler_rule_lookup()`` is\n                ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: a ``SequenceRuleEnablerRuleLookupSession``\n        :rtype: ``osid.assessment.authoring.SequenceRuleEnablerRuleLookupSession``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_sequence_rule_enabler_rule_lookup()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_sequence_rule_enabler_rule_lookup()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.assessment.authoring.SequenceRuleEnablerRuleLookupSession", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_sequence_rule_enabler_rule_lookup_session_for_bank", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` associated with the sequence rule enabler mapping lookup service for the given bank.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    bank_id (osid.id.Id): the ``Id`` of the ``Bank``\n", 
               "return_doc": "        return:\n                (osid.assessment.authoring.SequenceRuleEnablerRuleLookup\n                Session) - a ``SequenceRuleEnablerRuleLookupSession``", 
               "error_doc": "        raise:  NotFound - no ``Bank`` found by the given ``Id``\n        raise:  NullArgument - ``bank_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented -\n                ``supports_sequence_rule_enabler_rule_lookup()`` or\n                ``supports_visible_federation()`` is ``false``", 
               "sphinx_param_doc": "        :param bank_id: the ``Id`` of the ``Bank``\n        :type bank_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: a ``SequenceRuleEnablerRuleLookupSession``\n        :rtype: ``osid.assessment.authoring.SequenceRuleEnablerRuleLookupSession``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- no ``Bank`` found by the given ``Id``\n        :raise: ``NullArgument`` -- ``bank_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_sequence_rule_enabler_rule_lookup()`` or ``supports_visible_federation()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_sequence_rule_enabler_rule_lookup()`` and ``supports_visible_federation()`` are ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "bank_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "osid.assessment.authoring.SequenceRuleEnablerRuleLookupSession", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_sequence_rule_enabler_rule_application_session", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` associated with the sequence rule enabler assignment service.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.assessment.authoring.SequenceRuleEnablerRuleApplic\n                ationSession) - a\n                ``SequenceRuleEnablerRuleApplicationSession``", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented -\n                ``supports_sequence_rule_enabler_rule_application()`` is\n                ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: a ``SequenceRuleEnablerRuleApplicationSession``\n        :rtype: ``osid.assessment.authoring.SequenceRuleEnablerRuleApplicationSession``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_sequence_rule_enabler_rule_application()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_sequence_rule_enabler_rule_application()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.assessment.authoring.SequenceRuleEnablerRuleApplicationSession", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_sequence_rule_enabler_rule_application_session_for_bank", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` associated with the sequence rule enabler assignment service for the given bank.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    bank_id (osid.id.Id): the ``Id`` of the ``Bank``\n", 
               "return_doc": "        return: (osid.assessment.authoring.SequenceRuleEnablerRuleApplic\n                ationSession) - a\n                ``SequenceRuleEnablerRuleApplicationSession``", 
               "error_doc": "        raise:  NotFound - no ``Bank`` found by the given ``Id``\n        raise:  NullArgument - ``bank_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented -\n                ``supports_sequence_rule_enabler_rule_application()`` or\n                ``supports_visible_federation()`` is ``false``", 
               "sphinx_param_doc": "        :param bank_id: the ``Id`` of the ``Bank``\n        :type bank_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: a ``SequenceRuleEnablerRuleApplicationSession``\n        :rtype: ``osid.assessment.authoring.SequenceRuleEnablerRuleApplicationSession``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- no ``Bank`` found by the given ``Id``\n        :raise: ``NullArgument`` -- ``bank_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_sequence_rule_enabler_rule_application()`` or ``supports_visible_federation()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_sequence_rule_enabler_rule_application()`` and ``supports_visible_federation()`` are ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "bank_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "osid.assessment.authoring.SequenceRuleEnablerRuleApplicationSession", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.assessment.authoring.AssessmentAuthoringProxyManager", 
         "shortname": "AssessmentAuthoringProxyManager", 
         "category": "managers", 
         "doc": {
            "headline": "The assessment authoring manager provides access to assessment authoring sessions and provides interoperability tests for various aspects of this service.", 
            "body": "    Methods in this manager support the passing of a ``Proxy`` object.\n    The sessions included in this manager are:\n\n      * ``AssessmentPartLookupSession:`` a session to retrieve\n        assessment part\n      * ``AssessmentPartQuerySession:`` a session to query for\n        assessment part\n      * ``AssessmentPartSearchSession:`` a session to search for\n        assessment part\n      * ``AssessmentPartAdminSession:`` a session to create and delete\n        assessment part\n      * ``AssessmentPartNotificationSession:`` a session to receive\n        notifications pertaining to assessment part changes\n      * ``AssessmentPartBankSession:`` a session to look up assessment\n        part bank mappings\n      * ``AssessmentPartBankAssignmentSession:`` a session to manage\n        assessment part to bank mappings\n      * ``AssessmentPartSmartBankSession:`` a session to manage dynamic\n        bank of assessment part\n      * ``AssessmentPartItemSession:`` a session to look up assessment\n        part to item mappings\n      * ``AssessmentPartItemDesignSession:`` a session to map items to\n        assessment parts\n    \n      * ``SequenceRuleLookupSession:`` a session to retrieve sequence\n        rule\n      * ``SequenceRuleQuerySession:`` a session to query for sequence\n        rule\n      * ``SequenceRuleSearchSession:`` a session to search for sequence\n        rule\n      * ``SequenceRuleAdminSession:`` a session to create and delete\n        sequence rule\n      * ``SequenceRuleNotificationSession:`` a session to receive\n        notifications pertaining to sequence rule changes\n      * ``SequenceRuleBankSession:`` a session to look up sequence rule\n        bank mappings\n      * ``SequenceRuleBankAssignmentSession:`` a session to manage\n        sequence rule to bank mappings\n      * ``SequenceRuleSmartBankSession:`` a session to manage dynamic\n        bank of sequence rule\n    \n      * ``SequenceRuleEnablerLookupSession:`` a session to retrieve\n        sequence rule enablers\n      * ``SequenceRuleEnablerQuerySession:`` a session to query for\n        sequence rule enablers\n      * ``SequenceRuleEnablerSearchSession:`` a session to search for\n        sequence rule enablers\n      * ``SequenceRuleEnablerAdminSession:`` a session to create and\n        delete sequence rule enablers\n      * ``SequenceRuleEnablerNotificationSession:`` a session to receive\n        notifications pertaining to sequence rule enabler changes\n      * ``SequenceRuleEnablerBankSession:`` a session to look up\n        sequence rule enabler bank mappings\n      * ``SequenceRuleEnablerBankAssignmentSession:`` a session to\n        manage sequence rule enabler to bank mappings\n      * ``SequenceRuleEnablerSmartBankSession:`` a session to manage\n        dynamic bank of sequence rule enablers\n      * ``SequenceRuleEnableRuleLookupSession:`` a session to look up\n        sequence rule enabler mappings\n      * ``SequenceRuleEnablerRuleApplicationSession:`` a session to\n        apply sequence rule enablers\n"
         }, 
         "inherit_fullnames": [
            "osid.OsidProxyManager", 
            "osid.assessment.authoring.AssessmentAuthoringProfile"
         ], 
         "inherit_shortnames": [
            "OsidProxyManager", 
            "AssessmentAuthoringProfile"
         ], 
         "inherit_pkg_names": [
            "osid", 
            "authoring"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidProxyManager"
            }, 
            {
               "pkg_name": "assessment.authoring", 
               "name": "AssessmentAuthoringProfile"
            }
         ], 
         "method_names": [
            "get_assessment_part_lookup_session", 
            "get_assessment_part_lookup_session_for_bank", 
            "get_assessment_part_query_session", 
            "get_assessment_part_query_session_for_bank", 
            "get_assessment_part_search_session", 
            "get_assessment_part_search_session_for_bank", 
            "get_assessment_part_admin_session", 
            "get_assessment_part_admin_session_for_bank", 
            "get_assessment_part_notification_session", 
            "get_assessment_part_notification_session_for_bank", 
            "get_assessment_part_bank_session", 
            "get_assessment_part_bank_assignment_session", 
            "get_assessment_part_smart_bank_session", 
            "get_sequence_rule_lookup_session", 
            "get_sequence_rule_lookup_session_for_bank", 
            "get_sequence_rule_query_session", 
            "get_sequence_rule_query_session_for_bank", 
            "get_sequence_rule_search_session", 
            "get_sequence_rule_search_session_for_bank", 
            "get_sequence_rule_admin_session", 
            "get_sequence_rule_admin_session_for_bank", 
            "get_sequence_rule_notification_session", 
            "get_sequence_rule_notification_session_for_bank", 
            "get_sequence_rule_bank_session", 
            "get_sequence_rule_bank_assignment_session", 
            "get_sequence_rule_smart_bank_session", 
            "get_sequence_rule_enabler_lookup_session", 
            "get_sequence_rule_enabler_lookup_session_for_bank", 
            "get_sequence_rule_enabler_query_session", 
            "get_sequence_rule_enabler_query_session_for_bank", 
            "get_sequence_rule_enabler_search_session", 
            "get_sequence_rule_enabler_search_session_for_bank", 
            "get_sequence_rule_enabler_admin_session", 
            "get_sequence_rule_enabler_admin_session_for_bank", 
            "get_sequence_rule_enabler_notification_session", 
            "get_sequence_rule_enabler_notification_session_for_bank", 
            "get_sequence_rule_enabler_bank_session", 
            "get_sequence_rule_enabler_bank_assignment_session", 
            "get_sequence_rule_enabler_smart_bank_session", 
            "get_sequence_rule_enabler_rule_lookup_session", 
            "get_sequence_rule_enabler_rule_lookup_session_for_bank", 
            "get_sequence_rule_enabler_rule_application_session", 
            "get_sequence_rule_enabler_rule_application_session_for_bank"
         ], 
         "methods": [
            {
               "name": "get_assessment_part_lookup_session", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` associated with the assessment part lookup service.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    proxy (osid.proxy.Proxy): a proxy\n", 
               "return_doc": "        return: (osid.assessment.authoring.AssessmentPartLookupSession)\n                - an ``AssessmentPartLookupSession``", 
               "error_doc": "        raise:  NullArgument - ``proxy`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_assessment_part_lookup()`` is\n                ``false``", 
               "sphinx_param_doc": "        :param proxy: a proxy\n        :type proxy: ``osid.proxy.Proxy``\n", 
               "sphinx_return_doc": "        :return: an ``AssessmentPartLookupSession``\n        :rtype: ``osid.assessment.authoring.AssessmentPartLookupSession``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``proxy`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_assessment_part_lookup()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_assessment_part_lookup()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.proxy.Proxy", 
                     "var_name": "proxy", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.proxy.Proxy"
               ], 
               "return_type": "osid.assessment.authoring.AssessmentPartLookupSession", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_assessment_part_lookup_session_for_bank", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` associated with the assessment part lookup service for the given bank.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    bank_id (osid.id.Id): the ``Id`` of the ``Bank``\n        arg:    proxy (osid.proxy.Proxy): a proxy\n", 
               "return_doc": "        return: (osid.assessment.authoring.AssessmentPartLookupSession)\n                - an ``AssessmentPartLookupSession``", 
               "error_doc": "        raise:  NotFound - no ``Bank`` found by the given ``Id``\n        raise:  NullArgument - ``bank_id or proxy is null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_assessment_part_lookup()`` or\n                ``supports_visible_federation()`` is ``false``", 
               "sphinx_param_doc": "        :param bank_id: the ``Id`` of the ``Bank``\n        :type bank_id: ``osid.id.Id``\n        :param proxy: a proxy\n        :type proxy: ``osid.proxy.Proxy``\n", 
               "sphinx_return_doc": "        :return: an ``AssessmentPartLookupSession``\n        :rtype: ``osid.assessment.authoring.AssessmentPartLookupSession``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- no ``Bank`` found by the given ``Id``\n        :raise: ``NullArgument`` -- ``bank_id or proxy is null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_assessment_part_lookup()`` or ``supports_visible_federation()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_assessment_part_lookup()`` and ``supports_visible_federation()`` are ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "bank_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.proxy.Proxy", 
                     "var_name": "proxy", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "osid.proxy.Proxy"
               ], 
               "return_type": "osid.assessment.authoring.AssessmentPartLookupSession", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_assessment_part_query_session", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` associated with the assessment part query service.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    proxy (osid.proxy.Proxy): a proxy\n", 
               "return_doc": "        return: (osid.assessment.authoring.AssessmentPartQuerySession) -\n                an ``AssessmentPartQuerySession``", 
               "error_doc": "        raise:  NullArgument - ``proxy`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_assessment_part_query()`` is\n                ``false``", 
               "sphinx_param_doc": "        :param proxy: a proxy\n        :type proxy: ``osid.proxy.Proxy``\n", 
               "sphinx_return_doc": "        :return: an ``AssessmentPartQuerySession``\n        :rtype: ``osid.assessment.authoring.AssessmentPartQuerySession``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``proxy`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_assessment_part_query()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_assessment_part_query()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.proxy.Proxy", 
                     "var_name": "proxy", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.proxy.Proxy"
               ], 
               "return_type": "osid.assessment.authoring.AssessmentPartQuerySession", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_assessment_part_query_session_for_bank", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` associated with the assessment part query service for the given bank.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    bank_id (osid.id.Id): the ``Id`` of the ``Bank``\n        arg:    proxy (osid.proxy.Proxy): a proxy\n", 
               "return_doc": "        return: (osid.assessment.authoring.AssessmentPartQuerySession) -\n                an ``AssessmentPartQuerySession``", 
               "error_doc": "        raise:  NotFound - no ``Bank`` found by the given ``Id``\n        raise:  NullArgument - ``bank_id or proxy is null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_assessment_part_query()`` or\n                ``supports_visible_federation()`` is ``false``", 
               "sphinx_param_doc": "        :param bank_id: the ``Id`` of the ``Bank``\n        :type bank_id: ``osid.id.Id``\n        :param proxy: a proxy\n        :type proxy: ``osid.proxy.Proxy``\n", 
               "sphinx_return_doc": "        :return: an ``AssessmentPartQuerySession``\n        :rtype: ``osid.assessment.authoring.AssessmentPartQuerySession``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- no ``Bank`` found by the given ``Id``\n        :raise: ``NullArgument`` -- ``bank_id or proxy is null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_assessment_part_query()`` or ``supports_visible_federation()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_assessment_part_query()`` and ``supports_visible_federation()`` are ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "bank_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.proxy.Proxy", 
                     "var_name": "proxy", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "osid.proxy.Proxy"
               ], 
               "return_type": "osid.assessment.authoring.AssessmentPartQuerySession", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_assessment_part_search_session", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` associated with the assessment part search service.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    proxy (osid.proxy.Proxy): a proxy\n", 
               "return_doc": "        return: (osid.assessment.authoring.AssessmentPartSearchSession)\n                - an ``AssessmentPartSearchSession``", 
               "error_doc": "        raise:  NullArgument - ``proxy`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_assessment_part_search()`` is\n                ``false``", 
               "sphinx_param_doc": "        :param proxy: a proxy\n        :type proxy: ``osid.proxy.Proxy``\n", 
               "sphinx_return_doc": "        :return: an ``AssessmentPartSearchSession``\n        :rtype: ``osid.assessment.authoring.AssessmentPartSearchSession``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``proxy`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_assessment_part_search()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_assessment_part_search()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.proxy.Proxy", 
                     "var_name": "proxy", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.proxy.Proxy"
               ], 
               "return_type": "osid.assessment.authoring.AssessmentPartSearchSession", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_assessment_part_search_session_for_bank", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` associated with the assessment part earch service for the given bank.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    bank_id (osid.id.Id): the ``Id`` of the ``Bank``\n        arg:    proxy (osid.proxy.Proxy): a proxy\n", 
               "return_doc": "        return: (osid.assessment.authoring.AssessmentPartSearchSession)\n                - an ``AssessmentPartSearchSession``", 
               "error_doc": "        raise:  NotFound - no ``Bank`` found by the given ``Id``\n        raise:  NullArgument - ``bank_id or proxy is null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_assessment_part_search()`` or\n                ``supports_visible_federation()`` is ``false``", 
               "sphinx_param_doc": "        :param bank_id: the ``Id`` of the ``Bank``\n        :type bank_id: ``osid.id.Id``\n        :param proxy: a proxy\n        :type proxy: ``osid.proxy.Proxy``\n", 
               "sphinx_return_doc": "        :return: an ``AssessmentPartSearchSession``\n        :rtype: ``osid.assessment.authoring.AssessmentPartSearchSession``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- no ``Bank`` found by the given ``Id``\n        :raise: ``NullArgument`` -- ``bank_id or proxy is null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_assessment_part_search()`` or ``supports_visible_federation()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_assessment_part_search()`` and ``supports_visible_federation()`` are ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "bank_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.proxy.Proxy", 
                     "var_name": "proxy", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "osid.proxy.Proxy"
               ], 
               "return_type": "osid.assessment.authoring.AssessmentPartSearchSession", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_assessment_part_admin_session", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` associated with the assessment part administration service.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    proxy (osid.proxy.Proxy): a proxy\n", 
               "return_doc": "        return: (osid.assessment.authoring.AssessmentPartAdminSession) -\n                an ``AssessmentPartAdminSession``", 
               "error_doc": "        raise:  NullArgument - ``proxy`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_assessment_part_admin()`` is\n                ``false``", 
               "sphinx_param_doc": "        :param proxy: a proxy\n        :type proxy: ``osid.proxy.Proxy``\n", 
               "sphinx_return_doc": "        :return: an ``AssessmentPartAdminSession``\n        :rtype: ``osid.assessment.authoring.AssessmentPartAdminSession``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``proxy`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_assessment_part_admin()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_assessment_part_admin()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.proxy.Proxy", 
                     "var_name": "proxy", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.proxy.Proxy"
               ], 
               "return_type": "osid.assessment.authoring.AssessmentPartAdminSession", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_assessment_part_admin_session_for_bank", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` associated with the assessment part administration service for the given bank.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    bank_id (osid.id.Id): the ``Id`` of the ``Bank``\n        arg:    proxy (osid.proxy.Proxy): a proxy\n", 
               "return_doc": "        return: (osid.assessment.authoring.AssessmentPartAdminSession) -\n                an ``AssessmentPartAdminSession``", 
               "error_doc": "        raise:  NotFound - no ``Bank`` found by the given ``Id``\n        raise:  NullArgument - ``bank_id or proxy is null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_assessment_part_admin()`` or\n                ``supports_visible_federation()`` is ``false``", 
               "sphinx_param_doc": "        :param bank_id: the ``Id`` of the ``Bank``\n        :type bank_id: ``osid.id.Id``\n        :param proxy: a proxy\n        :type proxy: ``osid.proxy.Proxy``\n", 
               "sphinx_return_doc": "        :return: an ``AssessmentPartAdminSession``\n        :rtype: ``osid.assessment.authoring.AssessmentPartAdminSession``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- no ``Bank`` found by the given ``Id``\n        :raise: ``NullArgument`` -- ``bank_id or proxy is null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_assessment_part_admin()`` or ``supports_visible_federation()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_assessment_part_admin()`` and ``supports_visible_federation()`` are ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "bank_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.proxy.Proxy", 
                     "var_name": "proxy", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "osid.proxy.Proxy"
               ], 
               "return_type": "osid.assessment.authoring.AssessmentPartAdminSession", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_assessment_part_notification_session", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` associated with the assessment part notification service.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    assessment_part_receiver\n                (osid.assessment.authoring.AssessmentPartReceiver): the\n                notification callback\n        arg:    proxy (osid.proxy.Proxy): a proxy\n", 
               "return_doc": "        return:\n                (osid.assessment.authoring.AssessmentPartNotificationSes\n                sion) - an ``AssessmentPartNotificationSession``", 
               "error_doc": "        raise:  NullArgument - ``assessment_part_receiver`` or ``proxy``\n                is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented -\n                ``supports_assessment_part_notification()`` is ``false``", 
               "sphinx_param_doc": "        :param assessment_part_receiver: the notification callback\n        :type assessment_part_receiver: ``osid.assessment.authoring.AssessmentPartReceiver``\n        :param proxy: a proxy\n        :type proxy: ``osid.proxy.Proxy``\n", 
               "sphinx_return_doc": "        :return: an ``AssessmentPartNotificationSession``\n        :rtype: ``osid.assessment.authoring.AssessmentPartNotificationSession``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``assessment_part_receiver`` or ``proxy`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_assessment_part_notification()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_assessment_part_notification()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.assessment.authoring.AssessmentPartReceiver", 
                     "var_name": "assessment_part_receiver", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.proxy.Proxy", 
                     "var_name": "proxy", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.assessment.authoring.AssessmentPartReceiver", 
                  "osid.proxy.Proxy"
               ], 
               "return_type": "osid.assessment.authoring.AssessmentPartNotificationSession", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_assessment_part_notification_session_for_bank", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` associated with the assessment part notification service for the given bank.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    assessment_part_receiver\n                (osid.assessment.authoring.AssessmentPartReceiver): the\n                notification callback\n        arg:    bank_id (osid.id.Id): the ``Id`` of the ``Bank``\n        arg:    proxy (osid.proxy.Proxy): a proxy\n", 
               "return_doc": "        return:\n                (osid.assessment.authoring.AssessmentPartNotificationSes\n                sion) - an ``AssessmentPartNotificationSession``", 
               "error_doc": "        raise:  NotFound - no bank found by the given ``Id``\n        raise:  NullArgument - ``assessment_part_receiver, bank_id`` or\n                ``proxy`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented -\n                ``supports_assessment_part_notification()`` or\n                ``supports_visible_federation()`` is ``false``", 
               "sphinx_param_doc": "        :param assessment_part_receiver: the notification callback\n        :type assessment_part_receiver: ``osid.assessment.authoring.AssessmentPartReceiver``\n        :param bank_id: the ``Id`` of the ``Bank``\n        :type bank_id: ``osid.id.Id``\n        :param proxy: a proxy\n        :type proxy: ``osid.proxy.Proxy``\n", 
               "sphinx_return_doc": "        :return: an ``AssessmentPartNotificationSession``\n        :rtype: ``osid.assessment.authoring.AssessmentPartNotificationSession``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- no bank found by the given ``Id``\n        :raise: ``NullArgument`` -- ``assessment_part_receiver, bank_id`` or ``proxy`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_assessment_part_notification()`` or ``supports_visible_federation()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_assessment_part_notification()`` and ``supports_visible_federation()`` are ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.assessment.authoring.AssessmentPartReceiver", 
                     "var_name": "assessment_part_receiver", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "bank_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.proxy.Proxy", 
                     "var_name": "proxy", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.assessment.authoring.AssessmentPartReceiver", 
                  "osid.id.Id", 
                  "osid.proxy.Proxy"
               ], 
               "return_type": "osid.assessment.authoring.AssessmentPartNotificationSession", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_assessment_part_bank_session", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` to lookup assessment part/bank mappings for assessment parts.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    proxy (osid.proxy.Proxy): a proxy\n", 
               "return_doc": "        return: (osid.assessment.authoring.AssessmentPartBankSession) -\n                an ``AssessmentPartBankSession``", 
               "error_doc": "        raise:  NullArgument - ``proxy`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_assessment_part_bank()`` is\n                ``false``", 
               "sphinx_param_doc": "        :param proxy: a proxy\n        :type proxy: ``osid.proxy.Proxy``\n", 
               "sphinx_return_doc": "        :return: an ``AssessmentPartBankSession``\n        :rtype: ``osid.assessment.authoring.AssessmentPartBankSession``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``proxy`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_assessment_part_bank()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_assessment_part_bank()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.proxy.Proxy", 
                     "var_name": "proxy", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.proxy.Proxy"
               ], 
               "return_type": "osid.assessment.authoring.AssessmentPartBankSession", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_assessment_part_bank_assignment_session", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` associated with assigning assessment part to bank.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    proxy (osid.proxy.Proxy): a proxy\n", 
               "return_doc": "        return:\n                (osid.assessment.authoring.AssessmentPartBankAssignmentS\n                ession) - an ``AssessmentPartBankAssignmentSession``", 
               "error_doc": "        raise:  NullArgument - ``proxy`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented -\n                ``supports_assessment_part_bank_assignment()`` is\n                ``false``", 
               "sphinx_param_doc": "        :param proxy: a proxy\n        :type proxy: ``osid.proxy.Proxy``\n", 
               "sphinx_return_doc": "        :return: an ``AssessmentPartBankAssignmentSession``\n        :rtype: ``osid.assessment.authoring.AssessmentPartBankAssignmentSession``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``proxy`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_assessment_part_bank_assignment()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_assessment_part_bank_assignment()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.proxy.Proxy", 
                     "var_name": "proxy", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.proxy.Proxy"
               ], 
               "return_type": "osid.assessment.authoring.AssessmentPartBankAssignmentSession", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_assessment_part_smart_bank_session", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` to manage assessment part smart bank.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    bank_id (osid.id.Id): the ``Id`` of the ``Bank``\n        arg:    proxy (osid.proxy.Proxy): a proxy\n", 
               "return_doc": "        return:\n                (osid.assessment.authoring.AssessmentPartSmartBankSessio\n                n) - an ``AssessmentPartSmartBankSession``", 
               "error_doc": "        raise:  NotFound - no ``Bank`` found by the given ``Id``\n        raise:  NullArgument - ``bank_id`` or ``proxy`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented -\n                ``supports_assessment_part_smart_bank()`` is ``false``", 
               "sphinx_param_doc": "        :param bank_id: the ``Id`` of the ``Bank``\n        :type bank_id: ``osid.id.Id``\n        :param proxy: a proxy\n        :type proxy: ``osid.proxy.Proxy``\n", 
               "sphinx_return_doc": "        :return: an ``AssessmentPartSmartBankSession``\n        :rtype: ``osid.assessment.authoring.AssessmentPartSmartBankSession``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- no ``Bank`` found by the given ``Id``\n        :raise: ``NullArgument`` -- ``bank_id`` or ``proxy`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_assessment_part_smart_bank()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_assessment_part_smart_bank()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "bank_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.proxy.Proxy", 
                     "var_name": "proxy", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "osid.proxy.Proxy"
               ], 
               "return_type": "osid.assessment.authoring.AssessmentPartSmartBankSession", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_sequence_rule_lookup_session", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` associated with the sequence rule lookup service.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    proxy (osid.proxy.Proxy): a proxy\n", 
               "return_doc": "        return: (osid.assessment.authoring.SequenceRuleLookupSession) -\n                a ``SequenceRuleLookupSession``", 
               "error_doc": "        raise:  NullArgument - ``proxy`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_sequence_rule_lookup()`` is\n                ``false``", 
               "sphinx_param_doc": "        :param proxy: a proxy\n        :type proxy: ``osid.proxy.Proxy``\n", 
               "sphinx_return_doc": "        :return: a ``SequenceRuleLookupSession``\n        :rtype: ``osid.assessment.authoring.SequenceRuleLookupSession``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``proxy`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_sequence_rule_lookup()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_sequence_rule_lookup()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.proxy.Proxy", 
                     "var_name": "proxy", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.proxy.Proxy"
               ], 
               "return_type": "osid.assessment.authoring.SequenceRuleLookupSession", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_sequence_rule_lookup_session_for_bank", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` associated with the sequence rule lookup service for the given bank.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    bank_id (osid.id.Id): the ``Id`` of the ``Bank``\n        arg:    proxy (osid.proxy.Proxy): a proxy\n", 
               "return_doc": "        return: (osid.assessment.authoring.SequenceRuleLookupSession) -\n                a ``SequenceRuleLookupSession``", 
               "error_doc": "        raise:  NotFound - no ``Bank`` found by the given ``Id``\n        raise:  NullArgument - ``bank_id or proxy is null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_sequence_rule_lookup()`` or\n                ``supports_visible_federation()`` is ``false``", 
               "sphinx_param_doc": "        :param bank_id: the ``Id`` of the ``Bank``\n        :type bank_id: ``osid.id.Id``\n        :param proxy: a proxy\n        :type proxy: ``osid.proxy.Proxy``\n", 
               "sphinx_return_doc": "        :return: a ``SequenceRuleLookupSession``\n        :rtype: ``osid.assessment.authoring.SequenceRuleLookupSession``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- no ``Bank`` found by the given ``Id``\n        :raise: ``NullArgument`` -- ``bank_id or proxy is null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_sequence_rule_lookup()`` or ``supports_visible_federation()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_sequence_rule_lookup()`` and ``supports_visible_federation()`` are ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "bank_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.proxy.Proxy", 
                     "var_name": "proxy", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "osid.proxy.Proxy"
               ], 
               "return_type": "osid.assessment.authoring.SequenceRuleLookupSession", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_sequence_rule_query_session", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` associated with the sequence rule query service.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    proxy (osid.proxy.Proxy): a proxy\n", 
               "return_doc": "        return: (osid.assessment.authoring.SequenceRuleQuerySession) - a\n                ``SequenceRuleQuerySession``", 
               "error_doc": "        raise:  NullArgument - ``proxy`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_sequence_rule_query()`` is\n                ``false``", 
               "sphinx_param_doc": "        :param proxy: a proxy\n        :type proxy: ``osid.proxy.Proxy``\n", 
               "sphinx_return_doc": "        :return: a ``SequenceRuleQuerySession``\n        :rtype: ``osid.assessment.authoring.SequenceRuleQuerySession``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``proxy`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_sequence_rule_query()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_sequence_rule_query()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.proxy.Proxy", 
                     "var_name": "proxy", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.proxy.Proxy"
               ], 
               "return_type": "osid.assessment.authoring.SequenceRuleQuerySession", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_sequence_rule_query_session_for_bank", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` associated with the sequence rule query service for the given bank.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    bank_id (osid.id.Id): the ``Id`` of the ``Bank``\n        arg:    proxy (osid.proxy.Proxy): a proxy\n", 
               "return_doc": "        return: (osid.assessment.authoring.SequenceRuleQuerySession) - a\n                ``SequenceRuleQuerySession``", 
               "error_doc": "        raise:  NotFound - no ``Bank`` found by the given ``Id``\n        raise:  NullArgument - ``bank_id or proxy is null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_sequence_rule_query()`` or\n                ``supports_visible_federation()`` is ``false``", 
               "sphinx_param_doc": "        :param bank_id: the ``Id`` of the ``Bank``\n        :type bank_id: ``osid.id.Id``\n        :param proxy: a proxy\n        :type proxy: ``osid.proxy.Proxy``\n", 
               "sphinx_return_doc": "        :return: a ``SequenceRuleQuerySession``\n        :rtype: ``osid.assessment.authoring.SequenceRuleQuerySession``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- no ``Bank`` found by the given ``Id``\n        :raise: ``NullArgument`` -- ``bank_id or proxy is null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_sequence_rule_query()`` or ``supports_visible_federation()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_sequence_rule_query()`` and ``supports_visible_federation()`` are ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "bank_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.proxy.Proxy", 
                     "var_name": "proxy", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "osid.proxy.Proxy"
               ], 
               "return_type": "osid.assessment.authoring.SequenceRuleQuerySession", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_sequence_rule_search_session", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` associated with the sequence rule search service.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    proxy (osid.proxy.Proxy): a proxy\n", 
               "return_doc": "        return: (osid.assessment.authoring.SequenceRuleSearchSession) -\n                a ``SequenceRuleSearchSession``", 
               "error_doc": "        raise:  NullArgument - ``proxy`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_sequence_rule_search()`` is\n                ``false``", 
               "sphinx_param_doc": "        :param proxy: a proxy\n        :type proxy: ``osid.proxy.Proxy``\n", 
               "sphinx_return_doc": "        :return: a ``SequenceRuleSearchSession``\n        :rtype: ``osid.assessment.authoring.SequenceRuleSearchSession``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``proxy`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_sequence_rule_search()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_sequence_rule_search()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.proxy.Proxy", 
                     "var_name": "proxy", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.proxy.Proxy"
               ], 
               "return_type": "osid.assessment.authoring.SequenceRuleSearchSession", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_sequence_rule_search_session_for_bank", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` associated with the sequence rule earch service for the given bank.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    bank_id (osid.id.Id): the ``Id`` of the ``Bank``\n        arg:    proxy (osid.proxy.Proxy): a proxy\n", 
               "return_doc": "        return: (osid.assessment.authoring.SequenceRuleSearchSession) -\n                a ``SequenceRuleSearchSession``", 
               "error_doc": "        raise:  NotFound - no ``Bank`` found by the given ``Id``\n        raise:  NullArgument - ``bank_id or proxy is null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_sequence_rule_search()`` or\n                ``supports_visible_federation()`` is ``false``", 
               "sphinx_param_doc": "        :param bank_id: the ``Id`` of the ``Bank``\n        :type bank_id: ``osid.id.Id``\n        :param proxy: a proxy\n        :type proxy: ``osid.proxy.Proxy``\n", 
               "sphinx_return_doc": "        :return: a ``SequenceRuleSearchSession``\n        :rtype: ``osid.assessment.authoring.SequenceRuleSearchSession``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- no ``Bank`` found by the given ``Id``\n        :raise: ``NullArgument`` -- ``bank_id or proxy is null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_sequence_rule_search()`` or ``supports_visible_federation()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_sequence_rule_search()`` and ``supports_visible_federation()`` are ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "bank_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.proxy.Proxy", 
                     "var_name": "proxy", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "osid.proxy.Proxy"
               ], 
               "return_type": "osid.assessment.authoring.SequenceRuleSearchSession", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_sequence_rule_admin_session", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` associated with the sequence rule administration service.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    proxy (osid.proxy.Proxy): a proxy\n", 
               "return_doc": "        return: (osid.assessment.authoring.SequenceRuleAdminSession) - a\n                ``SequenceRuleAdminSession``", 
               "error_doc": "        raise:  NullArgument - ``proxy`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_sequence_rule_admin()`` is\n                ``false``", 
               "sphinx_param_doc": "        :param proxy: a proxy\n        :type proxy: ``osid.proxy.Proxy``\n", 
               "sphinx_return_doc": "        :return: a ``SequenceRuleAdminSession``\n        :rtype: ``osid.assessment.authoring.SequenceRuleAdminSession``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``proxy`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_sequence_rule_admin()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_sequence_rule_admin()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.proxy.Proxy", 
                     "var_name": "proxy", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.proxy.Proxy"
               ], 
               "return_type": "osid.assessment.authoring.SequenceRuleAdminSession", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_sequence_rule_admin_session_for_bank", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` associated with the sequence rule administration service for the given bank.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    bank_id (osid.id.Id): the ``Id`` of the ``Bank``\n        arg:    proxy (osid.proxy.Proxy): a proxy\n", 
               "return_doc": "        return: (osid.assessment.authoring.SequenceRuleAdminSession) - a\n                ``SequenceRuleAdminSession``", 
               "error_doc": "        raise:  NotFound - no ``Bank`` found by the given ``Id``\n        raise:  NullArgument - ``bank_id or proxy is null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_sequence_rule_admin()`` or\n                ``supports_visible_federation()`` is ``false``", 
               "sphinx_param_doc": "        :param bank_id: the ``Id`` of the ``Bank``\n        :type bank_id: ``osid.id.Id``\n        :param proxy: a proxy\n        :type proxy: ``osid.proxy.Proxy``\n", 
               "sphinx_return_doc": "        :return: a ``SequenceRuleAdminSession``\n        :rtype: ``osid.assessment.authoring.SequenceRuleAdminSession``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- no ``Bank`` found by the given ``Id``\n        :raise: ``NullArgument`` -- ``bank_id or proxy is null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_sequence_rule_admin()`` or ``supports_visible_federation()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_sequence_rule_admin()`` and ``supports_visible_federation()`` are ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "bank_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.proxy.Proxy", 
                     "var_name": "proxy", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "osid.proxy.Proxy"
               ], 
               "return_type": "osid.assessment.authoring.SequenceRuleAdminSession", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_sequence_rule_notification_session", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` associated with the sequence rule notification service.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    sequence_rule_receiver\n                (osid.assessment.authoring.SequenceRuleReceiver): the\n                notification callback\n        arg:    proxy (osid.proxy.Proxy): a proxy\n", 
               "return_doc": "        return:\n                (osid.assessment.authoring.SequenceRuleNotificationSessi\n                on) - a ``SequenceRuleNotificationSession``", 
               "error_doc": "        raise:  NullArgument - ``sequence_rule_receiver`` or ``proxy``\n                is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented -\n                ``supports_sequence_rule_notification()`` is ``false``", 
               "sphinx_param_doc": "        :param sequence_rule_receiver: the notification callback\n        :type sequence_rule_receiver: ``osid.assessment.authoring.SequenceRuleReceiver``\n        :param proxy: a proxy\n        :type proxy: ``osid.proxy.Proxy``\n", 
               "sphinx_return_doc": "        :return: a ``SequenceRuleNotificationSession``\n        :rtype: ``osid.assessment.authoring.SequenceRuleNotificationSession``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``sequence_rule_receiver`` or ``proxy`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_sequence_rule_notification()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_sequence_rule_notification()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.assessment.authoring.SequenceRuleReceiver", 
                     "var_name": "sequence_rule_receiver", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.proxy.Proxy", 
                     "var_name": "proxy", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.assessment.authoring.SequenceRuleReceiver", 
                  "osid.proxy.Proxy"
               ], 
               "return_type": "osid.assessment.authoring.SequenceRuleNotificationSession", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_sequence_rule_notification_session_for_bank", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` associated with the sequence rule notification service for the given bank.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    sequence_rule_receiver\n                (osid.assessment.authoring.SequenceRuleReceiver): the\n                notification callback\n        arg:    bank_id (osid.id.Id): the ``Id`` of the ``Bank``\n        arg:    proxy (osid.proxy.Proxy): a proxy\n", 
               "return_doc": "        return:\n                (osid.assessment.authoring.SequenceRuleNotificationSessi\n                on) - a ``SequenceRuleNotificationSession``", 
               "error_doc": "        raise:  NotFound - no bank found by the given ``Id``\n        raise:  NullArgument - ``sequence_rule_receiver, bank_id`` or\n                ``proxy`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented -\n                ``supports_sequence_rule_notification()`` or\n                ``supports_visible_federation()`` is ``false``", 
               "sphinx_param_doc": "        :param sequence_rule_receiver: the notification callback\n        :type sequence_rule_receiver: ``osid.assessment.authoring.SequenceRuleReceiver``\n        :param bank_id: the ``Id`` of the ``Bank``\n        :type bank_id: ``osid.id.Id``\n        :param proxy: a proxy\n        :type proxy: ``osid.proxy.Proxy``\n", 
               "sphinx_return_doc": "        :return: a ``SequenceRuleNotificationSession``\n        :rtype: ``osid.assessment.authoring.SequenceRuleNotificationSession``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- no bank found by the given ``Id``\n        :raise: ``NullArgument`` -- ``sequence_rule_receiver, bank_id`` or ``proxy`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_sequence_rule_notification()`` or ``supports_visible_federation()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_sequence_rule_notification()`` and ``supports_visible_federation()`` are ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.assessment.authoring.SequenceRuleReceiver", 
                     "var_name": "sequence_rule_receiver", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "bank_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.proxy.Proxy", 
                     "var_name": "proxy", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.assessment.authoring.SequenceRuleReceiver", 
                  "osid.id.Id", 
                  "osid.proxy.Proxy"
               ], 
               "return_type": "osid.assessment.authoring.SequenceRuleNotificationSession", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_sequence_rule_bank_session", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` to lookup sequence rule/bank mappings for sequence rules.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    proxy (osid.proxy.Proxy): a proxy\n", 
               "return_doc": "        return: (osid.assessment.authoring.SequenceRuleBankSession) - a\n                ``SequenceRuleBankSession``", 
               "error_doc": "        raise:  NullArgument - ``proxy`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_sequence_rule_bank()`` is\n                ``false``", 
               "sphinx_param_doc": "        :param proxy: a proxy\n        :type proxy: ``osid.proxy.Proxy``\n", 
               "sphinx_return_doc": "        :return: a ``SequenceRuleBankSession``\n        :rtype: ``osid.assessment.authoring.SequenceRuleBankSession``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``proxy`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_sequence_rule_bank()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_sequence_rule_bank()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.proxy.Proxy", 
                     "var_name": "proxy", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.proxy.Proxy"
               ], 
               "return_type": "osid.assessment.authoring.SequenceRuleBankSession", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_sequence_rule_bank_assignment_session", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` associated with assigning sequence rule to bank.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    proxy (osid.proxy.Proxy): a proxy\n", 
               "return_doc": "        return:\n                (osid.assessment.authoring.SequenceRuleBankAssignmentSes\n                sion) - a ``SequenceRuleBankAssignmentSession``", 
               "error_doc": "        raise:  NullArgument - ``proxy`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented -\n                ``supports_sequence_rule_bank_assignment()`` is\n                ``false``", 
               "sphinx_param_doc": "        :param proxy: a proxy\n        :type proxy: ``osid.proxy.Proxy``\n", 
               "sphinx_return_doc": "        :return: a ``SequenceRuleBankAssignmentSession``\n        :rtype: ``osid.assessment.authoring.SequenceRuleBankAssignmentSession``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``proxy`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_sequence_rule_bank_assignment()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_sequence_rule_bank_assignment()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.proxy.Proxy", 
                     "var_name": "proxy", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.proxy.Proxy"
               ], 
               "return_type": "osid.assessment.authoring.SequenceRuleBankAssignmentSession", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_sequence_rule_smart_bank_session", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` to manage sequence rule smart bank.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    bank_id (osid.id.Id): the ``Id`` of the ``Bank``\n        arg:    proxy (osid.proxy.Proxy): a proxy\n", 
               "return_doc": "        return: (osid.assessment.authoring.SequenceRuleSmartBankSession)\n                - a ``SequenceRuleSmartBankSession``", 
               "error_doc": "        raise:  NotFound - no ``Bank`` found by the given ``Id``\n        raise:  NullArgument - ``bank_id`` or ``proxy`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_sequence_rule_smart_bank()``\n                is ``false``", 
               "sphinx_param_doc": "        :param bank_id: the ``Id`` of the ``Bank``\n        :type bank_id: ``osid.id.Id``\n        :param proxy: a proxy\n        :type proxy: ``osid.proxy.Proxy``\n", 
               "sphinx_return_doc": "        :return: a ``SequenceRuleSmartBankSession``\n        :rtype: ``osid.assessment.authoring.SequenceRuleSmartBankSession``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- no ``Bank`` found by the given ``Id``\n        :raise: ``NullArgument`` -- ``bank_id`` or ``proxy`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_sequence_rule_smart_bank()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_sequence_rule_smart_bank()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "bank_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.proxy.Proxy", 
                     "var_name": "proxy", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "osid.proxy.Proxy"
               ], 
               "return_type": "osid.assessment.authoring.SequenceRuleSmartBankSession", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_sequence_rule_enabler_lookup_session", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` associated with the sequence rule enabler lookup service.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    proxy (osid.proxy.Proxy): a proxy\n", 
               "return_doc": "        return:\n                (osid.assessment.authoring.SequenceRuleEnablerLookupSess\n                ion) - a ``SequenceRuleEnablerLookupSession``", 
               "error_doc": "        raise:  NullArgument - ``proxy`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented -\n                ``supports_sequence_rule_enabler_lookup()`` is ``false``", 
               "sphinx_param_doc": "        :param proxy: a proxy\n        :type proxy: ``osid.proxy.Proxy``\n", 
               "sphinx_return_doc": "        :return: a ``SequenceRuleEnablerLookupSession``\n        :rtype: ``osid.assessment.authoring.SequenceRuleEnablerLookupSession``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``proxy`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_sequence_rule_enabler_lookup()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_sequence_rule_enabler_lookup()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.proxy.Proxy", 
                     "var_name": "proxy", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.proxy.Proxy"
               ], 
               "return_type": "osid.assessment.authoring.SequenceRuleEnablerLookupSession", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_sequence_rule_enabler_lookup_session_for_bank", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` associated with the sequence rule enabler lookup service for the given bank.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    bank_id (osid.id.Id): the ``Id`` of the ``Bank``\n        arg:    proxy (osid.proxy.Proxy): a proxy\n", 
               "return_doc": "        return:\n                (osid.assessment.authoring.SequenceRuleEnablerLookupSess\n                ion) - a ``SequenceRuleEnablerLookupSession``", 
               "error_doc": "        raise:  NotFound - no ``Bank`` found by the given ``Id``\n        raise:  NullArgument - ``bank_id or proxy is null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented -\n                ``supports_sequence_rule_enabler_lookup()`` or\n                ``supports_visible_federation()`` is ``false``", 
               "sphinx_param_doc": "        :param bank_id: the ``Id`` of the ``Bank``\n        :type bank_id: ``osid.id.Id``\n        :param proxy: a proxy\n        :type proxy: ``osid.proxy.Proxy``\n", 
               "sphinx_return_doc": "        :return: a ``SequenceRuleEnablerLookupSession``\n        :rtype: ``osid.assessment.authoring.SequenceRuleEnablerLookupSession``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- no ``Bank`` found by the given ``Id``\n        :raise: ``NullArgument`` -- ``bank_id or proxy is null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_sequence_rule_enabler_lookup()`` or ``supports_visible_federation()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_sequence_rule_enabler_lookup()`` and ``supports_visible_federation()`` are ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "bank_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.proxy.Proxy", 
                     "var_name": "proxy", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "osid.proxy.Proxy"
               ], 
               "return_type": "osid.assessment.authoring.SequenceRuleEnablerLookupSession", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_sequence_rule_enabler_query_session", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` associated with the sequence rule enabler query service.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    proxy (osid.proxy.Proxy): a proxy\n", 
               "return_doc": "        return:\n                (osid.assessment.authoring.SequenceRuleEnablerQuerySessi\n                on) - a ``SequenceRuleEnablerQuerySession``", 
               "error_doc": "        raise:  NullArgument - ``proxy`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented -\n                ``supports_sequence_rule_enabler_query()`` is ``false``", 
               "sphinx_param_doc": "        :param proxy: a proxy\n        :type proxy: ``osid.proxy.Proxy``\n", 
               "sphinx_return_doc": "        :return: a ``SequenceRuleEnablerQuerySession``\n        :rtype: ``osid.assessment.authoring.SequenceRuleEnablerQuerySession``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``proxy`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_sequence_rule_enabler_query()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_sequence_rule_enabler_query()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.proxy.Proxy", 
                     "var_name": "proxy", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.proxy.Proxy"
               ], 
               "return_type": "osid.assessment.authoring.SequenceRuleEnablerQuerySession", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_sequence_rule_enabler_query_session_for_bank", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` associated with the sequence rule enabler query service for the given bank.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    bank_id (osid.id.Id): the ``Id`` of the ``Bank``\n        arg:    proxy (osid.proxy.Proxy): a proxy\n", 
               "return_doc": "        return:\n                (osid.assessment.authoring.SequenceRuleEnablerQuerySessi\n                on) - a ``SequenceRuleEnablerQuerySession``", 
               "error_doc": "        raise:  NotFound - no ``Bank`` found by the given ``Id``\n        raise:  NullArgument - ``bank_id or proxy is null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented -\n                ``supports_sequence_rule_enabler_query()`` or\n                ``supports_visible_federation()`` is ``false``", 
               "sphinx_param_doc": "        :param bank_id: the ``Id`` of the ``Bank``\n        :type bank_id: ``osid.id.Id``\n        :param proxy: a proxy\n        :type proxy: ``osid.proxy.Proxy``\n", 
               "sphinx_return_doc": "        :return: a ``SequenceRuleEnablerQuerySession``\n        :rtype: ``osid.assessment.authoring.SequenceRuleEnablerQuerySession``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- no ``Bank`` found by the given ``Id``\n        :raise: ``NullArgument`` -- ``bank_id or proxy is null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_sequence_rule_enabler_query()`` or ``supports_visible_federation()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_sequence_rule_enabler_query()`` and ``supports_visible_federation()`` are ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "bank_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.proxy.Proxy", 
                     "var_name": "proxy", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "osid.proxy.Proxy"
               ], 
               "return_type": "osid.assessment.authoring.SequenceRuleEnablerQuerySession", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_sequence_rule_enabler_search_session", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` associated with the sequence rule enabler search service.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    proxy (osid.proxy.Proxy): a proxy\n", 
               "return_doc": "        return:\n                (osid.assessment.authoring.SequenceRuleEnablerSearchSess\n                ion) - a ``SequenceRuleEnablerSearchSession``", 
               "error_doc": "        raise:  NullArgument - ``proxy`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented -\n                ``supports_sequence_rule_enabler_search()`` is ``false``", 
               "sphinx_param_doc": "        :param proxy: a proxy\n        :type proxy: ``osid.proxy.Proxy``\n", 
               "sphinx_return_doc": "        :return: a ``SequenceRuleEnablerSearchSession``\n        :rtype: ``osid.assessment.authoring.SequenceRuleEnablerSearchSession``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``proxy`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_sequence_rule_enabler_search()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_sequence_rule_enabler_search()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.proxy.Proxy", 
                     "var_name": "proxy", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.proxy.Proxy"
               ], 
               "return_type": "osid.assessment.authoring.SequenceRuleEnablerSearchSession", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_sequence_rule_enabler_search_session_for_bank", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` associated with the sequence rule enablers earch service for the given bank.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    bank_id (osid.id.Id): the ``Id`` of the ``Bank``\n        arg:    proxy (osid.proxy.Proxy): a proxy\n", 
               "return_doc": "        return:\n                (osid.assessment.authoring.SequenceRuleEnablerSearchSess\n                ion) - a ``SequenceRuleEnablerSearchSession``", 
               "error_doc": "        raise:  NotFound - no ``Bank`` found by the given ``Id``\n        raise:  NullArgument - ``bank_id or proxy is null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented -\n                ``supports_sequence_rule_enabler_search()`` or\n                ``supports_visible_federation()`` is ``false``", 
               "sphinx_param_doc": "        :param bank_id: the ``Id`` of the ``Bank``\n        :type bank_id: ``osid.id.Id``\n        :param proxy: a proxy\n        :type proxy: ``osid.proxy.Proxy``\n", 
               "sphinx_return_doc": "        :return: a ``SequenceRuleEnablerSearchSession``\n        :rtype: ``osid.assessment.authoring.SequenceRuleEnablerSearchSession``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- no ``Bank`` found by the given ``Id``\n        :raise: ``NullArgument`` -- ``bank_id or proxy is null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_sequence_rule_enabler_search()`` or ``supports_visible_federation()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_sequence_rule_enabler_search()`` and ``supports_visible_federation()`` are ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "bank_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.proxy.Proxy", 
                     "var_name": "proxy", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "osid.proxy.Proxy"
               ], 
               "return_type": "osid.assessment.authoring.SequenceRuleEnablerSearchSession", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_sequence_rule_enabler_admin_session", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` associated with the sequence rule enabler administration service.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    proxy (osid.proxy.Proxy): a proxy\n", 
               "return_doc": "        return:\n                (osid.assessment.authoring.SequenceRuleEnablerAdminSessi\n                on) - a ``SequenceRuleEnablerAdminSession``", 
               "error_doc": "        raise:  NullArgument - ``proxy`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented -\n                ``supports_sequence_rule_enabler_admin()`` is ``false``", 
               "sphinx_param_doc": "        :param proxy: a proxy\n        :type proxy: ``osid.proxy.Proxy``\n", 
               "sphinx_return_doc": "        :return: a ``SequenceRuleEnablerAdminSession``\n        :rtype: ``osid.assessment.authoring.SequenceRuleEnablerAdminSession``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``proxy`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_sequence_rule_enabler_admin()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_sequence_rule_enabler_admin()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.proxy.Proxy", 
                     "var_name": "proxy", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.proxy.Proxy"
               ], 
               "return_type": "osid.assessment.authoring.SequenceRuleEnablerAdminSession", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_sequence_rule_enabler_admin_session_for_bank", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` associated with the sequence rule enabler administration service for the given bank.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    bank_id (osid.id.Id): the ``Id`` of the ``Bank``\n        arg:    proxy (osid.proxy.Proxy): a proxy\n", 
               "return_doc": "        return:\n                (osid.assessment.authoring.SequenceRuleEnablerAdminSessi\n                on) - a ``SequenceRuleEnablerAdminSession``", 
               "error_doc": "        raise:  NotFound - no ``Bank`` found by the given ``Id``\n        raise:  NullArgument - ``bank_id or proxy is null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented -\n                ``supports_sequence_rule_enabler_admin()`` or\n                ``supports_visible_federation()`` is ``false``", 
               "sphinx_param_doc": "        :param bank_id: the ``Id`` of the ``Bank``\n        :type bank_id: ``osid.id.Id``\n        :param proxy: a proxy\n        :type proxy: ``osid.proxy.Proxy``\n", 
               "sphinx_return_doc": "        :return: a ``SequenceRuleEnablerAdminSession``\n        :rtype: ``osid.assessment.authoring.SequenceRuleEnablerAdminSession``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- no ``Bank`` found by the given ``Id``\n        :raise: ``NullArgument`` -- ``bank_id or proxy is null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_sequence_rule_enabler_admin()`` or ``supports_visible_federation()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_sequence_rule_enabler_admin()`` and ``supports_visible_federation()`` are ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "bank_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.proxy.Proxy", 
                     "var_name": "proxy", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "osid.proxy.Proxy"
               ], 
               "return_type": "osid.assessment.authoring.SequenceRuleEnablerAdminSession", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_sequence_rule_enabler_notification_session", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` associated with the sequence rule enabler notification service.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    sequence_rule_enabler_receiver\n                (osid.assessment.authoring.SequenceRuleEnablerReceiver):\n                the notification callback\n        arg:    proxy (osid.proxy.Proxy): a proxy\n", 
               "return_doc": "        return: (osid.assessment.authoring.SequenceRuleEnablerNotificati\n                onSession) - a\n                ``SequenceRuleEnablerNotificationSession``", 
               "error_doc": "        raise:  NullArgument - ``sequence_rule_enabler_receiver`` or\n                ``proxy`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented -\n                ``supports_sequence_rule_enabler_notification()`` is\n                ``false``", 
               "sphinx_param_doc": "        :param sequence_rule_enabler_receiver: the notification callback\n        :type sequence_rule_enabler_receiver: ``osid.assessment.authoring.SequenceRuleEnablerReceiver``\n        :param proxy: a proxy\n        :type proxy: ``osid.proxy.Proxy``\n", 
               "sphinx_return_doc": "        :return: a ``SequenceRuleEnablerNotificationSession``\n        :rtype: ``osid.assessment.authoring.SequenceRuleEnablerNotificationSession``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``sequence_rule_enabler_receiver`` or ``proxy`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_sequence_rule_enabler_notification()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_sequence_rule_enabler_notification()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.assessment.authoring.SequenceRuleEnablerReceiver", 
                     "var_name": "sequence_rule_enabler_receiver", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.proxy.Proxy", 
                     "var_name": "proxy", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.assessment.authoring.SequenceRuleEnablerReceiver", 
                  "osid.proxy.Proxy"
               ], 
               "return_type": "osid.assessment.authoring.SequenceRuleEnablerNotificationSession", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_sequence_rule_enabler_notification_session_for_bank", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` associated with the sequence rule enabler notification service for the given bank.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    sequence_rule_enabler_receiver\n                (osid.assessment.authoring.SequenceRuleEnablerReceiver):\n                the notification callback\n        arg:    bank_id (osid.id.Id): the ``Id`` of the ``Bank``\n        arg:    proxy (osid.proxy.Proxy): a proxy\n", 
               "return_doc": "        return: (osid.assessment.authoring.SequenceRuleEnablerNotificati\n                onSession) - a\n                ``SequenceRuleEnablerNotificationSession``", 
               "error_doc": "        raise:  NotFound - no bank found by the given ``Id``\n        raise:  NullArgument - ``sequence_rule_enabler_receiver,\n                bank_id`` or ``proxy`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented -\n                ``supports_sequence_rule_enabler_notification()`` or\n                ``supports_visible_federation()`` is ``false``", 
               "sphinx_param_doc": "        :param sequence_rule_enabler_receiver: the notification callback\n        :type sequence_rule_enabler_receiver: ``osid.assessment.authoring.SequenceRuleEnablerReceiver``\n        :param bank_id: the ``Id`` of the ``Bank``\n        :type bank_id: ``osid.id.Id``\n        :param proxy: a proxy\n        :type proxy: ``osid.proxy.Proxy``\n", 
               "sphinx_return_doc": "        :return: a ``SequenceRuleEnablerNotificationSession``\n        :rtype: ``osid.assessment.authoring.SequenceRuleEnablerNotificationSession``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- no bank found by the given ``Id``\n        :raise: ``NullArgument`` -- ``sequence_rule_enabler_receiver, bank_id`` or ``proxy`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_sequence_rule_enabler_notification()`` or ``supports_visible_federation()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_sequence_rule_enabler_notification()`` and ``supports_visible_federation()`` are ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.assessment.authoring.SequenceRuleEnablerReceiver", 
                     "var_name": "sequence_rule_enabler_receiver", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "bank_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.proxy.Proxy", 
                     "var_name": "proxy", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.assessment.authoring.SequenceRuleEnablerReceiver", 
                  "osid.id.Id", 
                  "osid.proxy.Proxy"
               ], 
               "return_type": "osid.assessment.authoring.SequenceRuleEnablerNotificationSession", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_sequence_rule_enabler_bank_session", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` to lookup sequence rule enabler/bank mappings for sequence rule enablers.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    proxy (osid.proxy.Proxy): a proxy\n", 
               "return_doc": "        return:\n                (osid.assessment.authoring.SequenceRuleEnablerBankSessio\n                n) - a ``SequenceRuleEnablerBankSession``", 
               "error_doc": "        raise:  NullArgument - ``proxy`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented -\n                ``supports_sequence_rule_enabler_bank()`` is ``false``", 
               "sphinx_param_doc": "        :param proxy: a proxy\n        :type proxy: ``osid.proxy.Proxy``\n", 
               "sphinx_return_doc": "        :return: a ``SequenceRuleEnablerBankSession``\n        :rtype: ``osid.assessment.authoring.SequenceRuleEnablerBankSession``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``proxy`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_sequence_rule_enabler_bank()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_sequence_rule_enabler_bank()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.proxy.Proxy", 
                     "var_name": "proxy", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.proxy.Proxy"
               ], 
               "return_type": "osid.assessment.authoring.SequenceRuleEnablerBankSession", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_sequence_rule_enabler_bank_assignment_session", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` associated with assigning sequence rule enablers to bank.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    proxy (osid.proxy.Proxy): a proxy\n", 
               "return_doc": "        return: (osid.assessment.authoring.SequenceRuleEnablerBankAssign\n                mentSession) - a\n                ``SequenceRuleEnablerBankAssignmentSession``", 
               "error_doc": "        raise:  NullArgument - ``proxy`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented -\n                ``supports_sequence_rule_enabler_bank_assignment()`` is\n                ``false``", 
               "sphinx_param_doc": "        :param proxy: a proxy\n        :type proxy: ``osid.proxy.Proxy``\n", 
               "sphinx_return_doc": "        :return: a ``SequenceRuleEnablerBankAssignmentSession``\n        :rtype: ``osid.assessment.authoring.SequenceRuleEnablerBankAssignmentSession``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``proxy`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_sequence_rule_enabler_bank_assignment()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_sequence_rule_enabler_bank_assignment()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.proxy.Proxy", 
                     "var_name": "proxy", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.proxy.Proxy"
               ], 
               "return_type": "osid.assessment.authoring.SequenceRuleEnablerBankAssignmentSession", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_sequence_rule_enabler_smart_bank_session", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` to manage sequence rule enabler smart bank.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    bank_id (osid.id.Id): the ``Id`` of the ``Bank``\n        arg:    proxy (osid.proxy.Proxy): a proxy\n", 
               "return_doc": "        return:\n                (osid.assessment.authoring.SequenceRuleEnablerSmartBankS\n                ession) - a ``SequenceRuleEnablerSmartBankSession``", 
               "error_doc": "        raise:  NotFound - no ``Bank`` found by the given ``Id``\n        raise:  NullArgument - ``bank_id`` or ``proxy`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented -\n                ``supports_sequence_rule_enabler_smart_bank()`` is\n                ``false``", 
               "sphinx_param_doc": "        :param bank_id: the ``Id`` of the ``Bank``\n        :type bank_id: ``osid.id.Id``\n        :param proxy: a proxy\n        :type proxy: ``osid.proxy.Proxy``\n", 
               "sphinx_return_doc": "        :return: a ``SequenceRuleEnablerSmartBankSession``\n        :rtype: ``osid.assessment.authoring.SequenceRuleEnablerSmartBankSession``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- no ``Bank`` found by the given ``Id``\n        :raise: ``NullArgument`` -- ``bank_id`` or ``proxy`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_sequence_rule_enabler_smart_bank()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_sequence_rule_enabler_smart_bank()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "bank_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.proxy.Proxy", 
                     "var_name": "proxy", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "osid.proxy.Proxy"
               ], 
               "return_type": "osid.assessment.authoring.SequenceRuleEnablerSmartBankSession", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_sequence_rule_enabler_rule_lookup_session", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` associated with the sequence rule enabler mapping lookup service.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    proxy (osid.proxy.Proxy): a proxy\n", 
               "return_doc": "        return:\n                (osid.assessment.authoring.SequenceRuleEnablerRuleLookup\n                Session) - a ``SequenceRuleEnablerRuleLookupSession``", 
               "error_doc": "        raise:  NullArgument - ``proxy`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented -\n                ``supports_sequence_rule_enabler_rule_lookup()`` is\n                ``false``", 
               "sphinx_param_doc": "        :param proxy: a proxy\n        :type proxy: ``osid.proxy.Proxy``\n", 
               "sphinx_return_doc": "        :return: a ``SequenceRuleEnablerRuleLookupSession``\n        :rtype: ``osid.assessment.authoring.SequenceRuleEnablerRuleLookupSession``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``proxy`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_sequence_rule_enabler_rule_lookup()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_sequence_rule_enabler_rule_lookup()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.proxy.Proxy", 
                     "var_name": "proxy", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.proxy.Proxy"
               ], 
               "return_type": "osid.assessment.authoring.SequenceRuleEnablerRuleLookupSession", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_sequence_rule_enabler_rule_lookup_session_for_bank", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` associated with the sequence rule enabler mapping lookup service for the given bank.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    bank_id (osid.id.Id): the ``Id`` of the ``Bank``\n        arg:    proxy (osid.proxy.Proxy): a proxy\n", 
               "return_doc": "        return:\n                (osid.assessment.authoring.SequenceRuleEnablerRuleLookup\n                Session) - a ``SequenceRuleEnablerRuleLookupSession``", 
               "error_doc": "        raise:  NotFound - no ``Bank`` found by the given ``Id``\n        raise:  NullArgument - ``bank_id`` or ``proxy`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented -\n                ``supports_sequence_rule_enabler_rule_lookup()`` or\n                ``supports_visible_federation()`` is ``false``", 
               "sphinx_param_doc": "        :param bank_id: the ``Id`` of the ``Bank``\n        :type bank_id: ``osid.id.Id``\n        :param proxy: a proxy\n        :type proxy: ``osid.proxy.Proxy``\n", 
               "sphinx_return_doc": "        :return: a ``SequenceRuleEnablerRuleLookupSession``\n        :rtype: ``osid.assessment.authoring.SequenceRuleEnablerRuleLookupSession``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- no ``Bank`` found by the given ``Id``\n        :raise: ``NullArgument`` -- ``bank_id`` or ``proxy`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_sequence_rule_enabler_rule_lookup()`` or ``supports_visible_federation()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_sequence_rule_enabler_rule_lookup()`` and ``supports_visible_federation()`` are ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "bank_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.proxy.Proxy", 
                     "var_name": "proxy", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "osid.proxy.Proxy"
               ], 
               "return_type": "osid.assessment.authoring.SequenceRuleEnablerRuleLookupSession", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_sequence_rule_enabler_rule_application_session", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` associated with the sequence rule enabler assignment service.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    proxy (osid.proxy.Proxy): a proxy\n", 
               "return_doc": "        return: (osid.assessment.authoring.SequenceRuleEnablerRuleApplic\n                ationSession) - a\n                ``SequenceRuleEnablerRuleApplicationSession``", 
               "error_doc": "        raise:  NullArgument - ``proxy`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented -\n                ``supports_sequence_rule_enabler_rule_application()`` is\n                ``false``", 
               "sphinx_param_doc": "        :param proxy: a proxy\n        :type proxy: ``osid.proxy.Proxy``\n", 
               "sphinx_return_doc": "        :return: a ``SequenceRuleEnablerRuleApplicationSession``\n        :rtype: ``osid.assessment.authoring.SequenceRuleEnablerRuleApplicationSession``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``proxy`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_sequence_rule_enabler_rule_application()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_sequence_rule_enabler_rule_application()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.proxy.Proxy", 
                     "var_name": "proxy", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.proxy.Proxy"
               ], 
               "return_type": "osid.assessment.authoring.SequenceRuleEnablerRuleApplicationSession", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_sequence_rule_enabler_rule_application_session_for_bank", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` associated with the sequence rule enabler assignment service for the given bank.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    bank_id (osid.id.Id): the ``Id`` of the ``Bank``\n        arg:    proxy (osid.proxy.Proxy): a proxy\n", 
               "return_doc": "        return: (osid.assessment.authoring.SequenceRuleEnablerRuleApplic\n                ationSession) - a\n                ``SequenceRuleEnablerRuleApplicationSession``", 
               "error_doc": "        raise:  NotFound - no ``Bank`` found by the given ``Id``\n        raise:  NullArgument - ``bank_id`` or ``proxy`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented -\n                ``supports_sequence_rule_enabler_rule_application()`` or\n                ``supports_visible_federation()`` is ``false``", 
               "sphinx_param_doc": "        :param bank_id: the ``Id`` of the ``Bank``\n        :type bank_id: ``osid.id.Id``\n        :param proxy: a proxy\n        :type proxy: ``osid.proxy.Proxy``\n", 
               "sphinx_return_doc": "        :return: a ``SequenceRuleEnablerRuleApplicationSession``\n        :rtype: ``osid.assessment.authoring.SequenceRuleEnablerRuleApplicationSession``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- no ``Bank`` found by the given ``Id``\n        :raise: ``NullArgument`` -- ``bank_id`` or ``proxy`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_sequence_rule_enabler_rule_application()`` or ``supports_visible_federation()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_sequence_rule_enabler_rule_application()`` and ``supports_visible_federation()`` are ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "bank_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.proxy.Proxy", 
                     "var_name": "proxy", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "osid.proxy.Proxy"
               ], 
               "return_type": "osid.assessment.authoring.SequenceRuleEnablerRuleApplicationSession", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.assessment.authoring.AssessmentPartLookupSession", 
         "shortname": "AssessmentPartLookupSession", 
         "category": "sessions", 
         "doc": {
            "headline": "This session defines methods for retrieving assessment parts.", 
            "body": ""
         }, 
         "inherit_fullnames": [
            "osid.OsidSession"
         ], 
         "inherit_shortnames": [
            "OsidSession"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidSession"
            }
         ], 
         "method_names": [
            "get_bank_id", 
            "get_bank", 
            "can_lookup_assessment_parts", 
            "use_comparative_assessment_part_view", 
            "use_plenary_assessment_part_view", 
            "use_federated_bank_view", 
            "use_isolated_bank_view", 
            "use_active_assessment_part_view", 
            "use_any_status_assessment_part_view", 
            "use_sequestered_assessment_part_view", 
            "use_unsequestered_assessment_part_view", 
            "get_assessment_part", 
            "get_assessment_parts_by_ids", 
            "get_assessment_parts_by_genus_type", 
            "get_assessment_parts_by_parent_genus_type", 
            "get_assessment_parts_by_record_type", 
            "get_assessment_parts_for_assessment", 
            "get_assessment_parts"
         ], 
         "methods": [
            {
               "name": "get_bank_id", 
               "doc": {
                  "headline": "Gets the ``Bank``  ``Id`` associated with this session.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.id.Id) - the ``Bank Id`` associated with this\n                session", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the ``Bank Id`` associated with this session\n        :rtype: ``osid.id.Id``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.id.Id", 
               "errors": {}
            }, 
            {
               "name": "get_bank", 
               "doc": {
                  "headline": "Gets the ``Bank`` associated with this session.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.assessment.Bank) - the ``Bank`` associated with\n                this session", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the ``Bank`` associated with this session\n        :rtype: ``osid.assessment.Bank``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.assessment.Bank", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "can_lookup_assessment_parts", 
               "doc": {
                  "headline": "Tests if this user can perform ``AssessmentPart`` lookups.", 
                  "body": "        A return of true does not guarantee successful authorization. A\n        return of false indicates that it is known all methods in this\n        session will result in a ``PermissionDenied``. This is intended\n        as a hint to an application that may not offer lookup operations\n        to unauthorized users."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``false`` if lookup methods are not\n                authorized, ``true`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``false`` if lookup methods are not authorized, ``true`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "use_comparative_assessment_part_view", 
               "doc": {
                  "headline": "The returns from the lookup methods may omit or translate elements based on this session, such as authorization, and not result in an error.", 
                  "body": "        This view is used when greater interoperability is desired at\n        the expense of precision."
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "use_plenary_assessment_part_view", 
               "doc": {
                  "headline": "A complete view of the ``AssessmentPart`` returns is desired.", 
                  "body": "        Methods will return what is requested or result in an error.\n        This view is used when greater precision is desired at the\n        expense of interoperability."
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "use_federated_bank_view", 
               "doc": {
                  "headline": "Federates the view for methods in this session.", 
                  "body": "        A federated view will include assessment parts in catalogs which\n        are children of this catalog in the bank hierarchy."
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "use_isolated_bank_view", 
               "doc": {
                  "headline": "Isolates the view for methods in this session.", 
                  "body": "        An isolated view restricts retrievals to this bank only."
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "use_active_assessment_part_view", 
               "doc": {
                  "headline": "Only active assessment parts are returned by methods in this session.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "use_any_status_assessment_part_view", 
               "doc": {
                  "headline": "All active and inactive assessment parts are returned by methods in this session.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "use_sequestered_assessment_part_view", 
               "doc": {
                  "headline": "The methods in this session omit sequestered assessment parts.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "use_unsequestered_assessment_part_view", 
               "doc": {
                  "headline": "The methods in this session return all assessment parts, including sequestered assessment parts.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "get_assessment_part", 
               "doc": {
                  "headline": "Gets the ``AssessmentPart`` specified by its ``Id``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    assessment_part_id (osid.id.Id): the ``Id`` of the\n                ``AssessmentPart`` to retrieve\n", 
               "return_doc": "        return: (osid.assessment.authoring.AssessmentPart) - the\n                returned ``AssessmentPart``", 
               "error_doc": "        raise:  NotFound - no ``AssessmentPart`` found with the given\n                ``Id``\n        raise:  NullArgument - ``assessment_part_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param assessment_part_id: the ``Id`` of the ``AssessmentPart`` to retrieve\n        :type assessment_part_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: the returned ``AssessmentPart``\n        :rtype: ``osid.assessment.authoring.AssessmentPart``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- no ``AssessmentPart`` found with the given ``Id``\n        :raise: ``NullArgument`` -- ``assessment_part_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "assessment_part_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "osid.assessment.authoring.AssessmentPart", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_assessment_parts_by_ids", 
               "doc": {
                  "headline": "Gets an ``AssessmentPartList`` corresponding to the given ``IdList``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    assessment_part_ids (osid.id.IdList): the list of\n                ``Ids`` to retrieve\n", 
               "return_doc": "        return: (osid.assessment.authoring.AssessmentPartList) - the\n                returned ``AssessmentPart`` list", 
               "error_doc": "        raise:  NotFound - an ``Id was`` not found\n        raise:  NullArgument - ``assessment_part_ids`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param assessment_part_ids: the list of ``Ids`` to retrieve\n        :type assessment_part_ids: ``osid.id.IdList``\n", 
               "sphinx_return_doc": "        :return: the returned ``AssessmentPart`` list\n        :rtype: ``osid.assessment.authoring.AssessmentPartList``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- an ``Id was`` not found\n        :raise: ``NullArgument`` -- ``assessment_part_ids`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.IdList", 
                     "var_name": "assessment_part_ids", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.IdList"
               ], 
               "return_type": "osid.assessment.authoring.AssessmentPartList", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_assessment_parts_by_genus_type", 
               "doc": {
                  "headline": "Gets an ``AssessmentPartList`` corresponding to the given assessment part genus ``Type`` which does not include assessment parts of types derived from the specified ``Type``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    assessment_part_genus_type (osid.type.Type): an\n                assessment part genus type\n", 
               "return_doc": "        return: (osid.assessment.authoring.AssessmentPartList) - the\n                returned ``AssessmentPart`` list", 
               "error_doc": "        raise:  NullArgument - ``assessment_part_genus_type`` is\n                ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param assessment_part_genus_type: an assessment part genus type\n        :type assessment_part_genus_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "        :return: the returned ``AssessmentPart`` list\n        :rtype: ``osid.assessment.authoring.AssessmentPartList``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``assessment_part_genus_type`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "assessment_part_genus_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "osid.assessment.authoring.AssessmentPartList", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_assessment_parts_by_parent_genus_type", 
               "doc": {
                  "headline": "Gets an ``AssessmentPartList`` corresponding to the given assessment part genus ``Type`` and include any additional assessment parts with genus types derived from the specified ``Type``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    assessment_genus_type (osid.type.Type): an assessment\n                part genus type\n", 
               "return_doc": "        return: (osid.assessment.authoring.AssessmentPartList) - the\n                returned ``AssessmentPart`` list", 
               "error_doc": "        raise:  NullArgument - ``assessment_part_genus_type`` is\n                ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param assessment_genus_type: an assessment part genus type\n        :type assessment_genus_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "        :return: the returned ``AssessmentPart`` list\n        :rtype: ``osid.assessment.authoring.AssessmentPartList``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``assessment_part_genus_type`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "assessment_genus_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "osid.assessment.authoring.AssessmentPartList", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_assessment_parts_by_record_type", 
               "doc": {
                  "headline": "Gets an ``AssessmentPart`` containing the given assessment part record ``Type``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    assessment_part_record_type (osid.type.Type): an\n                assessment part record type\n", 
               "return_doc": "        return: (osid.assessment.authoring.AssessmentPartList) - the\n                returned ``AssessmentPart`` list", 
               "error_doc": "        raise:  NullArgument - ``assessment_part_record_type`` is\n                ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param assessment_part_record_type: an assessment part record type\n        :type assessment_part_record_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "        :return: the returned ``AssessmentPart`` list\n        :rtype: ``osid.assessment.authoring.AssessmentPartList``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``assessment_part_record_type`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "assessment_part_record_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "osid.assessment.authoring.AssessmentPartList", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_assessment_parts_for_assessment", 
               "doc": {
                  "headline": "Gets an ``AssessmentPart`` for the given assessment.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    assessment_id (osid.id.Id): an assessment ``Id``\n", 
               "return_doc": "        return: (osid.assessment.authoring.AssessmentPartList) - the\n                returned ``AssessmentPart`` list", 
               "error_doc": "        raise:  NullArgument - ``assessment_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param assessment_id: an assessment ``Id``\n        :type assessment_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: the returned ``AssessmentPart`` list\n        :rtype: ``osid.assessment.authoring.AssessmentPartList``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``assessment_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "assessment_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "osid.assessment.authoring.AssessmentPartList", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_assessment_parts", 
               "doc": {
                  "headline": "Gets all ``AssessmentParts``.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.assessment.authoring.AssessmentPartList) - a list\n                of ``AssessmentParts``", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: a list of ``AssessmentParts``\n        :rtype: ``osid.assessment.authoring.AssessmentPartList``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.assessment.authoring.AssessmentPartList", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.assessment.authoring.AssessmentPartQuerySession", 
         "shortname": "AssessmentPartQuerySession", 
         "category": "sessions", 
         "doc": {
            "headline": "This session provides methods for searching among ``AssessmentPart`` objects.", 
            "body": "    The search query is constructed using the ``AssessmentPartQuery``.\n\n    This session defines views that offer differing behaviors for\n    searching.\n    \n      * federated bank view: searches include assessment parts in bank\n        of which this bank is an ancestor in the bank hierarchy\n      * isolated bank view: searches are restricted to assessment parts\n        in this bank\n      * sequestered assessment part viiew: All assessment part methods\n        suppress sequestered assessment parts.\n      * unsequestered assessment part view: All assessment part methods\n        return all assessment parts.\n\n    \n    Assessment parts may have a query record indicated by their\n    respective record types. The query record is accessed via the\n    ``AssessmentPartQuery``."
         }, 
         "inherit_fullnames": [
            "osid.OsidSession"
         ], 
         "inherit_shortnames": [
            "OsidSession"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidSession"
            }
         ], 
         "method_names": [
            "get_bank_id", 
            "get_bank", 
            "can_search_assessment_parts", 
            "use_federated_bank_view", 
            "use_isolated_bank_view", 
            "use_sequestered_assessment_part_view", 
            "use_unsequestered_assessment_part_view", 
            "get_assessment_part_query", 
            "get_assessment_parts_by_query"
         ], 
         "methods": [
            {
               "name": "get_bank_id", 
               "doc": {
                  "headline": "Gets the ``Bank``  ``Id`` associated with this session.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.id.Id) - the ``Bank Id`` associated with this\n                session", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the ``Bank Id`` associated with this session\n        :rtype: ``osid.id.Id``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.id.Id", 
               "errors": {}
            }, 
            {
               "name": "get_bank", 
               "doc": {
                  "headline": "Gets the ``Bank`` associated with this session.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.assessment.Bank) - the bank", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the bank\n        :rtype: ``osid.assessment.Bank``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.assessment.Bank", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "can_search_assessment_parts", 
               "doc": {
                  "headline": "Tests if this user can perform ``AssessmentPart`` lookups.", 
                  "body": "        A return of true does not guarantee successful authorization. A\n        return of false indicates that it is known all methods in this\n        session will result in a ``PermissionDenied``. This is intended\n        as a hint to an application that may not offer lookup operations\n        to unauthorized users."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``false`` if search methods are not\n                authorized, ``true`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``false`` if search methods are not authorized, ``true`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "use_federated_bank_view", 
               "doc": {
                  "headline": "Federates the view for methods in this session.", 
                  "body": "        A federated view will include assessment part in banks which are\n        children of this step in the bank hierarchy."
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "use_isolated_bank_view", 
               "doc": {
                  "headline": "Isolates the view for methods in this session.", 
                  "body": "        An isolated view restricts lookups to this bank only."
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "use_sequestered_assessment_part_view", 
               "doc": {
                  "headline": "The methods in this session omit sequestered assessment parts.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "use_unsequestered_assessment_part_view", 
               "doc": {
                  "headline": "The methods in this session return all assessment parts, including sequestered assessment parts.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "get_assessment_part_query", 
               "doc": {
                  "headline": "Gets an assessment part query.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.assessment.authoring.AssessmentPartQuery) - the\n                assessment part query", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the assessment part query\n        :rtype: ``osid.assessment.authoring.AssessmentPartQuery``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.assessment.authoring.AssessmentPartQuery", 
               "errors": {}
            }, 
            {
               "name": "get_assessment_parts_by_query", 
               "doc": {
                  "headline": "Gets a list of ``AssessmentParts`` matching the given assessment part query.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    assessment_part_query\n                (osid.assessment.authoring.AssessmentPartQuery): the\n                assessment part query\n", 
               "return_doc": "        return: (osid.assessment.authoring.AssessmentPartList) - the\n                returned ``AssessmentPartList``", 
               "error_doc": "        raise:  NullArgument - ``assessment_part_query`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        raise:  Unsupported - ``assessment_part_query`` is not of this\n                service", 
               "sphinx_param_doc": "        :param assessment_part_query: the assessment part query\n        :type assessment_part_query: ``osid.assessment.authoring.AssessmentPartQuery``\n", 
               "sphinx_return_doc": "        :return: the returned ``AssessmentPartList``\n        :rtype: ``osid.assessment.authoring.AssessmentPartList``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``assessment_part_query`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure\n        :raise: ``Unsupported`` -- ``assessment_part_query`` is not of this service", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.assessment.authoring.AssessmentPartQuery", 
                     "var_name": "assessment_part_query", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.assessment.authoring.AssessmentPartQuery"
               ], 
               "return_type": "osid.assessment.authoring.AssessmentPartList", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.assessment.authoring.AssessmentPartSearchSession", 
         "shortname": "AssessmentPartSearchSession", 
         "category": "sessions", 
         "doc": {
            "headline": "This session provides methods for searching among ``AssessmentPart`` objects.", 
            "body": "    The search query is constructed using the ``AssessmentPartyQuery``.\n\n    ``get_assessment_parts_by_query()`` is the basic search method and\n    returns a list of ``AssessmentParts``. A more advanced search may be\n    performed with ``getAssessmentPartsBySearch()``. It accepts an\n    ``AssessmentPartSearch`` in addition to the query for the purpose of\n    specifying additional options affecting the entire search, such as\n    workflow. ``get_assessment_parts_by_search()`` returns an\n    ``AssessmentPartSearchResults`` that can be used to access the\n    resulting ``AssessmentPartList`` or be used to perform a search\n    within the result set through ``AssessmentPartSearch``.\n    \n    This session defines views that offer differing behaviors for\n    searching.\n    \n      * federated bank view: searches include assessment part in bank of\n        which this bank matchmaker is an ancestor in the bank hierarchy\n      * isolated bank view: searches are restricted to assessment part\n        in this bank\n\n    \n    ``AssessmentParts`` may have a query record indicated by their\n    respective record types. Thequery record is accessed via the\n    ``AssessmentPartQuery``."
         }, 
         "inherit_fullnames": [
            "osid.assessment.authoring.AssessmentPartQuerySession"
         ], 
         "inherit_shortnames": [
            "AssessmentPartQuerySession"
         ], 
         "inherit_pkg_names": [
            "authoring"
         ], 
         "inheritance": [
            {
               "pkg_name": "assessment.authoring", 
               "name": "AssessmentPartQuerySession"
            }
         ], 
         "method_names": [
            "get_assessment_part_search", 
            "get_assessment_part_search_order", 
            "get_assessment_parts_by_search", 
            "get_assessment_part_query_from_inspector"
         ], 
         "methods": [
            {
               "name": "get_assessment_part_search", 
               "doc": {
                  "headline": "Gets an assessment part search.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.assessment.authoring.AssessmentPartSearch) - the\n                assessment part search", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the assessment part search\n        :rtype: ``osid.assessment.authoring.AssessmentPartSearch``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.assessment.authoring.AssessmentPartSearch", 
               "errors": {}
            }, 
            {
               "name": "get_assessment_part_search_order", 
               "doc": {
                  "headline": "Gets an assessment part search order.", 
                  "body": "        The ``AssessmentPartSearchOrder`` is supplied to an\n        ``AssessmentPartSearch`` to specify the ordering of results."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.assessment.authoring.AssessmentPartSearchOrder) -\n                the assessment part search order", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the assessment part search order\n        :rtype: ``osid.assessment.authoring.AssessmentPartSearchOrder``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.assessment.authoring.AssessmentPartSearchOrder", 
               "errors": {}
            }, 
            {
               "name": "get_assessment_parts_by_search", 
               "doc": {
                  "headline": "Gets the search results matching the given search query using the given search.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    assessment_part_query\n                (osid.assessment.authoring.AssessmentPartQuery): the\n                assessment part query\n        arg:    assessment_part_search\n                (osid.assessment.authoring.AssessmentPartSearch): the\n                assessment part search\n", 
               "return_doc": "        return: (osid.assessment.authoring.AssessmentPartSearchResults)\n                - the returned search results", 
               "error_doc": "        raise:  NullArgument - ``assessment_part_query`` or\n                ``assessment_part_search`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        raise:  Unsupported - ``assessment_part_query`` or\n                ``assessment_part_search`` is not of this service", 
               "sphinx_param_doc": "        :param assessment_part_query: the assessment part query\n        :type assessment_part_query: ``osid.assessment.authoring.AssessmentPartQuery``\n        :param assessment_part_search: the assessment part search\n        :type assessment_part_search: ``osid.assessment.authoring.AssessmentPartSearch``\n", 
               "sphinx_return_doc": "        :return: the returned search results\n        :rtype: ``osid.assessment.authoring.AssessmentPartSearchResults``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``assessment_part_query`` or ``assessment_part_search`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure\n        :raise: ``Unsupported`` -- ``assessment_part_query`` or ``assessment_part_search`` is not of this service", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.assessment.authoring.AssessmentPartQuery", 
                     "var_name": "assessment_part_query", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.assessment.authoring.AssessmentPartSearch", 
                     "var_name": "assessment_part_search", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.assessment.authoring.AssessmentPartQuery", 
                  "osid.assessment.authoring.AssessmentPartSearch"
               ], 
               "return_type": "osid.assessment.authoring.AssessmentPartSearchResults", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_assessment_part_query_from_inspector", 
               "doc": {
                  "headline": "Gets an assessment part query from an inspector.", 
                  "body": "        The inspector is available from an\n        ``AssessmentPartSearchResults``."
               }, 
               "arg_doc": "        arg:    assessment_part_query_inspector\n                (osid.assessment.authoring.AssessmentPartQueryInspector)\n                : an assessment part query inspector\n", 
               "return_doc": "        return: (osid.assessment.authoring.AssessmentPartQuery) - the\n                assessment part query", 
               "error_doc": "        raise:  NullArgument - ``assessment_part_query_inspector`` is\n                ``null``\n        raise:  Unsupported - ``assessment_part_query_inspector`` is not\n                of this service", 
               "sphinx_param_doc": "        :param assessment_part_query_inspector: an assessment part query inspector\n        :type assessment_part_query_inspector: ``osid.assessment.authoring.AssessmentPartQueryInspector``\n", 
               "sphinx_return_doc": "        :return: the assessment part query\n        :rtype: ``osid.assessment.authoring.AssessmentPartQuery``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``assessment_part_query_inspector`` is ``null``\n        :raise: ``Unsupported`` -- ``assessment_part_query_inspector`` is not of this service", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.assessment.authoring.AssessmentPartQueryInspector", 
                     "var_name": "assessment_part_query_inspector", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.assessment.authoring.AssessmentPartQueryInspector"
               ], 
               "return_type": "osid.assessment.authoring.AssessmentPartQuery", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.assessment.authoring.AssessmentPartAdminSession", 
         "shortname": "AssessmentPartAdminSession", 
         "category": "sessions", 
         "doc": {
            "headline": "This session creates, updates, and deletes ``AssessmentParts``.", 
            "body": "    The data for create and update is provided by the consumer via the\n    form object. ``OsidForms`` are requested for each create or update\n    and may not be reused.\n\n    Create and update operations differ in their usage. To create an\n    ``AssessmentPart,`` an ``AssessmentPartForm`` is requested using\n    ``get_assessment_part_form_for_create()`` specifying the desired\n    record ``Types`` or none if no record ``Types`` are needed. The\n    returned ``AssessmentPartForm`` will indicate that it is to be used\n    with a create operation and can be used to examine metdata or\n    validate data prior to creation. Once the ``AssessmentPartForm`` is\n    submiited to a create operation, it cannot be reused with another\n    create operation unless the first operation was unsuccessful. Each\n    ``AssessmentPartForm`` corresponds to an attempted transaction.\n    \n    For updates, ``AssessmentPartForms`` are requested to the\n    ``AssessmentPart``  ``Id`` that is to be updated using\n    ``getAssessmentPartFormForUpdate()``. Similarly, the\n    ``AssessmentPartForm`` has metadata about the data that can be\n    updated and it can perform validation before submitting the update.\n    The ``AssessmentPartForm`` can only be used once for a successful\n    update and cannot be reused.\n    \n    The delete operations delete ``AssessmentParts``.\n    \n    This session includes an ``Id`` aliasing mechanism to assign an\n    external ``Id`` to an internally assigned Id."
         }, 
         "inherit_fullnames": [
            "osid.OsidSession"
         ], 
         "inherit_shortnames": [
            "OsidSession"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidSession"
            }
         ], 
         "method_names": [
            "get_bank_id", 
            "get_bank", 
            "can_create_assessment_parts", 
            "can_create_assessment_part_with_record_types", 
            "get_assessment_part_form_for_create_for_assessment", 
            "create_assessment_part_for_assessment", 
            "get_assessment_part_form_for_create_for_assessment_part", 
            "create_assessment_part_for_assessment_part", 
            "can_update_assessment_parts", 
            "get_assessment_part_form_for_update", 
            "update_assessment_part", 
            "can_delete_assessment_parts", 
            "delete_assessment_part", 
            "can_manage_assessment_part_aliases", 
            "alias_assessment_part"
         ], 
         "methods": [
            {
               "name": "get_bank_id", 
               "doc": {
                  "headline": "Gets the ``Bank``  ``Id`` associated with this session.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.id.Id) - the ``Bank Id`` associated with this\n                session", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the ``Bank Id`` associated with this session\n        :rtype: ``osid.id.Id``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.id.Id", 
               "errors": {}
            }, 
            {
               "name": "get_bank", 
               "doc": {
                  "headline": "Gets the ``Bank`` associated with this session.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.assessment.Bank) - the ``Bank`` associated with\n                this session", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the ``Bank`` associated with this session\n        :rtype: ``osid.assessment.Bank``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.assessment.Bank", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "can_create_assessment_parts", 
               "doc": {
                  "headline": "Tests if this user can create assessment parts.", 
                  "body": "        A return of true does not guarantee successful authorization. A\n        return of false indicates that it is known mapping methods in\n        this session will result in a ``PermissionDenied``. This is\n        intended as a hint to an application that may opt not to offer\n        create operations to unauthorized users."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``false`` if ``AssessmentPart`` creation is\n                not authorized, ``true`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``false`` if ``AssessmentPart`` creation is not authorized, ``true`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "can_create_assessment_part_with_record_types", 
               "doc": {
                  "headline": "Tests if this user can create a single ``AssessmentPart`` using the desired record types.", 
                  "body": "        While\n        ``AssessmentAuthoringManager.getAssessmentPartRecordTypes()``\n        can be used to examine which records are supported, this method\n        tests which record(s) are required for creating a specific\n        ``AssessmentPart``. Providing an empty array tests if an\n        ``AssessmentPart`` can be created with no records."
               }, 
               "arg_doc": "        arg:    assessment_part_record_types (osid.type.Type[]): array\n                of assessment part record types\n", 
               "return_doc": "        return: (boolean) - ``true`` if ``AssessmentPart`` creation\n                using the specified record ``Types`` is supported,\n                ``false`` otherwise", 
               "error_doc": "        raise:  NullArgument - ``assessment_part_record_types`` is\n                ``null``", 
               "sphinx_param_doc": "        :param assessment_part_record_types: array of assessment part record types\n        :type assessment_part_record_types: ``osid.type.Type[]``\n", 
               "sphinx_return_doc": "        :return: ``true`` if ``AssessmentPart`` creation using the specified record ``Types`` is supported, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``assessment_part_record_types`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type[]", 
                     "var_name": "assessment_part_record_types", 
                     "array": true
                  }
               ], 
               "arg_types": [
                  "osid.type.Type[]"
               ], 
               "return_type": "boolean", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "get_assessment_part_form_for_create_for_assessment", 
               "doc": {
                  "headline": "Gets the assessment part form for creating new assessment parts for an assessment.", 
                  "body": "        A new form should be requested for each create transaction."
               }, 
               "arg_doc": "        arg:    assessment_id (osid.id.Id): an assessment ``Id``\n        arg:    assessment_part_record_types (osid.type.Type[]): array\n                of assessment part record types to be included in the\n                create operation or an empty list if none\n", 
               "return_doc": "        return: (osid.assessment.authoring.AssessmentPartForm) - the\n                assessment part form", 
               "error_doc": "        raise:  NotFound - ``assessment_id`` is not found\n        raise:  NullArgument - ``assessment_id`` or\n                ``assessment_part_record_types`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure occurred\n        raise:  Unsupported - unable to get form for requested record\n                types", 
               "sphinx_param_doc": "        :param assessment_id: an assessment ``Id``\n        :type assessment_id: ``osid.id.Id``\n        :param assessment_part_record_types: array of assessment part record types to be included in the create operation or an empty list if none\n        :type assessment_part_record_types: ``osid.type.Type[]``\n", 
               "sphinx_return_doc": "        :return: the assessment part form\n        :rtype: ``osid.assessment.authoring.AssessmentPartForm``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``assessment_id`` is not found\n        :raise: ``NullArgument`` -- ``assessment_id`` or ``assessment_part_record_types`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure occurred\n        :raise: ``Unsupported`` -- unable to get form for requested record types", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "assessment_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.type.Type[]", 
                     "var_name": "assessment_part_record_types", 
                     "array": true
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "osid.type.Type[]"
               ], 
               "return_type": "osid.assessment.authoring.AssessmentPartForm", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }, 
            {
               "name": "create_assessment_part_for_assessment", 
               "doc": {
                  "headline": "Creates a new assessment part.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    assessment_part_form\n                (osid.assessment.authoring.AssessmentPartForm):\n                assessment part form\n", 
               "return_doc": "        return: (osid.assessment.authoring.AssessmentPart) - the new\n                part", 
               "error_doc": "        raise:  IllegalState - ``assessment_part_form`` already used in\n                a create transaction\n        raise:  InvalidArgument - ``assessment_part_form`` is invalid\n        raise:  NullArgument - ``assessment_part_form`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure occurred\n        raise:  Unsupported - ``assessment_part_form`` did not originate\n                from\n                ``get_assessment_part_form_for_create_for_assessment()``", 
               "sphinx_param_doc": "        :param assessment_part_form: assessment part form\n        :type assessment_part_form: ``osid.assessment.authoring.AssessmentPartForm``\n", 
               "sphinx_return_doc": "        :return: the new part\n        :rtype: ``osid.assessment.authoring.AssessmentPart``", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- ``assessment_part_form`` already used in a create transaction\n        :raise: ``InvalidArgument`` -- ``assessment_part_form`` is invalid\n        :raise: ``NullArgument`` -- ``assessment_part_form`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure occurred\n        :raise: ``Unsupported`` -- ``assessment_part_form`` did not originate from ``get_assessment_part_form_for_create_for_assessment()``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.assessment.authoring.AssessmentPartForm", 
                     "var_name": "assessment_part_form", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.assessment.authoring.AssessmentPartForm"
               ], 
               "return_type": "osid.assessment.authoring.AssessmentPart", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract", 
                  "INVALID_ARGUMENT": "ConsumerContract", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_assessment_part_form_for_create_for_assessment_part", 
               "doc": {
                  "headline": "Gets the assessment part form for creating new assessment parts under another assessment part.", 
                  "body": "        A new form should be requested for each create transaction."
               }, 
               "arg_doc": "        arg:    assessment_part_id (osid.id.Id): an assessment part\n                ``Id``\n        arg:    assessment_part_record_types (osid.type.Type[]): array\n                of assessment part record types to be included in the\n                create operation or an empty list if none\n", 
               "return_doc": "        return: (osid.assessment.authoring.AssessmentPartForm) - the\n                assessment part form", 
               "error_doc": "        raise:  NotFound - ``assessment_part_id`` is not found\n        raise:  NullArgument - ``assessment_part_id`` or\n                ``assessment_part_record_types`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure occurred\n        raise:  Unsupported - unable to get form for requested record\n                types", 
               "sphinx_param_doc": "        :param assessment_part_id: an assessment part ``Id``\n        :type assessment_part_id: ``osid.id.Id``\n        :param assessment_part_record_types: array of assessment part record types to be included in the create operation or an empty list if none\n        :type assessment_part_record_types: ``osid.type.Type[]``\n", 
               "sphinx_return_doc": "        :return: the assessment part form\n        :rtype: ``osid.assessment.authoring.AssessmentPartForm``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``assessment_part_id`` is not found\n        :raise: ``NullArgument`` -- ``assessment_part_id`` or ``assessment_part_record_types`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure occurred\n        :raise: ``Unsupported`` -- unable to get form for requested record types", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "assessment_part_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.type.Type[]", 
                     "var_name": "assessment_part_record_types", 
                     "array": true
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "osid.type.Type[]"
               ], 
               "return_type": "osid.assessment.authoring.AssessmentPartForm", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }, 
            {
               "name": "create_assessment_part_for_assessment_part", 
               "doc": {
                  "headline": "Creates a new assessment part.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    assessment_part_form\n                (osid.assessment.authoring.AssessmentPartForm):\n                assessment part form\n", 
               "return_doc": "        return: (osid.assessment.authoring.AssessmentPart) - the new\n                part", 
               "error_doc": "        raise:  IllegalState - ``assessment_part_form`` already used in\n                a create transaction\n        raise:  InvalidArgument - ``assessment_part_form`` is invalid\n        raise:  NullArgument - ``assessment_part_form`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure occurred\n        raise:  Unsupported - ``assessment_part_form`` did not originate\n                from ``get_assessment_part_form_for_create_for_assessmen\n                t_part()``", 
               "sphinx_param_doc": "        :param assessment_part_form: assessment part form\n        :type assessment_part_form: ``osid.assessment.authoring.AssessmentPartForm``\n", 
               "sphinx_return_doc": "        :return: the new part\n        :rtype: ``osid.assessment.authoring.AssessmentPart``", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- ``assessment_part_form`` already used in a create transaction\n        :raise: ``InvalidArgument`` -- ``assessment_part_form`` is invalid\n        :raise: ``NullArgument`` -- ``assessment_part_form`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure occurred\n        :raise: ``Unsupported`` -- ``assessment_part_form`` did not originate from ``get_assessment_part_form_for_create_for_assessment_part()``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.assessment.authoring.AssessmentPartForm", 
                     "var_name": "assessment_part_form", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.assessment.authoring.AssessmentPartForm"
               ], 
               "return_type": "osid.assessment.authoring.AssessmentPart", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract", 
                  "INVALID_ARGUMENT": "ConsumerContract", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }, 
            {
               "name": "can_update_assessment_parts", 
               "doc": {
                  "headline": "Tests if this user can update ``AssessmentParts``.", 
                  "body": "        A return of true does not guarantee successful authorization. A\n        return of false indicates that it is known updating an\n        ``AssessmentPart`` will result in a ``PermissionDenied``. This\n        is intended as a hint to an application that may opt not to\n        offer update operations to an unauthorized user."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``false`` if assessment part modification is\n                not authorized, ``true`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``false`` if assessment part modification is not authorized, ``true`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "get_assessment_part_form_for_update", 
               "doc": {
                  "headline": "Gets the assessment part form for updating an existing assessment part.", 
                  "body": "        A new assessment part form should be requested for each update\n        transaction."
               }, 
               "arg_doc": "        arg:    assessment_part_id (osid.id.Id): the ``Id`` of the\n                ``AssessmentPart``\n", 
               "return_doc": "        return: (osid.assessment.authoring.AssessmentPartForm) - the\n                assessment part form", 
               "error_doc": "        raise:  NotFound - ``assessment_part_id`` is not found\n        raise:  NullArgument - ``assessment_part_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure occurred", 
               "sphinx_param_doc": "        :param assessment_part_id: the ``Id`` of the ``AssessmentPart``\n        :type assessment_part_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: the assessment part form\n        :rtype: ``osid.assessment.authoring.AssessmentPartForm``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``assessment_part_id`` is not found\n        :raise: ``NullArgument`` -- ``assessment_part_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure occurred", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "assessment_part_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "osid.assessment.authoring.AssessmentPartForm", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "update_assessment_part", 
               "doc": {
                  "headline": "Updates an existing assessment part.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    assessment_part_id (osid.id.Id): the ``Id`` of the\n                ``AssessmentPart``\n        arg:    assessment_part_form\n                (osid.assessment.authoring.AssessmentPartForm): part\n                form\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NotFound - ``assessment_part_id`` not found\n        raise:  NullArgument - ``assessment_part_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure occurred\n        raise:  Unsupported - ``assessment_part_form`` is not of this\n                service", 
               "sphinx_param_doc": "        :param assessment_part_id: the ``Id`` of the ``AssessmentPart``\n        :type assessment_part_id: ``osid.id.Id``\n        :param assessment_part_form: part form\n        :type assessment_part_form: ``osid.assessment.authoring.AssessmentPartForm``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``assessment_part_id`` not found\n        :raise: ``NullArgument`` -- ``assessment_part_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure occurred\n        :raise: ``Unsupported`` -- ``assessment_part_form`` is not of this service", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "assessment_part_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.assessment.authoring.AssessmentPartForm", 
                     "var_name": "assessment_part_form", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "osid.assessment.authoring.AssessmentPartForm"
               ], 
               "return_type": "", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }, 
            {
               "name": "can_delete_assessment_parts", 
               "doc": {
                  "headline": "Tests if this user can delete ``AssessmentParts``.", 
                  "body": "        A return of true does not guarantee successful authorization. A\n        return of false indicates that it is known deleting an\n        ``AssessmentPart`` will result in a ``PermissionDenied``. This\n        is intended as a hint to an application that may opt not to\n        offer delete operations to an unauthorized user."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``false`` if ``AssessmentPart`` deletion is\n                not authorized, ``true`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``false`` if ``AssessmentPart`` deletion is not authorized, ``true`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "delete_assessment_part", 
               "doc": {
                  "headline": "Removes an asessment part and all mapped items.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    assessment_part_id (osid.id.Id): the ``Id`` of the\n                ``AssessmentPart``\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NotFound - ``assessment_part_id`` not found\n        raise:  NullArgument - ``assessment_part_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure occurred", 
               "sphinx_param_doc": "        :param assessment_part_id: the ``Id`` of the ``AssessmentPart``\n        :type assessment_part_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``assessment_part_id`` not found\n        :raise: ``NullArgument`` -- ``assessment_part_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure occurred", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "assessment_part_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "can_manage_assessment_part_aliases", 
               "doc": {
                  "headline": "Tests if this user can manage ``Id`` aliases for ``AssessmentParts``.", 
                  "body": "        A return of true does not guarantee successful authorization. A\n        return of false indicates that it is known changing an alias\n        will result in a ``PermissionDenied``. This is intended as a\n        hint to an application that may opt not to offer alias\n        operations to an unauthorized user."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``false`` if ``AssessmentPart`` aliasing is\n                not authorized, ``true`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``false`` if ``AssessmentPart`` aliasing is not authorized, ``true`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "alias_assessment_part", 
               "doc": {
                  "headline": "Adds an ``Id`` to an ``AssessmentPart`` for the purpose of creating compatibility.", 
                  "body": "        The primary ``Id`` of the ``AssessmentPart`` is determined by\n        the provider. The new ``Id`` is an alias to the primary ``Id``.\n        If the alias is a pointer to another assessment part, it is\n        reassigned to the given assessment part ``Id``."
               }, 
               "arg_doc": "        arg:    assessment_part_id (osid.id.Id): the ``Id`` of an\n                ``AssessmentPart``\n        arg:    alias_id (osid.id.Id): the alias ``Id``\n", 
               "return_doc": "", 
               "error_doc": "        raise:  AlreadyExists - ``alias_id`` is in use as a primary\n                ``Id``\n        raise:  NotFound - ``assessment_part_id`` not found\n        raise:  NullArgument - ``assessment_part_id`` or ``alias_id`` is\n                ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param assessment_part_id: the ``Id`` of an ``AssessmentPart``\n        :type assessment_part_id: ``osid.id.Id``\n        :param alias_id: the alias ``Id``\n        :type alias_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``AlreadyExists`` -- ``alias_id`` is in use as a primary ``Id``\n        :raise: ``NotFound`` -- ``assessment_part_id`` not found\n        :raise: ``NullArgument`` -- ``assessment_part_id`` or ``alias_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "assessment_part_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "alias_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {
                  "ALREADY_EXISTS": "User", 
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.assessment.authoring.AssessmentPartNotificationSession", 
         "shortname": "AssessmentPartNotificationSession", 
         "category": "sessions", 
         "doc": {
            "headline": "This session defines methods to receive notifications on adds/changes to ``AssessmentPart`` objects in this ``Bank``.", 
            "body": "    This also includes existing ``AssessmentParts`` that may appear or\n    disappear due to changes in the ``Bank`` hierarchy, This session is\n    intended for consumers needing to synchronize their state with this\n    service without the use of polling. Notifications are cancelled when\n    this session is closed.\n\n    The two views defined in this session correspond to the views in the\n    ``AssessmentPartLookupSession``."
         }, 
         "inherit_fullnames": [
            "osid.OsidSession"
         ], 
         "inherit_shortnames": [
            "OsidSession"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidSession"
            }
         ], 
         "method_names": [
            "get_bank_id", 
            "get_bank", 
            "can_register_for_assessment_part_notifications", 
            "use_federated_bank_view", 
            "use_isolated_bank_view", 
            "register_for_new_assessment_parts", 
            "register_for_changed_assessment_parts", 
            "register_for_changed_assessment_part", 
            "register_for_deleted_assessment_parts", 
            "register_for_deleted_assessment_part"
         ], 
         "methods": [
            {
               "name": "get_bank_id", 
               "doc": {
                  "headline": "Gets the ``Bank``  ``Id`` associated with this session.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.id.Id) - the ``Bank Id`` associated with this\n                session", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the ``Bank Id`` associated with this session\n        :rtype: ``osid.id.Id``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.id.Id", 
               "errors": {}
            }, 
            {
               "name": "get_bank", 
               "doc": {
                  "headline": "Gets the ``Bank`` associated with this session.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.assessment.Bank) - the bank", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the bank\n        :rtype: ``osid.assessment.Bank``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.assessment.Bank", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "can_register_for_assessment_part_notifications", 
               "doc": {
                  "headline": "Tests if this user can register for ``AssessmentPart`` notifications.", 
                  "body": "        A return of true does not guarantee successful authorization. A\n        return of false indicates that it is known all methods in this\n        session will result in a ``PermissionDenied``. This is intended\n        as a hint to an application that may opt not to offer\n        notification operations."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``false`` if notification methods are not\n                authorized, ``true`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``false`` if notification methods are not authorized, ``true`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "use_federated_bank_view", 
               "doc": {
                  "headline": "Federates the view for methods in this session.", 
                  "body": "        A federated view will include in bank which are children of this\n        bank in the bank hierarchy."
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "use_isolated_bank_view", 
               "doc": {
                  "headline": "Isolates the view for methods in this session.", 
                  "body": "        An isolated view restricts notifications to this bank only."
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "register_for_new_assessment_parts", 
               "doc": {
                  "headline": "Register for notifications of new assessment parts.", 
                  "body": "        ``AssessmentPartReceiver.newAssessmentPart()`` is invoked when a\n        new ``AssessmentPart`` appears in this bank."
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "register_for_changed_assessment_parts", 
               "doc": {
                  "headline": "Registers for notification of updated bank.", 
                  "body": "        ``AssessmentPartReceiver.changedAssessmentPart()`` is invoked\n        when an assessment part in this bank is changed."
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "register_for_changed_assessment_part", 
               "doc": {
                  "headline": "Registers for notification of an updated assessment part.", 
                  "body": "        ``ProvisionableReceiver.changedAssessmentPart()`` is invoked\n        when the specified assessment part in this bank is changed."
               }, 
               "arg_doc": "        arg:    assessment_part_id (osid.id.Id): the ``Id`` of the\n                ``AssessmentPart`` to monitor\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NotFound - an assessment part was not found in this step\n                matchmaker identified by the given ``Id``\n        raise:  NullArgument - ``assessment_part_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param assessment_part_id: the ``Id`` of the ``AssessmentPart`` to monitor\n        :type assessment_part_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- an assessment part was not found in this step matchmaker identified by the given ``Id``\n        :raise: ``NullArgument`` -- ``assessment_part_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "assessment_part_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "register_for_deleted_assessment_parts", 
               "doc": {
                  "headline": "Registers for notification of deleted assessment parts.", 
                  "body": "        ``AssessmentPartReceiver.deletedAssessmentPart()`` is invoked\n        when an assessment part is deleted or removed from this bank."
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "register_for_deleted_assessment_part", 
               "doc": {
                  "headline": "Registers for notification of a deleted assessment part.", 
                  "body": "        ``AssessmentPartReceiver.deletedAssessmentPart()`` is invoked\n        when the specified assessment part is deleted or removed from\n        this bank."
               }, 
               "arg_doc": "        arg:    assessment_part_id (osid.id.Id): the ``Id`` of the\n                ``AssessmentPart`` to monitor\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NotFound - an assessment part was not found in this step\n                matchmaker identified by the given ``Id``\n        raise:  NullArgument - ``assessment_part_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param assessment_part_id: the ``Id`` of the ``AssessmentPart`` to monitor\n        :type assessment_part_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- an assessment part was not found in this step matchmaker identified by the given ``Id``\n        :raise: ``NullArgument`` -- ``assessment_part_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "assessment_part_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.assessment.authoring.AssessmentPartBankSession", 
         "shortname": "AssessmentPartBankSession", 
         "category": "sessions", 
         "doc": {
            "headline": "This session provides methods to retrieve ``AssessmentPart`` to ``Bank`` mappings.", 
            "body": "    an ``AssessmentPart`` may appear in multiple ``Bank`` objects. Each\n    bank may have its own authorizations governing who is allowed to\n    look at it.\n\n    This lookup session defines several views:\n    \n      * comparative view: elements may be silently omitted or re-ordered\n      * plenary view: provides a complete result set or is an error\n        condition\n"
         }, 
         "inherit_fullnames": [
            "osid.OsidSession"
         ], 
         "inherit_shortnames": [
            "OsidSession"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidSession"
            }
         ], 
         "method_names": [
            "can_lookup_assessment_part_bank_mappings", 
            "use_comparative_assessment_part_bank_view", 
            "use_plenary_assessment_part_bank_view", 
            "get_assessment_part_ids_by_bank", 
            "get_assessment_parts_by_bank", 
            "get_assessment_part_ids_by_banks", 
            "get_assessment_parts_by_banks", 
            "get_bank_ids_by_assessment_part", 
            "get_banks_by_assessment_part"
         ], 
         "methods": [
            {
               "name": "can_lookup_assessment_part_bank_mappings", 
               "doc": {
                  "headline": "Tests if this user can perform lookups of assessment part/bank mappings.", 
                  "body": "        A return of true does not guarantee successful authorization. A\n        return of false indicates that it is known lookup methods in\n        this session will result in a ``PermissionDenied``. This is\n        intended as a hint to an application that may opt not to offer\n        lookup operations to unauthorized users."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``false`` if looking up mappings is not\n                authorized, ``true`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``false`` if looking up mappings is not authorized, ``true`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "use_comparative_assessment_part_bank_view", 
               "doc": {
                  "headline": "The returns from the lookup methods may omit or translate elements based on this session, such as authorization, and not result in an error.", 
                  "body": "        This view is used when greater interoperability is desired at\n        the expense of precision."
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "use_plenary_assessment_part_bank_view", 
               "doc": {
                  "headline": "A complete view of the ``AssessmentPart`` and ``Bank`` returns is desired.", 
                  "body": "        Methods will return what is requested or result in an error.\n        This view is used when greater precision is desired at the\n        expense of interoperability."
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "get_assessment_part_ids_by_bank", 
               "doc": {
                  "headline": "Gets the list of ``AssessmentPartIds`` associated with an ``Bank``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    bank_id (osid.id.Id): ``Id`` of the ``Bank``\n", 
               "return_doc": "        return: (osid.id.IdList) - list of related assessment part\n                ``Ids``", 
               "error_doc": "        raise:  NotFound - ``bank_id`` is not found\n        raise:  NullArgument - ``bank_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param bank_id: ``Id`` of the ``Bank``\n        :type bank_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: list of related assessment part ``Ids``\n        :rtype: ``osid.id.IdList``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``bank_id`` is not found\n        :raise: ``NullArgument`` -- ``bank_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "bank_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "osid.id.IdList", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_assessment_parts_by_bank", 
               "doc": {
                  "headline": "Gets the list of assessment parts associated with an ``Bank``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    bank_id (osid.id.Id): ``Id`` of the ``Bank``\n", 
               "return_doc": "        return: (osid.assessment.authoring.AssessmentPartList) - list of\n                related assessment parts", 
               "error_doc": "        raise:  NotFound - ``bank_id`` is not found\n        raise:  NullArgument - ``bank_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param bank_id: ``Id`` of the ``Bank``\n        :type bank_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: list of related assessment parts\n        :rtype: ``osid.assessment.authoring.AssessmentPartList``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``bank_id`` is not found\n        :raise: ``NullArgument`` -- ``bank_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "bank_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "osid.assessment.authoring.AssessmentPartList", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_assessment_part_ids_by_banks", 
               "doc": {
                  "headline": "Gets the list of ``AssessmentPart Ids`` corresponding to a list of ``Banks``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    bank_ids (osid.id.IdList): list of bank ``Ids``\n", 
               "return_doc": "        return: (osid.id.IdList) - list of assessment part ``Ids``", 
               "error_doc": "        raise:  NullArgument - ``bank_ids`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param bank_ids: list of bank ``Ids``\n        :type bank_ids: ``osid.id.IdList``\n", 
               "sphinx_return_doc": "        :return: list of assessment part ``Ids``\n        :rtype: ``osid.id.IdList``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``bank_ids`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.IdList", 
                     "var_name": "bank_ids", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.IdList"
               ], 
               "return_type": "osid.id.IdList", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_assessment_parts_by_banks", 
               "doc": {
                  "headline": "Gets the list of assessment part corresponding to a list of ``Banks``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    bank_ids (osid.id.IdList): list of bank ``Ids``\n", 
               "return_doc": "        return: (osid.assessment.authoring.AssessmentPartList) - list of\n                assessment parts", 
               "error_doc": "        raise:  NullArgument - ``bank_ids`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param bank_ids: list of bank ``Ids``\n        :type bank_ids: ``osid.id.IdList``\n", 
               "sphinx_return_doc": "        :return: list of assessment parts\n        :rtype: ``osid.assessment.authoring.AssessmentPartList``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``bank_ids`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.IdList", 
                     "var_name": "bank_ids", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.IdList"
               ], 
               "return_type": "osid.assessment.authoring.AssessmentPartList", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_bank_ids_by_assessment_part", 
               "doc": {
                  "headline": "Gets the ``Bank``  ``Ids`` mapped to an ``AssessmentPart``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    assessment_part_id (osid.id.Id): ``Id`` of an\n                ``AssessmentPart``\n", 
               "return_doc": "        return: (osid.id.IdList) - list of banks", 
               "error_doc": "        raise:  NotFound - ``assessment_part_id`` is not found\n        raise:  NullArgument - ``assessment_part_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param assessment_part_id: ``Id`` of an ``AssessmentPart``\n        :type assessment_part_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: list of banks\n        :rtype: ``osid.id.IdList``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``assessment_part_id`` is not found\n        :raise: ``NullArgument`` -- ``assessment_part_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "assessment_part_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "osid.id.IdList", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_banks_by_assessment_part", 
               "doc": {
                  "headline": "Gets the ``Banks`` mapped to an ``AssessmentPart``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    assessment_part_id (osid.id.Id): ``Id`` of an\n                ``AssessmentPart``\n", 
               "return_doc": "        return: (osid.assessment.BankList) - list of banks", 
               "error_doc": "        raise:  NotFound - ``assessment_part_id`` is not found\n        raise:  NullArgument - ``assessment_part_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param assessment_part_id: ``Id`` of an ``AssessmentPart``\n        :type assessment_part_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: list of banks\n        :rtype: ``osid.assessment.BankList``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``assessment_part_id`` is not found\n        :raise: ``NullArgument`` -- ``assessment_part_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "assessment_part_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "osid.assessment.BankList", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.assessment.authoring.AssessmentPartBankAssignmentSession", 
         "shortname": "AssessmentPartBankAssignmentSession", 
         "category": "sessions", 
         "doc": {
            "headline": "This session provides methods to re-assign ``AssessmentPart`` to ``Bank`` mappings.", 
            "body": "    An ``AssessmentPart`` may appear in multiple ``Bank`` objects and\n    removing the last reference to an ``AssessmentPart`` is the\n    equivalent of deleting it. Each ``Bank`` may have its own\n    authorizations governing who is allowed to operate on it.\n\n    Adding a reference of an ``AssessmentPart`` to another ``Bank`` is\n    not a copy operation (eg: does not change its ``Id`` )."
         }, 
         "inherit_fullnames": [
            "osid.OsidSession"
         ], 
         "inherit_shortnames": [
            "OsidSession"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidSession"
            }
         ], 
         "method_names": [
            "can_assign_assessment_parts", 
            "can_assign_assessment_parts_to_bank", 
            "get_assignable_bank_ids", 
            "get_assignable_bank_ids_for_assessment_part", 
            "assign_assessment_part_to_bank", 
            "unassign_assessment_part_from_bank"
         ], 
         "methods": [
            {
               "name": "can_assign_assessment_parts", 
               "doc": {
                  "headline": "Tests if this user can alter assessment part/bank mappings.", 
                  "body": "        A return of true does not guarantee successful authorization. A\n        return of false indicates that it is known mapping methods in\n        this session will result in a ``PermissionDenied``. This is\n        intended as a hint to an application that may opt not to offer\n        lookup operations to unauthorized users."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``false`` if mapping is not authorized,\n                ``true`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``false`` if mapping is not authorized, ``true`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "can_assign_assessment_parts_to_bank", 
               "doc": {
                  "headline": "Tests if this user can alter assessment part/bank mappings.", 
                  "body": "        A return of true does not guarantee successful authorization. A\n        return of false indicates that it is known mapping methods in\n        this session will result in a ``PermissionDenied``. This is\n        intended as a hint to an application that may opt not to offer\n        lookup operations to unauthorized users."
               }, 
               "arg_doc": "        arg:    bank_id (osid.id.Id): the ``Id`` of the ``Bank``\n", 
               "return_doc": "        return: (boolean) - ``false`` if mapping is not authorized,\n                ``true`` otherwise", 
               "error_doc": "        raise:  NullArgument - ``bank_id`` is ``null``", 
               "sphinx_param_doc": "        :param bank_id: the ``Id`` of the ``Bank``\n        :type bank_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: ``false`` if mapping is not authorized, ``true`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``bank_id`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "bank_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "boolean", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "get_assignable_bank_ids", 
               "doc": {
                  "headline": "Gets a list of bank including and under the given bank node in which any assessment part can be assigned.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    bank_id (osid.id.Id): the ``Id`` of the ``Bank``\n", 
               "return_doc": "        return: (osid.id.IdList) - list of assignable bank ``Ids``", 
               "error_doc": "        raise:  NullArgument - ``bank_id`` is ``null``\n        raise:  OperationFailed - unable to complete request", 
               "sphinx_param_doc": "        :param bank_id: the ``Id`` of the ``Bank``\n        :type bank_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: list of assignable bank ``Ids``\n        :rtype: ``osid.id.IdList``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``bank_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "bank_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "osid.id.IdList", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational"
               }
            }, 
            {
               "name": "get_assignable_bank_ids_for_assessment_part", 
               "doc": {
                  "headline": "Gets a list of bank including and under the given bank node in which a specific assessment part can be assigned.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    bank_id (osid.id.Id): the ``Id`` of the ``Bank``\n        arg:    assessment_part_id (osid.id.Id): the ``Id`` of the\n                ``AssessmentPart``\n", 
               "return_doc": "        return: (osid.id.IdList) - list of assignable bank ``Ids``", 
               "error_doc": "        raise:  NullArgument - ``bank_id`` or ``assessment_part_id`` is\n                ``null``\n        raise:  OperationFailed - unable to complete request", 
               "sphinx_param_doc": "        :param bank_id: the ``Id`` of the ``Bank``\n        :type bank_id: ``osid.id.Id``\n        :param assessment_part_id: the ``Id`` of the ``AssessmentPart``\n        :type assessment_part_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: list of assignable bank ``Ids``\n        :rtype: ``osid.id.IdList``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``bank_id`` or ``assessment_part_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "bank_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "assessment_part_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "osid.id.Id"
               ], 
               "return_type": "osid.id.IdList", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational"
               }
            }, 
            {
               "name": "assign_assessment_part_to_bank", 
               "doc": {
                  "headline": "Adds an existing ``AssessmentPart`` to an ``Bank``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    assessment_part_id (osid.id.Id): the ``Id`` of the\n                ``AssessmentPart``\n        arg:    bank_id (osid.id.Id): the ``Id`` of the ``Bank``\n", 
               "return_doc": "", 
               "error_doc": "        raise:  AlreadyExists - ``assessment_part_id`` is already\n                assigned to ``bank_id``\n        raise:  NotFound - ``assessment_part_id`` or ``bank_id`` not\n                found\n        raise:  NullArgument - ``assessment_part_id`` or ``bank_id`` is\n                ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param assessment_part_id: the ``Id`` of the ``AssessmentPart``\n        :type assessment_part_id: ``osid.id.Id``\n        :param bank_id: the ``Id`` of the ``Bank``\n        :type bank_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``AlreadyExists`` -- ``assessment_part_id`` is already assigned to ``bank_id``\n        :raise: ``NotFound`` -- ``assessment_part_id`` or ``bank_id`` not found\n        :raise: ``NullArgument`` -- ``assessment_part_id`` or ``bank_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "assessment_part_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "bank_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {
                  "ALREADY_EXISTS": "User", 
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "unassign_assessment_part_from_bank", 
               "doc": {
                  "headline": "Removes an ``AssessmentPart`` from an ``Bank``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    assessment_part_id (osid.id.Id): the ``Id`` of the\n                ``AssessmentPart``\n        arg:    bank_id (osid.id.Id): the ``Id`` of the ``Bank``\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NotFound - ``assessment_part_id`` or ``bank_id`` not\n                found or ``assessment_part_id`` not assigned to\n                ``bank_id``\n        raise:  NullArgument - ``assessment_part_id`` or ``bank_id`` is\n                ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param assessment_part_id: the ``Id`` of the ``AssessmentPart``\n        :type assessment_part_id: ``osid.id.Id``\n        :param bank_id: the ``Id`` of the ``Bank``\n        :type bank_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``assessment_part_id`` or ``bank_id`` not found or ``assessment_part_id`` not assigned to ``bank_id``\n        :raise: ``NullArgument`` -- ``assessment_part_id`` or ``bank_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "assessment_part_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "bank_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.assessment.authoring.AssessmentPartSmartBankSession", 
         "shortname": "AssessmentPartSmartBankSession", 
         "category": "sessions", 
         "doc": {
            "headline": "This session manages queries and sequencing to create \"smart\" dynamic bank.", 
            "body": "    An ``AssessmentPartQuery`` can be retrieved from this session and\n    mapped to this ``Bank`` to create a virtual collection of assessment\n    parts. The assessment part may be sequenced using the\n    ``AssessmentPartSearchOrder`` from this session.\n\n    This ``Bank`` has a default query that matches any assessment part\n    and a default search order that specifies no sequencing. The queries\n    may be examined using an ``AssessmentPartQueryInspector``. The query\n    may be modified by converting the inspector back to an\n    ``AssessmentPartQuery``."
         }, 
         "inherit_fullnames": [
            "osid.OsidSession"
         ], 
         "inherit_shortnames": [
            "OsidSession"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidSession"
            }
         ], 
         "method_names": [
            "get_bank_id", 
            "get_bank", 
            "can_manage_smart_banks", 
            "get_assessment_part_query", 
            "get_assessment_part_search_order", 
            "apply_assessment_part_query", 
            "inspect_assessment_part_query", 
            "apply_assessment_part_sequencing", 
            "get_assessment_part_query_from_inspector"
         ], 
         "methods": [
            {
               "name": "get_bank_id", 
               "doc": {
                  "headline": "Gets the ``Bank``  ``Id`` associated with this session.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.id.Id) - the ``Bank Id`` associated with this\n                session", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the ``Bank Id`` associated with this session\n        :rtype: ``osid.id.Id``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.id.Id", 
               "errors": {}
            }, 
            {
               "name": "get_bank", 
               "doc": {
                  "headline": "Gets the ``Bank`` associated with this session.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.assessment.Bank) - the bank", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the bank\n        :rtype: ``osid.assessment.Bank``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.assessment.Bank", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "can_manage_smart_banks", 
               "doc": {
                  "headline": "Tests if this user can manage smart bank.", 
                  "body": "        A return of true does not guarantee successful authorization. A\n        return of false indicates that it is known methods in this\n        session will result in a ``PermissionDenied``. This is intended\n        as a hint to an application that may opt not to offer operations\n        to unauthorized users."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``false`` if smart bank management is not\n                authorized, ``true`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``false`` if smart bank management is not authorized, ``true`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "get_assessment_part_query", 
               "doc": {
                  "headline": "Gets an assessment part query.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.assessment.authoring.AssessmentPartQuery) - the\n                assessment part query", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the assessment part query\n        :rtype: ``osid.assessment.authoring.AssessmentPartQuery``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.assessment.authoring.AssessmentPartQuery", 
               "errors": {}
            }, 
            {
               "name": "get_assessment_part_search_order", 
               "doc": {
                  "headline": "Gets an assessment part search order.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.assessment.authoring.AssessmentPartSearchOrder) -\n                the assessment part search order", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the assessment part search order\n        :rtype: ``osid.assessment.authoring.AssessmentPartSearchOrder``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.assessment.authoring.AssessmentPartSearchOrder", 
               "errors": {}
            }, 
            {
               "name": "apply_assessment_part_query", 
               "doc": {
                  "headline": "Applies an assessment part query to this bank.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    assessment_part_query\n                (osid.assessment.authoring.AssessmentPartQuery): the\n                assessment part query\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``assessment_part_query`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure occurred\n        raise:  Unsupported - ``assessment_part_query`` not of this\n                service", 
               "sphinx_param_doc": "        :param assessment_part_query: the assessment part query\n        :type assessment_part_query: ``osid.assessment.authoring.AssessmentPartQuery``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``assessment_part_query`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure occurred\n        :raise: ``Unsupported`` -- ``assessment_part_query`` not of this service", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.assessment.authoring.AssessmentPartQuery", 
                     "var_name": "assessment_part_query", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.assessment.authoring.AssessmentPartQuery"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }, 
            {
               "name": "inspect_assessment_part_query", 
               "doc": {
                  "headline": "Gets an assessment part query inspector for this bank.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.assessment.authoring.AssessmentPartQueryInspector)\n                - the assessment part query inspector", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure occurred", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the assessment part query inspector\n        :rtype: ``osid.assessment.authoring.AssessmentPartQueryInspector``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure occurred", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.assessment.authoring.AssessmentPartQueryInspector", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "apply_assessment_part_sequencing", 
               "doc": {
                  "headline": "Applies an assessment part search order to this bank.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    assessment_part_search_order\n                (osid.assessment.authoring.AssessmentPartSearchOrder):\n                the assessment part search order\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``assessment_part_search_order`` is\n                ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure occurred\n        raise:  Unsupported - ``assessment_part_search_order`` not of\n                this service", 
               "sphinx_param_doc": "        :param assessment_part_search_order: the assessment part search order\n        :type assessment_part_search_order: ``osid.assessment.authoring.AssessmentPartSearchOrder``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``assessment_part_search_order`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure occurred\n        :raise: ``Unsupported`` -- ``assessment_part_search_order`` not of this service", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.assessment.authoring.AssessmentPartSearchOrder", 
                     "var_name": "assessment_part_search_order", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.assessment.authoring.AssessmentPartSearchOrder"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_assessment_part_query_from_inspector", 
               "doc": {
                  "headline": "Gets an assessment part query from an inspector.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    assessment_part_query_inspector\n                (osid.assessment.authoring.AssessmentPartQueryInspector)\n                : an assessment part query inspector\n", 
               "return_doc": "        return: (osid.assessment.authoring.AssessmentPartQuery) - the\n                assessment part query", 
               "error_doc": "        raise:  NullArgument - ``assessment_part_query_inspector`` is\n                ``null``\n        raise:  Unsupported - ``assessment_part_query_inspector`` is not\n                of this service", 
               "sphinx_param_doc": "        :param assessment_part_query_inspector: an assessment part query inspector\n        :type assessment_part_query_inspector: ``osid.assessment.authoring.AssessmentPartQueryInspector``\n", 
               "sphinx_return_doc": "        :return: the assessment part query\n        :rtype: ``osid.assessment.authoring.AssessmentPartQuery``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``assessment_part_query_inspector`` is ``null``\n        :raise: ``Unsupported`` -- ``assessment_part_query_inspector`` is not of this service", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.assessment.authoring.AssessmentPartQueryInspector", 
                     "var_name": "assessment_part_query_inspector", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.assessment.authoring.AssessmentPartQueryInspector"
               ], 
               "return_type": "osid.assessment.authoring.AssessmentPartQuery", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.assessment.authoring.AssessmentPartItemSession", 
         "shortname": "AssessmentPartItemSession", 
         "category": "sessions", 
         "doc": {
            "headline": "This session defines methods for looking up ``Item`` to ``AssessmentPart`` mappings.", 
            "body": ""
         }, 
         "inherit_fullnames": [
            "osid.OsidSession"
         ], 
         "inherit_shortnames": [
            "OsidSession"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidSession"
            }
         ], 
         "method_names": [
            "get_bank_id", 
            "get_bank", 
            "can_access_assessment_part_items", 
            "use_comparative_asseessment_part_item_view", 
            "use_plenary_assessment_part_item_view", 
            "use_federated_bank_view", 
            "use_isolated_bank_view", 
            "get_assessment_part_items", 
            "get_assessment_parts_by_item"
         ], 
         "methods": [
            {
               "name": "get_bank_id", 
               "doc": {
                  "headline": "Gets the ``Bank``  ``Id`` associated with this session.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.id.Id) - the ``Bank Id`` associated with this\n                session", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the ``Bank Id`` associated with this session\n        :rtype: ``osid.id.Id``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.id.Id", 
               "errors": {}
            }, 
            {
               "name": "get_bank", 
               "doc": {
                  "headline": "Gets the ``Bank`` associated with this session.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.assessment.Bank) - the ``Bank`` associated with\n                this session", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the ``Bank`` associated with this session\n        :rtype: ``osid.assessment.Bank``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.assessment.Bank", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "can_access_assessment_part_items", 
               "doc": {
                  "headline": "Tests if this user can perform assessment part lookups.", 
                  "body": "        A return of true does not guarantee successful authorization. A\n        return of false indicates that it is known all methods in this\n        session will result in a ``PermissionDenied``. This is intended\n        as a hint to an application that may opt not to offer lookup\n        operations to unauthorized users."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``false`` if lookup methods are not\n                authorized, ``true`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``false`` if lookup methods are not authorized, ``true`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "use_comparative_asseessment_part_item_view", 
               "doc": {
                  "headline": "The returns from the lookup methods may omit or translate elements based on this session, such as authorization, and not result in an error.", 
                  "body": "        This view is used when greater interoperability is desired at\n        the expense of precision."
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "use_plenary_assessment_part_item_view", 
               "doc": {
                  "headline": "A complete view of the returns is desired.", 
                  "body": "        Methods will return what is requested or result in an error.\n        This view is used when greater precision is desired at the\n        expense of interoperability."
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "use_federated_bank_view", 
               "doc": {
                  "headline": "Federates the view for methods in this session.", 
                  "body": "        A federated view will include assessment parts in catalogs which\n        are children of this catalog in the bank hierarchy."
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "use_isolated_bank_view", 
               "doc": {
                  "headline": "Isolates the view for methods in this session.", 
                  "body": "        An isolated view restricts retrievals to this bank only."
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "get_assessment_part_items", 
               "doc": {
                  "headline": "Gets the list of items mapped to the given ``AssessmentPart``.", 
                  "body": "        In plenary mode, the returned list contains all known items or\n        an error results. Otherwise, the returned list may contain only\n        those items that are accessible through this session."
               }, 
               "arg_doc": "        arg:    assessment_part_id (osid.id.Id): ``Id`` of the\n                ``AssessmentPart``\n", 
               "return_doc": "        return: (osid.assessment.ItemList) - list of items", 
               "error_doc": "        raise:  NotFound - ``assessment_part_id`` not found\n        raise:  NullArgument - ``assessment_part_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param assessment_part_id: ``Id`` of the ``AssessmentPart``\n        :type assessment_part_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: list of items\n        :rtype: ``osid.assessment.ItemList``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``assessment_part_id`` not found\n        :raise: ``NullArgument`` -- ``assessment_part_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "assessment_part_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "osid.assessment.ItemList", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_assessment_parts_by_item", 
               "doc": {
                  "headline": "Gets the assessment parts containing the given item.", 
                  "body": "        In plenary mode, the returned list contains all known assessment\n        parts or an error results. Otherwise, the returned list may\n        contain only those assessment parts that are accessible through\n        this session."
               }, 
               "arg_doc": "        arg:    item_id (osid.id.Id): ``Id`` of the ``Item``\n", 
               "return_doc": "        return: (osid.assessment.authoring.AssessmentPartList) - the\n                returned ``AssessmentPart list``", 
               "error_doc": "        raise:  NotFound - ``item_id`` is not found\n        raise:  NullArgument - ``item_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param item_id: ``Id`` of the ``Item``\n        :type item_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: the returned ``AssessmentPart list``\n        :rtype: ``osid.assessment.authoring.AssessmentPartList``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``item_id`` is not found\n        :raise: ``NullArgument`` -- ``item_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "item_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "osid.assessment.authoring.AssessmentPartList", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.assessment.authoring.AssessmentPartItemDesignSession", 
         "shortname": "AssessmentPartItemDesignSession", 
         "category": "sessions", 
         "doc": {
            "headline": "This session provides the means for adding items to an assessment part.", 
            "body": "    The item is identified inside an assesment part using its own Id. To\n    add the same item to the assessment part, multiple assessment parts\n    should be used and placed at the same level in the\n    ``AssessmentPart`` hierarchy."
         }, 
         "inherit_fullnames": [
            "osid.OsidSession"
         ], 
         "inherit_shortnames": [
            "OsidSession"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidSession"
            }
         ], 
         "method_names": [
            "get_bank_id", 
            "get_bank", 
            "can_design_assessment_parts", 
            "add_item", 
            "move_item_ahead", 
            "move_item_behind", 
            "order_items", 
            "remove_item"
         ], 
         "methods": [
            {
               "name": "get_bank_id", 
               "doc": {
                  "headline": "Gets the ``Bank``  ``Id`` associated with this session.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.id.Id) - the ``Bank Id`` associated with this\n                session", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the ``Bank Id`` associated with this session\n        :rtype: ``osid.id.Id``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.id.Id", 
               "errors": {}
            }, 
            {
               "name": "get_bank", 
               "doc": {
                  "headline": "Gets the ``Bank`` associated with this session.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.assessment.Bank) - the ``Bank`` associated with\n                this session", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the ``Bank`` associated with this session\n        :rtype: ``osid.assessment.Bank``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.assessment.Bank", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "can_design_assessment_parts", 
               "doc": {
                  "headline": "Tests if this user can manage mapping of ``Items`` to ``AssessmentParts``.", 
                  "body": "        A return of true does not guarantee successful authorization. A\n        return of false indicates that it is known all methods in this\n        session will result in a ``PermissionDenied``. This is intended\n        as an application hint that may opt not to offer composition\n        operations."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``false`` if assessment part composition is\n                not authorized, ``true`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``false`` if assessment part composition is not authorized, ``true`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "add_item", 
               "doc": {
                  "headline": "Appends an item to an assessment part.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    item_id (osid.id.Id): ``Id`` of the ``Item``\n        arg:    assessment_part_id (osid.id.Id): ``Id`` of the\n                ``AssessmentPart``\n", 
               "return_doc": "", 
               "error_doc": "        raise:  AlreadyExists - ``item_id`` already part of\n                ``assessment_part_id``\n        raise:  NotFound - ``item_id`` or ``assessment_part_id`` not\n                found\n        raise:  NullArgument - ``item_id`` or ``assessment_part_id`` is\n                ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization fauilure", 
               "sphinx_param_doc": "        :param item_id: ``Id`` of the ``Item``\n        :type item_id: ``osid.id.Id``\n        :param assessment_part_id: ``Id`` of the ``AssessmentPart``\n        :type assessment_part_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``AlreadyExists`` -- ``item_id`` already part of ``assessment_part_id``\n        :raise: ``NotFound`` -- ``item_id`` or ``assessment_part_id`` not found\n        :raise: ``NullArgument`` -- ``item_id`` or ``assessment_part_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization fauilure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "item_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "assessment_part_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {
                  "ALREADY_EXISTS": "User", 
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "move_item_ahead", 
               "doc": {
                  "headline": "Reorders items in an assessment part by moving the specified item in front of a reference item.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    item_id (osid.id.Id): ``Id`` of the ``Item``\n        arg:    assessment_part_id (osid.id.Id): ``Id`` of the\n                ``AssessmentPartId``\n        arg:    reference_id (osid.id.Id): ``Id`` of the reference\n                ``Item``\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NotFound - ``item_id`` or ``reference_id``  ``not found\n                in assessment_part_id``\n        raise:  NullArgument - ``item_id, reference_id`` or\n                ``assessment_part_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization fauilure", 
               "sphinx_param_doc": "        :param item_id: ``Id`` of the ``Item``\n        :type item_id: ``osid.id.Id``\n        :param assessment_part_id: ``Id`` of the ``AssessmentPartId``\n        :type assessment_part_id: ``osid.id.Id``\n        :param reference_id: ``Id`` of the reference ``Item``\n        :type reference_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``item_id`` or ``reference_id``  ``not found in assessment_part_id``\n        :raise: ``NullArgument`` -- ``item_id, reference_id`` or ``assessment_part_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization fauilure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "item_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "assessment_part_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "reference_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "osid.id.Id", 
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "move_item_behind", 
               "doc": {
                  "headline": "Reorders items in an assessment part by moving the specified item behind of a reference item.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    item_id (osid.id.Id): ``Id`` of the ``Item``\n        arg:    assessment_part_id (osid.id.Id): ``Id of the\n                AssessmentPartId``\n        arg:    reference_id (osid.id.Id): ``Id`` of the reference\n                ``Item``\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NotFound - ``item_id`` or ``reference_id``  ``not found\n                in assessment_part_id``\n        raise:  NullArgument - ``item_id, reference_id`` or\n                ``assessment_part_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization fauilure", 
               "sphinx_param_doc": "        :param item_id: ``Id`` of the ``Item``\n        :type item_id: ``osid.id.Id``\n        :param assessment_part_id: ``Id of the AssessmentPartId``\n        :type assessment_part_id: ``osid.id.Id``\n        :param reference_id: ``Id`` of the reference ``Item``\n        :type reference_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``item_id`` or ``reference_id``  ``not found in assessment_part_id``\n        :raise: ``NullArgument`` -- ``item_id, reference_id`` or ``assessment_part_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization fauilure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "item_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "assessment_part_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "reference_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "osid.id.Id", 
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "order_items", 
               "doc": {
                  "headline": "Reorders a set of items in an assessment part.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    item_ids (osid.id.Id[]): ``Ids`` for a set of ``Items``\n        arg:    assessment_part_id (osid.id.Id): ``Id`` of the\n                ``AssessmentPartId``\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NotFound - ``assessment_part_id`` not found or, an\n                ``item_id`` not related to ``assessment_part_id``\n        raise:  NullArgument - ``item_ids`` or ``agenda_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param item_ids: ``Ids`` for a set of ``Items``\n        :type item_ids: ``osid.id.Id[]``\n        :param assessment_part_id: ``Id`` of the ``AssessmentPartId``\n        :type assessment_part_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``assessment_part_id`` not found or, an ``item_id`` not related to ``assessment_part_id``\n        :raise: ``NullArgument`` -- ``item_ids`` or ``agenda_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id[]", 
                     "var_name": "item_ids", 
                     "array": true
                  }, 
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "assessment_part_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id[]", 
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "remove_item", 
               "doc": {
                  "headline": "Removes an ``Item`` from an ``AssessmentPartId``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    item_id (osid.id.Id): ``Id`` of the ``Item``\n        arg:    assessment_part_id (osid.id.Id): ``Id`` of the\n                ``AssessmentPartId``\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NotFound - ``item_id``  ``not found in\n                assessment_part_id``\n        raise:  NullArgument - ``item_id`` or ``assessment_part_id`` is\n                ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization fauilure", 
               "sphinx_param_doc": "        :param item_id: ``Id`` of the ``Item``\n        :type item_id: ``osid.id.Id``\n        :param assessment_part_id: ``Id`` of the ``AssessmentPartId``\n        :type assessment_part_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``item_id``  ``not found in assessment_part_id``\n        :raise: ``NullArgument`` -- ``item_id`` or ``assessment_part_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization fauilure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "item_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "assessment_part_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.assessment.authoring.SequenceRuleLookupSession", 
         "shortname": "SequenceRuleLookupSession", 
         "category": "sessions", 
         "doc": {
            "headline": "This session provides methods for retrieving ``SequenceRules``.", 
            "body": ""
         }, 
         "inherit_fullnames": [
            "osid.OsidSession"
         ], 
         "inherit_shortnames": [
            "OsidSession"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidSession"
            }
         ], 
         "method_names": [
            "get_bank_id", 
            "get_bank", 
            "can_lookup_sequence_rules", 
            "use_comparative_sequence_rule_view", 
            "use_plenary_sequence_rule_view", 
            "use_federated_bank_view", 
            "use_isolated_bank_view", 
            "use_active_sequence_rule_view", 
            "use_any_status_sequence_rule_view", 
            "get_sequence_rule", 
            "get_sequence_rules_by_ids", 
            "get_sequence_rules_by_genus_type", 
            "get_sequence_rules_by_parent_genus_type", 
            "get_sequence_rules_by_record_type", 
            "get_sequence_rules_for_assessment_part", 
            "get_sequence_rules_for_next_assessment_part", 
            "get_sequence_rules_for_assessment_parts", 
            "get_sequence_rules_for_assessment", 
            "get_sequence_rules"
         ], 
         "methods": [
            {
               "name": "get_bank_id", 
               "doc": {
                  "headline": "Gets the ``Bank``  ``Id`` associated with this session.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.id.Id) - the ``Bank Id`` associated with this\n                session", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the ``Bank Id`` associated with this session\n        :rtype: ``osid.id.Id``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.id.Id", 
               "errors": {}
            }, 
            {
               "name": "get_bank", 
               "doc": {
                  "headline": "Gets the ``Bank`` associated with this session.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.assessment.Bank) - the bank", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the bank\n        :rtype: ``osid.assessment.Bank``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.assessment.Bank", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "can_lookup_sequence_rules", 
               "doc": {
                  "headline": "Tests if this user can perform ``SequenceRules`` lookups.", 
                  "body": "        A return of true does not guarantee successful authorization. A\n        return of false indicates that it is known all methods in this\n        session will result in a ``PermissionDenied``. This is intended\n        as a hint to an application that may opt not to offer lookup\n        operations to unauthorized users."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``false`` if lookup methods are not\n                authorized, ``true`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``false`` if lookup methods are not authorized, ``true`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "use_comparative_sequence_rule_view", 
               "doc": {
                  "headline": "The returns from the lookup methods may omit or translate elements based on this session, such as authorization, and not result in an error.", 
                  "body": "        This view is used when greater interoperability is desired at\n        the expense of precision."
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "use_plenary_sequence_rule_view", 
               "doc": {
                  "headline": "A complete view of the ``SequenceRule`` returns is desired.", 
                  "body": "        Methods will return what is requested or result in an error.\n        This view is used when greater precision is desired at the\n        expense of interoperability."
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "use_federated_bank_view", 
               "doc": {
                  "headline": "Federates the view for methods in this session.", 
                  "body": "        A federated view will include sequence rule in banks which are\n        children of this bank in the bank hierarchy."
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "use_isolated_bank_view", 
               "doc": {
                  "headline": "Isolates the view for methods in this session.", 
                  "body": "        An isolated view restricts lookups to this bank only."
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "use_active_sequence_rule_view", 
               "doc": {
                  "headline": "Only active sequence rules are returned by methods in this session.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "use_any_status_sequence_rule_view", 
               "doc": {
                  "headline": "All active and inactive sequence rules are returned by methods in this session.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "get_sequence_rule", 
               "doc": {
                  "headline": "Gets the ``SequenceRule`` specified by its ``Id``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    sequence_rule_id (osid.id.Id): ``Id`` of the\n                ``SequenceRule``\n", 
               "return_doc": "        return: (osid.assessment.authoring.SequenceRule) - the sequence\n                rule", 
               "error_doc": "        raise:  NotFound - ``sequence_rule_id`` not found\n        raise:  NullArgument - ``sequence_rule_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param sequence_rule_id: ``Id`` of the ``SequenceRule``\n        :type sequence_rule_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: the sequence rule\n        :rtype: ``osid.assessment.authoring.SequenceRule``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``sequence_rule_id`` not found\n        :raise: ``NullArgument`` -- ``sequence_rule_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "sequence_rule_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "osid.assessment.authoring.SequenceRule", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_sequence_rules_by_ids", 
               "doc": {
                  "headline": "Gets a ``SequenceRuleList`` corresponding to the given ``IdList``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    sequence_rule_ids (osid.id.IdList): the list of ``Ids``\n                to retrieve\n", 
               "return_doc": "        return: (osid.assessment.authoring.SequenceRuleList) - the\n                returned ``SequenceRule`` list", 
               "error_doc": "        raise:  NotFound - a ``Id was`` not found\n        raise:  NullArgument - ``sequence_rule_ids`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param sequence_rule_ids: the list of ``Ids`` to retrieve\n        :type sequence_rule_ids: ``osid.id.IdList``\n", 
               "sphinx_return_doc": "        :return: the returned ``SequenceRule`` list\n        :rtype: ``osid.assessment.authoring.SequenceRuleList``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- a ``Id was`` not found\n        :raise: ``NullArgument`` -- ``sequence_rule_ids`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.IdList", 
                     "var_name": "sequence_rule_ids", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.IdList"
               ], 
               "return_type": "osid.assessment.authoring.SequenceRuleList", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_sequence_rules_by_genus_type", 
               "doc": {
                  "headline": "Gets a ``SequenceRuleList`` corresponding to the given sequence rule genus ``Type`` which does not include sequence rule of genus types derived from the specified ``Type``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    sequence_rule_genus_type (osid.type.Type): a sequence\n                rule genus type\n", 
               "return_doc": "        return: (osid.assessment.authoring.SequenceRuleList) - the\n                returned ``SequenceRule`` list", 
               "error_doc": "        raise:  NullArgument - ``sequence_rule_genus_type`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param sequence_rule_genus_type: a sequence rule genus type\n        :type sequence_rule_genus_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "        :return: the returned ``SequenceRule`` list\n        :rtype: ``osid.assessment.authoring.SequenceRuleList``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``sequence_rule_genus_type`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "sequence_rule_genus_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "osid.assessment.authoring.SequenceRuleList", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_sequence_rules_by_parent_genus_type", 
               "doc": {
                  "headline": "Gets a ``SequenceRuleList`` corresponding to the given sequence rule genus ``Type`` and include any additional sequence rule with genus types derived from the specified ``Type``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    sequence_rule_genus_type (osid.type.Type): a sequence\n                rule genus type\n", 
               "return_doc": "        return: (osid.assessment.authoring.SequenceRuleList) - the\n                returned ``SequenceRule`` list", 
               "error_doc": "        raise:  NullArgument - ``sequence_rule_genus_type`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param sequence_rule_genus_type: a sequence rule genus type\n        :type sequence_rule_genus_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "        :return: the returned ``SequenceRule`` list\n        :rtype: ``osid.assessment.authoring.SequenceRuleList``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``sequence_rule_genus_type`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "sequence_rule_genus_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "osid.assessment.authoring.SequenceRuleList", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_sequence_rules_by_record_type", 
               "doc": {
                  "headline": "Gets a ``SequenceRuleList`` containing the given sequence rule record ``Type``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    sequence_rule_record_type (osid.type.Type): a sequence\n                rule record type\n", 
               "return_doc": "        return: (osid.assessment.authoring.SequenceRuleList) - the\n                returned ``SequenceRule`` list", 
               "error_doc": "        raise:  NullArgument - ``sequence_rule_record_type`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param sequence_rule_record_type: a sequence rule record type\n        :type sequence_rule_record_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "        :return: the returned ``SequenceRule`` list\n        :rtype: ``osid.assessment.authoring.SequenceRuleList``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``sequence_rule_record_type`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "sequence_rule_record_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "osid.assessment.authoring.SequenceRuleList", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_sequence_rules_for_assessment_part", 
               "doc": {
                  "headline": "Gets a ``SequenceRuleList`` for the given source assessment part.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    assessment_part_id (osid.id.Id): an assessment part\n                ``Id``\n", 
               "return_doc": "        return: (osid.assessment.authoring.SequenceRuleList) - the\n                returned ``SequenceRule`` list", 
               "error_doc": "        raise:  NullArgument - ``assessment_part_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param assessment_part_id: an assessment part ``Id``\n        :type assessment_part_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: the returned ``SequenceRule`` list\n        :rtype: ``osid.assessment.authoring.SequenceRuleList``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``assessment_part_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "assessment_part_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "osid.assessment.authoring.SequenceRuleList", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_sequence_rules_for_next_assessment_part", 
               "doc": {
                  "headline": "Gets a ``SequenceRuleList`` for the given target assessment part.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    next_assessment_part_id (osid.id.Id): an assessment part\n                ``Id``\n", 
               "return_doc": "        return: (osid.assessment.authoring.SequenceRuleList) - the\n                returned ``SequenceRule`` list", 
               "error_doc": "        raise:  NullArgument - ``next_assessment_part_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param next_assessment_part_id: an assessment part ``Id``\n        :type next_assessment_part_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: the returned ``SequenceRule`` list\n        :rtype: ``osid.assessment.authoring.SequenceRuleList``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``next_assessment_part_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "next_assessment_part_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "osid.assessment.authoring.SequenceRuleList", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_sequence_rules_for_assessment_parts", 
               "doc": {
                  "headline": "Gets a ``SequenceRuleList`` for the given source and target assessment parts.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    assessment_part_id (osid.id.Id): source assessment part\n                ``Id``\n        arg:    next_assessment_part_id (osid.id.Id): target assessment\n                part ``Id``\n", 
               "return_doc": "        return: (osid.assessment.authoring.SequenceRuleList) - the\n                returned ``SequenceRule`` list", 
               "error_doc": "        raise:  NullArgument - ``assessment_part_id`` or\n                ``next_assessment_part_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param assessment_part_id: source assessment part ``Id``\n        :type assessment_part_id: ``osid.id.Id``\n        :param next_assessment_part_id: target assessment part ``Id``\n        :type next_assessment_part_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: the returned ``SequenceRule`` list\n        :rtype: ``osid.assessment.authoring.SequenceRuleList``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``assessment_part_id`` or ``next_assessment_part_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "assessment_part_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "next_assessment_part_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "osid.id.Id"
               ], 
               "return_type": "osid.assessment.authoring.SequenceRuleList", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_sequence_rules_for_assessment", 
               "doc": {
                  "headline": "Gets a ``SequenceRuleList`` for an entire assessment.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    assessment_id (osid.id.Id): an assessment ``Id``\n", 
               "return_doc": "        return: (osid.assessment.authoring.SequenceRuleList) - the\n                returned ``SequenceRule`` list", 
               "error_doc": "        raise:  NullArgument - ``assessment_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param assessment_id: an assessment ``Id``\n        :type assessment_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: the returned ``SequenceRule`` list\n        :rtype: ``osid.assessment.authoring.SequenceRuleList``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``assessment_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "assessment_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "osid.assessment.authoring.SequenceRuleList", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_sequence_rules", 
               "doc": {
                  "headline": "Gets all ``SequenceRules``.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.assessment.authoring.SequenceRuleList) - the\n                returned ``SequenceRule`` list", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the returned ``SequenceRule`` list\n        :rtype: ``osid.assessment.authoring.SequenceRuleList``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.assessment.authoring.SequenceRuleList", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.assessment.authoring.SequenceRuleQuerySession", 
         "shortname": "SequenceRuleQuerySession", 
         "category": "sessions", 
         "doc": {
            "headline": "This session provides methods for searching among ``SequenceRule`` objects.", 
            "body": "    The search query is constructed using the ``SequenceRuleQuery``.\n\n    This session defines views that offer differing behaviors for\n    searching.\n    \n      * federated bank view: searches include sequence rule in bank of\n        which this bank is an ancestor in the bank hierarchy\n      * isolated bank view: searches are restricted to sequence rule in\n        this bank\n\n    \n    sequence rule may have a query record indicated by their respective\n    record types. The query record is accessed via the\n    ``SequenceRuleQuery``."
         }, 
         "inherit_fullnames": [
            "osid.OsidSession"
         ], 
         "inherit_shortnames": [
            "OsidSession"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidSession"
            }
         ], 
         "method_names": [
            "get_bank_id", 
            "get_bank", 
            "can_search_sequence_rules", 
            "use_federated_bank_view", 
            "use_isolated_bank_view", 
            "get_sequence_rule_query", 
            "get_sequence_rules_by_query"
         ], 
         "methods": [
            {
               "name": "get_bank_id", 
               "doc": {
                  "headline": "Gets the ``Bank``  ``Id`` associated with this session.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.id.Id) - the ``Bank Id`` associated with this\n                session", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the ``Bank Id`` associated with this session\n        :rtype: ``osid.id.Id``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.id.Id", 
               "errors": {}
            }, 
            {
               "name": "get_bank", 
               "doc": {
                  "headline": "Gets the ``Bank`` associated with this session.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.assessment.Bank) - the bank", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the bank\n        :rtype: ``osid.assessment.Bank``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.assessment.Bank", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "can_search_sequence_rules", 
               "doc": {
                  "headline": "Tests if this user can perform ``SequenceRule`` lookups.", 
                  "body": "        A return of true does not guarantee successful authorization. A\n        return of false indicates that it is known all methods in this\n        session will result in a ``PermissionDenied``. This is intended\n        as a hint to an application that may not offer lookup operations\n        to unauthorized users."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``false`` if search methods are not\n                authorized, ``true`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``false`` if search methods are not authorized, ``true`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "use_federated_bank_view", 
               "doc": {
                  "headline": "Federates the view for methods in this session.", 
                  "body": "        A federated view will include sequence rule in banks which are\n        children of this step in the bank hierarchy."
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "use_isolated_bank_view", 
               "doc": {
                  "headline": "Isolates the view for methods in this session.", 
                  "body": "        An isolated view restricts lookups to this bank only."
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "get_sequence_rule_query", 
               "doc": {
                  "headline": "Gets a sequence rule query.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.assessment.authoring.SequenceRuleQuery) - the\n                sequence rule query", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the sequence rule query\n        :rtype: ``osid.assessment.authoring.SequenceRuleQuery``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.assessment.authoring.SequenceRuleQuery", 
               "errors": {}
            }, 
            {
               "name": "get_sequence_rules_by_query", 
               "doc": {
                  "headline": "Gets a list of ``SequenceRules`` matching the given sequence rule query.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    sequence_rule_query\n                (osid.assessment.authoring.SequenceRuleQuery): the\n                sequence rule query\n", 
               "return_doc": "        return: (osid.assessment.authoring.SequenceRuleList) - the\n                returned ``SequenceRuleList``", 
               "error_doc": "        raise:  NullArgument - ``sequence_rule_query`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        raise:  Unsupported - ``sequence_rule_query`` is not of this\n                service", 
               "sphinx_param_doc": "        :param sequence_rule_query: the sequence rule query\n        :type sequence_rule_query: ``osid.assessment.authoring.SequenceRuleQuery``\n", 
               "sphinx_return_doc": "        :return: the returned ``SequenceRuleList``\n        :rtype: ``osid.assessment.authoring.SequenceRuleList``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``sequence_rule_query`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure\n        :raise: ``Unsupported`` -- ``sequence_rule_query`` is not of this service", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.assessment.authoring.SequenceRuleQuery", 
                     "var_name": "sequence_rule_query", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.assessment.authoring.SequenceRuleQuery"
               ], 
               "return_type": "osid.assessment.authoring.SequenceRuleList", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.assessment.authoring.SequenceRuleSearchSession", 
         "shortname": "SequenceRuleSearchSession", 
         "category": "sessions", 
         "doc": {
            "headline": "This session provides methods for searching among ``SequenceRule`` objects.", 
            "body": "    The search query is constructed using the ``SequenceRuleyQuery``.\n\n    ``get_sequence_rules_by_query()`` is the basic search method and\n    returns a list of ``SequenceRules``. A more advanced search may be\n    performed with ``getSequenceRulesBySearch()``. It accepts a\n    ``SequenceRuleSearch`` in addition to the query for the purpose of\n    specifying additional options affecting the entire search, such as\n    workflow. ``get_sequence_rules_by_search()`` returns a\n    ``SequenceRuleSearchResults`` that can be used to access the\n    resulting ``SequenceRuleList`` or be used to perform a search within\n    the result set through ``SequenceRuleSearch``.\n    \n    This session defines views that offer differing behaviors for\n    searching.\n    \n      * federated bank view: searches include sequence rule in bank of\n        which this bank matchmaker is an ancestor in the bank hierarchy\n      * isolated bank view: searches are restricted to sequence rule in\n        this bank\n\n    \n    ``SequenceRules`` may have a query record indicated by their\n    respective record types. The query record is accessed via the\n    ``SequenceRuleQuery``."
         }, 
         "inherit_fullnames": [
            "osid.assessment.authoring.SequenceRuleQuerySession"
         ], 
         "inherit_shortnames": [
            "SequenceRuleQuerySession"
         ], 
         "inherit_pkg_names": [
            "authoring"
         ], 
         "inheritance": [
            {
               "pkg_name": "assessment.authoring", 
               "name": "SequenceRuleQuerySession"
            }
         ], 
         "method_names": [
            "get_sequence_rule_search", 
            "get_sequence_rule_search_order", 
            "get_sequence_rules_by_search", 
            "get_sequence_rule_query_from_inspector"
         ], 
         "methods": [
            {
               "name": "get_sequence_rule_search", 
               "doc": {
                  "headline": "Gets a sequence rule search.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.assessment.authoring.SequenceRuleSearch) - the\n                sequence rule search", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the sequence rule search\n        :rtype: ``osid.assessment.authoring.SequenceRuleSearch``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.assessment.authoring.SequenceRuleSearch", 
               "errors": {}
            }, 
            {
               "name": "get_sequence_rule_search_order", 
               "doc": {
                  "headline": "Gets a sequence rule search order.", 
                  "body": "        The ``SequenceRuleSearchOrder`` is supplied to a\n        ``SequenceRuleSearch`` to specify the ordering of results."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.assessment.authoring.SequenceRuleSearchOrder) -\n                the sequence rule search order", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the sequence rule search order\n        :rtype: ``osid.assessment.authoring.SequenceRuleSearchOrder``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.assessment.authoring.SequenceRuleSearchOrder", 
               "errors": {}
            }, 
            {
               "name": "get_sequence_rules_by_search", 
               "doc": {
                  "headline": "Gets the search results matching the given search query using the given search.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    sequence_rule_query\n                (osid.assessment.authoring.SequenceRuleQuery): the\n                sequence rule query\n        arg:    sequence_rule_search\n                (osid.assessment.authoring.SequenceRuleSearch): the\n                sequence rule search\n", 
               "return_doc": "        return: (osid.assessment.authoring.SequenceRuleSearchResults) -\n                the returned search results", 
               "error_doc": "        raise:  NullArgument - ``sequence_rule_query`` or\n                ``sequence_rule_search`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        raise:  Unsupported - ``sequence_rule_query`` or\n                ``sequence_rule_search`` is not of this service", 
               "sphinx_param_doc": "        :param sequence_rule_query: the sequence rule query\n        :type sequence_rule_query: ``osid.assessment.authoring.SequenceRuleQuery``\n        :param sequence_rule_search: the sequence rule search\n        :type sequence_rule_search: ``osid.assessment.authoring.SequenceRuleSearch``\n", 
               "sphinx_return_doc": "        :return: the returned search results\n        :rtype: ``osid.assessment.authoring.SequenceRuleSearchResults``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``sequence_rule_query`` or ``sequence_rule_search`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure\n        :raise: ``Unsupported`` -- ``sequence_rule_query`` or ``sequence_rule_search`` is not of this service", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.assessment.authoring.SequenceRuleQuery", 
                     "var_name": "sequence_rule_query", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.assessment.authoring.SequenceRuleSearch", 
                     "var_name": "sequence_rule_search", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.assessment.authoring.SequenceRuleQuery", 
                  "osid.assessment.authoring.SequenceRuleSearch"
               ], 
               "return_type": "osid.assessment.authoring.SequenceRuleSearchResults", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_sequence_rule_query_from_inspector", 
               "doc": {
                  "headline": "Gets a sequence rule query from an inspector.", 
                  "body": "        The inspector is available from a ``SequenceRuleSearchResults``."
               }, 
               "arg_doc": "        arg:    sequence_rule_query_inspector\n                (osid.assessment.authoring.SequenceRuleQueryInspector):\n                a sequence rule query inspector\n", 
               "return_doc": "        return: (osid.assessment.authoring.SequenceRuleQuery) - the\n                sequence rule query", 
               "error_doc": "        raise:  NullArgument - ``sequence_rule_query_inspector`` is\n                ``null``\n        raise:  Unsupported - ``sequence_rule_query_inspector`` is not\n                of this service", 
               "sphinx_param_doc": "        :param sequence_rule_query_inspector: a sequence rule query inspector\n        :type sequence_rule_query_inspector: ``osid.assessment.authoring.SequenceRuleQueryInspector``\n", 
               "sphinx_return_doc": "        :return: the sequence rule query\n        :rtype: ``osid.assessment.authoring.SequenceRuleQuery``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``sequence_rule_query_inspector`` is ``null``\n        :raise: ``Unsupported`` -- ``sequence_rule_query_inspector`` is not of this service", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.assessment.authoring.SequenceRuleQueryInspector", 
                     "var_name": "sequence_rule_query_inspector", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.assessment.authoring.SequenceRuleQueryInspector"
               ], 
               "return_type": "osid.assessment.authoring.SequenceRuleQuery", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.assessment.authoring.SequenceRuleAdminSession", 
         "shortname": "SequenceRuleAdminSession", 
         "category": "sessions", 
         "doc": {
            "headline": "This session creates and removes sequence rules.", 
            "body": "    The data for create and update is provided via the\n    ``SequenceRuleForm``."
         }, 
         "inherit_fullnames": [
            "osid.OsidSession"
         ], 
         "inherit_shortnames": [
            "OsidSession"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidSession"
            }
         ], 
         "method_names": [
            "get_bank_id", 
            "get_bank", 
            "can_create_sequence_rule", 
            "can_create_sequence_rule_with_record_types", 
            "get_sequence_rule_form_for_create", 
            "create_sequence_rule", 
            "can_update_sequence_rules", 
            "get_sequence_rule_form_for_update", 
            "update_sequence_rule", 
            "can_delete_sequence_rules", 
            "delete_sequence_rule", 
            "can_manage_sequence_rule_aliases", 
            "alias_sequence_rule", 
            "can_sequence_sequence_rules", 
            "move_sequence_rule_ahead", 
            "move_sequence_rule_behind", 
            "order_sequence_rules"
         ], 
         "methods": [
            {
               "name": "get_bank_id", 
               "doc": {
                  "headline": "Gets the ``Bank``  ``Id`` associated with this session.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.id.Id) - the ``Bank Id`` associated with this\n                session", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the ``Bank Id`` associated with this session\n        :rtype: ``osid.id.Id``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.id.Id", 
               "errors": {}
            }, 
            {
               "name": "get_bank", 
               "doc": {
                  "headline": "Gets the ``Bank`` associated with this session.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.assessment.Bank) - the bank", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the bank\n        :rtype: ``osid.assessment.Bank``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.assessment.Bank", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "can_create_sequence_rule", 
               "doc": {
                  "headline": "Tests if this user can create sequence rules.", 
                  "body": "        A return of true does not guarantee successful authorization. A\n        return of false indicates that it is known creating a\n        ``SequenceRule`` will result in a ``PermissionDenied``. This is\n        intended as a hint to an application that may opt not to offer\n        create operations to an unauthorized user."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``false`` if ``SequenceRule`` creation is\n                not authorized, ``true`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``false`` if ``SequenceRule`` creation is not authorized, ``true`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "can_create_sequence_rule_with_record_types", 
               "doc": {
                  "headline": "Tests if this user can create a single ``SequenceRule`` using the desired record types.", 
                  "body": "        While\n        ``AssessmentAuthoringManager.getSequenceRuleRecordTypes()`` can\n        be used to examine which records are supported, this method\n        tests which record(s) are required for creating a specific\n        ``SequenceRule``. Providing an empty array tests if a\n        ``SequenceRule`` can be created with no records."
               }, 
               "arg_doc": "        arg:    sequence_rule_record_types (osid.type.Type[]): array of\n                sequence rule record types\n", 
               "return_doc": "        return: (boolean) - ``true`` if ``SequenceRule`` creation using\n                the specified record ``Types`` is supported, ``false``\n                otherwise", 
               "error_doc": "        raise:  NullArgument - ``sequence_rule_record_types`` is\n                ``null``", 
               "sphinx_param_doc": "        :param sequence_rule_record_types: array of sequence rule record types\n        :type sequence_rule_record_types: ``osid.type.Type[]``\n", 
               "sphinx_return_doc": "        :return: ``true`` if ``SequenceRule`` creation using the specified record ``Types`` is supported, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``sequence_rule_record_types`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type[]", 
                     "var_name": "sequence_rule_record_types", 
                     "array": true
                  }
               ], 
               "arg_types": [
                  "osid.type.Type[]"
               ], 
               "return_type": "boolean", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "get_sequence_rule_form_for_create", 
               "doc": {
                  "headline": "Gets the sequence rule form for creating new sequence rules between two assessment parts.", 
                  "body": "        A new form should be requested for each create transaction."
               }, 
               "arg_doc": "        arg:    assessment_part_id (osid.id.Id): the source assessment\n                part ``Id``\n        arg:    next_assessment_part_id (osid.id.Id): the target\n                assessment part ``Id``\n        arg:    sequence_rule_record_types (osid.type.Type[]): array of\n                sequence rule record types\n", 
               "return_doc": "        return: (osid.assessment.authoring.SequenceRuleForm) - the\n                sequence rule form", 
               "error_doc": "        raise:  InvalidArgument - ``assessment_part_id`` and\n                ``next_assessment_part_id`` not on the same assessment\n        raise:  NotFound - ``assessment_part_id`` or\n                ``next_assessment_part_id`` is not found\n        raise:  NullArgument - ``assessment_part_id,\n                next_assessment_part_id`` , or\n                ``sequence_rule_record_types`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        raise:  Unsupported - unable to get form for requested record\n                types", 
               "sphinx_param_doc": "        :param assessment_part_id: the source assessment part ``Id``\n        :type assessment_part_id: ``osid.id.Id``\n        :param next_assessment_part_id: the target assessment part ``Id``\n        :type next_assessment_part_id: ``osid.id.Id``\n        :param sequence_rule_record_types: array of sequence rule record types\n        :type sequence_rule_record_types: ``osid.type.Type[]``\n", 
               "sphinx_return_doc": "        :return: the sequence rule form\n        :rtype: ``osid.assessment.authoring.SequenceRuleForm``", 
               "sphinx_error_doc": "        :raise: ``InvalidArgument`` -- ``assessment_part_id`` and ``next_assessment_part_id`` not on the same assessment\n        :raise: ``NotFound`` -- ``assessment_part_id`` or ``next_assessment_part_id`` is not found\n        :raise: ``NullArgument`` -- ``assessment_part_id, next_assessment_part_id`` , or ``sequence_rule_record_types`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure\n        :raise: ``Unsupported`` -- unable to get form for requested record types", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "assessment_part_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "next_assessment_part_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.type.Type[]", 
                     "var_name": "sequence_rule_record_types", 
                     "array": true
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "osid.id.Id", 
                  "osid.type.Type[]"
               ], 
               "return_type": "osid.assessment.authoring.SequenceRuleForm", 
               "errors": {
                  "INVALID_ARGUMENT": "ConsumerContract", 
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }, 
            {
               "name": "create_sequence_rule", 
               "doc": {
                  "headline": "Creates a new ``SequenceRule``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    sequence_rule_form\n                (osid.assessment.authoring.SequenceRuleForm): the form\n                for this ``SequenceRule``\n", 
               "return_doc": "        return: (osid.assessment.authoring.SequenceRule) - the new\n                ``SequenceRule``", 
               "error_doc": "        raise:  IllegalState - ``sequence_rule_form`` already used in a\n                create transaction\n        raise:  InvalidArgument - one or more of the form elements is\n                invalid\n        raise:  NullArgument - ``sequence_rule_form`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        raise:  Unsupported - ``sequence_rule_form`` did not originate\n                from ``get_sequence_rule_form_for_create()``", 
               "sphinx_param_doc": "        :param sequence_rule_form: the form for this ``SequenceRule``\n        :type sequence_rule_form: ``osid.assessment.authoring.SequenceRuleForm``\n", 
               "sphinx_return_doc": "        :return: the new ``SequenceRule``\n        :rtype: ``osid.assessment.authoring.SequenceRule``", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- ``sequence_rule_form`` already used in a create transaction\n        :raise: ``InvalidArgument`` -- one or more of the form elements is invalid\n        :raise: ``NullArgument`` -- ``sequence_rule_form`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure\n        :raise: ``Unsupported`` -- ``sequence_rule_form`` did not originate from ``get_sequence_rule_form_for_create()``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.assessment.authoring.SequenceRuleForm", 
                     "var_name": "sequence_rule_form", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.assessment.authoring.SequenceRuleForm"
               ], 
               "return_type": "osid.assessment.authoring.SequenceRule", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract", 
                  "INVALID_ARGUMENT": "ConsumerContract", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }, 
            {
               "name": "can_update_sequence_rules", 
               "doc": {
                  "headline": "Tests if this user can update sequence rules.", 
                  "body": "        A return of true does not guarantee successful authorization. A\n        return of false indicates that it is known updating a\n        ``SequenceRule`` will result in a ``PermissionDenied``. This is\n        intended as a hint to an application that may opt not to offer\n        update operations to an unauthorized user."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``false`` if ``SequenceRule`` modification\n                is not authorized, ``true`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``false`` if ``SequenceRule`` modification is not authorized, ``true`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "get_sequence_rule_form_for_update", 
               "doc": {
                  "headline": "Gets the sequence rule form for updating an existing sequence rule.", 
                  "body": "        A new sequence rule form should be requested for each update\n        transaction."
               }, 
               "arg_doc": "        arg:    sequence_rule_id (osid.id.Id): the ``Id`` of the\n                ``SequenceRule``\n", 
               "return_doc": "        return: (osid.assessment.authoring.SequenceRuleForm) - the\n                sequence rule form", 
               "error_doc": "        raise:  NotFound - ``sequence_rule_id`` is not found\n        raise:  NullArgument - ``sequence_rule_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param sequence_rule_id: the ``Id`` of the ``SequenceRule``\n        :type sequence_rule_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: the sequence rule form\n        :rtype: ``osid.assessment.authoring.SequenceRuleForm``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``sequence_rule_id`` is not found\n        :raise: ``NullArgument`` -- ``sequence_rule_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "sequence_rule_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "osid.assessment.authoring.SequenceRuleForm", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "update_sequence_rule", 
               "doc": {
                  "headline": "Updates an existing sequence rule.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    sequence_rule_form\n                (osid.assessment.authoring.SequenceRuleForm): the form\n                containing the elements to be updated\n", 
               "return_doc": "", 
               "error_doc": "        raise:  IllegalState - ``sequence_rule_form`` already used in an\n                update transaction\n        raise:  InvalidArgument - the form contains an invalid value\n        raise:  NullArgument - ``sequence_rule_form`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        raise:  Unsupported - ``sequence_rule_form`` did not originate\n                from ``get_sequence_rule_form_for_update()``", 
               "sphinx_param_doc": "        :param sequence_rule_form: the form containing the elements to be updated\n        :type sequence_rule_form: ``osid.assessment.authoring.SequenceRuleForm``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- ``sequence_rule_form`` already used in an update transaction\n        :raise: ``InvalidArgument`` -- the form contains an invalid value\n        :raise: ``NullArgument`` -- ``sequence_rule_form`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure\n        :raise: ``Unsupported`` -- ``sequence_rule_form`` did not originate from ``get_sequence_rule_form_for_update()``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.assessment.authoring.SequenceRuleForm", 
                     "var_name": "sequence_rule_form", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.assessment.authoring.SequenceRuleForm"
               ], 
               "return_type": "", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract", 
                  "INVALID_ARGUMENT": "ConsumerContract", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }, 
            {
               "name": "can_delete_sequence_rules", 
               "doc": {
                  "headline": "Tests if this user can delete sequence rules.", 
                  "body": "        A return of true does not guarantee successful authorization. A\n        return of false indicates that it is known deleting a\n        ``SequenceRule`` will result in a ``PermissionDenied``. This is\n        intended as a hint to an application that may opt not to offer\n        delete operations to an unauthorized user."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``false`` if ``SequenceRule`` deletion is\n                not authorized, ``true`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``false`` if ``SequenceRule`` deletion is not authorized, ``true`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "delete_sequence_rule", 
               "doc": {
                  "headline": "Deletes a ``SequenceRule``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    sequence_rule_id (osid.id.Id): the ``Id`` of the\n                ``SequenceRule`` to remove\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NotFound - ``sequence_rule_id`` not found\n        raise:  NullArgument - ``sequence_rule_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param sequence_rule_id: the ``Id`` of the ``SequenceRule`` to remove\n        :type sequence_rule_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``sequence_rule_id`` not found\n        :raise: ``NullArgument`` -- ``sequence_rule_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "sequence_rule_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "can_manage_sequence_rule_aliases", 
               "doc": {
                  "headline": "Tests if this user can manage ``Id`` aliases for sequence rules.", 
                  "body": "        A return of true does not guarantee successful authorization. A\n        return of false indicates that it is known changing an alias\n        will result in a ``PermissionDenied``. This is intended as a\n        hint to an application that may opt not to offer alias\n        operations to an unauthorized user."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``false`` if ``SequenceRule`` aliasing is\n                not authorized, ``true`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``false`` if ``SequenceRule`` aliasing is not authorized, ``true`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "alias_sequence_rule", 
               "doc": {
                  "headline": "Adds a ``Id`` to a ``SequenceRule`` for the purpose of creating compatibility.", 
                  "body": "        The primary ``Id`` of the ``SequenceRule`` is determined by the\n        provider. The new ``Id`` performs as an alias to the primary\n        ``Id`` . If the alias is a pointer to another sequence rule. it\n        is reassigned to the given sequence rule ``Id``."
               }, 
               "arg_doc": "        arg:    sequence_rule_id (osid.id.Id): the ``Id`` of a\n                ``SequenceRule``\n        arg:    alias_id (osid.id.Id): the alias ``Id``\n", 
               "return_doc": "", 
               "error_doc": "        raise:  AlreadyExists - ``alias_id`` is already assigned\n        raise:  NotFound - ``sequence_rule_id`` not found\n        raise:  NullArgument - ``sequence_rule_id`` or ``alias_id`` is\n                ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param sequence_rule_id: the ``Id`` of a ``SequenceRule``\n        :type sequence_rule_id: ``osid.id.Id``\n        :param alias_id: the alias ``Id``\n        :type alias_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``AlreadyExists`` -- ``alias_id`` is already assigned\n        :raise: ``NotFound`` -- ``sequence_rule_id`` not found\n        :raise: ``NullArgument`` -- ``sequence_rule_id`` or ``alias_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "sequence_rule_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "alias_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {
                  "ALREADY_EXISTS": "User", 
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "can_sequence_sequence_rules", 
               "doc": {
                  "headline": "Tests if this user can order ``SequenceRules``.", 
                  "body": "        A return of true does not guarantee successful authorization. A\n        return of false indicates that it is known sequencing operations\n        will result in a ``PermissionDenied``. This is intended as a\n        hint to an application that may opt not to offer sequencing\n        operations to an unauthorized user."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``false`` if ``SequenceRule`` ordering is\n                not authorized, ``true`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``false`` if ``SequenceRule`` ordering is not authorized, ``true`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "move_sequence_rule_ahead", 
               "doc": {
                  "headline": "Reorders sequence rule for a source assessment part by moving the specified sequence rule in front of a reference sequence rule.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    sequence_rule_id (osid.id.Id): the ``Id`` of a\n                ``SequenceRule``\n        arg:    assessment_part_id (osid.id.Id): the ``Id`` of an\n                ``AssessmentPart``\n        arg:    reference_id (osid.id.Id): the reference sequence rule\n                ``Id``\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NotFound - ``sequence_rule_id, assessment_part_id,`` or\n                ``reference_id`` not found or, ``sequence_rule_id`` or\n                ``reference_id`` not related to ``assessment_part_id``\n        raise:  NullArgument - ``sequence_rule_id, assessment_part_id,``\n                or ``reference_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param sequence_rule_id: the ``Id`` of a ``SequenceRule``\n        :type sequence_rule_id: ``osid.id.Id``\n        :param assessment_part_id: the ``Id`` of an ``AssessmentPart``\n        :type assessment_part_id: ``osid.id.Id``\n        :param reference_id: the reference sequence rule ``Id``\n        :type reference_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``sequence_rule_id, assessment_part_id,`` or ``reference_id`` not found or, ``sequence_rule_id`` or ``reference_id`` not related to ``assessment_part_id``\n        :raise: ``NullArgument`` -- ``sequence_rule_id, assessment_part_id,`` or ``reference_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "sequence_rule_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "assessment_part_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "reference_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "osid.id.Id", 
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "move_sequence_rule_behind", 
               "doc": {
                  "headline": "Reorders sequence rule for a source assessment part by moving the specified sequence rule behind a reference sequence rule.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    sequence_rule_id (osid.id.Id): the ``Id`` of a\n                ``SequenceRule``\n        arg:    assessment_part_id (osid.id.Id): the ``Id`` of an\n                ``AssessmentPart``\n        arg:    reference_id (osid.id.Id): the reference sequence rule\n                ``Id``\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NotFound - ``sequence_rule_id, assessment_part_id,`` or\n                ``reference_id`` not found or, ``sequence_rule_id`` or\n                ``reference_id`` not related to ``assessment_part_id``\n        raise:  NullArgument - ``sequence_rule_id, assessment_part_id,``\n                or ``reference_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param sequence_rule_id: the ``Id`` of a ``SequenceRule``\n        :type sequence_rule_id: ``osid.id.Id``\n        :param assessment_part_id: the ``Id`` of an ``AssessmentPart``\n        :type assessment_part_id: ``osid.id.Id``\n        :param reference_id: the reference sequence rule ``Id``\n        :type reference_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``sequence_rule_id, assessment_part_id,`` or ``reference_id`` not found or, ``sequence_rule_id`` or ``reference_id`` not related to ``assessment_part_id``\n        :raise: ``NullArgument`` -- ``sequence_rule_id, assessment_part_id,`` or ``reference_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "sequence_rule_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "assessment_part_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "reference_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "osid.id.Id", 
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "order_sequence_rules", 
               "doc": {
                  "headline": "Reorders a set of sequence rules for an assessment part.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    sequence_rule_ids (osid.id.Id[]): the ``Ids`` for a set\n                of ``SequenceRules``\n        arg:    assessment_part_id (osid.id.Id): the ``Id`` of an\n                ``AssessmentPart``\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NotFound - ``assessment_part_id`` not found or, a\n                ``sequence_rule_id`` not related to\n                ``assessment_part_id``\n        raise:  NullArgument - ``sequence_rule_ids`` or\n                ``assessment_part_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param sequence_rule_ids: the ``Ids`` for a set of ``SequenceRules``\n        :type sequence_rule_ids: ``osid.id.Id[]``\n        :param assessment_part_id: the ``Id`` of an ``AssessmentPart``\n        :type assessment_part_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``assessment_part_id`` not found or, a ``sequence_rule_id`` not related to ``assessment_part_id``\n        :raise: ``NullArgument`` -- ``sequence_rule_ids`` or ``assessment_part_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id[]", 
                     "var_name": "sequence_rule_ids", 
                     "array": true
                  }, 
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "assessment_part_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id[]", 
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.assessment.authoring.SequenceRuleNotificationSession", 
         "shortname": "SequenceRuleNotificationSession", 
         "category": "sessions", 
         "doc": {
            "headline": "This session defines methods to receive notifications on adds/changes to ``SequenceRule`` objects in this ``Bank``.", 
            "body": "    This also includes existing ``SequenceRules`` that may appear or\n    disappear due to changes in the ``Bank`` hierarchy, This session is\n    intended for consumers needing to synchronize their state with this\n    service without the use of polling. Notifications are cancelled when\n    this session is closed.\n\n    The two views defined in this session correspond to the views in the\n    ``SequenceRuleLookupSession``."
         }, 
         "inherit_fullnames": [
            "osid.OsidSession"
         ], 
         "inherit_shortnames": [
            "OsidSession"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidSession"
            }
         ], 
         "method_names": [
            "get_bank_id", 
            "get_bank", 
            "can_register_for_sequence_rule_notifications", 
            "use_federated_bank_view", 
            "use_isolated_bank_view", 
            "register_for_new_sequence_rules", 
            "register_for_new_sequence_rules_for_assessment_part", 
            "register_for_new_sequence_rules_for_next_assessment_part", 
            "register_for_changed_sequence_rules", 
            "register_for_changed_sequence_rules_for_assessment_part", 
            "register_for_changed_sequence_rules_for_next_assessment_part", 
            "register_for_changed_sequence_rule", 
            "register_for_deleted_sequence_rules", 
            "register_for_deleted_sequence_rules_for_assessment_part", 
            "register_for_deleted_sequence_rules_for_next_assessment_part", 
            "register_for_deleted_sequence_rule"
         ], 
         "methods": [
            {
               "name": "get_bank_id", 
               "doc": {
                  "headline": "Gets the ``Bank``  ``Id`` associated with this session.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.id.Id) - the ``Bank Id`` associated with this\n                session", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the ``Bank Id`` associated with this session\n        :rtype: ``osid.id.Id``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.id.Id", 
               "errors": {}
            }, 
            {
               "name": "get_bank", 
               "doc": {
                  "headline": "Gets the ``Bank`` associated with this session.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.assessment.Bank) - the bank", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the bank\n        :rtype: ``osid.assessment.Bank``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.assessment.Bank", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "can_register_for_sequence_rule_notifications", 
               "doc": {
                  "headline": "Tests if this user can register for ``SequenceRule`` notifications.", 
                  "body": "        A return of true does not guarantee successful authorization. A\n        return of false indicates that it is known all methods in this\n        session will result in a ``PermissionDenied``. This is intended\n        as a hint to an application that may opt not to offer\n        notification operations."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``false`` if notification methods are not\n                authorized, ``true`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``false`` if notification methods are not authorized, ``true`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "use_federated_bank_view", 
               "doc": {
                  "headline": "Federates the view for methods in this session.", 
                  "body": "        A federated view will include in banks which are children of\n        this bank in the bank hierarchy."
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "use_isolated_bank_view", 
               "doc": {
                  "headline": "Isolates the view for methods in this session.", 
                  "body": "        An isolated view restricts notifications to this bank only."
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "register_for_new_sequence_rules", 
               "doc": {
                  "headline": "Register for notifications of new sequence rules.", 
                  "body": "        ``SequenceRuleReceiver.newSequenceRule()`` is invoked when a new\n        ``SequenceRule`` appears in this bank."
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "register_for_new_sequence_rules_for_assessment_part", 
               "doc": {
                  "headline": "Register for notifications of new sequence rules for the given assessment part.", 
                  "body": "        ``SequenceRuleReceiver.newSequenceRule()`` is invoked when a new\n        ``SequenceRule`` appears in this bank."
               }, 
               "arg_doc": "        arg:    assessment_part_id (osid.id.Id): the ``Id`` of the\n                ``AssessmentPart`` to monitor\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``sequence_rule_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param assessment_part_id: the ``Id`` of the ``AssessmentPart`` to monitor\n        :type assessment_part_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``sequence_rule_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "assessment_part_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "register_for_new_sequence_rules_for_next_assessment_part", 
               "doc": {
                  "headline": "Register for notifications of new sequence rules for the given assessment part.", 
                  "body": "        ``SequenceRuleReceiver.newSequenceRule()`` is invoked when a new\n        ``SequenceRule`` appears in this bank."
               }, 
               "arg_doc": "        arg:    assessment_part_id (osid.id.Id): the ``Id`` of the\n                ``AssessmentPart`` to monitor\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``sequence_rule_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param assessment_part_id: the ``Id`` of the ``AssessmentPart`` to monitor\n        :type assessment_part_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``sequence_rule_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "assessment_part_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "register_for_changed_sequence_rules", 
               "doc": {
                  "headline": "Registers for notification of updated sequence rules.", 
                  "body": "        ``SequenceRuleReceiver.changedSequenceRule()`` is invoked when a\n        sequence rule in this bank is changed."
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "register_for_changed_sequence_rules_for_assessment_part", 
               "doc": {
                  "headline": "Register for notifications of updated sequence rules for the given assessment part.", 
                  "body": "        ``SequenceRuleReceiver.changedSequenceRule()`` is invoked when a\n        new ``SequenceRule`` in this bank is changed."
               }, 
               "arg_doc": "        arg:    assessment_part_id (osid.id.Id): the ``Id`` of the\n                ``AssessmentPart`` to monitor\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``sequence_rule_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param assessment_part_id: the ``Id`` of the ``AssessmentPart`` to monitor\n        :type assessment_part_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``sequence_rule_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "assessment_part_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "register_for_changed_sequence_rules_for_next_assessment_part", 
               "doc": {
                  "headline": "Register for notifications of updated sequence rules for the given assessment part.", 
                  "body": "        ``SequenceRuleReceiver.changedSequenceRule()`` is invoked when a\n        new ``SequenceRule`` in this bank is changed."
               }, 
               "arg_doc": "        arg:    assessment_part_id (osid.id.Id): the ``Id`` of the\n                ``AssessmentPart`` to monitor\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``sequence_rule_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param assessment_part_id: the ``Id`` of the ``AssessmentPart`` to monitor\n        :type assessment_part_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``sequence_rule_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "assessment_part_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "register_for_changed_sequence_rule", 
               "doc": {
                  "headline": "Registers for notification of an updated sequence rule.", 
                  "body": "        ``ProvisionableReceiver.changedSequenceRule()`` is invoked when\n        the specified sequence rule in this bank is changed."
               }, 
               "arg_doc": "        arg:    sequence_rule_id (osid.id.Id): the ``Id`` of the\n                ``SequenceRule`` to monitor\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``sequence_rule_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param sequence_rule_id: the ``Id`` of the ``SequenceRule`` to monitor\n        :type sequence_rule_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``sequence_rule_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "sequence_rule_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "register_for_deleted_sequence_rules", 
               "doc": {
                  "headline": "Registers for notification of deleted sequence rules.", 
                  "body": "        ``SequenceRuleReceiver.deletedSequenceRule()`` is invoked when a\n        sequence rule is deleted or removed from this bank."
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "register_for_deleted_sequence_rules_for_assessment_part", 
               "doc": {
                  "headline": "Registers for notification of deleted sequence rules for the given assessment part.", 
                  "body": "        ``SequenceRuleReceiver.deletedSequenceRule()`` is invoked when a\n        sequence rule is deleted or removed from this bank."
               }, 
               "arg_doc": "        arg:    assessment_part_id (osid.id.Id): the ``Id`` of the\n                ``AssessmentPart`` to monitor\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``sequence_rule_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param assessment_part_id: the ``Id`` of the ``AssessmentPart`` to monitor\n        :type assessment_part_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``sequence_rule_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "assessment_part_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "register_for_deleted_sequence_rules_for_next_assessment_part", 
               "doc": {
                  "headline": "Registers for notification of deleted sequence rules for the given assessment part.", 
                  "body": "        ``SequenceRuleReceiver.deletedSequenceRule()`` is invoked when a\n        sequence rule is deleted or removed from this bank."
               }, 
               "arg_doc": "        arg:    assessment_part_id (osid.id.Id): the ``Id`` of the\n                ``AssessmentPart`` to monitor\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``sequence_rule_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param assessment_part_id: the ``Id`` of the ``AssessmentPart`` to monitor\n        :type assessment_part_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``sequence_rule_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "assessment_part_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "register_for_deleted_sequence_rule", 
               "doc": {
                  "headline": "Registers for notification of a deleted sequence rule.", 
                  "body": "        ``SequenceRuleReceiver.deletedSequenceRule()`` is invoked when\n        the specified sequence rule is deleted or removed from this\n        bank."
               }, 
               "arg_doc": "        arg:    sequence_rule_id (osid.id.Id): the ``Id`` of the\n                ``SequenceRule`` to monitor\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``sequence_rule_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param sequence_rule_id: the ``Id`` of the ``SequenceRule`` to monitor\n        :type sequence_rule_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``sequence_rule_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "sequence_rule_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.assessment.authoring.SequenceRuleBankSession", 
         "shortname": "SequenceRuleBankSession", 
         "category": "sessions", 
         "doc": {
            "headline": "This session provides methods to retrieve ``SequenceRule`` to ``Bank`` mappings.", 
            "body": "    a ``SequenceRule`` may appear in multiple ``Bank`` objects. Each\n    bank may have its own authorizations governing who is allowed to\n    look at it.\n\n    This lookup session defines several views:\n    \n      * comparative view: elements may be silently omitted or re-ordered\n      * plenary view: provides a complete result set or is an error\n        condition\n"
         }, 
         "inherit_fullnames": [
            "osid.OsidSession"
         ], 
         "inherit_shortnames": [
            "OsidSession"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidSession"
            }
         ], 
         "method_names": [
            "can_lookup_sequence_rule_bank_mappings", 
            "use_comparative_sequence_rule_bank_view", 
            "use_plenary_sequence_rule_bank_view", 
            "get_sequence_rule_ids_by_bank", 
            "get_sequence_rules_by_bank", 
            "get_sequence_rule_ids_by_banks", 
            "get_sequence_rules_by_banks", 
            "get_bank_ids_by_sequence_rule", 
            "get_banks_by_sequence_rule"
         ], 
         "methods": [
            {
               "name": "can_lookup_sequence_rule_bank_mappings", 
               "doc": {
                  "headline": "Tests if this user can perform lookups of sequence rule/bank mappings.", 
                  "body": "        A return of true does not guarantee successful authorization. A\n        return of false indicates that it is known lookup methods in\n        this session will result in a ``PermissionDenied``. This is\n        intended as a hint to an application that may opt not to offer\n        lookup operations to unauthorized users."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``false`` if looking up mappings is not\n                authorized, ``true`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``false`` if looking up mappings is not authorized, ``true`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "use_comparative_sequence_rule_bank_view", 
               "doc": {
                  "headline": "The returns from the lookup methods may omit or translate elements based on this session, such as authorization, and not result in an error.", 
                  "body": "        This view is used when greater interoperability is desired at\n        the expense of precision."
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "use_plenary_sequence_rule_bank_view", 
               "doc": {
                  "headline": "A complete view of the ``SequenceRule`` and ``Bank`` returns is desired.", 
                  "body": "        Methods will return what is requested or result in an error.\n        This view is used when greater precision is desired at the\n        expense of interoperability."
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "get_sequence_rule_ids_by_bank", 
               "doc": {
                  "headline": "Gets the list of ``SequenceRuleIds`` associated with a ``Bank``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    bank_id (osid.id.Id): ``Id`` of the ``Bank``\n", 
               "return_doc": "        return: (osid.id.IdList) - list of related sequence rule ``Ids``", 
               "error_doc": "        raise:  NotFound - ``bank_id`` is not found\n        raise:  NullArgument - ``bank_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param bank_id: ``Id`` of the ``Bank``\n        :type bank_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: list of related sequence rule ``Ids``\n        :rtype: ``osid.id.IdList``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``bank_id`` is not found\n        :raise: ``NullArgument`` -- ``bank_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "bank_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "osid.id.IdList", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_sequence_rules_by_bank", 
               "doc": {
                  "headline": "Gets the list of sequence rule associated with a ``Bank``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    bank_id (osid.id.Id): ``Id`` of the ``Bank``\n", 
               "return_doc": "        return: (osid.assessment.authoring.SequenceRuleList) - list of\n                related sequence rules", 
               "error_doc": "        raise:  NotFound - ``bank_id`` is not found\n        raise:  NullArgument - ``bank_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param bank_id: ``Id`` of the ``Bank``\n        :type bank_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: list of related sequence rules\n        :rtype: ``osid.assessment.authoring.SequenceRuleList``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``bank_id`` is not found\n        :raise: ``NullArgument`` -- ``bank_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "bank_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "osid.assessment.authoring.SequenceRuleList", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_sequence_rule_ids_by_banks", 
               "doc": {
                  "headline": "Gets the list of ``SequenceRule Ids`` corresponding to a list of ``Banks``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    bank_ids (osid.id.IdList): list of bank ``Ids``\n", 
               "return_doc": "        return: (osid.id.IdList) - list of sequence rule ``Ids``", 
               "error_doc": "        raise:  NullArgument - ``bank_ids`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param bank_ids: list of bank ``Ids``\n        :type bank_ids: ``osid.id.IdList``\n", 
               "sphinx_return_doc": "        :return: list of sequence rule ``Ids``\n        :rtype: ``osid.id.IdList``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``bank_ids`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.IdList", 
                     "var_name": "bank_ids", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.IdList"
               ], 
               "return_type": "osid.id.IdList", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_sequence_rules_by_banks", 
               "doc": {
                  "headline": "Gets the list of sequence rule corresponding to a list of ``Banks``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    bank_ids (osid.id.IdList): list of bank ``Ids``\n", 
               "return_doc": "        return: (osid.assessment.authoring.SequenceRuleList) - list of\n                sequence rules", 
               "error_doc": "        raise:  NullArgument - ``bank_ids`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param bank_ids: list of bank ``Ids``\n        :type bank_ids: ``osid.id.IdList``\n", 
               "sphinx_return_doc": "        :return: list of sequence rules\n        :rtype: ``osid.assessment.authoring.SequenceRuleList``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``bank_ids`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.IdList", 
                     "var_name": "bank_ids", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.IdList"
               ], 
               "return_type": "osid.assessment.authoring.SequenceRuleList", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_bank_ids_by_sequence_rule", 
               "doc": {
                  "headline": "Gets the ``Bank``  ``Ids`` mapped to a ``SequenceRule``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    sequence_rule_id (osid.id.Id): ``Id`` of a\n                ``SequenceRule``\n", 
               "return_doc": "        return: (osid.id.IdList) - list of banks", 
               "error_doc": "        raise:  NotFound - ``sequence_rule_id`` is not found\n        raise:  NullArgument - ``sequence_rule_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param sequence_rule_id: ``Id`` of a ``SequenceRule``\n        :type sequence_rule_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: list of banks\n        :rtype: ``osid.id.IdList``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``sequence_rule_id`` is not found\n        :raise: ``NullArgument`` -- ``sequence_rule_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "sequence_rule_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "osid.id.IdList", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_banks_by_sequence_rule", 
               "doc": {
                  "headline": "Gets the ``Banks`` mapped to a ``SequenceRule``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    sequence_rule_id (osid.id.Id): ``Id`` of a\n                ``SequenceRule``\n", 
               "return_doc": "        return: (osid.assessment.BankList) - list of banks", 
               "error_doc": "        raise:  NotFound - ``sequence_rule_id`` is not found\n        raise:  NullArgument - ``sequence_rule_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param sequence_rule_id: ``Id`` of a ``SequenceRule``\n        :type sequence_rule_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: list of banks\n        :rtype: ``osid.assessment.BankList``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``sequence_rule_id`` is not found\n        :raise: ``NullArgument`` -- ``sequence_rule_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "sequence_rule_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "osid.assessment.BankList", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.assessment.authoring.SequenceRuleBankAssignmentSession", 
         "shortname": "SequenceRuleBankAssignmentSession", 
         "category": "sessions", 
         "doc": {
            "headline": "This session provides methods to re-assign ``SequenceRule`` to ``Bank`` mappings.", 
            "body": "    a ``SequenceRule`` may appear in multiple ``Bank`` objects and\n    removing the last reference to a ``SequenceRule`` is the equivalent\n    of deleting it. Each ``Bank`` may have its own authorizations\n    governing who is allowed to operate on it.\n\n    Adding a reference of a ``SequenceRule`` to another ``Bank`` is not\n    a copy operation (eg: does not change its ``Id`` )."
         }, 
         "inherit_fullnames": [
            "osid.OsidSession"
         ], 
         "inherit_shortnames": [
            "OsidSession"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidSession"
            }
         ], 
         "method_names": [
            "can_assign_sequence_rules", 
            "can_assign_sequence_rules_to_bank", 
            "get_assignable_bank_ids", 
            "get_assignable_bank_ids_for_sequence_rule", 
            "assign_sequence_rule_to_bank", 
            "unassign_sequence_rule_from_bank"
         ], 
         "methods": [
            {
               "name": "can_assign_sequence_rules", 
               "doc": {
                  "headline": "Tests if this user can alter sequence rule/bank mappings.", 
                  "body": "        A return of true does not guarantee successful authorization. A\n        return of false indicates that it is known mapping methods in\n        this session will result in a ``PermissionDenied``. This is\n        intended as a hint to an application that may opt not to offer\n        lookup operations to unauthorized users."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``false`` if mapping is not authorized,\n                ``true`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``false`` if mapping is not authorized, ``true`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "can_assign_sequence_rules_to_bank", 
               "doc": {
                  "headline": "Tests if this user can alter sequence rule/bank mappings.", 
                  "body": "        A return of true does not guarantee successful authorization. A\n        return of false indicates that it is known mapping methods in\n        this session will result in a ``PermissionDenied``. This is\n        intended as a hint to an application that may opt not to offer\n        lookup operations to unauthorized users."
               }, 
               "arg_doc": "        arg:    bank_id (osid.id.Id): the ``Id`` of the ``Bank``\n", 
               "return_doc": "        return: (boolean) - ``false`` if mapping is not authorized,\n                ``true`` otherwise", 
               "error_doc": "        raise:  NullArgument - ``bank_id`` is ``null``", 
               "sphinx_param_doc": "        :param bank_id: the ``Id`` of the ``Bank``\n        :type bank_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: ``false`` if mapping is not authorized, ``true`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``bank_id`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "bank_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "boolean", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "get_assignable_bank_ids", 
               "doc": {
                  "headline": "Gets a list of bank including and under the given bank node in which any sequence rule can be assigned.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    bank_id (osid.id.Id): the ``Id`` of the ``Bank``\n", 
               "return_doc": "        return: (osid.id.IdList) - list of assignable bank ``Ids``", 
               "error_doc": "        raise:  NullArgument - ``bank_id`` is ``null``\n        raise:  OperationFailed - unable to complete request", 
               "sphinx_param_doc": "        :param bank_id: the ``Id`` of the ``Bank``\n        :type bank_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: list of assignable bank ``Ids``\n        :rtype: ``osid.id.IdList``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``bank_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "bank_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "osid.id.IdList", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational"
               }
            }, 
            {
               "name": "get_assignable_bank_ids_for_sequence_rule", 
               "doc": {
                  "headline": "Gets a list of bank including and under the given bank node in which a specific sequence rule can be assigned.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    bank_id (osid.id.Id): the ``Id`` of the ``Bank``\n        arg:    sequence_rule_id (osid.id.Id): the ``Id`` of the\n                ``SequenceRule``\n", 
               "return_doc": "        return: (osid.id.IdList) - list of assignable bank ``Ids``", 
               "error_doc": "        raise:  NullArgument - ``bank_id`` or ``sequence_rule_id`` is\n                ``null``\n        raise:  OperationFailed - unable to complete request", 
               "sphinx_param_doc": "        :param bank_id: the ``Id`` of the ``Bank``\n        :type bank_id: ``osid.id.Id``\n        :param sequence_rule_id: the ``Id`` of the ``SequenceRule``\n        :type sequence_rule_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: list of assignable bank ``Ids``\n        :rtype: ``osid.id.IdList``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``bank_id`` or ``sequence_rule_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "bank_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "sequence_rule_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "osid.id.Id"
               ], 
               "return_type": "osid.id.IdList", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational"
               }
            }, 
            {
               "name": "assign_sequence_rule_to_bank", 
               "doc": {
                  "headline": "Adds an existing ``SequenceRule`` to a ``Bank``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    sequence_rule_id (osid.id.Id): the ``Id`` of the\n                ``SequenceRule``\n        arg:    bank_id (osid.id.Id): the ``Id`` of the ``Bank``\n", 
               "return_doc": "", 
               "error_doc": "        raise:  AlreadyExists - ``sequence_rule_id`` is already assigned\n                to ``bank_id``\n        raise:  NotFound - ``sequence_rule_id`` or ``bank_id`` not found\n        raise:  NullArgument - ``sequence_rule_id`` or ``bank_id`` is\n                ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param sequence_rule_id: the ``Id`` of the ``SequenceRule``\n        :type sequence_rule_id: ``osid.id.Id``\n        :param bank_id: the ``Id`` of the ``Bank``\n        :type bank_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``AlreadyExists`` -- ``sequence_rule_id`` is already assigned to ``bank_id``\n        :raise: ``NotFound`` -- ``sequence_rule_id`` or ``bank_id`` not found\n        :raise: ``NullArgument`` -- ``sequence_rule_id`` or ``bank_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "sequence_rule_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "bank_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {
                  "ALREADY_EXISTS": "User", 
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "unassign_sequence_rule_from_bank", 
               "doc": {
                  "headline": "Removes a ``SequenceRule`` from a ``Bank``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    sequence_rule_id (osid.id.Id): the ``Id`` of the\n                ``SequenceRule``\n        arg:    bank_id (osid.id.Id): the ``Id`` of the ``Bank``\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NotFound - ``sequence_rule_id`` or ``bank_id`` not found\n                or ``sequence_rule_id`` not assigned to ``bank_id``\n        raise:  NullArgument - ``sequence_rule_id`` or ``bank_id`` is\n                ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param sequence_rule_id: the ``Id`` of the ``SequenceRule``\n        :type sequence_rule_id: ``osid.id.Id``\n        :param bank_id: the ``Id`` of the ``Bank``\n        :type bank_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``sequence_rule_id`` or ``bank_id`` not found or ``sequence_rule_id`` not assigned to ``bank_id``\n        :raise: ``NullArgument`` -- ``sequence_rule_id`` or ``bank_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "sequence_rule_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "bank_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.assessment.authoring.SequenceRuleSmartBankSession", 
         "shortname": "SequenceRuleSmartBankSession", 
         "category": "sessions", 
         "doc": {
            "headline": "This session manages queries and sequencing to create \"smart\" dynamic bank.", 
            "body": "    a ``SequenceRuleQuery`` can be retrieved from this session and\n    mapped to this ``Bank`` to create a virtual collection of sequence\n    rules. The sequence rule may be sequenced using the\n    ``SequenceRuleSearchOrder`` from this session.\n\n    This ``Bank`` has a default query that matches any sequence rule and\n    a default search order that specifies no sequencing. The queries may\n    be examined using a ``SequenceRuleQueryInspector``. The query may be\n    modified by converting the inspector back to a\n    ``SequenceRuleQuery``."
         }, 
         "inherit_fullnames": [
            "osid.OsidSession"
         ], 
         "inherit_shortnames": [
            "OsidSession"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidSession"
            }
         ], 
         "method_names": [
            "get_bank_id", 
            "get_bank", 
            "can_manage_smart_banks", 
            "get_sequence_rule_query", 
            "get_sequence_rule_search_order", 
            "apply_sequence_rule_query", 
            "inspect_sequence_rule_query", 
            "apply_sequence_rule_sequencing", 
            "get_sequence_rule_query_from_inspector"
         ], 
         "methods": [
            {
               "name": "get_bank_id", 
               "doc": {
                  "headline": "Gets the ``Bank``  ``Id`` associated with this session.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.id.Id) - the ``Bank Id`` associated with this\n                session", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the ``Bank Id`` associated with this session\n        :rtype: ``osid.id.Id``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.id.Id", 
               "errors": {}
            }, 
            {
               "name": "get_bank", 
               "doc": {
                  "headline": "Gets the ``Bank`` associated with this session.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.assessment.Bank) - the bank", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the bank\n        :rtype: ``osid.assessment.Bank``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.assessment.Bank", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "can_manage_smart_banks", 
               "doc": {
                  "headline": "Tests if this user can manage smart bank.", 
                  "body": "        A return of true does not guarantee successful authorization. A\n        return of false indicates that it is known methods in this\n        session will result in a ``PermissionDenied``. This is intended\n        as a hint to an application that may opt not to offer operations\n        to unauthorized users."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``false`` if smart bank management is not\n                authorized, ``true`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``false`` if smart bank management is not authorized, ``true`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "get_sequence_rule_query", 
               "doc": {
                  "headline": "Gets a sequence rule query.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.assessment.authoring.SequenceRuleQuery) - the\n                sequence rule query", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the sequence rule query\n        :rtype: ``osid.assessment.authoring.SequenceRuleQuery``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.assessment.authoring.SequenceRuleQuery", 
               "errors": {}
            }, 
            {
               "name": "get_sequence_rule_search_order", 
               "doc": {
                  "headline": "Gets a sequence rule search order.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.assessment.authoring.SequenceRuleSearchOrder) -\n                the sequence rule search order", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the sequence rule search order\n        :rtype: ``osid.assessment.authoring.SequenceRuleSearchOrder``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.assessment.authoring.SequenceRuleSearchOrder", 
               "errors": {}
            }, 
            {
               "name": "apply_sequence_rule_query", 
               "doc": {
                  "headline": "Applies a sequence rule query to this bank.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    sequence_rule_query\n                (osid.assessment.authoring.SequenceRuleQuery): the\n                sequence rule query\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``sequence_rule_query`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure occurred\n        raise:  Unsupported - ``sequence_rule_query`` not of this\n                service", 
               "sphinx_param_doc": "        :param sequence_rule_query: the sequence rule query\n        :type sequence_rule_query: ``osid.assessment.authoring.SequenceRuleQuery``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``sequence_rule_query`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure occurred\n        :raise: ``Unsupported`` -- ``sequence_rule_query`` not of this service", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.assessment.authoring.SequenceRuleQuery", 
                     "var_name": "sequence_rule_query", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.assessment.authoring.SequenceRuleQuery"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }, 
            {
               "name": "inspect_sequence_rule_query", 
               "doc": {
                  "headline": "Gets a sequence rule query inspector for this bank.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.assessment.authoring.SequenceRuleQueryInspector) -\n                the sequence rule query inspector", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure occurred", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the sequence rule query inspector\n        :rtype: ``osid.assessment.authoring.SequenceRuleQueryInspector``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure occurred", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.assessment.authoring.SequenceRuleQueryInspector", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "apply_sequence_rule_sequencing", 
               "doc": {
                  "headline": "Applies a sequence rule search order to this bank.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    sequence_rule_search_order\n                (osid.assessment.authoring.SequenceRuleSearchOrder): the\n                sequence rule search order\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``sequence_rule_search_order`` is\n                ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure occurred\n        raise:  Unsupported - ``sequence_rule_search_order`` not of this\n                service", 
               "sphinx_param_doc": "        :param sequence_rule_search_order: the sequence rule search order\n        :type sequence_rule_search_order: ``osid.assessment.authoring.SequenceRuleSearchOrder``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``sequence_rule_search_order`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure occurred\n        :raise: ``Unsupported`` -- ``sequence_rule_search_order`` not of this service", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.assessment.authoring.SequenceRuleSearchOrder", 
                     "var_name": "sequence_rule_search_order", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.assessment.authoring.SequenceRuleSearchOrder"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_sequence_rule_query_from_inspector", 
               "doc": {
                  "headline": "Gets a sequence rule query from an inspector.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    sequence_rule_query_inspector\n                (osid.assessment.authoring.SequenceRuleQueryInspector):\n                a sequence rule query inspector\n", 
               "return_doc": "        return: (osid.assessment.authoring.SequenceRuleQuery) - the\n                sequence rule query", 
               "error_doc": "        raise:  NullArgument - ``sequence_rule_query_inspector`` is\n                ``null``\n        raise:  Unsupported - ``sequence_rule_query_inspector`` is not\n                of this service", 
               "sphinx_param_doc": "        :param sequence_rule_query_inspector: a sequence rule query inspector\n        :type sequence_rule_query_inspector: ``osid.assessment.authoring.SequenceRuleQueryInspector``\n", 
               "sphinx_return_doc": "        :return: the sequence rule query\n        :rtype: ``osid.assessment.authoring.SequenceRuleQuery``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``sequence_rule_query_inspector`` is ``null``\n        :raise: ``Unsupported`` -- ``sequence_rule_query_inspector`` is not of this service", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.assessment.authoring.SequenceRuleQueryInspector", 
                     "var_name": "sequence_rule_query_inspector", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.assessment.authoring.SequenceRuleQueryInspector"
               ], 
               "return_type": "osid.assessment.authoring.SequenceRuleQuery", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.assessment.authoring.SequenceRuleEnablerLookupSession", 
         "shortname": "SequenceRuleEnablerLookupSession", 
         "category": "sessions", 
         "doc": {
            "headline": "This session provides methods for retrieving ``SequenceRuleEnablers``.", 
            "body": ""
         }, 
         "inherit_fullnames": [
            "osid.OsidSession"
         ], 
         "inherit_shortnames": [
            "OsidSession"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidSession"
            }
         ], 
         "method_names": [
            "get_bank_id", 
            "get_bank", 
            "can_lookup_sequence_rule_enablers", 
            "use_comparative_sequence_rule_enabler_view", 
            "use_plenary_sequence_rule_enabler_view", 
            "use_federated_bank_view", 
            "use_isolated_bank_view", 
            "use_active_sequence_rule_enabler_view", 
            "use_any_status_sequence_rule_enabler_view", 
            "get_sequence_rule_enabler", 
            "get_sequence_rule_enablers_by_ids", 
            "get_sequence_rule_enablers_by_genus_type", 
            "get_sequence_rule_enablers_by_parent_genus_type", 
            "get_sequence_rule_enablers_by_record_type", 
            "get_sequence_rule_enablers_on_date", 
            "get_sequence_rule_enablers_on_date_with_agent", 
            "get_sequence_rule_enablers"
         ], 
         "methods": [
            {
               "name": "get_bank_id", 
               "doc": {
                  "headline": "Gets the ``Bank``  ``Id`` associated with this session.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.id.Id) - the ``Bank Id`` associated with this\n                session", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the ``Bank Id`` associated with this session\n        :rtype: ``osid.id.Id``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.id.Id", 
               "errors": {}
            }, 
            {
               "name": "get_bank", 
               "doc": {
                  "headline": "Gets the ``Bank`` associated with this session.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.assessment.Bank) - the bank", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the bank\n        :rtype: ``osid.assessment.Bank``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.assessment.Bank", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "can_lookup_sequence_rule_enablers", 
               "doc": {
                  "headline": "Tests if this user can perform ``SequenceRuleEnablers`` lookups.", 
                  "body": "        A return of true does not guarantee successful authorization. A\n        return of false indicates that it is known all methods in this\n        session will result in a ``PermissionDenied``. This is intended\n        as a hint to an application that may opt not to offer lookup\n        operations to unauthorized users."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``false`` if lookup methods are not\n                authorized, ``true`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``false`` if lookup methods are not authorized, ``true`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "use_comparative_sequence_rule_enabler_view", 
               "doc": {
                  "headline": "The returns from the lookup methods may omit or translate elements based on this session, such as authorization, and not result in an error.", 
                  "body": "        This view is used when greater interoperability is desired at\n        the expense of precision."
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "use_plenary_sequence_rule_enabler_view", 
               "doc": {
                  "headline": "A complete view of the ``SequenceRuleEnabler`` returns is desired.", 
                  "body": "        Methods will return what is requested or result in an error.\n        This view is used when greater precision is desired at the\n        expense of interoperability."
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "use_federated_bank_view", 
               "doc": {
                  "headline": "Federates the view for methods in this session.", 
                  "body": "        A federated view will include sequence rule enablers in banks\n        which are children of this bank in the bank hierarchy."
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "use_isolated_bank_view", 
               "doc": {
                  "headline": "Isolates the view for methods in this session.", 
                  "body": "        An isolated view restricts lookups to this bank only."
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "use_active_sequence_rule_enabler_view", 
               "doc": {
                  "headline": "Only active sequence rule enablers are returned by methods in this session.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "use_any_status_sequence_rule_enabler_view", 
               "doc": {
                  "headline": "All active and inactive sequence rule enablers are returned by methods in this session.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "get_sequence_rule_enabler", 
               "doc": {
                  "headline": "Gets the ``SequenceRuleEnabler`` specified by its ``Id``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    sequence_rule_enabler_id (osid.id.Id): ``Id`` of the\n                ``SequenceRuleEnabler``\n", 
               "return_doc": "        return: (osid.assessment.authoring.SequenceRuleEnabler) - the\n                sequence rule enabler", 
               "error_doc": "        raise:  NotFound - ``sequence_rule_enabler_id`` not found\n        raise:  NullArgument - ``sequence_rule_enabler_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param sequence_rule_enabler_id: ``Id`` of the ``SequenceRuleEnabler``\n        :type sequence_rule_enabler_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: the sequence rule enabler\n        :rtype: ``osid.assessment.authoring.SequenceRuleEnabler``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``sequence_rule_enabler_id`` not found\n        :raise: ``NullArgument`` -- ``sequence_rule_enabler_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "sequence_rule_enabler_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "osid.assessment.authoring.SequenceRuleEnabler", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_sequence_rule_enablers_by_ids", 
               "doc": {
                  "headline": "Gets a ``SequenceRuleEnablerList`` corresponding to the given ``IdList``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    sequence_rule_enabler_ids (osid.id.IdList): the list of\n                ``Ids`` to retrieve\n", 
               "return_doc": "        return: (osid.assessment.authoring.SequenceRuleEnablerList) -\n                the returned ``SequenceRuleEnabler`` list", 
               "error_doc": "        raise:  NotFound - a ``Id was`` not found\n        raise:  NullArgument - ``sequence_rule_enabler_ids`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param sequence_rule_enabler_ids: the list of ``Ids`` to retrieve\n        :type sequence_rule_enabler_ids: ``osid.id.IdList``\n", 
               "sphinx_return_doc": "        :return: the returned ``SequenceRuleEnabler`` list\n        :rtype: ``osid.assessment.authoring.SequenceRuleEnablerList``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- a ``Id was`` not found\n        :raise: ``NullArgument`` -- ``sequence_rule_enabler_ids`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.IdList", 
                     "var_name": "sequence_rule_enabler_ids", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.IdList"
               ], 
               "return_type": "osid.assessment.authoring.SequenceRuleEnablerList", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_sequence_rule_enablers_by_genus_type", 
               "doc": {
                  "headline": "Gets a ``SequenceRuleEnablerList`` corresponding to the given sequence rule enabler genus ``Type`` which does not include sequence rule enablers of genus types derived from the specified ``Type``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    sequence_rule_enabler_genus_type (osid.type.Type): a\n                sequence rule enabler genus type\n", 
               "return_doc": "        return: (osid.assessment.authoring.SequenceRuleEnablerList) -\n                the returned ``SequenceRuleEnabler`` list", 
               "error_doc": "        raise:  NullArgument - ``sequence_rule_enabler_genus_type`` is\n                ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param sequence_rule_enabler_genus_type: a sequence rule enabler genus type\n        :type sequence_rule_enabler_genus_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "        :return: the returned ``SequenceRuleEnabler`` list\n        :rtype: ``osid.assessment.authoring.SequenceRuleEnablerList``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``sequence_rule_enabler_genus_type`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "sequence_rule_enabler_genus_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "osid.assessment.authoring.SequenceRuleEnablerList", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_sequence_rule_enablers_by_parent_genus_type", 
               "doc": {
                  "headline": "Gets a ``SequenceRuleEnablerList`` corresponding to the given sequence rule enabler genus ``Type`` and include any additional sequence rule enablers with genus types derived from the specified ``Type``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    sequence_rule_enabler_genus_type (osid.type.Type): a\n                sequence rule enabler genus type\n", 
               "return_doc": "        return: (osid.assessment.authoring.SequenceRuleEnablerList) -\n                the returned ``SequenceRuleEnabler`` list", 
               "error_doc": "        raise:  NullArgument - ``sequence_rule_enabler_genus_type`` is\n                ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param sequence_rule_enabler_genus_type: a sequence rule enabler genus type\n        :type sequence_rule_enabler_genus_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "        :return: the returned ``SequenceRuleEnabler`` list\n        :rtype: ``osid.assessment.authoring.SequenceRuleEnablerList``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``sequence_rule_enabler_genus_type`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "sequence_rule_enabler_genus_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "osid.assessment.authoring.SequenceRuleEnablerList", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_sequence_rule_enablers_by_record_type", 
               "doc": {
                  "headline": "Gets a ``SequenceRuleEnablerList`` containing the given sequence rule enabler record ``Type``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    sequence_rule_enabler_record_type (osid.type.Type): a\n                sequence rule enabler record type\n", 
               "return_doc": "        return: (osid.assessment.authoring.SequenceRuleEnablerList) -\n                the returned ``SequenceRuleEnabler`` list", 
               "error_doc": "        raise:  NullArgument - ``sequence_rule_enabler_record_type`` is\n                ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param sequence_rule_enabler_record_type: a sequence rule enabler record type\n        :type sequence_rule_enabler_record_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "        :return: the returned ``SequenceRuleEnabler`` list\n        :rtype: ``osid.assessment.authoring.SequenceRuleEnablerList``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``sequence_rule_enabler_record_type`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "sequence_rule_enabler_record_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "osid.assessment.authoring.SequenceRuleEnablerList", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_sequence_rule_enablers_on_date", 
               "doc": {
                  "headline": "Gets a ``SequenceRuleEnablerList`` that are effective for the entire given date range inclusive but not confined to the date range for any agent.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    from (osid.calendaring.DateTime): a start date\n        arg:    to (osid.calendaring.DateTime): an end date\n", 
               "return_doc": "        return: (osid.assessment.authoring.SequenceRuleEnablerList) -\n                the returned ``SequenceRuleEnabler`` list", 
               "error_doc": "        raise:  InvalidArgument - ``from`` is greater tha ``to``\n        raise:  NullArgument - ``from`` or ``to`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param from: a start date\n        :type from: ``osid.calendaring.DateTime``\n        :param to: an end date\n        :type to: ``osid.calendaring.DateTime``\n", 
               "sphinx_return_doc": "        :return: the returned ``SequenceRuleEnabler`` list\n        :rtype: ``osid.assessment.authoring.SequenceRuleEnablerList``", 
               "sphinx_error_doc": "        :raise: ``InvalidArgument`` -- ``from`` is greater tha ``to``\n        :raise: ``NullArgument`` -- ``from`` or ``to`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.calendaring.DateTime", 
                     "var_name": "from_", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.calendaring.DateTime", 
                     "var_name": "to", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.calendaring.DateTime", 
                  "osid.calendaring.DateTime"
               ], 
               "return_type": "osid.assessment.authoring.SequenceRuleEnablerList", 
               "errors": {
                  "INVALID_ARGUMENT": "ConsumerContract", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_sequence_rule_enablers_on_date_with_agent", 
               "doc": {
                  "headline": "Gets a ``SequenceRuleEnablerList`` that are effective for the entire given date range inclusive but not confined to the date range and evaluated against the given agent.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    agent_id (osid.id.Id): an agent ``Id``\n        arg:    from (osid.calendaring.DateTime): a start date\n        arg:    to (osid.calendaring.DateTime): an end date\n", 
               "return_doc": "        return: (osid.assessment.authoring.SequenceRuleEnablerList) -\n                the returned ``SequenceRuleEnabler`` list", 
               "error_doc": "        raise:  InvalidArgument - ``from`` is greater tha ``to``\n        raise:  NullArgument - ``agent_id, from,`` or ``to`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param agent_id: an agent ``Id``\n        :type agent_id: ``osid.id.Id``\n        :param from: a start date\n        :type from: ``osid.calendaring.DateTime``\n        :param to: an end date\n        :type to: ``osid.calendaring.DateTime``\n", 
               "sphinx_return_doc": "        :return: the returned ``SequenceRuleEnabler`` list\n        :rtype: ``osid.assessment.authoring.SequenceRuleEnablerList``", 
               "sphinx_error_doc": "        :raise: ``InvalidArgument`` -- ``from`` is greater tha ``to``\n        :raise: ``NullArgument`` -- ``agent_id, from,`` or ``to`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "agent_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.calendaring.DateTime", 
                     "var_name": "from_", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.calendaring.DateTime", 
                     "var_name": "to", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "osid.calendaring.DateTime", 
                  "osid.calendaring.DateTime"
               ], 
               "return_type": "osid.assessment.authoring.SequenceRuleEnablerList", 
               "errors": {
                  "INVALID_ARGUMENT": "ConsumerContract", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_sequence_rule_enablers", 
               "doc": {
                  "headline": "Gets all ``SequenceRuleEnablers``.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.assessment.authoring.SequenceRuleEnablerList) -\n                the returned ``SequenceRuleEnabler`` list", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the returned ``SequenceRuleEnabler`` list\n        :rtype: ``osid.assessment.authoring.SequenceRuleEnablerList``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.assessment.authoring.SequenceRuleEnablerList", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.assessment.authoring.SequenceRuleEnablerQuerySession", 
         "shortname": "SequenceRuleEnablerQuerySession", 
         "category": "sessions", 
         "doc": {
            "headline": "This session provides methods for searching among ``SequenceRuleEnabler`` objects.", 
            "body": "    The search query is constructed using the\n    ``SequenceRuleEnablerQuery``.\n\n    This session defines views that offer differing behaviors for\n    searching.\n    \n      * federated bank view: searches include sequence rule enablers in\n        bank of which this bank is an ancestor in the bank hierarchy\n      * isolated bank view: searches are restricted to sequence rule\n        enablers in this bank\n\n    \n    sequence rule enablers may have a query record indicated by their\n    respective record types. The query record is accessed via the\n    ``SequenceRuleEnablerQuery``."
         }, 
         "inherit_fullnames": [
            "osid.OsidSession"
         ], 
         "inherit_shortnames": [
            "OsidSession"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidSession"
            }
         ], 
         "method_names": [
            "get_bank_id", 
            "get_bank", 
            "can_search_sequence_rule_enablers", 
            "use_federated_bank_view", 
            "use_isolated_bank_view", 
            "get_sequence_rule_enabler_query", 
            "get_sequence_rule_enablers_by_query"
         ], 
         "methods": [
            {
               "name": "get_bank_id", 
               "doc": {
                  "headline": "Gets the ``Bank``  ``Id`` associated with this session.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.id.Id) - the ``Bank Id`` associated with this\n                session", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the ``Bank Id`` associated with this session\n        :rtype: ``osid.id.Id``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.id.Id", 
               "errors": {}
            }, 
            {
               "name": "get_bank", 
               "doc": {
                  "headline": "Gets the ``Bank`` associated with this session.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.assessment.Bank) - the bank", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the bank\n        :rtype: ``osid.assessment.Bank``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.assessment.Bank", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "can_search_sequence_rule_enablers", 
               "doc": {
                  "headline": "Tests if this user can perform ``SequenceRuleEnabler`` lookups.", 
                  "body": "        A return of true does not guarantee successful authorization. A\n        return of false indicates that it is known all methods in this\n        session will result in a ``PermissionDenied``. This is intended\n        as a hint to an application that may not offer lookup operations\n        to unauthorized users."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``false`` if search methods are not\n                authorized, ``true`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``false`` if search methods are not authorized, ``true`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "use_federated_bank_view", 
               "doc": {
                  "headline": "Federates the view for methods in this session.", 
                  "body": "        A federated view will include sequence rule enablers in banks\n        which are children of this step in the bank hierarchy."
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "use_isolated_bank_view", 
               "doc": {
                  "headline": "Isolates the view for methods in this session.", 
                  "body": "        An isolated view restricts lookups to this bank only."
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "get_sequence_rule_enabler_query", 
               "doc": {
                  "headline": "Gets a sequence rule enabler query.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.assessment.authoring.SequenceRuleEnablerQuery) -\n                the sequence rule enabler query", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the sequence rule enabler query\n        :rtype: ``osid.assessment.authoring.SequenceRuleEnablerQuery``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.assessment.authoring.SequenceRuleEnablerQuery", 
               "errors": {}
            }, 
            {
               "name": "get_sequence_rule_enablers_by_query", 
               "doc": {
                  "headline": "Gets a list of ``SequenceRuleEnablers`` matching the given sequence rule enabler query.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    sequence_rule_enabler_query\n                (osid.assessment.authoring.SequenceRuleEnablerQuery):\n                the sesequence rule enabler query\n", 
               "return_doc": "        return: (osid.assessment.authoring.SequenceRuleEnablerList) -\n                the returned ``SequenceRuleEnablerList``", 
               "error_doc": "        raise:  NullArgument - ``sequence_rule_enabler_query`` is\n                ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        raise:  Unsupported - ``sequence_rule_enabler_query`` is not of\n                this service", 
               "sphinx_param_doc": "        :param sequence_rule_enabler_query: the sesequence rule enabler query\n        :type sequence_rule_enabler_query: ``osid.assessment.authoring.SequenceRuleEnablerQuery``\n", 
               "sphinx_return_doc": "        :return: the returned ``SequenceRuleEnablerList``\n        :rtype: ``osid.assessment.authoring.SequenceRuleEnablerList``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``sequence_rule_enabler_query`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure\n        :raise: ``Unsupported`` -- ``sequence_rule_enabler_query`` is not of this service", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.assessment.authoring.SequenceRuleEnablerQuery", 
                     "var_name": "sequence_rule_enabler_query", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.assessment.authoring.SequenceRuleEnablerQuery"
               ], 
               "return_type": "osid.assessment.authoring.SequenceRuleEnablerList", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.assessment.authoring.SequenceRuleEnablerSearchSession", 
         "shortname": "SequenceRuleEnablerSearchSession", 
         "category": "sessions", 
         "doc": {
            "headline": "This session provides methods for searching among ``SequenceRuleEnabler`` objects.", 
            "body": "    The search query is constructed using the\n    ``SequenceRuleEnableryQuery``.\n\n    ``get_sequence_rule_enablers_by_query()`` is the basic search method\n    and returns a list of ``SequenceRuleEnablers``. A more advanced\n    search may be performed with ``getSequenceRuleEnablersBySearch()``.\n    It accepts a ``SequenceRuleEnablerSearch`` in addition to the query\n    for the purpose of specifying additional options affecting the\n    entire search, such as workflow.\n    ``get_sequence_rule_enablers_by_search()`` returns a\n    ``SequenceRuleEnablerSearchResults`` that can be used to access the\n    resulting ``SequenceRuleEnablerList`` or be used to perform a search\n    within the result set through ``SequenceRuleEnablerSearch``.\n    \n    This session defines views that offer differing behaviors for\n    searching.\n    \n      * federated bank view: searches include sequence rule enablers in\n        bank of which this bank is an ancestor in the bank hierarchy\n      * isolated bank view: searches are restricted to sequence rule\n        enablers in this bank\n\n    \n    ``SequenceRuleEnablers`` may have a query record indicated by their\n    respective record types. The query record is accessed via the\n    ``SequenceRuleEnablerQuery``."
         }, 
         "inherit_fullnames": [
            "osid.assessment.authoring.SequenceRuleEnablerQuerySession"
         ], 
         "inherit_shortnames": [
            "SequenceRuleEnablerQuerySession"
         ], 
         "inherit_pkg_names": [
            "authoring"
         ], 
         "inheritance": [
            {
               "pkg_name": "assessment.authoring", 
               "name": "SequenceRuleEnablerQuerySession"
            }
         ], 
         "method_names": [
            "get_sequence_rule_enabler_search", 
            "get_sequence_rule_enabler_search_order", 
            "get_sequence_rule_enablers_by_search", 
            "get_sequence_rule_enabler_query_from_inspector"
         ], 
         "methods": [
            {
               "name": "get_sequence_rule_enabler_search", 
               "doc": {
                  "headline": "Gets a sequence rule enabler search.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.assessment.authoring.SequenceRuleEnablerSearch) -\n                the sequence rule enabler search", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the sequence rule enabler search\n        :rtype: ``osid.assessment.authoring.SequenceRuleEnablerSearch``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.assessment.authoring.SequenceRuleEnablerSearch", 
               "errors": {}
            }, 
            {
               "name": "get_sequence_rule_enabler_search_order", 
               "doc": {
                  "headline": "Gets a sequence rule enabler search order.", 
                  "body": "        The ``SequenceRuleEnablerSearchOrder`` is supplied to a\n        ``SequenceRuleEnablerSearch`` to specify the ordering of\n        results."
               }, 
               "arg_doc": "", 
               "return_doc": "        return:\n                (osid.assessment.authoring.SequenceRuleEnablerSearchOrde\n                r) - the sequence rule enabler search order", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the sequence rule enabler search order\n        :rtype: ``osid.assessment.authoring.SequenceRuleEnablerSearchOrder``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.assessment.authoring.SequenceRuleEnablerSearchOrder", 
               "errors": {}
            }, 
            {
               "name": "get_sequence_rule_enablers_by_search", 
               "doc": {
                  "headline": "Gets the search results matching the given search query using the given search.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    sequence_rule_enabler_query\n                (osid.assessment.authoring.SequenceRuleEnablerQuery):\n                the sequence rule enabler query\n        arg:    sequence_rule_enabler_search\n                (osid.assessment.authoring.SequenceRuleEnablerSearch):\n                the sequence rule enabler search\n", 
               "return_doc": "        return:\n                (osid.assessment.authoring.SequenceRuleEnablerSearchResu\n                lts) - the returned search results", 
               "error_doc": "        raise:  NullArgument - ``sequence_rule_enabler_query`` or\n                ``sequence_rule_enabler_search`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        raise:  Unsupported - ``sequence_rule_enabler_query`` or\n                ``sequence_rule_enabler_search`` is not of this service", 
               "sphinx_param_doc": "        :param sequence_rule_enabler_query: the sequence rule enabler query\n        :type sequence_rule_enabler_query: ``osid.assessment.authoring.SequenceRuleEnablerQuery``\n        :param sequence_rule_enabler_search: the sequence rule enabler search\n        :type sequence_rule_enabler_search: ``osid.assessment.authoring.SequenceRuleEnablerSearch``\n", 
               "sphinx_return_doc": "        :return: the returned search results\n        :rtype: ``osid.assessment.authoring.SequenceRuleEnablerSearchResults``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``sequence_rule_enabler_query`` or ``sequence_rule_enabler_search`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure\n        :raise: ``Unsupported`` -- ``sequence_rule_enabler_query`` or ``sequence_rule_enabler_search`` is not of this service", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.assessment.authoring.SequenceRuleEnablerQuery", 
                     "var_name": "sequence_rule_enabler_query", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.assessment.authoring.SequenceRuleEnablerSearch", 
                     "var_name": "sequence_rule_enabler_search", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.assessment.authoring.SequenceRuleEnablerQuery", 
                  "osid.assessment.authoring.SequenceRuleEnablerSearch"
               ], 
               "return_type": "osid.assessment.authoring.SequenceRuleEnablerSearchResults", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_sequence_rule_enabler_query_from_inspector", 
               "doc": {
                  "headline": "Gets a sequence rule enabler query from an inspector.", 
                  "body": "        The inspector is available from a\n        ``SequenceRuleEnablerSearchResults``."
               }, 
               "arg_doc": "        arg:    sequence_rule_enabler_query_inspector\n                (osid.assessment.authoring.SequenceRuleEnablerQueryInspe\n                ctor): a sequence rule enabler query inspector\n", 
               "return_doc": "        return: (osid.assessment.authoring.SequenceRuleEnablerQuery) -\n                the sequence rule enabler query", 
               "error_doc": "        raise:  NullArgument - ``sequence_rule_enabler_query_inspector``\n                is ``null``\n        raise:  Unsupported - ``sequence_rule_enabler_query_inspector``\n                is not of this service", 
               "sphinx_param_doc": "        :param sequence_rule_enabler_query_inspector: a sequence rule enabler query inspector\n        :type sequence_rule_enabler_query_inspector: ``osid.assessment.authoring.SequenceRuleEnablerQueryInspector``\n", 
               "sphinx_return_doc": "        :return: the sequence rule enabler query\n        :rtype: ``osid.assessment.authoring.SequenceRuleEnablerQuery``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``sequence_rule_enabler_query_inspector`` is ``null``\n        :raise: ``Unsupported`` -- ``sequence_rule_enabler_query_inspector`` is not of this service", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.assessment.authoring.SequenceRuleEnablerQueryInspector", 
                     "var_name": "sequence_rule_enabler_query_inspector", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.assessment.authoring.SequenceRuleEnablerQueryInspector"
               ], 
               "return_type": "osid.assessment.authoring.SequenceRuleEnablerQuery", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.assessment.authoring.SequenceRuleEnablerAdminSession", 
         "shortname": "SequenceRuleEnablerAdminSession", 
         "category": "sessions", 
         "doc": {
            "headline": "This session creates and removes sequence rule enablers.", 
            "body": "    The data for create and update is provided via the\n    ``SequenceRuleEnablerForm``."
         }, 
         "inherit_fullnames": [
            "osid.OsidSession"
         ], 
         "inherit_shortnames": [
            "OsidSession"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidSession"
            }
         ], 
         "method_names": [
            "get_bank_id", 
            "get_bank", 
            "can_create_sequence_rule_enabler", 
            "can_create_sequence_rule_enabler_with_record_types", 
            "get_sequence_rule_enabler_form_for_create", 
            "create_sequence_rule_enabler", 
            "can_update_sequence_rule_enablers", 
            "get_sequence_rule_enabler_form_for_update", 
            "update_sequence_rule_enabler", 
            "can_delete_sequence_rule_enablers", 
            "delete_sequence_rule_enabler", 
            "can_manage_sequence_rule_enabler_aliases", 
            "alias_sequence_rule_enabler"
         ], 
         "methods": [
            {
               "name": "get_bank_id", 
               "doc": {
                  "headline": "Gets the ``Bank``  ``Id`` associated with this session.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.id.Id) - the ``Bank Id`` associated with this\n                session", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the ``Bank Id`` associated with this session\n        :rtype: ``osid.id.Id``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.id.Id", 
               "errors": {}
            }, 
            {
               "name": "get_bank", 
               "doc": {
                  "headline": "Gets the ``Bank`` associated with this session.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.assessment.Bank) - the bank", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the bank\n        :rtype: ``osid.assessment.Bank``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.assessment.Bank", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "can_create_sequence_rule_enabler", 
               "doc": {
                  "headline": "Tests if this user can create sequence rule enablers.", 
                  "body": "        A return of true does not guarantee successful authorization. A\n        return of false indicates that it is known creating a\n        ``SequenceRuleEnabler`` will result in a ``PermissionDenied``.\n        This is intended as a hint to an application that may opt not to\n        offer create operations to an unauthorized user."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``false`` if ``SequenceRuleEnabler``\n                creation is not authorized, ``true`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``false`` if ``SequenceRuleEnabler`` creation is not authorized, ``true`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "can_create_sequence_rule_enabler_with_record_types", 
               "doc": {
                  "headline": "Tests if this user can create a single ``SequenceRuleEnabler`` using the desired record types.", 
                  "body": "        While ``AssessmentAuthoringManag\n        er.getSequenceRuleEnablerRecordTypes()`` can be used to examine\n        which records are supported, this method tests which record(s)\n        are required for creating a specific ``SequenceRuleEnabler``.\n        Providing an empty array tests if a ``SequenceRuleEnabler`` can\n        be created with no records."
               }, 
               "arg_doc": "        arg:    sequence_rule_enabler_record_types (osid.type.Type[]):\n                array of sequence rule enabler record types\n", 
               "return_doc": "        return: (boolean) - ``true`` if ``SequenceRuleEnabler`` creation\n                using the specified record ``Types`` is supported,\n                ``false`` otherwise", 
               "error_doc": "        raise:  NullArgument - ``sequence_rule_enabler_record_types`` is\n                ``null``", 
               "sphinx_param_doc": "        :param sequence_rule_enabler_record_types: array of sequence rule enabler record types\n        :type sequence_rule_enabler_record_types: ``osid.type.Type[]``\n", 
               "sphinx_return_doc": "        :return: ``true`` if ``SequenceRuleEnabler`` creation using the specified record ``Types`` is supported, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``sequence_rule_enabler_record_types`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type[]", 
                     "var_name": "sequence_rule_enabler_record_types", 
                     "array": true
                  }
               ], 
               "arg_types": [
                  "osid.type.Type[]"
               ], 
               "return_type": "boolean", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "get_sequence_rule_enabler_form_for_create", 
               "doc": {
                  "headline": "Gets the sequence rule enabler form for creating new sequence rule enablers.", 
                  "body": "        A new form should be requested for each create transaction."
               }, 
               "arg_doc": "        arg:    sequence_rule_enabler_record_types (osid.type.Type[]):\n                array of sequence rule enabler record types\n", 
               "return_doc": "        return: (osid.assessment.authoring.SequenceRuleEnablerForm) -\n                the sequence rule enabler form", 
               "error_doc": "        raise:  NullArgument - ``sequence_rule_enabler_record_types`` is\n                ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        raise:  Unsupported - unable to get form for requested record\n                types", 
               "sphinx_param_doc": "        :param sequence_rule_enabler_record_types: array of sequence rule enabler record types\n        :type sequence_rule_enabler_record_types: ``osid.type.Type[]``\n", 
               "sphinx_return_doc": "        :return: the sequence rule enabler form\n        :rtype: ``osid.assessment.authoring.SequenceRuleEnablerForm``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``sequence_rule_enabler_record_types`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure\n        :raise: ``Unsupported`` -- unable to get form for requested record types", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type[]", 
                     "var_name": "sequence_rule_enabler_record_types", 
                     "array": true
                  }
               ], 
               "arg_types": [
                  "osid.type.Type[]"
               ], 
               "return_type": "osid.assessment.authoring.SequenceRuleEnablerForm", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }, 
            {
               "name": "create_sequence_rule_enabler", 
               "doc": {
                  "headline": "Creates a new ``SequenceRuleEnabler``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    sequence_rule_enabler_form\n                (osid.assessment.authoring.SequenceRuleEnablerForm): the\n                form for this ``SequenceRuleEnabler``\n", 
               "return_doc": "        return: (osid.assessment.authoring.SequenceRuleEnabler) - the\n                new ``SequenceRuleEnabler``", 
               "error_doc": "        raise:  IllegalState - ``sequence_rule_enabler_form`` already\n                used in a create transaction\n        raise:  InvalidArgument - one or more of the form elements is\n                invalid\n        raise:  NullArgument - ``sequence_rule_enabler_form`` is\n                ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        raise:  Unsupported - ``sequence_rule_enabler_form`` did not\n                originate from\n                ``get_sequence_rule_enabler_form_for_create()``", 
               "sphinx_param_doc": "        :param sequence_rule_enabler_form: the form for this ``SequenceRuleEnabler``\n        :type sequence_rule_enabler_form: ``osid.assessment.authoring.SequenceRuleEnablerForm``\n", 
               "sphinx_return_doc": "        :return: the new ``SequenceRuleEnabler``\n        :rtype: ``osid.assessment.authoring.SequenceRuleEnabler``", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- ``sequence_rule_enabler_form`` already used in a create transaction\n        :raise: ``InvalidArgument`` -- one or more of the form elements is invalid\n        :raise: ``NullArgument`` -- ``sequence_rule_enabler_form`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure\n        :raise: ``Unsupported`` -- ``sequence_rule_enabler_form`` did not originate from ``get_sequence_rule_enabler_form_for_create()``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.assessment.authoring.SequenceRuleEnablerForm", 
                     "var_name": "sequence_rule_enabler_form", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.assessment.authoring.SequenceRuleEnablerForm"
               ], 
               "return_type": "osid.assessment.authoring.SequenceRuleEnabler", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract", 
                  "INVALID_ARGUMENT": "ConsumerContract", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }, 
            {
               "name": "can_update_sequence_rule_enablers", 
               "doc": {
                  "headline": "Tests if this user can update sequence rule enablers.", 
                  "body": "        A return of true does not guarantee successful authorization. A\n        return of false indicates that it is known updating a\n        ``SequenceRuleEnabler`` will result in a ``PermissionDenied``.\n        This is intended as a hint to an application that may opt not to\n        offer update operations to an unauthorized user."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``false`` if ``SequenceRuleEnabler``\n                modification is not authorized, ``true`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``false`` if ``SequenceRuleEnabler`` modification is not authorized, ``true`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "get_sequence_rule_enabler_form_for_update", 
               "doc": {
                  "headline": "Gets the sequence rule enabler form for updating an existing sequence rule enabler.", 
                  "body": "        A new sequence rule enabler form should be requested for each\n        update transaction."
               }, 
               "arg_doc": "        arg:    sequence_rule_enabler_id (osid.id.Id): the ``Id`` of the\n                ``SequenceRuleEnabler``\n", 
               "return_doc": "        return: (osid.assessment.authoring.SequenceRuleEnablerForm) -\n                the sequence rule enabler form", 
               "error_doc": "        raise:  NotFound - ``sequence_rule_enabler_id`` is not found\n        raise:  NullArgument - ``sequence_rule_enabler_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param sequence_rule_enabler_id: the ``Id`` of the ``SequenceRuleEnabler``\n        :type sequence_rule_enabler_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: the sequence rule enabler form\n        :rtype: ``osid.assessment.authoring.SequenceRuleEnablerForm``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``sequence_rule_enabler_id`` is not found\n        :raise: ``NullArgument`` -- ``sequence_rule_enabler_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "sequence_rule_enabler_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "osid.assessment.authoring.SequenceRuleEnablerForm", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "update_sequence_rule_enabler", 
               "doc": {
                  "headline": "Updates an existing sequence rule enabler.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    sequence_rule_enabler_form\n                (osid.assessment.authoring.SequenceRuleEnablerForm): the\n                form containing the elements to be updated\n", 
               "return_doc": "", 
               "error_doc": "        raise:  IllegalState - ``sequence_rule_enabler_form`` already\n                used in an update transaction\n        raise:  InvalidArgument - the form contains an invalid value\n        raise:  NullArgument - ``sequence_rule_enabler_form`` is\n                ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        raise:  Unsupported - ``sequence_rule_enabler_form`` did not\n                originate from\n                ``get_sequence_rule_enabler_form_for_update()``", 
               "sphinx_param_doc": "        :param sequence_rule_enabler_form: the form containing the elements to be updated\n        :type sequence_rule_enabler_form: ``osid.assessment.authoring.SequenceRuleEnablerForm``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- ``sequence_rule_enabler_form`` already used in an update transaction\n        :raise: ``InvalidArgument`` -- the form contains an invalid value\n        :raise: ``NullArgument`` -- ``sequence_rule_enabler_form`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure\n        :raise: ``Unsupported`` -- ``sequence_rule_enabler_form`` did not originate from ``get_sequence_rule_enabler_form_for_update()``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.assessment.authoring.SequenceRuleEnablerForm", 
                     "var_name": "sequence_rule_enabler_form", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.assessment.authoring.SequenceRuleEnablerForm"
               ], 
               "return_type": "", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract", 
                  "INVALID_ARGUMENT": "ConsumerContract", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }, 
            {
               "name": "can_delete_sequence_rule_enablers", 
               "doc": {
                  "headline": "Tests if this user can delete sequence rule enablers.", 
                  "body": "        A return of true does not guarantee successful authorization. A\n        return of false indicates that it is known deleting a\n        ``SequenceRuleEnabler`` will result in a ``PermissionDenied``.\n        This is intended as a hint to an application that may opt not to\n        offer delete operations to an unauthorized user."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``false`` if ``SequenceRuleEnabler``\n                deletion is not authorized, ``true`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``false`` if ``SequenceRuleEnabler`` deletion is not authorized, ``true`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "delete_sequence_rule_enabler", 
               "doc": {
                  "headline": "Deletes a ``SequenceRuleEnabler``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    sequence_rule_enabler_id (osid.id.Id): the ``Id`` of the\n                ``SequenceRuleEnabler`` to remove\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NotFound - ``sequence_rule_enabler_id`` not found\n        raise:  NullArgument - ``sequence_rule_enabler_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param sequence_rule_enabler_id: the ``Id`` of the ``SequenceRuleEnabler`` to remove\n        :type sequence_rule_enabler_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``sequence_rule_enabler_id`` not found\n        :raise: ``NullArgument`` -- ``sequence_rule_enabler_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "sequence_rule_enabler_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "can_manage_sequence_rule_enabler_aliases", 
               "doc": {
                  "headline": "Tests if this user can manage ``Id`` aliases for sequence rule enablers.", 
                  "body": "        A return of true does not guarantee successful authorization. A\n        return of false indicates that it is known changing an alias\n        will result in a ``PermissionDenied``. This is intended as a\n        hint to an application that may opt not to offer alias\n        operations to an unauthorized user."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``false`` if ``SequenceRuleEnabler``\n                aliasing is not authorized, ``true`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``false`` if ``SequenceRuleEnabler`` aliasing is not authorized, ``true`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "alias_sequence_rule_enabler", 
               "doc": {
                  "headline": "Adds a ``Id`` to a ``SequenceRuleEnabler`` for the purpose of creating compatibility.", 
                  "body": "        The primary ``Id`` of the ``SequenceRuleEnabler`` is determined\n        by the provider. The new ``Id`` performs as an alias to the\n        primary ``Id`` . If the alias is a pointer to another sequence\n        rule enabler. it is reassigned to the given sequence rule\n        enabler ``Id``."
               }, 
               "arg_doc": "        arg:    sequence_rule_enabler_id (osid.id.Id): the ``Id`` of a\n                ``SequenceRuleEnabler``\n        arg:    alias_id (osid.id.Id): the alias ``Id``\n", 
               "return_doc": "", 
               "error_doc": "        raise:  AlreadyExists - ``alias_id`` is already assigned\n        raise:  NotFound - ``sequence_rule_enabler_id`` not found\n        raise:  NullArgument - ``sequence_rule_enabler_id`` or\n                ``alias_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param sequence_rule_enabler_id: the ``Id`` of a ``SequenceRuleEnabler``\n        :type sequence_rule_enabler_id: ``osid.id.Id``\n        :param alias_id: the alias ``Id``\n        :type alias_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``AlreadyExists`` -- ``alias_id`` is already assigned\n        :raise: ``NotFound`` -- ``sequence_rule_enabler_id`` not found\n        :raise: ``NullArgument`` -- ``sequence_rule_enabler_id`` or ``alias_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "sequence_rule_enabler_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "alias_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {
                  "ALREADY_EXISTS": "User", 
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.assessment.authoring.SequenceRuleEnablerNotificationSession", 
         "shortname": "SequenceRuleEnablerNotificationSession", 
         "category": "sessions", 
         "doc": {
            "headline": "This session defines methods to receive notifications on adds/changes to ``SequenceRuleEnabler`` objects in this ``Bank``.", 
            "body": "    This also includes existing ``SequenceRuleEnablers`` that may appear\n    or disappear due to changes in the ``Bank`` hierarchy, This session\n    is intended for consumers needing to synchronize their state with\n    this service without the use of polling. Notifications are cancelled\n    when this session is closed.\n\n    The two views defined in this session correspond to the views in the\n    ``SequenceRuleEnablerLookupSession``."
         }, 
         "inherit_fullnames": [
            "osid.OsidSession"
         ], 
         "inherit_shortnames": [
            "OsidSession"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidSession"
            }
         ], 
         "method_names": [
            "get_bank_id", 
            "get_bank", 
            "can_register_for_sequence_rule_enabler_notifications", 
            "use_federated_bank_view", 
            "use_isolated_bank_view", 
            "register_for_new_sequence_rule_enablers", 
            "register_for_changed_sequence_rule_enablers", 
            "register_for_changed_sequence_rule_enabler", 
            "register_for_deleted_sequence_rule_enablers", 
            "register_for_deleted_sequence_rule_enabler"
         ], 
         "methods": [
            {
               "name": "get_bank_id", 
               "doc": {
                  "headline": "Gets the ``Bank``  ``Id`` associated with this session.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.id.Id) - the ``Bank Id`` associated with this\n                session", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the ``Bank Id`` associated with this session\n        :rtype: ``osid.id.Id``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.id.Id", 
               "errors": {}
            }, 
            {
               "name": "get_bank", 
               "doc": {
                  "headline": "Gets the ``Bank`` associated with this session.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.assessment.Bank) - the bank", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the bank\n        :rtype: ``osid.assessment.Bank``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.assessment.Bank", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "can_register_for_sequence_rule_enabler_notifications", 
               "doc": {
                  "headline": "Tests if this user can register for ``SequenceRuleEnabler`` notifications.", 
                  "body": "        A return of true does not guarantee successful authorization. A\n        return of false indicates that it is known all methods in this\n        session will result in a ``PermissionDenied``. This is intended\n        as a hint to an application that may opt not to offer\n        notification operations."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``false`` if notification methods are not\n                authorized, ``true`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``false`` if notification methods are not authorized, ``true`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "use_federated_bank_view", 
               "doc": {
                  "headline": "Federates the view for methods in this session.", 
                  "body": "        A federated view will include enablers in banks which are\n        children of this bank in the bank hierarchy."
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "use_isolated_bank_view", 
               "doc": {
                  "headline": "Isolates the view for methods in this session.", 
                  "body": "        An isolated view restricts notifications to this bank only."
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "register_for_new_sequence_rule_enablers", 
               "doc": {
                  "headline": "Register for notifications of new sequence rule enablers.", 
                  "body": "        ``SequenceRuleEnablerReceiver.newSequenceRuleEnabler()`` is\n        invoked when a new ``SequenceRuleEnabler`` appears in this bank."
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "register_for_changed_sequence_rule_enablers", 
               "doc": {
                  "headline": "Registers for notification of updated bank enabelrs.", 
                  "body": "        ``SequenceRuleEnablerReceiver.changedSequenceRuleEnabler()`` is\n        invoked when a sequence rule enabler in this bank is changed."
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "register_for_changed_sequence_rule_enabler", 
               "doc": {
                  "headline": "Registers for notification of an updated sequence rule enabler.", 
                  "body": "        ``ProvisionableReceiver.changedSequenceRuleEnabler()`` is\n        invoked when the specified sequence rule enabler in this bank is\n        changed."
               }, 
               "arg_doc": "        arg:    sequence_rule_enabler_id (osid.id.Id): the ``Id`` of the\n                ``SequenceRuleEnabler`` to monitor\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``sequence_rule_enabler_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param sequence_rule_enabler_id: the ``Id`` of the ``SequenceRuleEnabler`` to monitor\n        :type sequence_rule_enabler_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``sequence_rule_enabler_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "sequence_rule_enabler_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "register_for_deleted_sequence_rule_enablers", 
               "doc": {
                  "headline": "Registers for notification of deleted sequence rule enablers.", 
                  "body": "        ``SequenceRuleEnablerReceiver.deletedSequenceRuleEnabler()`` is\n        invoked when a sequence rule enabler is deleted or removed from\n        this bank."
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "register_for_deleted_sequence_rule_enabler", 
               "doc": {
                  "headline": "Registers for notification of a deleted sequence rule enabler.", 
                  "body": "        ``SequenceRuleEnablerReceiver.deletedSequenceRuleEnabler()`` is\n        invoked when the specified sequence rule enabler is deleted or\n        removed from this bank."
               }, 
               "arg_doc": "        arg:    sequence_rule_enabler_id (osid.id.Id): the ``Id`` of the\n                ``SequenceRuleEnabler`` to monitor\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``sequence_rule_enabler_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param sequence_rule_enabler_id: the ``Id`` of the ``SequenceRuleEnabler`` to monitor\n        :type sequence_rule_enabler_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``sequence_rule_enabler_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "sequence_rule_enabler_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.assessment.authoring.SequenceRuleEnablerBankSession", 
         "shortname": "SequenceRuleEnablerBankSession", 
         "category": "sessions", 
         "doc": {
            "headline": "This session provides methods to retrieve ``SequenceRuleEnabler`` to ``Bank`` mappings.", 
            "body": "    a ``SequenceRuleEnabler`` may appear in multiple ``Bank`` objects.\n    Each bank may have its own authorizations governing who is allowed\n    to look at it.\n\n    This lookup session defines several views:\n    \n      * comparative view: elements may be silently omitted or re-ordered\n      * plenary view: provides a complete result set or is an error\n        condition\n"
         }, 
         "inherit_fullnames": [
            "osid.OsidSession"
         ], 
         "inherit_shortnames": [
            "OsidSession"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidSession"
            }
         ], 
         "method_names": [
            "can_lookup_sequence_rule_enabler_bank_mappings", 
            "use_comparative_sequence_rule_enabler_bank_view", 
            "use_plenary_sequence_rule_enabler_bank_view", 
            "get_sequence_rule_enabler_ids_by_bank", 
            "get_sequence_rule_enablers_by_bank", 
            "get_sequence_rule_enabler_ids_by_banks", 
            "get_sequence_rule_enablers_by_banks", 
            "get_bank_ids_by_sequence_rule_enabler", 
            "get_banks_by_sequence_rule_enabler"
         ], 
         "methods": [
            {
               "name": "can_lookup_sequence_rule_enabler_bank_mappings", 
               "doc": {
                  "headline": "Tests if this user can perform lookups of sequence rule enabler/bank mappings.", 
                  "body": "        A return of true does not guarantee successful authorization. A\n        return of false indicates that it is known lookup methods in\n        this session will result in a ``PermissionDenied``. This is\n        intended as a hint to an application that may opt not to offer\n        lookup operations to unauthorized users."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``false`` if looking up mappings is not\n                authorized, ``true`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``false`` if looking up mappings is not authorized, ``true`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "use_comparative_sequence_rule_enabler_bank_view", 
               "doc": {
                  "headline": "The returns from the lookup methods may omit or translate elements based on this session, such as authorization, and not result in an error.", 
                  "body": "        This view is used when greater interoperability is desired at\n        the expense of precision."
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "use_plenary_sequence_rule_enabler_bank_view", 
               "doc": {
                  "headline": "A complete view of the ``SequenceRuleEnabler`` and ``Bank`` returns is desired.", 
                  "body": "        Methods will return what is requested or result in an error.\n        This view is used when greater precision is desired at the\n        expense of interoperability."
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "get_sequence_rule_enabler_ids_by_bank", 
               "doc": {
                  "headline": "Gets the list of ``SequenceRuleEnablerIds`` associated with an ``Bank``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    bank_id (osid.id.Id): ``Id`` of the ``Bank``\n", 
               "return_doc": "        return: (osid.id.IdList) - list of related sequence rule enabler\n                ``Ids``", 
               "error_doc": "        raise:  NotFound - ``bank_id`` is not found\n        raise:  NullArgument - ``bank_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param bank_id: ``Id`` of the ``Bank``\n        :type bank_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: list of related sequence rule enabler ``Ids``\n        :rtype: ``osid.id.IdList``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``bank_id`` is not found\n        :raise: ``NullArgument`` -- ``bank_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "bank_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "osid.id.IdList", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_sequence_rule_enablers_by_bank", 
               "doc": {
                  "headline": "Gets the list of sequence rule enablers associated with an ``Bank``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    bank_id (osid.id.Id): ``Id`` of the ``Bank``\n", 
               "return_doc": "        return: (osid.assessment.authoring.SequenceRuleEnablerList) -\n                list of related sequence rule enablers", 
               "error_doc": "        raise:  NotFound - ``bank_id`` is not found\n        raise:  NullArgument - ``bank_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param bank_id: ``Id`` of the ``Bank``\n        :type bank_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: list of related sequence rule enablers\n        :rtype: ``osid.assessment.authoring.SequenceRuleEnablerList``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``bank_id`` is not found\n        :raise: ``NullArgument`` -- ``bank_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "bank_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "osid.assessment.authoring.SequenceRuleEnablerList", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_sequence_rule_enabler_ids_by_banks", 
               "doc": {
                  "headline": "Gets the list of ``SequenceRuleEnabler Ids`` corresponding to a list of ``Banks``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    bank_ids (osid.id.IdList): list of bank ``Ids``\n", 
               "return_doc": "        return: (osid.id.IdList) - list of sequence rule enabler ``Ids``", 
               "error_doc": "        raise:  NullArgument - ``bank_ids`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param bank_ids: list of bank ``Ids``\n        :type bank_ids: ``osid.id.IdList``\n", 
               "sphinx_return_doc": "        :return: list of sequence rule enabler ``Ids``\n        :rtype: ``osid.id.IdList``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``bank_ids`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.IdList", 
                     "var_name": "bank_ids", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.IdList"
               ], 
               "return_type": "osid.id.IdList", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_sequence_rule_enablers_by_banks", 
               "doc": {
                  "headline": "Gets the list of sequence rule enablers corresponding to a list of ``Banks``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    bank_ids (osid.id.IdList): list of bank ``Ids``\n", 
               "return_doc": "        return: (osid.assessment.authoring.SequenceRuleEnablerList) -\n                list of sequence rule enablers", 
               "error_doc": "        raise:  NullArgument - ``bank_ids`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param bank_ids: list of bank ``Ids``\n        :type bank_ids: ``osid.id.IdList``\n", 
               "sphinx_return_doc": "        :return: list of sequence rule enablers\n        :rtype: ``osid.assessment.authoring.SequenceRuleEnablerList``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``bank_ids`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.IdList", 
                     "var_name": "bank_ids", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.IdList"
               ], 
               "return_type": "osid.assessment.authoring.SequenceRuleEnablerList", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_bank_ids_by_sequence_rule_enabler", 
               "doc": {
                  "headline": "Gets the ``Bank``  ``Ids`` mapped to a ``SequenceRuleEnabler``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    sequence_rule_enabler_id (osid.id.Id): ``Id`` of a\n                ``SequenceRuleEnabler``\n", 
               "return_doc": "        return: (osid.id.IdList) - list of banks", 
               "error_doc": "        raise:  NotFound - ``sequence_rule_enabler_id`` is not found\n        raise:  NullArgument - ``sequence_rule_enabler_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param sequence_rule_enabler_id: ``Id`` of a ``SequenceRuleEnabler``\n        :type sequence_rule_enabler_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: list of banks\n        :rtype: ``osid.id.IdList``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``sequence_rule_enabler_id`` is not found\n        :raise: ``NullArgument`` -- ``sequence_rule_enabler_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "sequence_rule_enabler_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "osid.id.IdList", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_banks_by_sequence_rule_enabler", 
               "doc": {
                  "headline": "Gets the ``Banks`` mapped to a ``SequenceRuleEnabler``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    sequence_rule_enabler_id (osid.id.Id): ``Id`` of a\n                ``SequenceRuleEnabler``\n", 
               "return_doc": "        return: (osid.assessment.BankList) - list of banks", 
               "error_doc": "        raise:  NotFound - ``sequence_rule_enabler_id`` is not found\n        raise:  NullArgument - ``sequence_rule_enabler_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param sequence_rule_enabler_id: ``Id`` of a ``SequenceRuleEnabler``\n        :type sequence_rule_enabler_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: list of banks\n        :rtype: ``osid.assessment.BankList``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``sequence_rule_enabler_id`` is not found\n        :raise: ``NullArgument`` -- ``sequence_rule_enabler_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "sequence_rule_enabler_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "osid.assessment.BankList", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.assessment.authoring.SequenceRuleEnablerBankAssignmentSession", 
         "shortname": "SequenceRuleEnablerBankAssignmentSession", 
         "category": "sessions", 
         "doc": {
            "headline": "This session provides methods to re-assign ``SequenceRuleEnabler`` to ``Bank`` mappings.", 
            "body": "    a ``SequenceRuleEnabler`` may appear in multiple ``Bank`` objects\n    and removing the last reference to a ``SequenceRuleEnabler`` is the\n    equivalent of deleting it. Each ``Bank`` may have its own\n    authorizations governing who is allowed to operate on it.\n\n    Adding a reference of a ``SequenceRuleEnabler`` to another ``Bank``\n    is not a copy operation (eg: does not change its ``Id`` )."
         }, 
         "inherit_fullnames": [
            "osid.OsidSession"
         ], 
         "inherit_shortnames": [
            "OsidSession"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidSession"
            }
         ], 
         "method_names": [
            "can_assign_sequence_rule_enablers", 
            "can_assign_sequence_rule_enablers_to_bank", 
            "get_assignable_bank_ids", 
            "get_assignable_bank_ids_for_sequence_rule_enabler", 
            "assign_sequence_rule_enabler_to_bank", 
            "unassign_sequence_rule_enabler_from_bank"
         ], 
         "methods": [
            {
               "name": "can_assign_sequence_rule_enablers", 
               "doc": {
                  "headline": "Tests if this user can alter sequence rule enabler/bank mappings.", 
                  "body": "        A return of true does not guarantee successful authorization. A\n        return of false indicates that it is known mapping methods in\n        this session will result in a ``PermissionDenied``. This is\n        intended as a hint to an application that may opt not to offer\n        lookup operations to unauthorized users."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``false`` if mapping is not authorized,\n                ``true`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``false`` if mapping is not authorized, ``true`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "can_assign_sequence_rule_enablers_to_bank", 
               "doc": {
                  "headline": "Tests if this user can alter sequence rule enabler/bank mappings.", 
                  "body": "        A return of true does not guarantee successful authorization. A\n        return of false indicates that it is known mapping methods in\n        this session will result in a ``PermissionDenied``. This is\n        intended as a hint to an application that may opt not to offer\n        lookup operations to unauthorized users."
               }, 
               "arg_doc": "        arg:    bank_id (osid.id.Id): the ``Id`` of the ``Bank``\n", 
               "return_doc": "        return: (boolean) - ``false`` if mapping is not authorized,\n                ``true`` otherwise", 
               "error_doc": "        raise:  NullArgument - ``bank_id`` is ``null``", 
               "sphinx_param_doc": "        :param bank_id: the ``Id`` of the ``Bank``\n        :type bank_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: ``false`` if mapping is not authorized, ``true`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``bank_id`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "bank_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "boolean", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "get_assignable_bank_ids", 
               "doc": {
                  "headline": "Gets a list of bank including and under the given bank node in which any sequence rule enabler can be assigned.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    bank_id (osid.id.Id): the ``Id`` of the ``Bank``\n", 
               "return_doc": "        return: (osid.id.IdList) - list of assignable bank ``Ids``", 
               "error_doc": "        raise:  NullArgument - ``bank_id`` is ``null``\n        raise:  OperationFailed - unable to complete request", 
               "sphinx_param_doc": "        :param bank_id: the ``Id`` of the ``Bank``\n        :type bank_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: list of assignable bank ``Ids``\n        :rtype: ``osid.id.IdList``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``bank_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "bank_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "osid.id.IdList", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational"
               }
            }, 
            {
               "name": "get_assignable_bank_ids_for_sequence_rule_enabler", 
               "doc": {
                  "headline": "Gets a list of bank including and under the given bank node in which a specific sequence rule enabler can be assigned.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    bank_id (osid.id.Id): the ``Id`` of the ``Bank``\n        arg:    sequence_rule_enabler_id (osid.id.Id): the ``Id`` of the\n                ``SequenceRuleEnabler``\n", 
               "return_doc": "        return: (osid.id.IdList) - list of assignable bank ``Ids``", 
               "error_doc": "        raise:  NullArgument - ``bank_id`` or\n                ``sequence_rule_enabler_id`` is ``null``\n        raise:  OperationFailed - unable to complete request", 
               "sphinx_param_doc": "        :param bank_id: the ``Id`` of the ``Bank``\n        :type bank_id: ``osid.id.Id``\n        :param sequence_rule_enabler_id: the ``Id`` of the ``SequenceRuleEnabler``\n        :type sequence_rule_enabler_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: list of assignable bank ``Ids``\n        :rtype: ``osid.id.IdList``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``bank_id`` or ``sequence_rule_enabler_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "bank_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "sequence_rule_enabler_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "osid.id.Id"
               ], 
               "return_type": "osid.id.IdList", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational"
               }
            }, 
            {
               "name": "assign_sequence_rule_enabler_to_bank", 
               "doc": {
                  "headline": "Adds an existing ``SequenceRuleEnabler`` to a ``Bank``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    sequence_rule_enabler_id (osid.id.Id): the ``Id`` of the\n                ``SequenceRuleEnabler``\n        arg:    bank_id (osid.id.Id): the ``Id`` of the ``Bank``\n", 
               "return_doc": "", 
               "error_doc": "        raise:  AlreadyExists - ``sequence_rule_enabler_id`` is already\n                assigned to ``bank_id``\n        raise:  NotFound - ``sequence_rule_enabler_id`` or ``bank_id``\n                not found\n        raise:  NullArgument - ``sequence_rule_enabler_id`` or\n                ``bank_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param sequence_rule_enabler_id: the ``Id`` of the ``SequenceRuleEnabler``\n        :type sequence_rule_enabler_id: ``osid.id.Id``\n        :param bank_id: the ``Id`` of the ``Bank``\n        :type bank_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``AlreadyExists`` -- ``sequence_rule_enabler_id`` is already assigned to ``bank_id``\n        :raise: ``NotFound`` -- ``sequence_rule_enabler_id`` or ``bank_id`` not found\n        :raise: ``NullArgument`` -- ``sequence_rule_enabler_id`` or ``bank_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "sequence_rule_enabler_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "bank_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {
                  "ALREADY_EXISTS": "User", 
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "unassign_sequence_rule_enabler_from_bank", 
               "doc": {
                  "headline": "Removes a ``SequenceRuleEnabler`` from a ``Bank``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    sequence_rule_enabler_id (osid.id.Id): the ``Id`` of the\n                ``SequenceRuleEnabler``\n        arg:    bank_id (osid.id.Id): the ``Id`` of the ``Bank``\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NotFound - ``sequence_rule_enabler_id`` or ``bank_id``\n                not found or ``sequence_rule_enabler_id`` not assigned\n                to ``bank_id``\n        raise:  NullArgument - ``sequence_rule_enabler_id`` or\n                ``bank_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param sequence_rule_enabler_id: the ``Id`` of the ``SequenceRuleEnabler``\n        :type sequence_rule_enabler_id: ``osid.id.Id``\n        :param bank_id: the ``Id`` of the ``Bank``\n        :type bank_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``sequence_rule_enabler_id`` or ``bank_id`` not found or ``sequence_rule_enabler_id`` not assigned to ``bank_id``\n        :raise: ``NullArgument`` -- ``sequence_rule_enabler_id`` or ``bank_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "sequence_rule_enabler_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "bank_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.assessment.authoring.SequenceRuleEnablerSmartBankSession", 
         "shortname": "SequenceRuleEnablerSmartBankSession", 
         "category": "sessions", 
         "doc": {
            "headline": "This session manages queries and sequencing to create \"smart\" dynamic bank.", 
            "body": "    a ``SequenceRuleEnablerQuery`` can be retrieved from this session\n    and mapped to this ``Bank`` to create a virtual collection of\n    sequence rule enablers. The sequence rule enablers may be sequenced\n    using the ``SequenceRuleEnablerSearchOrder`` from this session.\n\n    This ``Bank`` has a default query that matches any sequence rule\n    enabler and a default search order that specifies no sequencing. The\n    queries may be examined using a\n    ``SequenceRuleEnablerQueryInspector``. The query may be modified by\n    converting the inspector back to a ``SequenceRuleEnablerQuery``."
         }, 
         "inherit_fullnames": [
            "osid.OsidSession"
         ], 
         "inherit_shortnames": [
            "OsidSession"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidSession"
            }
         ], 
         "method_names": [
            "get_bank_id", 
            "get_bank", 
            "can_manage_smart_banks", 
            "get_sequence_rule_enabler_query", 
            "get_sequence_rule_enabler_search_order", 
            "apply_sequence_rule_enabler_query", 
            "inspect_sequence_rule_enabler_query", 
            "apply_sequence_rule_enabler_sequencing", 
            "get_sequence_rule_enabler_query_from_inspector"
         ], 
         "methods": [
            {
               "name": "get_bank_id", 
               "doc": {
                  "headline": "Gets the ``Bank``  ``Id`` associated with this session.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.id.Id) - the ``Bank Id`` associated with this\n                session", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the ``Bank Id`` associated with this session\n        :rtype: ``osid.id.Id``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.id.Id", 
               "errors": {}
            }, 
            {
               "name": "get_bank", 
               "doc": {
                  "headline": "Gets the ``Bank`` associated with this session.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.assessment.Bank) - the bank", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the bank\n        :rtype: ``osid.assessment.Bank``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.assessment.Bank", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "can_manage_smart_banks", 
               "doc": {
                  "headline": "Tests if this user can manage smart bank.", 
                  "body": "        A return of true does not guarantee successful authorization. A\n        return of false indicates that it is known methods in this\n        session will result in a ``PermissionDenied``. This is intended\n        as a hint to an application that may opt not to offer operations\n        to unauthorized users."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``false`` if smart bank management is not\n                authorized, ``true`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``false`` if smart bank management is not authorized, ``true`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "get_sequence_rule_enabler_query", 
               "doc": {
                  "headline": "Gets a sequence rule enabler query.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.assessment.authoring.SequenceRuleEnablerQuery) -\n                the sequence rule enabler query", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the sequence rule enabler query\n        :rtype: ``osid.assessment.authoring.SequenceRuleEnablerQuery``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.assessment.authoring.SequenceRuleEnablerQuery", 
               "errors": {}
            }, 
            {
               "name": "get_sequence_rule_enabler_search_order", 
               "doc": {
                  "headline": "Gets a sequence rule enabler search order.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return:\n                (osid.assessment.authoring.SequenceRuleEnablerSearchOrde\n                r) - the sequence rule enabler search order", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the sequence rule enabler search order\n        :rtype: ``osid.assessment.authoring.SequenceRuleEnablerSearchOrder``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.assessment.authoring.SequenceRuleEnablerSearchOrder", 
               "errors": {}
            }, 
            {
               "name": "apply_sequence_rule_enabler_query", 
               "doc": {
                  "headline": "Applies a sequence rule enabler query to this bank.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    sequence_rule_enabler_query\n                (osid.assessment.authoring.SequenceRuleEnablerQuery):\n                the sequence rule enabler query\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``sequence_rule_enabler_query`` is\n                ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure occurred\n        raise:  Unsupported - ``sequence_rule_enabler_query`` not of\n                this service", 
               "sphinx_param_doc": "        :param sequence_rule_enabler_query: the sequence rule enabler query\n        :type sequence_rule_enabler_query: ``osid.assessment.authoring.SequenceRuleEnablerQuery``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``sequence_rule_enabler_query`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure occurred\n        :raise: ``Unsupported`` -- ``sequence_rule_enabler_query`` not of this service", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.assessment.authoring.SequenceRuleEnablerQuery", 
                     "var_name": "sequence_rule_enabler_query", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.assessment.authoring.SequenceRuleEnablerQuery"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }, 
            {
               "name": "inspect_sequence_rule_enabler_query", 
               "doc": {
                  "headline": "Gets a sequence rule enabler query inspector for this bank.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return:\n                (osid.assessment.authoring.SequenceRuleEnablerQueryInspe\n                ctor) - the sequence rule enabler query inspector", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure occurred", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the sequence rule enabler query inspector\n        :rtype: ``osid.assessment.authoring.SequenceRuleEnablerQueryInspector``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure occurred", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.assessment.authoring.SequenceRuleEnablerQueryInspector", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "apply_sequence_rule_enabler_sequencing", 
               "doc": {
                  "headline": "Applies a sequence rule enabler search order to this bank.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    sequence_rule_enabler_search_order\n                (osid.assessment.authoring.SequenceRuleEnablerSearchOrde\n                r): the sequence rule enabler search order\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``sequence_rule_enabler_search_order`` is\n                ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure occurred\n        raise:  Unsupported - ``sequence_rule_enabler_search_order`` not\n                of this service", 
               "sphinx_param_doc": "        :param sequence_rule_enabler_search_order: the sequence rule enabler search order\n        :type sequence_rule_enabler_search_order: ``osid.assessment.authoring.SequenceRuleEnablerSearchOrder``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``sequence_rule_enabler_search_order`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure occurred\n        :raise: ``Unsupported`` -- ``sequence_rule_enabler_search_order`` not of this service", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.assessment.authoring.SequenceRuleEnablerSearchOrder", 
                     "var_name": "sequence_rule_enabler_search_order", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.assessment.authoring.SequenceRuleEnablerSearchOrder"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_sequence_rule_enabler_query_from_inspector", 
               "doc": {
                  "headline": "Gets a sequence rule enabler query from an inspector.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    sequence_rule_enabler_query_inspector\n                (osid.assessment.authoring.SequenceRuleEnablerQueryInspe\n                ctor): a sequence rule enabler query inspector\n", 
               "return_doc": "        return: (osid.assessment.authoring.SequenceRuleEnablerQuery) -\n                the sequence rule enabler query", 
               "error_doc": "        raise:  NullArgument - ``sequence_rule_enabler_query_inspector``\n                is ``null``\n        raise:  Unsupported - ``sequence_rule_enabler_query_inspector``\n                is not of this service", 
               "sphinx_param_doc": "        :param sequence_rule_enabler_query_inspector: a sequence rule enabler query inspector\n        :type sequence_rule_enabler_query_inspector: ``osid.assessment.authoring.SequenceRuleEnablerQueryInspector``\n", 
               "sphinx_return_doc": "        :return: the sequence rule enabler query\n        :rtype: ``osid.assessment.authoring.SequenceRuleEnablerQuery``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``sequence_rule_enabler_query_inspector`` is ``null``\n        :raise: ``Unsupported`` -- ``sequence_rule_enabler_query_inspector`` is not of this service", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.assessment.authoring.SequenceRuleEnablerQueryInspector", 
                     "var_name": "sequence_rule_enabler_query_inspector", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.assessment.authoring.SequenceRuleEnablerQueryInspector"
               ], 
               "return_type": "osid.assessment.authoring.SequenceRuleEnablerQuery", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.assessment.authoring.SequenceRuleEnablerRuleLookupSession", 
         "shortname": "SequenceRuleEnablerRuleLookupSession", 
         "category": "sessions", 
         "doc": {
            "headline": "This session provides methods to retrieve ``SequenceRuleEnabler`` to ``SequenceRule`` mappings.", 
            "body": "    a ``Step`` with multiple ``SequenceRuleEnablers`` means any positive\n    rule evaluation across the enablers result in an effective\n    ``SequenceRule``.\n\n    This lookup session defines several views:\n    \n      * comparative view: elements may be silently omitted or re-ordered\n      * plenary view: provides a complete result set or is an error\n        condition\n      * isolated bank view: All methods in this session operate,\n        retrieve and pertain sequence rule enablers defined explicitly\n        in the current bank\n      * federated bank view: All methods in this session operate,\n        retrieve and pertain to all sequence rule enablers defined in\n        this bank and any other sequence rule enablers implicitly\n        available in this bank through bank inheritence.\n"
         }, 
         "inherit_fullnames": [
            "osid.OsidSession"
         ], 
         "inherit_shortnames": [
            "OsidSession"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidSession"
            }
         ], 
         "method_names": [
            "get_bank_id", 
            "get_bank", 
            "can_lookup_sequence_rule_enabler_rules", 
            "use_comparative_sequence_rule_enabler_rule_view", 
            "use_plenary_sequence_rule_enabler_rule_view", 
            "use_federated_bank_view", 
            "use_isolated_bank_view", 
            "get_sequence_rule_enabler_ids_for_sequence_rule", 
            "get_sequence_rule_enablers_for_sequence_rule", 
            "get_sequence_rule_ids_for_sequence_rule_enabler", 
            "get_sequence_rules_for_sequence_rule_enabler"
         ], 
         "methods": [
            {
               "name": "get_bank_id", 
               "doc": {
                  "headline": "Gets the ``Bank``  ``Id`` associated with this session.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.id.Id) - the ``Bank Id`` associated with this\n                session", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the ``Bank Id`` associated with this session\n        :rtype: ``osid.id.Id``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.id.Id", 
               "errors": {}
            }, 
            {
               "name": "get_bank", 
               "doc": {
                  "headline": "Gets the ``Bank`` associated with this session.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.assessment.Bank) - the bank", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the bank\n        :rtype: ``osid.assessment.Bank``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.assessment.Bank", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "can_lookup_sequence_rule_enabler_rules", 
               "doc": {
                  "headline": "Tests if this user can perform lookups of sequence rule enabler/sequence rule mappings.", 
                  "body": "        A return of true does not guarantee successful authorization. A\n        return of false indicates that it is known lookup methods in\n        this session will result in a ``PermissionDenied``. This is\n        intended as a hint to an application that may opt not to offer\n        lookup operations to unauthorized users."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``false`` if looking up mappings is not\n                authorized, ``true`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``false`` if looking up mappings is not authorized, ``true`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "use_comparative_sequence_rule_enabler_rule_view", 
               "doc": {
                  "headline": "The returns from the lookup methods may omit or translate elements based on this session, such as authorization, and not result in an error.", 
                  "body": "        This view is used when greater interoperability is desired at\n        the expense of precision."
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "use_plenary_sequence_rule_enabler_rule_view", 
               "doc": {
                  "headline": "A complete view of the ``SequenceRuleEnabler`` and ``SequenceRule`` returns is desired.", 
                  "body": "        Methods will return what is requested or result in an error.\n        This view is used when greater precision is desired at the\n        expense of interoperability."
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "use_federated_bank_view", 
               "doc": {
                  "headline": "Federates the view for methods in this session.", 
                  "body": "        A federated view will include sequence rule enablers in banks\n        which are children of this bank in the bank hierarchy."
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "use_isolated_bank_view", 
               "doc": {
                  "headline": "Isolates the view for methods in this session.", 
                  "body": "        An isolated view restricts lookups to this bank only."
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "get_sequence_rule_enabler_ids_for_sequence_rule", 
               "doc": {
                  "headline": "Gets the ``SequenceRuleEnabler Id`` associated with a ``SequenceRule``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:     sequence_rule_id (osid.id.Id): ``Id`` of the\n                ``SequenceRule``\n", 
               "return_doc": "        return: (osid.id.IdList) - the sequence rule enabler ``Ids``", 
               "error_doc": "        raise:  NotFound - ``sequence_rule_id`` is not found\n        raise:  NullArgument - ``sequence_rule_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param  sequence_rule_id: ``Id`` of the ``SequenceRule``\n        :type  sequence_rule_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: the sequence rule enabler ``Ids``\n        :rtype: ``osid.id.IdList``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``sequence_rule_id`` is not found\n        :raise: ``NullArgument`` -- ``sequence_rule_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": " sequence_rule_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "osid.id.IdList", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_sequence_rule_enablers_for_sequence_rule", 
               "doc": {
                  "headline": "Gets the ``SequenceRuleEnablers`` associated with a ``SequenceRule``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    sequence_rule_id (osid.id.Id): ``Id`` of the\n                ``SequenceRule``\n", 
               "return_doc": "        return: (osid.assessment.authoring.SequenceRuleEnablerList) -\n                the sequence rule enablers", 
               "error_doc": "        raise:  NotFound - ``sequence_rule_id`` is not found\n        raise:  NullArgument - ``sequence_rule_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param sequence_rule_id: ``Id`` of the ``SequenceRule``\n        :type sequence_rule_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: the sequence rule enablers\n        :rtype: ``osid.assessment.authoring.SequenceRuleEnablerList``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``sequence_rule_id`` is not found\n        :raise: ``NullArgument`` -- ``sequence_rule_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "sequence_rule_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "osid.assessment.authoring.SequenceRuleEnablerList", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_sequence_rule_ids_for_sequence_rule_enabler", 
               "doc": {
                  "headline": "Gets the ``SequenceRule``  ``Ids`` mapped to a ``SequenceRuleEnabler``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    sequence_rule_enabler_id (osid.id.Id): ``Id`` of a\n                ``SequenceRuleEnabler``\n", 
               "return_doc": "        return: (osid.id.IdList) - list of sequence rule ``Ids``", 
               "error_doc": "        raise:  NotFound - ``sequence_rule_enabler_id`` is not found\n        raise:  NullArgument - ``sequence_rule_enabler_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param sequence_rule_enabler_id: ``Id`` of a ``SequenceRuleEnabler``\n        :type sequence_rule_enabler_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: list of sequence rule ``Ids``\n        :rtype: ``osid.id.IdList``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``sequence_rule_enabler_id`` is not found\n        :raise: ``NullArgument`` -- ``sequence_rule_enabler_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "sequence_rule_enabler_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "osid.id.IdList", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_sequence_rules_for_sequence_rule_enabler", 
               "doc": {
                  "headline": "Gets the ``SequenceRules`` mapped to a ``SequenceRuleEnabler``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    sequence_rule_enabler_id (osid.id.Id): ``Id`` of a\n                ``SequenceRuleEnabler``\n", 
               "return_doc": "        return: (osid.assessment.authoring.SequenceRuleList) - list of\n                sequence rules", 
               "error_doc": "        raise:  NotFound - ``sequence_rule_enabler_id`` is not found\n        raise:  NullArgument - ``sequence_rule_enabler_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param sequence_rule_enabler_id: ``Id`` of a ``SequenceRuleEnabler``\n        :type sequence_rule_enabler_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: list of sequence rules\n        :rtype: ``osid.assessment.authoring.SequenceRuleList``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``sequence_rule_enabler_id`` is not found\n        :raise: ``NullArgument`` -- ``sequence_rule_enabler_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "sequence_rule_enabler_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "osid.assessment.authoring.SequenceRuleList", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.assessment.authoring.SequenceRuleEnablerRuleApplicationSession", 
         "shortname": "SequenceRuleEnablerRuleApplicationSession", 
         "category": "sessions", 
         "doc": {
            "headline": "This session provides methods to apply ``SequenceRuleEnablers`` to ``SequenceRules``.", 
            "body": "    a ``SequenceRule`` with multiple ``SequenceRuleEnablers`` means any\n    positive rule evaluation across the enablers result in an effective\n    ``SequenceRule``."
         }, 
         "inherit_fullnames": [
            "osid.OsidSession"
         ], 
         "inherit_shortnames": [
            "OsidSession"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidSession"
            }
         ], 
         "method_names": [
            "get_bank_id", 
            "get_bank", 
            "can_assign_sequence_rule_enablers", 
            "assign_sequence_rule_enabler_to_sequence_rule", 
            "unassign_sequence_rule_enabler_from_sequence_rule", 
            "can_sequence_sequence_rule_enablers", 
            "move_sequence_rule_enabler_ahead", 
            "move_sequence_rule_enabler_behind", 
            "order_sequence_rule_enablers"
         ], 
         "methods": [
            {
               "name": "get_bank_id", 
               "doc": {
                  "headline": "Gets the ``Bank``  ``Id`` associated with this session.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.id.Id) - the ``Bank Id`` associated with this\n                session", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the ``Bank Id`` associated with this session\n        :rtype: ``osid.id.Id``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.id.Id", 
               "errors": {}
            }, 
            {
               "name": "get_bank", 
               "doc": {
                  "headline": "Gets the ``Bank`` associated with this session.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.assessment.Bank) - the bank", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the bank\n        :rtype: ``osid.assessment.Bank``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.assessment.Bank", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "can_assign_sequence_rule_enablers", 
               "doc": {
                  "headline": "Tests if this user can alter sequence rule enabler/sequence rule mappings.", 
                  "body": "        A return of true does not guarantee successful authorization. A\n        return of false indicates that it is known mapping methods in\n        this session will result in a ``PermissionDenied``. This is\n        intended as a hint to an application that may opt not to offer\n        lookup operations to unauthorized users."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``false`` if mapping is not authorized,\n                ``true`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``false`` if mapping is not authorized, ``true`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "assign_sequence_rule_enabler_to_sequence_rule", 
               "doc": {
                  "headline": "Adds an existing ``SequenceRuleEnabler`` to a ``SequenceRule``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    sequence_rule_enabler_id (osid.id.Id): the ``Id`` of the\n                ``SequenceRuleEnabler``\n        arg:    sequence_rule_id (osid.id.Id): the ``Id`` of the\n                ``SequenceRule``\n", 
               "return_doc": "", 
               "error_doc": "        raise:  AlreadyExists - ``sequence_rule_enabler_id`` is already\n                applied to ``sequence_rule_id``\n        raise:  NotFound - ``sequence_rule_enabler_id`` or\n                ``sequence_rule_id`` not found\n        raise:  NullArgument - ``sequence_rule_enabler_id`` or\n                ``sequence_rule_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param sequence_rule_enabler_id: the ``Id`` of the ``SequenceRuleEnabler``\n        :type sequence_rule_enabler_id: ``osid.id.Id``\n        :param sequence_rule_id: the ``Id`` of the ``SequenceRule``\n        :type sequence_rule_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``AlreadyExists`` -- ``sequence_rule_enabler_id`` is already applied to ``sequence_rule_id``\n        :raise: ``NotFound`` -- ``sequence_rule_enabler_id`` or ``sequence_rule_id`` not found\n        :raise: ``NullArgument`` -- ``sequence_rule_enabler_id`` or ``sequence_rule_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "sequence_rule_enabler_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "sequence_rule_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {
                  "ALREADY_EXISTS": "User", 
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "unassign_sequence_rule_enabler_from_sequence_rule", 
               "doc": {
                  "headline": "Removes a ``SequenceRuleEnabler`` from a ``SequenceRule``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    sequence_rule_enabler_id (osid.id.Id): the ``Id`` of the\n                ``SequenceRuleEnabler``\n        arg:    sequence_rule_id (osid.id.Id): the ``Id`` of the\n                ``SequenceRule``\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NotFound - ``sequence_rule_enabler_id`` or\n                ``sequence_rule_id`` not found or\n                ``sequence_rule_enabler_id`` not applied to\n                ``sequence_rule_id``\n        raise:  NullArgument - ``sequence_rule_enabler_id`` or\n                ``sequence_rule_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param sequence_rule_enabler_id: the ``Id`` of the ``SequenceRuleEnabler``\n        :type sequence_rule_enabler_id: ``osid.id.Id``\n        :param sequence_rule_id: the ``Id`` of the ``SequenceRule``\n        :type sequence_rule_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``sequence_rule_enabler_id`` or ``sequence_rule_id`` not found or ``sequence_rule_enabler_id`` not applied to ``sequence_rule_id``\n        :raise: ``NullArgument`` -- ``sequence_rule_enabler_id`` or ``sequence_rule_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "sequence_rule_enabler_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "sequence_rule_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "can_sequence_sequence_rule_enablers", 
               "doc": {
                  "headline": "Tests if this user can order ``SequenceRuleEnablers``.", 
                  "body": "        A return of true does not guarantee successful authorization. A\n        return of false indicates that it is known sequencing operations\n        will result in a ``PermissionDenied``. This is intended as a\n        hint to an application that may opt not to offer sequencing\n        operations to an unauthorized user."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``false`` if ``SequenceRuleEnabler``\n                ordering is not authorized, ``true`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``false`` if ``SequenceRuleEnabler`` ordering is not authorized, ``true`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "move_sequence_rule_enabler_ahead", 
               "doc": {
                  "headline": "Reorders sequence rule enablers for a sequence rule by moving the specified sequence rule enabler in front of a reference sequence rule enabler.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    sequence_rule_enabler_id (osid.id.Id): the ``Id`` of a\n                ``SequenceRuleEnabler``\n        arg:    sequence_rule_id (osid.id.Id): the ``Id`` of a\n                ``SequenceRule``\n        arg:    reference_id (osid.id.Id): the reference sequence rule\n                enabler ``Id``\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NotFound - ``sequence_rule_enabler_id,\n                sequence_rule_id,`` or ``reference_id`` not found or,\n                ``sequence_rule_enabler_id`` or ``reference_id`` not\n                related to ``sequence_rule_id``\n        raise:  NullArgument - ``sequence_rule_enabler_id,\n                sequence_rule_id,`` or ``reference_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param sequence_rule_enabler_id: the ``Id`` of a ``SequenceRuleEnabler``\n        :type sequence_rule_enabler_id: ``osid.id.Id``\n        :param sequence_rule_id: the ``Id`` of a ``SequenceRule``\n        :type sequence_rule_id: ``osid.id.Id``\n        :param reference_id: the reference sequence rule enabler ``Id``\n        :type reference_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``sequence_rule_enabler_id, sequence_rule_id,`` or ``reference_id`` not found or, ``sequence_rule_enabler_id`` or ``reference_id`` not related to ``sequence_rule_id``\n        :raise: ``NullArgument`` -- ``sequence_rule_enabler_id, sequence_rule_id,`` or ``reference_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "sequence_rule_enabler_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "sequence_rule_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "reference_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "osid.id.Id", 
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "move_sequence_rule_enabler_behind", 
               "doc": {
                  "headline": "Reorders sequence rule enablers for a sequence rule by moving the specified sequence rule enabler behind a reference sequence rule enabler.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    sequence_rule_enabler_id (osid.id.Id): the ``Id`` of a\n                ``SequenceRuleEnabler``\n        arg:    sequence_rule_id (osid.id.Id): the ``Id`` of a\n                ``SequenceRule``\n        arg:    reference_id (osid.id.Id): the reference sequence rule\n                enabler ``Id``\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NotFound - ``sequence_rule_enabler_id,\n                sequence_rule_id,`` or ``reference_id`` not found or,\n                ``sequence_rule_enabler_id`` or ``reference_id`` not\n                related to ``sequence_rule_id``\n        raise:  NullArgument - ``sequence_rule_enabler_id,\n                sequence_rule_id,`` or ``reference_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param sequence_rule_enabler_id: the ``Id`` of a ``SequenceRuleEnabler``\n        :type sequence_rule_enabler_id: ``osid.id.Id``\n        :param sequence_rule_id: the ``Id`` of a ``SequenceRule``\n        :type sequence_rule_id: ``osid.id.Id``\n        :param reference_id: the reference sequence rule enabler ``Id``\n        :type reference_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``sequence_rule_enabler_id, sequence_rule_id,`` or ``reference_id`` not found or, ``sequence_rule_enabler_id`` or ``reference_id`` not related to ``sequence_rule_id``\n        :raise: ``NullArgument`` -- ``sequence_rule_enabler_id, sequence_rule_id,`` or ``reference_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "sequence_rule_enabler_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "sequence_rule_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "reference_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "osid.id.Id", 
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "order_sequence_rule_enablers", 
               "doc": {
                  "headline": "Reorders a set of sequence rule enablers for a sequence rule.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    sequence_rule_enabler_ids (osid.id.Id[]): the ``Ids``\n                for a set of ``SequenceRuleEnablers``\n        arg:    sequence_rule_id (osid.id.Id): the ``Id`` of a\n                ``SequenceRule``\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NotFound - ``sequence_rule_id`` not found or, an\n                ``sequence_rule_enabler_id`` not related to\n                ``sequence_rule_id``\n        raise:  NullArgument - ``sequence_rule_enabler_ids`` or\n                ``sequence_rule_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param sequence_rule_enabler_ids: the ``Ids`` for a set of ``SequenceRuleEnablers``\n        :type sequence_rule_enabler_ids: ``osid.id.Id[]``\n        :param sequence_rule_id: the ``Id`` of a ``SequenceRule``\n        :type sequence_rule_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``sequence_rule_id`` not found or, an ``sequence_rule_enabler_id`` not related to ``sequence_rule_id``\n        :raise: ``NullArgument`` -- ``sequence_rule_enabler_ids`` or ``sequence_rule_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id[]", 
                     "var_name": "sequence_rule_enabler_ids", 
                     "array": true
                  }, 
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "sequence_rule_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id[]", 
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.assessment.authoring.AssessmentPart", 
         "shortname": "AssessmentPart", 
         "category": "objects", 
         "doc": {
            "headline": "An ``AssessmentPart`` represents a section of an assessment.", 
            "body": "    ``AssessmentParts`` may be visible as sections of an assessment or\n    just used to clump together a set of items on which to hang sequence\n    rules."
         }, 
         "inherit_fullnames": [
            "osid.OsidObject", 
            "osid.Containable", 
            "osid.Operable"
         ], 
         "inherit_shortnames": [
            "OsidObject", 
            "Containable", 
            "Operable"
         ], 
         "inherit_pkg_names": [
            "osid", 
            "osid", 
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidObject"
            }, 
            {
               "pkg_name": "osid", 
               "name": "Containable"
            }, 
            {
               "pkg_name": "osid", 
               "name": "Operable"
            }
         ], 
         "method_names": [
            "get_assessment_id", 
            "get_assessment", 
            "has_parent_part", 
            "get_assessment_part_id", 
            "get_assessment_part", 
            "is_section", 
            "get_weight", 
            "get_allocated_time", 
            "get_child_assessment_part_ids", 
            "get_child_assessment_parts", 
            "get_assessment_part_record"
         ], 
         "methods": [
            {
               "name": "get_assessment_id", 
               "doc": {
                  "headline": "Gets the assessment ``Id`` to which this rule belongs.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.id.Id) - ``Id`` of an assessment", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``Id`` of an assessment\n        :rtype: ``osid.id.Id``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.id.Id", 
               "errors": {}
            }, 
            {
               "name": "get_assessment", 
               "doc": {
                  "headline": "Gets the assessment to which this rule belongs.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.assessment.Assessment) - an assessment", 
               "error_doc": "        raise:  OperationFailed - unable to complete request", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: an assessment\n        :rtype: ``osid.assessment.Assessment``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.assessment.Assessment", 
               "errors": {
                  "OPERATION_FAILED": "Operational"
               }
            }, 
            {
               "name": "has_parent_part", 
               "doc": {
                  "headline": "Tests if this assessment part belongs to a parent assessment part.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if this part has a parent,\n                ``false`` if a root", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if this part has a parent, ``false`` if a root\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "get_assessment_part_id", 
               "doc": {
                  "headline": "Gets the parent assessment ``Id``.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.id.Id) - ``Id`` of an assessment", 
               "error_doc": "        raise:  IllegalState - ``has_parent_part()`` is ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``Id`` of an assessment\n        :rtype: ``osid.id.Id``", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- ``has_parent_part()`` is ``false``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.id.Id", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract"
               }
            }, 
            {
               "name": "get_assessment_part", 
               "doc": {
                  "headline": "Gets the parent assessment.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.assessment.authoring.AssessmentPart) - the parent\n                assessment part", 
               "error_doc": "        raise:  IllegalState - ``has_parent_part()`` is ``false``\n        raise:  OperationFailed - unable to complete request", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the parent assessment part\n        :rtype: ``osid.assessment.authoring.AssessmentPart``", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- ``has_parent_part()`` is ``false``\n        :raise: ``OperationFailed`` -- unable to complete request", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.assessment.authoring.AssessmentPart", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational"
               }
            }, 
            {
               "name": "is_section", 
               "doc": {
                  "headline": "Tests if this part should be visible as a section in an assessment.", 
                  "body": "        If visible, this part will appear to the user as a separate\n        section of the assessment. Typically, a section may not be under\n        a non-sectioned part."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if this part is a section,\n                ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if this part is a section, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "get_weight", 
               "doc": {
                  "headline": "Gets an integral weight factor for this assessment part used for scoring.", 
                  "body": "        The percentage weight for this part is this weight divided by\n        the sum total of all the weights in the assessment."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (cardinal) - the weight", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the weight\n        :rtype: ``cardinal``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "cardinal", 
               "errors": {}
            }, 
            {
               "name": "get_allocated_time", 
               "doc": {
                  "headline": "Gets the allocated time for this part.", 
                  "body": "        The allocated time may be used to assign fixed time limits to\n        each item or can be used to estimate the total assessment time."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.Duration) - allocated time", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: allocated time\n        :rtype: ``osid.calendaring.Duration``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.Duration", 
               "errors": {}
            }, 
            {
               "name": "get_child_assessment_part_ids", 
               "doc": {
                  "headline": "Gets any child assessment part ``Ids``.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.id.IdList) - ``Ids`` of the child assessment parts", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``Ids`` of the child assessment parts\n        :rtype: ``osid.id.IdList``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.id.IdList", 
               "errors": {}
            }, 
            {
               "name": "get_child_assessment_parts", 
               "doc": {
                  "headline": "Gets any child assessment parts.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.assessment.authoring.AssessmentPartList) - the\n                child assessment parts", 
               "error_doc": "        raise:  OperationFailed - unable to complete request", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the child assessment parts\n        :rtype: ``osid.assessment.authoring.AssessmentPartList``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.assessment.authoring.AssessmentPartList", 
               "errors": {
                  "OPERATION_FAILED": "Operational"
               }
            }, 
            {
               "name": "get_assessment_part_record", 
               "doc": {
                  "headline": "Gets the assessment part record corresponding to the given ``AssessmentPart`` record ``Type``.", 
                  "body": "        This method is used to retrieve an object implementing the\n        requested record. The ``assessment_part_record_type`` may be the\n        ``Type`` returned in ``get_record_types()`` or any of its\n        parents in a ``Type`` hierarchy where\n        ``has_record_type(assessment_part_record_type)`` is ``true`` ."
               }, 
               "arg_doc": "        arg:    assessment_part_record_type (osid.type.Type): the type\n                of the record to retrieve\n", 
               "return_doc": "        return: (osid.assessment.authoring.records.AssessmentPartRecord)\n                - the assessment part record", 
               "error_doc": "        raise:  NullArgument - ``assessment_part_record_type`` is\n                ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unsupported -\n                ``has_record_type(assessment_part_record_type)`` is\n                ``false``", 
               "sphinx_param_doc": "        :param assessment_part_record_type: the type of the record to retrieve\n        :type assessment_part_record_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "        :return: the assessment part record\n        :rtype: ``osid.assessment.authoring.records.AssessmentPartRecord``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``assessment_part_record_type`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unsupported`` -- ``has_record_type(assessment_part_record_type)`` is ``false``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "assessment_part_record_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "osid.assessment.authoring.records.AssessmentPartRecord", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.assessment.authoring.records.AssessmentPartRecord", 
         "shortname": "AssessmentPartRecord", 
         "category": "records", 
         "doc": {
            "headline": "A record for an ``AssessmentPart``.", 
            "body": "    The methods specified by the record type are available through the\n    underlying object."
         }, 
         "inherit_fullnames": [
            "osid.OsidRecord"
         ], 
         "inherit_shortnames": [
            "OsidRecord"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidRecord"
            }
         ], 
         "method_names": [], 
         "methods": []
      }, 
      {
         "fullname": "osid.assessment.authoring.AssessmentPartQuery", 
         "shortname": "AssessmentPartQuery", 
         "category": "queries", 
         "doc": {
            "headline": "This is the query for searching assessment parts.", 
            "body": "    Each method match request produces an ``AND`` term while multiple\n    invocations of a method produces a nested ``OR``."
         }, 
         "inherit_fullnames": [
            "osid.OsidObjectQuery", 
            "osid.OsidContainableQuery", 
            "osid.OsidOperableQuery"
         ], 
         "inherit_shortnames": [
            "OsidObjectQuery", 
            "OsidContainableQuery", 
            "OsidOperableQuery"
         ], 
         "inherit_pkg_names": [
            "osid", 
            "osid", 
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidObjectQuery"
            }, 
            {
               "pkg_name": "osid", 
               "name": "OsidContainableQuery"
            }, 
            {
               "pkg_name": "osid", 
               "name": "OsidOperableQuery"
            }
         ], 
         "method_names": [
            "match_assessment_id", 
            "clear_assessment_id_terms", 
            "supports_assessment_query", 
            "get_assessment_query", 
            "clear_assessment_terms", 
            "match_parent_assessment_part_id", 
            "clear_parent_assessment_part_id_terms", 
            "supports_parent_assessment_part_query", 
            "get_parent_assessment_part_query", 
            "match_any_parent_assessment_part", 
            "clear_parent_assessment_part_terms", 
            "match_section", 
            "clear_section_terms", 
            "match_weight", 
            "match_any_weight", 
            "clear_weight_terms", 
            "match_allocated_time", 
            "match_any_allocated_time", 
            "clear_allocated_time_terms", 
            "match_child_assessment_part_id", 
            "clear_child_assessment_part_id_terms", 
            "supports_child_assessment_part_query", 
            "get_child_assessment_part_query", 
            "match_any_child_assessment_part", 
            "clear_child_assessment_part_terms", 
            "match_bank_id", 
            "clear_bank_id_terms", 
            "supports_bank_query", 
            "get_bank_query", 
            "clear_bank_terms", 
            "get_assessment_part_query_record"
         ], 
         "methods": [
            {
               "name": "match_assessment_id", 
               "doc": {
                  "headline": "Sets the assessment ``Id`` for this query.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    assessment_id (osid.id.Id): an assessment ``Id``\n        arg:    match (boolean): ``true`` for a positive match,\n                ``false`` for a negative match\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``assessment_id`` is ``null``", 
               "sphinx_param_doc": "        :param assessment_id: an assessment ``Id``\n        :type assessment_id: ``osid.id.Id``\n        :param match: ``true`` for a positive match, ``false`` for a negative match\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``assessment_id`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "assessment_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "clear_assessment_id_terms", 
               "doc": {
                  "headline": "Clears all assessment ``Id`` terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "supports_assessment_query", 
               "doc": {
                  "headline": "Tests if an ``AssessmentQuery`` is available.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if an assessment query is\n                available, ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if an assessment query is available, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "get_assessment_query", 
               "doc": {
                  "headline": "Gets the query for an assessment.", 
                  "body": "        Multiple retrievals produce a nested ``OR`` term."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.assessment.AssessmentQuery) - the assessment query", 
               "error_doc": "        raise:  Unimplemented - ``supports_assessment_query()`` is\n                ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the assessment query\n        :rtype: ``osid.assessment.AssessmentQuery``", 
               "sphinx_error_doc": "        :raise: ``Unimplemented`` -- ``supports_assessment_query()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_assessment_query()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.assessment.AssessmentQuery", 
               "errors": {
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "clear_assessment_terms", 
               "doc": {
                  "headline": "Clears all assessment terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "match_parent_assessment_part_id", 
               "doc": {
                  "headline": "Sets the assessment part ``Id`` for this query.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    assessment_part_id (osid.id.Id): an assessment part\n                ``Id``\n        arg:    match (boolean): ``true`` for a positive match,\n                ``false`` for a negative match\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``assessment_part_id`` is ``null``", 
               "sphinx_param_doc": "        :param assessment_part_id: an assessment part ``Id``\n        :type assessment_part_id: ``osid.id.Id``\n        :param match: ``true`` for a positive match, ``false`` for a negative match\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``assessment_part_id`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "assessment_part_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "clear_parent_assessment_part_id_terms", 
               "doc": {
                  "headline": "Clears all assessment part ``Id`` terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "supports_parent_assessment_part_query", 
               "doc": {
                  "headline": "Tests if an ``AssessmentPartQuery`` is available.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if an assessment part query is\n                available, ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if an assessment part query is available, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "get_parent_assessment_part_query", 
               "doc": {
                  "headline": "Gets the query for an assessment part.", 
                  "body": "        Multiple retrievals produce a nested ``OR`` term."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.assessment.authoring.AssessmentPartQuery) - the\n                assessment part query", 
               "error_doc": "        raise:  Unimplemented -\n                ``supports_parent_assessment_part_query()`` is ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the assessment part query\n        :rtype: ``osid.assessment.authoring.AssessmentPartQuery``", 
               "sphinx_error_doc": "        :raise: ``Unimplemented`` -- ``supports_parent_assessment_part_query()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_parent_assessment_part_query()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.assessment.authoring.AssessmentPartQuery", 
               "errors": {
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "match_any_parent_assessment_part", 
               "doc": {
                  "headline": "Matches assessment parts with any parent assessment part.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    match (boolean): ``true`` to match assessment parts with\n                any parent, ``false`` to match assessment parts with no\n                parents\n", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "        :param match: ``true`` to match assessment parts with any parent, ``false`` to match assessment parts with no parents\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "clear_parent_assessment_part_terms", 
               "doc": {
                  "headline": "Clears all assessment part terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "match_section", 
               "doc": {
                  "headline": "Matches assessment parts that are also used as sections.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    match (boolean): ``true`` for a positive match,\n                ``false`` for a negative match\n", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "        :param match: ``true`` for a positive match, ``false`` for a negative match\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "clear_section_terms", 
               "doc": {
                  "headline": "Clears all section terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "match_weight", 
               "doc": {
                  "headline": "Matches assessment parts that fall in between the given weights inclusive.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    low (cardinal): low end of range\n        arg:    high (cardinal): high end of range\n        arg:    match (boolean): ``true`` for a positive match,\n                ``false`` for a negative match\n", 
               "return_doc": "", 
               "error_doc": "        raise:  InvalidArgument - ``high`` is less than ``low``", 
               "sphinx_param_doc": "        :param low: low end of range\n        :type low: ``cardinal``\n        :param high: high end of range\n        :type high: ``cardinal``\n        :param match: ``true`` for a positive match, ``false`` for a negative match\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``InvalidArgument`` -- ``high`` is less than ``low``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "cardinal", 
                     "var_name": "low", 
                     "array": false
                  }, 
                  {
                     "arg_type": "cardinal", 
                     "var_name": "high", 
                     "array": false
                  }, 
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "cardinal", 
                  "cardinal", 
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {
                  "INVALID_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "match_any_weight", 
               "doc": {
                  "headline": "Matches assessment parts with any weight assigned.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    match (boolean): ``true`` to match assessment parts with\n                any wieght, ``false`` to match assessment parts with no\n                weight\n", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "        :param match: ``true`` to match assessment parts with any wieght, ``false`` to match assessment parts with no weight\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "clear_weight_terms", 
               "doc": {
                  "headline": "Clears all weight terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "match_allocated_time", 
               "doc": {
                  "headline": "Matches assessment parts hose allocated time falls in between the given times inclusive.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    low (osid.calendaring.Duration): low end of range\n        arg:    high (osid.calendaring.Duration): high end of range\n        arg:    match (boolean): ``true`` for a positive match,\n                ``false`` for a negative match\n", 
               "return_doc": "", 
               "error_doc": "        raise:  InvalidArgument - ``high`` is less than ``low``", 
               "sphinx_param_doc": "        :param low: low end of range\n        :type low: ``osid.calendaring.Duration``\n        :param high: high end of range\n        :type high: ``osid.calendaring.Duration``\n        :param match: ``true`` for a positive match, ``false`` for a negative match\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``InvalidArgument`` -- ``high`` is less than ``low``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.calendaring.Duration", 
                     "var_name": "low", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.calendaring.Duration", 
                     "var_name": "high", 
                     "array": false
                  }, 
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.calendaring.Duration", 
                  "osid.calendaring.Duration", 
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {
                  "INVALID_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "match_any_allocated_time", 
               "doc": {
                  "headline": "Matches assessment parts with any time assigned.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    match (boolean): ``true`` to match assessment parts with\n                any alloocated time, ``false`` to match assessment parts\n                with no allocated time\n", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "        :param match: ``true`` to match assessment parts with any alloocated time, ``false`` to match assessment parts with no allocated time\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "clear_allocated_time_terms", 
               "doc": {
                  "headline": "Clears all allocated time terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "match_child_assessment_part_id", 
               "doc": {
                  "headline": "Sets the assessment part ``Id`` for this query.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    assessment_part_id (osid.id.Id): an assessment part\n                ``Id``\n        arg:    match (boolean): ``true`` for a positive match,\n                ``false`` for a negative match\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``assessment_part_id`` is ``null``", 
               "sphinx_param_doc": "        :param assessment_part_id: an assessment part ``Id``\n        :type assessment_part_id: ``osid.id.Id``\n        :param match: ``true`` for a positive match, ``false`` for a negative match\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``assessment_part_id`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "assessment_part_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "clear_child_assessment_part_id_terms", 
               "doc": {
                  "headline": "Clears all assessment part ``Id`` terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "supports_child_assessment_part_query", 
               "doc": {
                  "headline": "Tests if an ``AssessmentPartQuery`` is available.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if an assessment part query is\n                available, ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if an assessment part query is available, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "get_child_assessment_part_query", 
               "doc": {
                  "headline": "Gets the query for an assessment part.", 
                  "body": "        Multiple retrievals produce a nested ``OR`` term."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.assessment.authoring.AssessmentPartQuery) - the\n                assessment part query", 
               "error_doc": "        raise:  Unimplemented -\n                ``supports_child_assessment_part_query()`` is ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the assessment part query\n        :rtype: ``osid.assessment.authoring.AssessmentPartQuery``", 
               "sphinx_error_doc": "        :raise: ``Unimplemented`` -- ``supports_child_assessment_part_query()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_child_assessment_part_query()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.assessment.authoring.AssessmentPartQuery", 
               "errors": {
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "match_any_child_assessment_part", 
               "doc": {
                  "headline": "Matches assessment parts with any child assessment part.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    match (boolean): ``true`` to match assessment parts with\n                any children, ``false`` to match assessment parts with\n                no children\n", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "        :param match: ``true`` to match assessment parts with any children, ``false`` to match assessment parts with no children\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "clear_child_assessment_part_terms", 
               "doc": {
                  "headline": "Clears all assessment part terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "match_bank_id", 
               "doc": {
                  "headline": "Matches constrainers mapped to the bank.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    bank_id (osid.id.Id): the bank ``Id``\n        arg:    match (boolean): ``true`` for a positive match,\n                ``false`` for a negative match\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``bank_id`` is ``null``", 
               "sphinx_param_doc": "        :param bank_id: the bank ``Id``\n        :type bank_id: ``osid.id.Id``\n        :param match: ``true`` for a positive match, ``false`` for a negative match\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``bank_id`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "bank_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "clear_bank_id_terms", 
               "doc": {
                  "headline": "Clears the bank ``Id`` query terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "supports_bank_query", 
               "doc": {
                  "headline": "Tests if an ``BankQuery`` is available.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if a bank query is available,\n                ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if a bank query is available, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "get_bank_query", 
               "doc": {
                  "headline": "Gets the query for a bank.", 
                  "body": "        Multiple retrievals produce a nested ``OR`` term."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.assessment.BankQuery) - the bank query", 
               "error_doc": "        raise:  Unimplemented - ``supports_bank_query()`` is ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the bank query\n        :rtype: ``osid.assessment.BankQuery``", 
               "sphinx_error_doc": "        :raise: ``Unimplemented`` -- ``supports_bank_query()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_bank_query()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.assessment.BankQuery", 
               "errors": {
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "clear_bank_terms", 
               "doc": {
                  "headline": "Clears the bank query terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "get_assessment_part_query_record", 
               "doc": {
                  "headline": "Gets the assessment part query record corresponding to the given ``AssessmentPart`` record ``Type``.", 
                  "body": "        Multiple retrievals produce a nested ``OR`` term."
               }, 
               "arg_doc": "        arg:    assessment_part_record_type (osid.type.Type): an\n                assessment part record type\n", 
               "return_doc": "        return:\n                (osid.assessment.authoring.records.AssessmentPartQueryRe\n                cord) - the assessment part query record", 
               "error_doc": "        raise:  NullArgument - ``assessment_part_record_type`` is\n                ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unsupported -\n                ``has_record_type(assessment_part_record_type)`` is\n                ``false``", 
               "sphinx_param_doc": "        :param assessment_part_record_type: an assessment part record type\n        :type assessment_part_record_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "        :return: the assessment part query record\n        :rtype: ``osid.assessment.authoring.records.AssessmentPartQueryRecord``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``assessment_part_record_type`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unsupported`` -- ``has_record_type(assessment_part_record_type)`` is ``false``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "assessment_part_record_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "osid.assessment.authoring.records.AssessmentPartQueryRecord", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.assessment.authoring.records.AssessmentPartQueryRecord", 
         "shortname": "AssessmentPartQueryRecord", 
         "category": "records", 
         "doc": {
            "headline": "A record for an ``AssessmentPartQuery``.", 
            "body": "    The methods specified by the record type are available through the\n    underlying object."
         }, 
         "inherit_fullnames": [
            "osid.OsidRecord"
         ], 
         "inherit_shortnames": [
            "OsidRecord"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidRecord"
            }
         ], 
         "method_names": [], 
         "methods": []
      }, 
      {
         "fullname": "osid.assessment.authoring.AssessmentPartQueryInspector", 
         "shortname": "AssessmentPartQueryInspector", 
         "category": "query_inspectors", 
         "doc": {
            "headline": "This is the query inspector for examining assessment part queries.", 
            "body": ""
         }, 
         "inherit_fullnames": [
            "osid.OsidObjectQueryInspector", 
            "osid.OsidContainableQueryInspector", 
            "osid.OsidOperableQueryInspector"
         ], 
         "inherit_shortnames": [
            "OsidObjectQueryInspector", 
            "OsidContainableQueryInspector", 
            "OsidOperableQueryInspector"
         ], 
         "inherit_pkg_names": [
            "osid", 
            "osid", 
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidObjectQueryInspector"
            }, 
            {
               "pkg_name": "osid", 
               "name": "OsidContainableQueryInspector"
            }, 
            {
               "pkg_name": "osid", 
               "name": "OsidOperableQueryInspector"
            }
         ], 
         "method_names": [
            "get_assessment_id_terms", 
            "get_assessment_terms", 
            "get_parent_assessment_part_id_terms", 
            "get_parent_assessment_part_terms", 
            "get_section_terms", 
            "get_weight_terms", 
            "get_allocated_time_terms", 
            "get_child_assessment_part_id_terms", 
            "get_child_assessment_part_terms", 
            "get_bank_id_terms", 
            "get_bank_terms", 
            "get_assessment_part_query_inspector_record"
         ], 
         "methods": [
            {
               "name": "get_assessment_id_terms", 
               "doc": {
                  "headline": "Gets the assessment ``Id`` query terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.search.terms.IdTerm) - the assessment ``Id`` terms", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the assessment ``Id`` terms\n        :rtype: ``osid.search.terms.IdTerm``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.search.terms.IdTerm", 
               "errors": {}
            }, 
            {
               "name": "get_assessment_terms", 
               "doc": {
                  "headline": "Gets the assessment query terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.assessment.AssessmentQueryInspector) - the\n                assessment terms", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the assessment terms\n        :rtype: ``osid.assessment.AssessmentQueryInspector``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.assessment.AssessmentQueryInspector", 
               "errors": {}
            }, 
            {
               "name": "get_parent_assessment_part_id_terms", 
               "doc": {
                  "headline": "Gets the assessment part ``Id`` query terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.search.terms.IdTerm) - the assessment parent\n                ``Id`` terms", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the assessment parent ``Id`` terms\n        :rtype: ``osid.search.terms.IdTerm``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.search.terms.IdTerm", 
               "errors": {}
            }, 
            {
               "name": "get_parent_assessment_part_terms", 
               "doc": {
                  "headline": "Gets the assessment part query terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.assessment.authoring.AssessmentPartQueryInspector)\n                - the assessment part terms", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the assessment part terms\n        :rtype: ``osid.assessment.authoring.AssessmentPartQueryInspector``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.assessment.authoring.AssessmentPartQueryInspector", 
               "errors": {}
            }, 
            {
               "name": "get_section_terms", 
               "doc": {
                  "headline": "Gets the section query terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.search.terms.BooleanTerm) - the section terms", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the section terms\n        :rtype: ``osid.search.terms.BooleanTerm``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.search.terms.BooleanTerm", 
               "errors": {}
            }, 
            {
               "name": "get_weight_terms", 
               "doc": {
                  "headline": "Gets the weight terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.search.terms.CardinalTerm) - the resource ``Id``\n                terms", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the resource ``Id`` terms\n        :rtype: ``osid.search.terms.CardinalTerm``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.search.terms.CardinalTerm", 
               "errors": {}
            }, 
            {
               "name": "get_allocated_time_terms", 
               "doc": {
                  "headline": "Gets the allocated time terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.search.terms.DurationTerm) - the time terms", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the time terms\n        :rtype: ``osid.search.terms.DurationTerm``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.search.terms.DurationTerm", 
               "errors": {}
            }, 
            {
               "name": "get_child_assessment_part_id_terms", 
               "doc": {
                  "headline": "Gets the assessment part ``Id`` query terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.search.terms.IdTerm) - the assessment parent\n                ``Id`` terms", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the assessment parent ``Id`` terms\n        :rtype: ``osid.search.terms.IdTerm``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.search.terms.IdTerm", 
               "errors": {}
            }, 
            {
               "name": "get_child_assessment_part_terms", 
               "doc": {
                  "headline": "Gets the assessment part query terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.assessment.authoring.AssessmentPartQueryInspector)\n                - the assessment part terms", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the assessment part terms\n        :rtype: ``osid.assessment.authoring.AssessmentPartQueryInspector``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.assessment.authoring.AssessmentPartQueryInspector", 
               "errors": {}
            }, 
            {
               "name": "get_bank_id_terms", 
               "doc": {
                  "headline": "Gets the bank ``Id`` query terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.search.terms.IdTerm) - the query terms", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the query terms\n        :rtype: ``osid.search.terms.IdTerm``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.search.terms.IdTerm", 
               "errors": {}
            }, 
            {
               "name": "get_bank_terms", 
               "doc": {
                  "headline": "Gets the bank query terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.assessment.BankQueryInspector) - the query terms", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the query terms\n        :rtype: ``osid.assessment.BankQueryInspector``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.assessment.BankQueryInspector", 
               "errors": {}
            }, 
            {
               "name": "get_assessment_part_query_inspector_record", 
               "doc": {
                  "headline": "Gets the assessment part query inspector record corresponding to the given ``AssessmentPart`` record ``Type``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    assessment_part_record_type (osid.type.Type): an\n                assessment part record type\n", 
               "return_doc": "        return: (osid.assessment.authoring.records.AssessmentPartQueryIn\n                spectorRecord) - the assessment part query inspector\n                record", 
               "error_doc": "        raise:  NullArgument - ``assessment_part_record_type`` is\n                ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unsupported -\n                ``has_record_type(assessment_part_record_type)`` is\n                ``false``", 
               "sphinx_param_doc": "        :param assessment_part_record_type: an assessment part record type\n        :type assessment_part_record_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "        :return: the assessment part query inspector record\n        :rtype: ``osid.assessment.authoring.records.AssessmentPartQueryInspectorRecord``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``assessment_part_record_type`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unsupported`` -- ``has_record_type(assessment_part_record_type)`` is ``false``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "assessment_part_record_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "osid.assessment.authoring.records.AssessmentPartQueryInspectorRecord", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.assessment.authoring.records.AssessmentPartQueryInspectorRecord", 
         "shortname": "AssessmentPartQueryInspectorRecord", 
         "category": "records", 
         "doc": {
            "headline": "A record for an ``AssessmentPartQueryInspector``.", 
            "body": "    The methods specified by the record type are available through the\n    underlying object."
         }, 
         "inherit_fullnames": [
            "osid.OsidRecord"
         ], 
         "inherit_shortnames": [
            "OsidRecord"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidRecord"
            }
         ], 
         "method_names": [], 
         "methods": []
      }, 
      {
         "fullname": "osid.assessment.authoring.AssessmentPartForm", 
         "shortname": "AssessmentPartForm", 
         "category": "objects", 
         "doc": {
            "headline": "This is the form for creating and updating ``AssessmentParts``.", 
            "body": "    Like all ``OsidForm`` objects, various data elements may be set here\n    for use in the create and update methods in the\n    ``AssessmentAuthoringSession``. For each data element that may be\n    set, metadata may be examined to provide display hints or data\n    constraints."
         }, 
         "inherit_fullnames": [
            "osid.OsidObjectForm", 
            "osid.OsidContainableForm", 
            "osid.OsidOperableForm"
         ], 
         "inherit_shortnames": [
            "OsidObjectForm", 
            "OsidContainableForm", 
            "OsidOperableForm"
         ], 
         "inherit_pkg_names": [
            "osid", 
            "osid", 
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidObjectForm"
            }, 
            {
               "pkg_name": "osid", 
               "name": "OsidContainableForm"
            }, 
            {
               "pkg_name": "osid", 
               "name": "OsidOperableForm"
            }
         ], 
         "method_names": [
            "get_weight_metadata", 
            "set_weight", 
            "clear_weight", 
            "get_allocated_time_metadata", 
            "set_allocated_time", 
            "clear_allocated_time", 
            "get_assessment_part_form_record"
         ], 
         "methods": [
            {
               "name": "get_weight_metadata", 
               "doc": {
                  "headline": "Gets the metadata for the weight.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.Metadata) - metadata for the weight", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: metadata for the weight\n        :rtype: ``osid.Metadata``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.Metadata", 
               "errors": {}
            }, 
            {
               "name": "set_weight", 
               "doc": {
                  "headline": "Sets the weight on a scale from 0-100.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    weight (cardinal): the new weight\n", 
               "return_doc": "", 
               "error_doc": "        raise:  InvalidArgument - ``weight`` is invalid\n        raise:  NoAccess - ``Metadata.isReadOnly()`` is ``true``", 
               "sphinx_param_doc": "        :param weight: the new weight\n        :type weight: ``cardinal``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``InvalidArgument`` -- ``weight`` is invalid\n        :raise: ``NoAccess`` -- ``Metadata.isReadOnly()`` is ``true``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "cardinal", 
                     "var_name": "weight", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "cardinal"
               ], 
               "return_type": "", 
               "errors": {
                  "INVALID_ARGUMENT": "ConsumerContract", 
                  "NO_ACCESS": "ConsumerContract"
               }
            }, 
            {
               "name": "clear_weight", 
               "doc": {
                  "headline": "Clears the weight.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "        raise:  NoAccess - ``Metadata.isRequired()`` or\n                ``Metadata.isReadOnly()`` is ``true``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NoAccess`` -- ``Metadata.isRequired()`` or ``Metadata.isReadOnly()`` is ``true``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {
                  "NO_ACCESS": "ConsumerContract"
               }
            }, 
            {
               "name": "get_allocated_time_metadata", 
               "doc": {
                  "headline": "Gets the metadata for the allocated time.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.Metadata) - metadata for the allocated time", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: metadata for the allocated time\n        :rtype: ``osid.Metadata``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.Metadata", 
               "errors": {}
            }, 
            {
               "name": "set_allocated_time", 
               "doc": {
                  "headline": "Sets the allocated time.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    time (osid.calendaring.Duration): the allocated time\n", 
               "return_doc": "", 
               "error_doc": "        raise:  InvalidArgument - ``time`` is invalid\n        raise:  NoAccess - ``Metadata.isReadOnly()`` is ``true``", 
               "sphinx_param_doc": "        :param time: the allocated time\n        :type time: ``osid.calendaring.Duration``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``InvalidArgument`` -- ``time`` is invalid\n        :raise: ``NoAccess`` -- ``Metadata.isReadOnly()`` is ``true``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.calendaring.Duration", 
                     "var_name": "time", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.calendaring.Duration"
               ], 
               "return_type": "", 
               "errors": {
                  "INVALID_ARGUMENT": "ConsumerContract", 
                  "NO_ACCESS": "ConsumerContract"
               }
            }, 
            {
               "name": "clear_allocated_time", 
               "doc": {
                  "headline": "Clears the allocated time.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "        raise:  NoAccess - ``Metadata.isRequired()`` or\n                ``Metadata.isReadOnly()`` is ``true``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NoAccess`` -- ``Metadata.isRequired()`` or ``Metadata.isReadOnly()`` is ``true``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {
                  "NO_ACCESS": "ConsumerContract"
               }
            }, 
            {
               "name": "get_assessment_part_form_record", 
               "doc": {
                  "headline": "Gets the ``AssessmentPartFormRecord`` corresponding to the given assessment record ``Type``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    assessment_part_record_type (osid.type.Type): the\n                assessment part record type\n", 
               "return_doc": "        return:\n                (osid.assessment.authoring.records.AssessmentPartFormRec\n                ord) - the assessment part record", 
               "error_doc": "        raise:  NullArgument - ``assessment_part_record_type`` is\n                ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unsupported -\n                ``has_record_type(assessment_part_record_type)`` is\n                ``false``", 
               "sphinx_param_doc": "        :param assessment_part_record_type: the assessment part record type\n        :type assessment_part_record_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "        :return: the assessment part record\n        :rtype: ``osid.assessment.authoring.records.AssessmentPartFormRecord``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``assessment_part_record_type`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unsupported`` -- ``has_record_type(assessment_part_record_type)`` is ``false``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "assessment_part_record_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "osid.assessment.authoring.records.AssessmentPartFormRecord", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.assessment.authoring.records.AssessmentPartFormRecord", 
         "shortname": "AssessmentPartFormRecord", 
         "category": "records", 
         "doc": {
            "headline": "A record for an ``AssessmentPartForm``.", 
            "body": "    The methods specified by the record type are available through the\n    underlying object."
         }, 
         "inherit_fullnames": [
            "osid.OsidRecord"
         ], 
         "inherit_shortnames": [
            "OsidRecord"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidRecord"
            }
         ], 
         "method_names": [], 
         "methods": []
      }, 
      {
         "fullname": "osid.assessment.authoring.AssessmentPartSearchOrder", 
         "shortname": "AssessmentPartSearchOrder", 
         "category": "search_orders", 
         "doc": {
            "headline": "An interface for specifying the ordering of search results.", 
            "body": ""
         }, 
         "inherit_fullnames": [
            "osid.OsidObjectSearchOrder", 
            "osid.OsidContainableSearchOrder", 
            "osid.OsidOperableSearchOrder"
         ], 
         "inherit_shortnames": [
            "OsidObjectSearchOrder", 
            "OsidContainableSearchOrder", 
            "OsidOperableSearchOrder"
         ], 
         "inherit_pkg_names": [
            "osid", 
            "osid", 
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidObjectSearchOrder"
            }, 
            {
               "pkg_name": "osid", 
               "name": "OsidContainableSearchOrder"
            }, 
            {
               "pkg_name": "osid", 
               "name": "OsidOperableSearchOrder"
            }
         ], 
         "method_names": [
            "order_by_assessment", 
            "supports_assessment_search_order", 
            "get_assessment_search_order", 
            "order_by_section", 
            "order_by_weight", 
            "order_by_allocated_time", 
            "get_assessment_part_search_order_record"
         ], 
         "methods": [
            {
               "name": "order_by_assessment", 
               "doc": {
                  "headline": "Specifies a preference for ordering the result set by the assessment.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    style (osid.SearchOrderStyle): search order style\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``style`` is ``null``", 
               "sphinx_param_doc": "        :param style: search order style\n        :type style: ``osid.SearchOrderStyle``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``style`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.SearchOrderStyle", 
                     "var_name": "style", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.SearchOrderStyle"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "supports_assessment_search_order", 
               "doc": {
                  "headline": "Tests if an assessment search order is available.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if an assessment search order is\n                available, ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if an assessment search order is available, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "get_assessment_search_order", 
               "doc": {
                  "headline": "Gets the assessment order.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.assessment.AssessmentSearchOrder) - the assessment\n                search order", 
               "error_doc": "        raise:  Unimplemented - ``supports_assessment_search_order()``\n                is ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the assessment search order\n        :rtype: ``osid.assessment.AssessmentSearchOrder``", 
               "sphinx_error_doc": "        :raise: ``Unimplemented`` -- ``supports_assessment_search_order()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_assessment_search_order()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.assessment.AssessmentSearchOrder", 
               "errors": {
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "order_by_section", 
               "doc": {
                  "headline": "Specifies a preference for ordering the result set by the section.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    style (osid.SearchOrderStyle): search order style\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``style`` is ``null``", 
               "sphinx_param_doc": "        :param style: search order style\n        :type style: ``osid.SearchOrderStyle``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``style`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.SearchOrderStyle", 
                     "var_name": "style", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.SearchOrderStyle"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "order_by_weight", 
               "doc": {
                  "headline": "Specifies a preference for ordering the result set by the weight.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    style (osid.SearchOrderStyle): search order style\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``style`` is ``null``", 
               "sphinx_param_doc": "        :param style: search order style\n        :type style: ``osid.SearchOrderStyle``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``style`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.SearchOrderStyle", 
                     "var_name": "style", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.SearchOrderStyle"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "order_by_allocated_time", 
               "doc": {
                  "headline": "Specifies a preference for ordering the result set by the allocated time.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    style (osid.SearchOrderStyle): search order style\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``style`` is ``null``", 
               "sphinx_param_doc": "        :param style: search order style\n        :type style: ``osid.SearchOrderStyle``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``style`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.SearchOrderStyle", 
                     "var_name": "style", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.SearchOrderStyle"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "get_assessment_part_search_order_record", 
               "doc": {
                  "headline": "Gets the assessment part search order record corresponding to the given assessment part record ``Type``.", 
                  "body": "        Multiple retrievals return the same underlying object."
               }, 
               "arg_doc": "        arg:    assessment_part_record_type (osid.type.Type): an\n                assessment part record type\n", 
               "return_doc": "        return: (osid.assessment.authoring.records.AssessmentPartSearchO\n                rderRecord) - the assessment part search order record", 
               "error_doc": "        raise:  NullArgument - ``assessment_part_record_type`` is\n                ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unsupported -\n                ``has_record_type(assessment_part_record_type)`` is\n                ``false``", 
               "sphinx_param_doc": "        :param assessment_part_record_type: an assessment part record type\n        :type assessment_part_record_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "        :return: the assessment part search order record\n        :rtype: ``osid.assessment.authoring.records.AssessmentPartSearchOrderRecord``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``assessment_part_record_type`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unsupported`` -- ``has_record_type(assessment_part_record_type)`` is ``false``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "assessment_part_record_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "osid.assessment.authoring.records.AssessmentPartSearchOrderRecord", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.assessment.authoring.records.AssessmentPartSearchOrderRecord", 
         "shortname": "AssessmentPartSearchOrderRecord", 
         "category": "records", 
         "doc": {
            "headline": "A record for an ``AssessmentPartSearchOrder``.", 
            "body": "    The methods specified by the record type are available through the\n    underlying object."
         }, 
         "inherit_fullnames": [
            "osid.OsidRecord"
         ], 
         "inherit_shortnames": [
            "OsidRecord"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidRecord"
            }
         ], 
         "method_names": [], 
         "methods": []
      }, 
      {
         "fullname": "osid.assessment.authoring.AssessmentPartSearch", 
         "shortname": "AssessmentPartSearch", 
         "category": "searches", 
         "doc": {
            "headline": "The search interface for governing assessment part searches.", 
            "body": ""
         }, 
         "inherit_fullnames": [
            "osid.OsidSearch"
         ], 
         "inherit_shortnames": [
            "OsidSearch"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidSearch"
            }
         ], 
         "method_names": [
            "search_among_assessment_parts", 
            "order_assessment_part_results", 
            "get_assessment_part_search_record"
         ], 
         "methods": [
            {
               "name": "search_among_assessment_parts", 
               "doc": {
                  "headline": "Execute this search among the given list of assessment parts.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    bank_ids (osid.id.IdList): list of assessment parts\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``bank_ids`` is ``null``", 
               "sphinx_param_doc": "        :param bank_ids: list of assessment parts\n        :type bank_ids: ``osid.id.IdList``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``bank_ids`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.IdList", 
                     "var_name": "bank_ids", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.IdList"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "order_assessment_part_results", 
               "doc": {
                  "headline": "Specify an ordering to the search results.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    assessment_part_search_order\n                (osid.assessment.authoring.AssessmentPartSearchOrder):\n                assessment part search order\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``assessment_part_search_order`` is\n                ``null``\n        raise:  Unsupported - ``assessment_part_search_order`` is not of\n                this service", 
               "sphinx_param_doc": "        :param assessment_part_search_order: assessment part search order\n        :type assessment_part_search_order: ``osid.assessment.authoring.AssessmentPartSearchOrder``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``assessment_part_search_order`` is ``null``\n        :raise: ``Unsupported`` -- ``assessment_part_search_order`` is not of this service", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.assessment.authoring.AssessmentPartSearchOrder", 
                     "var_name": "assessment_part_search_order", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.assessment.authoring.AssessmentPartSearchOrder"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_assessment_part_search_record", 
               "doc": {
                  "headline": "Gets the assessment part search record corresponding to the given assessment part search record ``Type``.", 
                  "body": "        This method is used to retrieve an object implementing the\n        requested record."
               }, 
               "arg_doc": "        arg:    assessment_part_search_record_type (osid.type.Type): an\n                assessment part search record type\n", 
               "return_doc": "        return:\n                (osid.assessment.authoring.records.AssessmentPartSearchR\n                ecord) - the assessment part search record", 
               "error_doc": "        raise:  NullArgument - ``assessment_part_search_record_type`` is\n                ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unsupported -\n                ``has_record_type(assessment_part_search_record_type)``\n                is ``false``", 
               "sphinx_param_doc": "        :param assessment_part_search_record_type: an assessment part search record type\n        :type assessment_part_search_record_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "        :return: the assessment part search record\n        :rtype: ``osid.assessment.authoring.records.AssessmentPartSearchRecord``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``assessment_part_search_record_type`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unsupported`` -- ``has_record_type(assessment_part_search_record_type)`` is ``false``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "assessment_part_search_record_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "osid.assessment.authoring.records.AssessmentPartSearchRecord", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.assessment.authoring.records.AssessmentPartSearchRecord", 
         "shortname": "AssessmentPartSearchRecord", 
         "category": "records", 
         "doc": {
            "headline": "A record for an ``AssessmentPartSearch``.", 
            "body": "    The methods specified by the record type are available through the\n    underlying object."
         }, 
         "inherit_fullnames": [
            "osid.OsidRecord"
         ], 
         "inherit_shortnames": [
            "OsidRecord"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidRecord"
            }
         ], 
         "method_names": [], 
         "methods": []
      }, 
      {
         "fullname": "osid.assessment.authoring.AssessmentPartSearchResults", 
         "shortname": "AssessmentPartSearchResults", 
         "category": "searches", 
         "doc": {
            "headline": "This interface provides a means to capture results of a search.", 
            "body": ""
         }, 
         "inherit_fullnames": [
            "osid.OsidSearchResults"
         ], 
         "inherit_shortnames": [
            "OsidSearchResults"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidSearchResults"
            }
         ], 
         "method_names": [
            "get_assessment_parts", 
            "get_assessment_part_query_inspector", 
            "get_assessment_part_search_results_record"
         ], 
         "methods": [
            {
               "name": "get_assessment_parts", 
               "doc": {
                  "headline": "Gets the ``AssessmentPartList`` resulting from a search.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.assessment.authoring.AssessmentPartList) - the\n                assessment part list", 
               "error_doc": "        raise:  IllegalState - list has already been retrieved", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the assessment part list\n        :rtype: ``osid.assessment.authoring.AssessmentPartList``", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- list has already been retrieved", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.assessment.authoring.AssessmentPartList", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract"
               }
            }, 
            {
               "name": "get_assessment_part_query_inspector", 
               "doc": {
                  "headline": "Gets the inspector for the query to examine the terms used in the search.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.assessment.authoring.AssessmentPartQueryInspector)\n                - the assessment part query inspector", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the assessment part query inspector\n        :rtype: ``osid.assessment.authoring.AssessmentPartQueryInspector``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.assessment.authoring.AssessmentPartQueryInspector", 
               "errors": {}
            }, 
            {
               "name": "get_assessment_part_search_results_record", 
               "doc": {
                  "headline": "Gets the assessment part search results record corresponding to the given assessment part search record ``Type``.", 
                  "body": "        This method must be used to retrieve an object implementing the\n        requested record."
               }, 
               "arg_doc": "        arg:    assessment_part_search_record_type (osid.type.Type): an\n                assessment part search record type\n", 
               "return_doc": "        return: (osid.assessment.authoring.records.AssessmentPartSearchR\n                esultsRecord) - the assessment part search results\n                record", 
               "error_doc": "        raise:  NullArgument - ``assessment_part_search_record_type`` is\n                ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure occurred\n        raise:  Unsupported -\n                ``has_record_type(assessment_part_search_record_type)``\n                is ``false``", 
               "sphinx_param_doc": "        :param assessment_part_search_record_type: an assessment part search record type\n        :type assessment_part_search_record_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "        :return: the assessment part search results record\n        :rtype: ``osid.assessment.authoring.records.AssessmentPartSearchResultsRecord``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``assessment_part_search_record_type`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure occurred\n        :raise: ``Unsupported`` -- ``has_record_type(assessment_part_search_record_type)`` is ``false``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "assessment_part_search_record_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "osid.assessment.authoring.records.AssessmentPartSearchResultsRecord", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.assessment.authoring.records.AssessmentPartSearchResultsRecord", 
         "shortname": "AssessmentPartSearchResultsRecord", 
         "category": "records", 
         "doc": {
            "headline": "A record for an ``AssessmentPartSearchResults``.", 
            "body": "    The methods specified by the record type are available through the\n    underlying object."
         }, 
         "inherit_fullnames": [
            "osid.OsidRecord"
         ], 
         "inherit_shortnames": [
            "OsidRecord"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidRecord"
            }
         ], 
         "method_names": [], 
         "methods": []
      }, 
      {
         "fullname": "osid.assessment.authoring.AssessmentPartReceiver", 
         "shortname": "AssessmentPartReceiver", 
         "category": "receivers", 
         "doc": {
            "headline": "The assessment part receiver is the consumer supplied interface for receiving notifications pertaining to new, updated or deleted assessment parts.", 
            "body": ""
         }, 
         "inherit_fullnames": [
            "osid.OsidReceiver"
         ], 
         "inherit_shortnames": [
            "OsidReceiver"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidReceiver"
            }
         ], 
         "method_names": [
            "new_assessment_part", 
            "changed_assessment_part", 
            "deleted_assessment_part"
         ], 
         "methods": [
            {
               "name": "new_assessment_part", 
               "doc": {
                  "headline": "The callback for notifications of new assessment parts.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    assessment_part_id (osid.id.Id): the ``Id`` of the new\n                ``AssessmentPart``\n", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "        :param assessment_part_id: the ``Id`` of the new ``AssessmentPart``\n        :type assessment_part_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "assessment_part_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "changed_assessment_part", 
               "doc": {
                  "headline": "The callback for notification of updated assessment parts.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    assessment_part_id (osid.id.Id): the ``Id`` of the\n                updated ``AssessmentPart``\n", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "        :param assessment_part_id: the ``Id`` of the updated ``AssessmentPart``\n        :type assessment_part_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "assessment_part_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "deleted_assessment_part", 
               "doc": {
                  "headline": "The callback for notification of deleted assessment parts.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    assessment_part_id (osid.id.Id): the ``Id`` of the\n                deleted ``AssessmentPart``\n", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "        :param assessment_part_id: the ``Id`` of the deleted ``AssessmentPart``\n        :type assessment_part_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "assessment_part_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {}
            }
         ]
      }, 
      {
         "fullname": "osid.assessment.authoring.AssessmentPartList", 
         "shortname": "AssessmentPartList", 
         "category": "objects", 
         "doc": {
            "headline": "Like all ``OsidLists,``  ``AssessmentPartList`` provides a means for accessing ``AssessmentPart`` elements sequentially either one at a time or many at a time.", 
            "body": "    Examples: while (apl.hasNext()) { AssessmentPart assessmentPart =\n    apl.getNextAssessmentPart(); }\n\n    or\n      while (apl.hasNext()) {\n           AssessmentPart[] assessmentParts = apl.hetNextAssessmentParts(apl.available());\n      }\n    \n"
         }, 
         "inherit_fullnames": [
            "osid.OsidList"
         ], 
         "inherit_shortnames": [
            "OsidList"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidList"
            }
         ], 
         "method_names": [
            "get_next_assessment_part", 
            "get_next_assessment_parts"
         ], 
         "methods": [
            {
               "name": "get_next_assessment_part", 
               "doc": {
                  "headline": "Gets the next ``AssessmentPart`` in this list.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.assessment.authoring.AssessmentPart) - the next\n                ``AssessmentPart`` in this list. The ``has_next()``\n                method should be used to test that a next\n                ``AssessmentPart`` is available before calling this\n                method.", 
               "error_doc": "        raise:  IllegalState - no more elements available in this list\n        raise:  OperationFailed - unable to complete request", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the next ``AssessmentPart`` in this list. The ``has_next()`` method should be used to test that a next ``AssessmentPart`` is available before calling this method.\n        :rtype: ``osid.assessment.authoring.AssessmentPart``", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- no more elements available in this list\n        :raise: ``OperationFailed`` -- unable to complete request", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.assessment.authoring.AssessmentPart", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational"
               }
            }, 
            {
               "name": "get_next_assessment_parts", 
               "doc": {
                  "headline": "Gets the next set of ``AssessmentPart`` elements in this list which must be less than or equal to the number returned from ``available()``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    n (cardinal): the number of ``AssessmentPart`` elements\n                requested which should be less than or equal to\n                ``available()``\n", 
               "return_doc": "        return: (osid.assessment.authoring.AssessmentPart) - an array of\n                ``AssessmentPart`` elements.The length of the array is\n                less than or equal to the number specified.", 
               "error_doc": "        raise:  IllegalState - no more elements available in this list\n        raise:  OperationFailed - unable to complete request", 
               "sphinx_param_doc": "        :param n: the number of ``AssessmentPart`` elements requested which should be less than or equal to ``available()``\n        :type n: ``cardinal``\n", 
               "sphinx_return_doc": "        :return: an array of ``AssessmentPart`` elements.The length of the array is less than or equal to the number specified.\n        :rtype: ``osid.assessment.authoring.AssessmentPart``", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- no more elements available in this list\n        :raise: ``OperationFailed`` -- unable to complete request", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "cardinal", 
                     "var_name": "n", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "cardinal"
               ], 
               "return_type": "osid.assessment.authoring.AssessmentPart", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.assessment.authoring.SequenceRule", 
         "shortname": "SequenceRule", 
         "category": "objects", 
         "doc": {
            "headline": "A ``SequenceRule`` defines the ordering of ``AssessmentParts``.", 
            "body": ""
         }, 
         "inherit_fullnames": [
            "osid.OsidRule"
         ], 
         "inherit_shortnames": [
            "OsidRule"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidRule"
            }
         ], 
         "method_names": [
            "get_assessment_part_id", 
            "get_assessment_part", 
            "get_next_assessment_part_id", 
            "get_next_assessment_part", 
            "get_minimum_score", 
            "get_maximum_score", 
            "is_cumulative", 
            "get_applied_assessment_part_ids", 
            "get_applied_assessment_parts", 
            "get_sequence_rule_record"
         ], 
         "methods": [
            {
               "name": "get_assessment_part_id", 
               "doc": {
                  "headline": "Gets the assessment part ``Id`` to which this rule belongs.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.id.Id) - ``Id`` of an assessment part", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``Id`` of an assessment part\n        :rtype: ``osid.id.Id``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.id.Id", 
               "errors": {}
            }, 
            {
               "name": "get_assessment_part", 
               "doc": {
                  "headline": "Gets the assessment part to which this rule belongs.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.assessment.authoring.AssessmentPart) - an\n                assessment part", 
               "error_doc": "        raise:  OperationFailed - unable to complete request", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: an assessment part\n        :rtype: ``osid.assessment.authoring.AssessmentPart``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.assessment.authoring.AssessmentPart", 
               "errors": {
                  "OPERATION_FAILED": "Operational"
               }
            }, 
            {
               "name": "get_next_assessment_part_id", 
               "doc": {
                  "headline": "Gets the next assessment part ``Id`` for success of this rule.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.id.Id) - ``Id`` of an assessment part", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``Id`` of an assessment part\n        :rtype: ``osid.id.Id``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.id.Id", 
               "errors": {}
            }, 
            {
               "name": "get_next_assessment_part", 
               "doc": {
                  "headline": "Gets the next assessment part for success of this rule.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.assessment.authoring.AssessmentPart) - an\n                assessment part", 
               "error_doc": "        raise:  OperationFailed - unable to complete request", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: an assessment part\n        :rtype: ``osid.assessment.authoring.AssessmentPart``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.assessment.authoring.AssessmentPart", 
               "errors": {
                  "OPERATION_FAILED": "Operational"
               }
            }, 
            {
               "name": "get_minimum_score", 
               "doc": {
                  "headline": "Gets the minimum score expressed as an integer (0-100) for this rule.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (cardinal) - minimum score", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: minimum score\n        :rtype: ``cardinal``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "cardinal", 
               "errors": {}
            }, 
            {
               "name": "get_maximum_score", 
               "doc": {
                  "headline": "Gets the maximum score expressed as an integer (0-100) for this rule.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (cardinal) - maximum score", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: maximum score\n        :rtype: ``cardinal``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "cardinal", 
               "errors": {}
            }, 
            {
               "name": "is_cumulative", 
               "doc": {
                  "headline": "Tests if the score is applied to all previous assessment parts.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if the score is applied to all\n                previous assessment parts, ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if the score is applied to all previous assessment parts, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "get_applied_assessment_part_ids", 
               "doc": {
                  "headline": "Qualifies ``is_cumulative()`` to apply to a specific list of assessment parts.", 
                  "body": "        If ``is_cumulative()`` is ``true,`` this method may return an\n        empty list to mean all previous assessment parts."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.id.IdList) - list of assessment parts", 
               "error_doc": "        raise:  IllegalState - ``is_cumulative()`` is ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: list of assessment parts\n        :rtype: ``osid.id.IdList``", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- ``is_cumulative()`` is ``false``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.id.IdList", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract"
               }
            }, 
            {
               "name": "get_applied_assessment_parts", 
               "doc": {
                  "headline": "Qualifies ``is_cumulative()`` to apply to a specific list of assessment parts.", 
                  "body": "        If ``is_cumulative()`` is ``true,`` this method may return an\n        empty list to mean all previous assessment parts."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.assessment.authoring.AssessmentPartList) - list of\n                assessment parts", 
               "error_doc": "        raise:  IllegalState - ``is_cumulative()`` is ``false``\n        raise:  OperationFailed - unable to complete request", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: list of assessment parts\n        :rtype: ``osid.assessment.authoring.AssessmentPartList``", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- ``is_cumulative()`` is ``false``\n        :raise: ``OperationFailed`` -- unable to complete request", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.assessment.authoring.AssessmentPartList", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational"
               }
            }, 
            {
               "name": "get_sequence_rule_record", 
               "doc": {
                  "headline": "Gets the assessment sequence rule record corresponding to the given ``SequenceRule`` record ``Type``.", 
                  "body": "        This method is used to retrieve an object implementing the\n        requested record. The ``sequence_rule_record_type`` may be the\n        ``Type`` returned in ``get_record_types()`` or any of its\n        parents in a ``Type`` hierarchy where\n        ``has_record_type(sequence_rule_record_type)`` is ``true`` ."
               }, 
               "arg_doc": "        arg:    sequence_rule_record_type (osid.type.Type): the type of\n                the record to retrieve\n", 
               "return_doc": "        return: (osid.assessment.authoring.records.SequenceRuleRecord) -\n                the assessment sequence rule record", 
               "error_doc": "        raise:  NullArgument - ``sequence_rule_record_type`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unsupported -\n                ``has_record_type(sequence_rule_record_type)`` is\n                ``false``", 
               "sphinx_param_doc": "        :param sequence_rule_record_type: the type of the record to retrieve\n        :type sequence_rule_record_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "        :return: the assessment sequence rule record\n        :rtype: ``osid.assessment.authoring.records.SequenceRuleRecord``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``sequence_rule_record_type`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unsupported`` -- ``has_record_type(sequence_rule_record_type)`` is ``false``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "sequence_rule_record_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "osid.assessment.authoring.records.SequenceRuleRecord", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.assessment.authoring.records.SequenceRuleRecord", 
         "shortname": "SequenceRuleRecord", 
         "category": "records", 
         "doc": {
            "headline": "A record for a ``SequenceRule``.", 
            "body": "    The methods specified by the record type are available through the\n    underlying object."
         }, 
         "inherit_fullnames": [
            "osid.OsidRecord"
         ], 
         "inherit_shortnames": [
            "OsidRecord"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidRecord"
            }
         ], 
         "method_names": [], 
         "methods": []
      }, 
      {
         "fullname": "osid.assessment.authoring.SequenceRuleQuery", 
         "shortname": "SequenceRuleQuery", 
         "category": "queries", 
         "doc": {
            "headline": "This is the query for searching sequence rules.", 
            "body": "    Each method match specifies a ``AND`` term while multiple\n    invocations of the same method produce a nested ``OR``."
         }, 
         "inherit_fullnames": [
            "osid.OsidRuleQuery"
         ], 
         "inherit_shortnames": [
            "OsidRuleQuery"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidRuleQuery"
            }
         ], 
         "method_names": [
            "match_assessment_part_id", 
            "clear_assessment_part_id_terms", 
            "supports_assessment_part_query", 
            "get_assessment_part_query", 
            "clear_assessment_part_terms", 
            "match_next_assessment_part_id", 
            "clear_next_assessment_part_id_terms", 
            "supports_next_assessment_part_query", 
            "get_next_assessment_part_query", 
            "clear_next_assessment_part_terms", 
            "match_minimum_score", 
            "match_any_minimum_score", 
            "clear_minimum_score_terms", 
            "match_maximum_score", 
            "match_any_maximum_score", 
            "clear_maximum_score_terms", 
            "match_cumulative", 
            "clear_cumulative_terms", 
            "match_applied_assessment_part_id", 
            "clear_applied_assessment_part_id_terms", 
            "supports_applied_assessment_part_query", 
            "get_applied_assessment_part_query", 
            "match_any_applied_assessment_part", 
            "clear_applied_assessment_part_terms", 
            "match_bank_id", 
            "clear_bank_id_terms", 
            "supports_bank_query", 
            "get_bank_query", 
            "clear_bank_terms", 
            "get_sequence_rule_query_record"
         ], 
         "methods": [
            {
               "name": "match_assessment_part_id", 
               "doc": {
                  "headline": "Sets the assessment part ``Id`` for this query.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    assessment_part_id (osid.id.Id): an assessment part\n                ``Id``\n        arg:    match (boolean): ``true`` for a positive match,\n                ``false`` for a negative match\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``assessment_part_id`` is ``null``", 
               "sphinx_param_doc": "        :param assessment_part_id: an assessment part ``Id``\n        :type assessment_part_id: ``osid.id.Id``\n        :param match: ``true`` for a positive match, ``false`` for a negative match\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``assessment_part_id`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "assessment_part_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "clear_assessment_part_id_terms", 
               "doc": {
                  "headline": "Clears all assessment part ``Id`` terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "supports_assessment_part_query", 
               "doc": {
                  "headline": "Tests if an ``AssessmentPartQuery`` is available.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if an assessment part query is\n                available, ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if an assessment part query is available, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "get_assessment_part_query", 
               "doc": {
                  "headline": "Gets the query for an assessment part.", 
                  "body": "        Multiple retrievals produce a nested ``OR`` term."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.assessment.authoring.AssessmentPartQuery) - the\n                assessment part query", 
               "error_doc": "        raise:  Unimplemented - ``supports_assessment_part_query()`` is\n                ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the assessment part query\n        :rtype: ``osid.assessment.authoring.AssessmentPartQuery``", 
               "sphinx_error_doc": "        :raise: ``Unimplemented`` -- ``supports_assessment_part_query()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_assessment_part_query()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.assessment.authoring.AssessmentPartQuery", 
               "errors": {
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "clear_assessment_part_terms", 
               "doc": {
                  "headline": "Clears all assessment part terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "match_next_assessment_part_id", 
               "doc": {
                  "headline": "Sets the assessment part ``Id`` for this query.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    assessment_part_id (osid.id.Id): an assessment part\n                ``Id``\n        arg:    match (boolean): ``true`` for a positive match,\n                ``false`` for a negative match\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``assessment_part_id`` is ``null``", 
               "sphinx_param_doc": "        :param assessment_part_id: an assessment part ``Id``\n        :type assessment_part_id: ``osid.id.Id``\n        :param match: ``true`` for a positive match, ``false`` for a negative match\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``assessment_part_id`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "assessment_part_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "clear_next_assessment_part_id_terms", 
               "doc": {
                  "headline": "Clears all assessment part ``Id`` terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "supports_next_assessment_part_query", 
               "doc": {
                  "headline": "Tests if an ``AssessmentPartQuery`` is available.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if an assessment part query is\n                available, ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if an assessment part query is available, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "get_next_assessment_part_query", 
               "doc": {
                  "headline": "Gets the query for an assessment part.", 
                  "body": "        Multiple retrievals produce a nested ``OR`` term."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.assessment.authoring.AssessmentPartQuery) - the\n                assessment part query", 
               "error_doc": "        raise:  Unimplemented -\n                ``supports_next_assessment_part_query()`` is ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the assessment part query\n        :rtype: ``osid.assessment.authoring.AssessmentPartQuery``", 
               "sphinx_error_doc": "        :raise: ``Unimplemented`` -- ``supports_next_assessment_part_query()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_next_assessment_part_query()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.assessment.authoring.AssessmentPartQuery", 
               "errors": {
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "clear_next_assessment_part_terms", 
               "doc": {
                  "headline": "Clears all assessment part terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "match_minimum_score", 
               "doc": {
                  "headline": "Matches minimum scores that fall in between the given scores inclusive.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    low (cardinal): low end of range\n        arg:    high (cardinal): high end of range\n        arg:    match (boolean): ``true`` for a positive match,\n                ``false`` for a negative match\n", 
               "return_doc": "", 
               "error_doc": "        raise:  InvalidArgument - ``high`` is less than ``low``", 
               "sphinx_param_doc": "        :param low: low end of range\n        :type low: ``cardinal``\n        :param high: high end of range\n        :type high: ``cardinal``\n        :param match: ``true`` for a positive match, ``false`` for a negative match\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``InvalidArgument`` -- ``high`` is less than ``low``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "cardinal", 
                     "var_name": "low", 
                     "array": false
                  }, 
                  {
                     "arg_type": "cardinal", 
                     "var_name": "high", 
                     "array": false
                  }, 
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "cardinal", 
                  "cardinal", 
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {
                  "INVALID_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "match_any_minimum_score", 
               "doc": {
                  "headline": "Matches assessment parts with any minimum score assigned.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    match (boolean): ``true`` to match assessment parts with\n                any minimum score, ``false`` to match assessment parts\n                with no minimum score\n", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "        :param match: ``true`` to match assessment parts with any minimum score, ``false`` to match assessment parts with no minimum score\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "clear_minimum_score_terms", 
               "doc": {
                  "headline": "Clears all minimum score terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "match_maximum_score", 
               "doc": {
                  "headline": "Matches maximum scores that fall in between the given scores inclusive.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    low (cardinal): low end of range\n        arg:    high (cardinal): high end of range\n        arg:    match (boolean): ``true`` for a positive match,\n                ``false`` for a negative match\n", 
               "return_doc": "", 
               "error_doc": "        raise:  InvalidArgument - ``high`` is less than ``low``", 
               "sphinx_param_doc": "        :param low: low end of range\n        :type low: ``cardinal``\n        :param high: high end of range\n        :type high: ``cardinal``\n        :param match: ``true`` for a positive match, ``false`` for a negative match\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``InvalidArgument`` -- ``high`` is less than ``low``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "cardinal", 
                     "var_name": "low", 
                     "array": false
                  }, 
                  {
                     "arg_type": "cardinal", 
                     "var_name": "high", 
                     "array": false
                  }, 
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "cardinal", 
                  "cardinal", 
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {
                  "INVALID_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "match_any_maximum_score", 
               "doc": {
                  "headline": "Matches assessment parts with any maximum score assigned.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    match (boolean): ``true`` to match assessment parts with\n                any maximum score, ``false`` to match assessment parts\n                with no maximum score\n", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "        :param match: ``true`` to match assessment parts with any maximum score, ``false`` to match assessment parts with no maximum score\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "clear_maximum_score_terms", 
               "doc": {
                  "headline": "Clears all maximum score terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "match_cumulative", 
               "doc": {
                  "headline": "Matches cumulative rules.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    match (boolean): ``true`` for a positive match,\n                ``false`` for a negative match\n", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "        :param match: ``true`` for a positive match, ``false`` for a negative match\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "clear_cumulative_terms", 
               "doc": {
                  "headline": "Clears all cumulative terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "match_applied_assessment_part_id", 
               "doc": {
                  "headline": "Sets the assessment part ``Id`` for this query.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    assessment_part_id (osid.id.Id): an assessment part\n                ``Id``\n        arg:    match (boolean): ``true`` for a positive match,\n                ``false`` for a negative match\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``assessment_part_id`` is ``null``", 
               "sphinx_param_doc": "        :param assessment_part_id: an assessment part ``Id``\n        :type assessment_part_id: ``osid.id.Id``\n        :param match: ``true`` for a positive match, ``false`` for a negative match\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``assessment_part_id`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "assessment_part_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "clear_applied_assessment_part_id_terms", 
               "doc": {
                  "headline": "Clears all assessment part ``Id`` terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "supports_applied_assessment_part_query", 
               "doc": {
                  "headline": "Tests if an ``AssessmentPartQuery`` is available.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if an assessment part query is\n                available, ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if an assessment part query is available, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "get_applied_assessment_part_query", 
               "doc": {
                  "headline": "Gets the query for an assessment part.", 
                  "body": "        Multiple retrievals produce a nested ``OR`` term."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.assessment.authoring.AssessmentPartQuery) - the\n                assessment part query", 
               "error_doc": "        raise:  Unimplemented -\n                ``supports_applied_assessment_part_query()`` is\n                ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the assessment part query\n        :rtype: ``osid.assessment.authoring.AssessmentPartQuery``", 
               "sphinx_error_doc": "        :raise: ``Unimplemented`` -- ``supports_applied_assessment_part_query()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_applied_assessment_part_query()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.assessment.authoring.AssessmentPartQuery", 
               "errors": {
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "match_any_applied_assessment_part", 
               "doc": {
                  "headline": "Matches assessment parts with any applied assessment part.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    match (boolean): ``true`` to match assessment parts with\n                any applied assessment part, ``false`` to match\n                assessment parts with no applied assessment parts\n", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "        :param match: ``true`` to match assessment parts with any applied assessment part, ``false`` to match assessment parts with no applied assessment parts\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "clear_applied_assessment_part_terms", 
               "doc": {
                  "headline": "Clears all assessment part terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "match_bank_id", 
               "doc": {
                  "headline": "Matches constrainers mapped to the bank.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    bank_id (osid.id.Id): the bank ``Id``\n        arg:    match (boolean): ``true`` for a positive match,\n                ``false`` for a negative match\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``bank_id`` is ``null``", 
               "sphinx_param_doc": "        :param bank_id: the bank ``Id``\n        :type bank_id: ``osid.id.Id``\n        :param match: ``true`` for a positive match, ``false`` for a negative match\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``bank_id`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "bank_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "clear_bank_id_terms", 
               "doc": {
                  "headline": "Clears the bank ``Id`` query terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "supports_bank_query", 
               "doc": {
                  "headline": "Tests if an ``BankQuery`` is available.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if a bank query is available,\n                ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if a bank query is available, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "get_bank_query", 
               "doc": {
                  "headline": "Gets the query for a bank.", 
                  "body": "        Multiple retrievals produce a nested ``OR`` term."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.assessment.BankQuery) - the bank query", 
               "error_doc": "        raise:  Unimplemented - ``supports_bank_query()`` is ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the bank query\n        :rtype: ``osid.assessment.BankQuery``", 
               "sphinx_error_doc": "        :raise: ``Unimplemented`` -- ``supports_bank_query()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_bank_query()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.assessment.BankQuery", 
               "errors": {
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "clear_bank_terms", 
               "doc": {
                  "headline": "Clears the bank query terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "get_sequence_rule_query_record", 
               "doc": {
                  "headline": "Gets the sequence rule query record corresponding to the given ``SequenceRule`` record ``Type``.", 
                  "body": "        Multiple record retrievals produce a nested ``OR`` term."
               }, 
               "arg_doc": "        arg:    sequence_rule_record_type (osid.type.Type): a sequence\n                rule record type\n", 
               "return_doc": "        return:\n                (osid.assessment.authoring.records.SequenceRuleQueryReco\n                rd) - the sequence rule query record", 
               "error_doc": "        raise:  NullArgument - ``sequence_rule_record_type`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unsupported -\n                ``has_record_type(sequence_rule_record_type)`` is\n                ``false``", 
               "sphinx_param_doc": "        :param sequence_rule_record_type: a sequence rule record type\n        :type sequence_rule_record_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "        :return: the sequence rule query record\n        :rtype: ``osid.assessment.authoring.records.SequenceRuleQueryRecord``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``sequence_rule_record_type`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unsupported`` -- ``has_record_type(sequence_rule_record_type)`` is ``false``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "sequence_rule_record_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "osid.assessment.authoring.records.SequenceRuleQueryRecord", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.assessment.authoring.records.SequenceRuleQueryRecord", 
         "shortname": "SequenceRuleQueryRecord", 
         "category": "records", 
         "doc": {
            "headline": "A record for a ``SequenceRuleQuery``.", 
            "body": "    The methods specified by the record type are available through the\n    underlying object."
         }, 
         "inherit_fullnames": [
            "osid.OsidRecord"
         ], 
         "inherit_shortnames": [
            "OsidRecord"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidRecord"
            }
         ], 
         "method_names": [], 
         "methods": []
      }, 
      {
         "fullname": "osid.assessment.authoring.SequenceRuleQueryInspector", 
         "shortname": "SequenceRuleQueryInspector", 
         "category": "query_inspectors", 
         "doc": {
            "headline": "This is the query inspector for examining sequence rule queries.", 
            "body": ""
         }, 
         "inherit_fullnames": [
            "osid.OsidRuleQueryInspector"
         ], 
         "inherit_shortnames": [
            "OsidRuleQueryInspector"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidRuleQueryInspector"
            }
         ], 
         "method_names": [
            "get_assessment_part_id_terms", 
            "get_assessment_part_terms", 
            "get_next_assessment_part_id_terms", 
            "get_next_assessment_part_terms", 
            "get_minimum_score_terms", 
            "get_maximum_score_terms", 
            "get_cumulative_terms", 
            "get_applied_assessment_part_id_terms", 
            "get_applied_assessment_part_terms", 
            "get_bank_id_terms", 
            "get_bank_terms", 
            "get_sequence_rule_query_inspector_record"
         ], 
         "methods": [
            {
               "name": "get_assessment_part_id_terms", 
               "doc": {
                  "headline": "Gets the assessment part ``Id`` query terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.search.terms.IdTerm) - the assessment parent\n                ``Id`` terms", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the assessment parent ``Id`` terms\n        :rtype: ``osid.search.terms.IdTerm``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.search.terms.IdTerm", 
               "errors": {}
            }, 
            {
               "name": "get_assessment_part_terms", 
               "doc": {
                  "headline": "Gets the assessment part query terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.assessment.authoring.AssessmentPartQueryInspector)\n                - the assessment part terms", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the assessment part terms\n        :rtype: ``osid.assessment.authoring.AssessmentPartQueryInspector``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.assessment.authoring.AssessmentPartQueryInspector", 
               "errors": {}
            }, 
            {
               "name": "get_next_assessment_part_id_terms", 
               "doc": {
                  "headline": "Gets the assessment part ``Id`` query terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.search.terms.IdTerm) - the assessment parent\n                ``Id`` terms", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the assessment parent ``Id`` terms\n        :rtype: ``osid.search.terms.IdTerm``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.search.terms.IdTerm", 
               "errors": {}
            }, 
            {
               "name": "get_next_assessment_part_terms", 
               "doc": {
                  "headline": "Gets the assessment part query terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.assessment.authoring.AssessmentPartQueryInspector)\n                - the assessment part terms", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the assessment part terms\n        :rtype: ``osid.assessment.authoring.AssessmentPartQueryInspector``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.assessment.authoring.AssessmentPartQueryInspector", 
               "errors": {}
            }, 
            {
               "name": "get_minimum_score_terms", 
               "doc": {
                  "headline": "Gets the minimum score query terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.search.terms.CardinalRangeTerm) - the minimum\n                score terms", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the minimum score terms\n        :rtype: ``osid.search.terms.CardinalRangeTerm``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.search.terms.CardinalRangeTerm", 
               "errors": {}
            }, 
            {
               "name": "get_maximum_score_terms", 
               "doc": {
                  "headline": "Gets the maximum score query terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.search.terms.CardinalRangeTerm) - the maximum\n                score terms", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the maximum score terms\n        :rtype: ``osid.search.terms.CardinalRangeTerm``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.search.terms.CardinalRangeTerm", 
               "errors": {}
            }, 
            {
               "name": "get_cumulative_terms", 
               "doc": {
                  "headline": "Gets the minimum score query terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.search.terms.BooleanTerm) - the cumulative terms", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the cumulative terms\n        :rtype: ``osid.search.terms.BooleanTerm``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.search.terms.BooleanTerm", 
               "errors": {}
            }, 
            {
               "name": "get_applied_assessment_part_id_terms", 
               "doc": {
                  "headline": "Gets the assessment part ``Id`` query terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.search.terms.IdTerm) - the assessment parent\n                ``Id`` terms", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the assessment parent ``Id`` terms\n        :rtype: ``osid.search.terms.IdTerm``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.search.terms.IdTerm", 
               "errors": {}
            }, 
            {
               "name": "get_applied_assessment_part_terms", 
               "doc": {
                  "headline": "Gets the assessment part query terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.assessment.authoring.AssessmentPartQueryInspector)\n                - the assessment part terms", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the assessment part terms\n        :rtype: ``osid.assessment.authoring.AssessmentPartQueryInspector``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.assessment.authoring.AssessmentPartQueryInspector", 
               "errors": {}
            }, 
            {
               "name": "get_bank_id_terms", 
               "doc": {
                  "headline": "Gets the bank ``Id`` query terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.search.terms.IdTerm) - the query terms", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the query terms\n        :rtype: ``osid.search.terms.IdTerm``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.search.terms.IdTerm", 
               "errors": {}
            }, 
            {
               "name": "get_bank_terms", 
               "doc": {
                  "headline": "Gets the bank query terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.assessment.BankQueryInspector) - the query terms", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the query terms\n        :rtype: ``osid.assessment.BankQueryInspector``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.assessment.BankQueryInspector", 
               "errors": {}
            }, 
            {
               "name": "get_sequence_rule_query_inspector_record", 
               "doc": {
                  "headline": "Gets the sequence rule query inspector record corresponding to the given ``SequenceRule`` record ``Type``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    sequence_rule_record_type (osid.type.Type): a sequence\n                rule record type\n", 
               "return_doc": "        return: (osid.assessment.authoring.records.SequenceRuleQueryInsp\n                ectorRecord) - the sequence rule query inspector record", 
               "error_doc": "        raise:  NullArgument - ``sequence_rule_record_type`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unsupported -\n                ``has_record_type(sequence_rule_record_type)`` is\n                ``false``", 
               "sphinx_param_doc": "        :param sequence_rule_record_type: a sequence rule record type\n        :type sequence_rule_record_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "        :return: the sequence rule query inspector record\n        :rtype: ``osid.assessment.authoring.records.SequenceRuleQueryInspectorRecord``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``sequence_rule_record_type`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unsupported`` -- ``has_record_type(sequence_rule_record_type)`` is ``false``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "sequence_rule_record_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "osid.assessment.authoring.records.SequenceRuleQueryInspectorRecord", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.assessment.authoring.records.SequenceRuleQueryInspectorRecord", 
         "shortname": "SequenceRuleQueryInspectorRecord", 
         "category": "records", 
         "doc": {
            "headline": "A record for a ``SequenceRuleQueryInspector``.", 
            "body": "    The methods specified by the record type are available through the\n    underlying object."
         }, 
         "inherit_fullnames": [
            "osid.OsidRecord"
         ], 
         "inherit_shortnames": [
            "OsidRecord"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidRecord"
            }
         ], 
         "method_names": [], 
         "methods": []
      }, 
      {
         "fullname": "osid.assessment.authoring.SequenceRuleForm", 
         "shortname": "SequenceRuleForm", 
         "category": "objects", 
         "doc": {
            "headline": "This is the form for creating and updating sequence rules.", 
            "body": "    Like all ``OsidForm`` objects, various data elements may be set here\n    for use in the create and update methods in the ``SequenceSession``\n    For each data element that may be set, metadata may be examined to\n    provide display hints or data constraints."
         }, 
         "inherit_fullnames": [
            "osid.OsidRuleForm"
         ], 
         "inherit_shortnames": [
            "OsidRuleForm"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidRuleForm"
            }
         ], 
         "method_names": [
            "get_minimum_score_metadata", 
            "set_minimum_score", 
            "get_maximum_score_metadata", 
            "set_maximum_score", 
            "get_cumulative_metadata", 
            "set_cumulative", 
            "get_applied_assessment_parts_metadata", 
            "apply_assessment_parts", 
            "get_sequence_rule_form_record"
         ], 
         "methods": [
            {
               "name": "get_minimum_score_metadata", 
               "doc": {
                  "headline": "Gets the metadata for the minimum score.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.Metadata) - metadata for the minimum score", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: metadata for the minimum score\n        :rtype: ``osid.Metadata``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.Metadata", 
               "errors": {}
            }, 
            {
               "name": "set_minimum_score", 
               "doc": {
                  "headline": "Sets the minimum score for this rule.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    score (cardinal): minimum score\n", 
               "return_doc": "", 
               "error_doc": "        raise:  InvalidArgument - ``score`` is invalid\n        raise:  NoAccess - ``Metadata.isReadOnly()`` is ``true``", 
               "sphinx_param_doc": "        :param score: minimum score\n        :type score: ``cardinal``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``InvalidArgument`` -- ``score`` is invalid\n        :raise: ``NoAccess`` -- ``Metadata.isReadOnly()`` is ``true``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "cardinal", 
                     "var_name": "score", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "cardinal"
               ], 
               "return_type": "", 
               "errors": {
                  "INVALID_ARGUMENT": "ConsumerContract", 
                  "NO_ACCESS": "ConsumerContract"
               }
            }, 
            {
               "name": "get_maximum_score_metadata", 
               "doc": {
                  "headline": "Gets the metadata for the maximum score.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.Metadata) - metadata for the maximum score", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: metadata for the maximum score\n        :rtype: ``osid.Metadata``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.Metadata", 
               "errors": {}
            }, 
            {
               "name": "set_maximum_score", 
               "doc": {
                  "headline": "Sets the maximum score for this rule.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    score (cardinal): maximum score\n", 
               "return_doc": "", 
               "error_doc": "        raise:  InvalidArgument - ``score`` is invalid\n        raise:  NoAccess - ``Metadata.isReadOnly()`` is ``true``", 
               "sphinx_param_doc": "        :param score: maximum score\n        :type score: ``cardinal``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``InvalidArgument`` -- ``score`` is invalid\n        :raise: ``NoAccess`` -- ``Metadata.isReadOnly()`` is ``true``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "cardinal", 
                     "var_name": "score", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "cardinal"
               ], 
               "return_type": "", 
               "errors": {
                  "INVALID_ARGUMENT": "ConsumerContract", 
                  "NO_ACCESS": "ConsumerContract"
               }
            }, 
            {
               "name": "get_cumulative_metadata", 
               "doc": {
                  "headline": "Gets the metadata for the cumulative flag.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.Metadata) - metadata for the cumulative flag", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: metadata for the cumulative flag\n        :rtype: ``osid.Metadata``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.Metadata", 
               "errors": {}
            }, 
            {
               "name": "set_cumulative", 
               "doc": {
                  "headline": "Applies this rule to all previous assessment parts.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    cumulative (boolean): ``true`` to apply to all previous\n                assessment parts. ``false`` to apply to the immediate\n                previous assessment part\n", 
               "return_doc": "", 
               "error_doc": "        raise:  InvalidArgument - ``cumulative`` is invalid\n        raise:  NoAccess - ``Metadata.isReadOnly()`` is ``true``", 
               "sphinx_param_doc": "        :param cumulative: ``true`` to apply to all previous assessment parts. ``false`` to apply to the immediate previous assessment part\n        :type cumulative: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``InvalidArgument`` -- ``cumulative`` is invalid\n        :raise: ``NoAccess`` -- ``Metadata.isReadOnly()`` is ``true``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "boolean", 
                     "var_name": "cumulative", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {
                  "INVALID_ARGUMENT": "ConsumerContract", 
                  "NO_ACCESS": "ConsumerContract"
               }
            }, 
            {
               "name": "get_applied_assessment_parts_metadata", 
               "doc": {
                  "headline": "Gets the metadata for the applied assessment parts.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.Metadata) - metadata for the applied assessment\n                parts", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: metadata for the applied assessment parts\n        :rtype: ``osid.Metadata``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.Metadata", 
               "errors": {}
            }, 
            {
               "name": "apply_assessment_parts", 
               "doc": {
                  "headline": "Designates assessment parts to which the rule applies.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    assessment_part_ids (osid.id.Id[]): the parts to which\n                this rule should apply\n", 
               "return_doc": "", 
               "error_doc": "        raise:  InvalidArgument - ``assessment_part_ids`` is invalid\n        raise:  NoAccess - ``Metadata.isReadOnly()`` is ``true``\n        raise:  NullArgument - ``assessment_part_ids`` is ``null``", 
               "sphinx_param_doc": "        :param assessment_part_ids: the parts to which this rule should apply\n        :type assessment_part_ids: ``osid.id.Id[]``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``InvalidArgument`` -- ``assessment_part_ids`` is invalid\n        :raise: ``NoAccess`` -- ``Metadata.isReadOnly()`` is ``true``\n        :raise: ``NullArgument`` -- ``assessment_part_ids`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id[]", 
                     "var_name": "assessment_part_ids", 
                     "array": true
                  }
               ], 
               "arg_types": [
                  "osid.id.Id[]"
               ], 
               "return_type": "", 
               "errors": {
                  "INVALID_ARGUMENT": "ConsumerContract", 
                  "NO_ACCESS": "ConsumerContract", 
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "get_sequence_rule_form_record", 
               "doc": {
                  "headline": "Gets the ``SequenceRuleFormRecord`` corresponding to the given sequence rule record ``Type``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    sequence_rule_record (osid.type.Type): a sequence rule\n                record type\n", 
               "return_doc": "        return:\n                (osid.assessment.authoring.records.SequenceRuleFormRecor\n                d) - the sequence rule record", 
               "error_doc": "        raise:  NullArgument - ``sequence_rule_record_type`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unsupported -\n                ``has_record_type(asequence_rule_record_type)`` is\n                ``false``", 
               "sphinx_param_doc": "        :param sequence_rule_record: a sequence rule record type\n        :type sequence_rule_record: ``osid.type.Type``\n", 
               "sphinx_return_doc": "        :return: the sequence rule record\n        :rtype: ``osid.assessment.authoring.records.SequenceRuleFormRecord``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``sequence_rule_record_type`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unsupported`` -- ``has_record_type(asequence_rule_record_type)`` is ``false``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "sequence_rule_record", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "osid.assessment.authoring.records.SequenceRuleFormRecord", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.assessment.authoring.records.SequenceRuleFormRecord", 
         "shortname": "SequenceRuleFormRecord", 
         "category": "records", 
         "doc": {
            "headline": "A record for a ``SequenceRuleForm``.", 
            "body": "    The methods specified by the record type are available through the\n    underlying object."
         }, 
         "inherit_fullnames": [
            "osid.OsidRecord"
         ], 
         "inherit_shortnames": [
            "OsidRecord"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidRecord"
            }
         ], 
         "method_names": [], 
         "methods": []
      }, 
      {
         "fullname": "osid.assessment.authoring.SequenceRuleSearchOrder", 
         "shortname": "SequenceRuleSearchOrder", 
         "category": "search_orders", 
         "doc": {
            "headline": "An interface for specifying the ordering of search results.", 
            "body": ""
         }, 
         "inherit_fullnames": [
            "osid.OsidRuleSearchOrder"
         ], 
         "inherit_shortnames": [
            "OsidRuleSearchOrder"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidRuleSearchOrder"
            }
         ], 
         "method_names": [
            "order_by_assessment_part", 
            "supports_assessment_part_search_order", 
            "get_assessment_part_search_order", 
            "order_by_next_assessment_part", 
            "supports_next_assessment_part_search_order", 
            "get_next_assessment_part_search_order", 
            "order_by_minimum_score", 
            "order_by_maximum_score", 
            "order_by_cumulative", 
            "get_sequence_rule_search_order_record"
         ], 
         "methods": [
            {
               "name": "order_by_assessment_part", 
               "doc": {
                  "headline": "Specifies a preference for ordering the result set by the assessment part.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    style (osid.SearchOrderStyle): search order style\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``style`` is ``null``", 
               "sphinx_param_doc": "        :param style: search order style\n        :type style: ``osid.SearchOrderStyle``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``style`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.SearchOrderStyle", 
                     "var_name": "style", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.SearchOrderStyle"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "supports_assessment_part_search_order", 
               "doc": {
                  "headline": "Tests if an assessment part search order is available.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if an assessment part search order\n                is available, ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if an assessment part search order is available, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "get_assessment_part_search_order", 
               "doc": {
                  "headline": "Gets the assessment order.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.assessment.authoring.AssessmentPartSearchOrder) -\n                the assessment part search order", 
               "error_doc": "        raise:  Unimplemented -\n                ``supports_assessment_part_search_order()`` is ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the assessment part search order\n        :rtype: ``osid.assessment.authoring.AssessmentPartSearchOrder``", 
               "sphinx_error_doc": "        :raise: ``Unimplemented`` -- ``supports_assessment_part_search_order()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_assessment_part_search_order()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.assessment.authoring.AssessmentPartSearchOrder", 
               "errors": {
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "order_by_next_assessment_part", 
               "doc": {
                  "headline": "Specifies a preference for ordering the result set by the assessment part.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    style (osid.SearchOrderStyle): search order style\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``style`` is ``null``", 
               "sphinx_param_doc": "        :param style: search order style\n        :type style: ``osid.SearchOrderStyle``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``style`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.SearchOrderStyle", 
                     "var_name": "style", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.SearchOrderStyle"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "supports_next_assessment_part_search_order", 
               "doc": {
                  "headline": "Tests if an assessment part search order is available.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if an assessment part search order\n                is available, ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if an assessment part search order is available, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "get_next_assessment_part_search_order", 
               "doc": {
                  "headline": "Gets the assessment order.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.assessment.authoring.AssessmentPartSearchOrder) -\n                the assessment part search order", 
               "error_doc": "        raise:  Unimplemented -\n                ``supports_next_assessment_part_search_order()`` is\n                ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the assessment part search order\n        :rtype: ``osid.assessment.authoring.AssessmentPartSearchOrder``", 
               "sphinx_error_doc": "        :raise: ``Unimplemented`` -- ``supports_next_assessment_part_search_order()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_next_assessment_part_search_order()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.assessment.authoring.AssessmentPartSearchOrder", 
               "errors": {
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "order_by_minimum_score", 
               "doc": {
                  "headline": "Specifies a preference for ordering the result set by the minimum score.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    style (osid.SearchOrderStyle): search order style\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``style`` is ``null``", 
               "sphinx_param_doc": "        :param style: search order style\n        :type style: ``osid.SearchOrderStyle``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``style`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.SearchOrderStyle", 
                     "var_name": "style", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.SearchOrderStyle"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "order_by_maximum_score", 
               "doc": {
                  "headline": "Specifies a preference for ordering the result set by the maximum score.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    style (osid.SearchOrderStyle): search order style\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``style`` is ``null``", 
               "sphinx_param_doc": "        :param style: search order style\n        :type style: ``osid.SearchOrderStyle``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``style`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.SearchOrderStyle", 
                     "var_name": "style", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.SearchOrderStyle"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "order_by_cumulative", 
               "doc": {
                  "headline": "Specifies a preference for ordering the result set by the cumulative.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    style (osid.SearchOrderStyle): search order style\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``style`` is ``null``", 
               "sphinx_param_doc": "        :param style: search order style\n        :type style: ``osid.SearchOrderStyle``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``style`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.SearchOrderStyle", 
                     "var_name": "style", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.SearchOrderStyle"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "get_sequence_rule_search_order_record", 
               "doc": {
                  "headline": "Gets the sequence rule search order record corresponding to the given sequence rule record ``Type``.", 
                  "body": "        Multiple retrievals return the same underlying object."
               }, 
               "arg_doc": "        arg:    sequence_rule_record_type (osid.type.Type): a sequence\n                rule record type\n", 
               "return_doc": "        return: (osid.assessment.authoring.records.SequenceRuleSearchOrd\n                erRecord) - the sequence rule search order record", 
               "error_doc": "        raise:  NullArgument - ``sequence_rule_record_type`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unsupported -\n                ``has_record_type(sequence_rule_record_type)`` is\n                ``false``", 
               "sphinx_param_doc": "        :param sequence_rule_record_type: a sequence rule record type\n        :type sequence_rule_record_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "        :return: the sequence rule search order record\n        :rtype: ``osid.assessment.authoring.records.SequenceRuleSearchOrderRecord``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``sequence_rule_record_type`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unsupported`` -- ``has_record_type(sequence_rule_record_type)`` is ``false``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "sequence_rule_record_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "osid.assessment.authoring.records.SequenceRuleSearchOrderRecord", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.assessment.authoring.records.SequenceRuleSearchOrderRecord", 
         "shortname": "SequenceRuleSearchOrderRecord", 
         "category": "records", 
         "doc": {
            "headline": "A record for a ``SequenceRuleSearchOrder``.", 
            "body": "    The methods specified by the record type are available through the\n    underlying object."
         }, 
         "inherit_fullnames": [
            "osid.OsidRecord"
         ], 
         "inherit_shortnames": [
            "OsidRecord"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidRecord"
            }
         ], 
         "method_names": [], 
         "methods": []
      }, 
      {
         "fullname": "osid.assessment.authoring.SequenceRuleSearch", 
         "shortname": "SequenceRuleSearch", 
         "category": "searches", 
         "doc": {
            "headline": "The search interface for governing sequence rule searches.", 
            "body": ""
         }, 
         "inherit_fullnames": [
            "osid.OsidSearch"
         ], 
         "inherit_shortnames": [
            "OsidSearch"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidSearch"
            }
         ], 
         "method_names": [
            "search_among_sequence_rules", 
            "order_sequence_rule_results", 
            "get_sequence_rule_search_record"
         ], 
         "methods": [
            {
               "name": "search_among_sequence_rules", 
               "doc": {
                  "headline": "Execute this search among the given list of sequence rules.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    bank_ids (osid.id.IdList): list of sequence rules\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``bank_ids`` is ``null``", 
               "sphinx_param_doc": "        :param bank_ids: list of sequence rules\n        :type bank_ids: ``osid.id.IdList``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``bank_ids`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.IdList", 
                     "var_name": "bank_ids", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.IdList"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "order_sequence_rule_results", 
               "doc": {
                  "headline": "Specify an ordering to the search results.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    sequence_rule_search_order\n                (osid.assessment.authoring.SequenceRuleSearchOrder):\n                sequence rule search order\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``sequence_rule_search_order`` is\n                ``null``\n        raise:  Unsupported - ``sequence_rule_search_order`` is not of\n                this service", 
               "sphinx_param_doc": "        :param sequence_rule_search_order: sequence rule search order\n        :type sequence_rule_search_order: ``osid.assessment.authoring.SequenceRuleSearchOrder``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``sequence_rule_search_order`` is ``null``\n        :raise: ``Unsupported`` -- ``sequence_rule_search_order`` is not of this service", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.assessment.authoring.SequenceRuleSearchOrder", 
                     "var_name": "sequence_rule_search_order", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.assessment.authoring.SequenceRuleSearchOrder"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_sequence_rule_search_record", 
               "doc": {
                  "headline": "Gets the sequence rule search record corresponding to the given sequence rule search record ``Type``.", 
                  "body": "        This method is used to retrieve an object implementing the\n        requested record."
               }, 
               "arg_doc": "        arg:    sequence_rule_search_record_type (osid.type.Type): a\n                sequence rule search record type\n", 
               "return_doc": "        return:\n                (osid.assessment.authoring.records.SequenceRuleSearchRec\n                ord) - the sequence rule search record", 
               "error_doc": "        raise:  NullArgument - ``sequence_rule_search_record_type`` is\n                ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unsupported -\n                ``has_record_type(sequence_rule_search_record_type)`` is\n                ``false``", 
               "sphinx_param_doc": "        :param sequence_rule_search_record_type: a sequence rule search record type\n        :type sequence_rule_search_record_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "        :return: the sequence rule search record\n        :rtype: ``osid.assessment.authoring.records.SequenceRuleSearchRecord``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``sequence_rule_search_record_type`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unsupported`` -- ``has_record_type(sequence_rule_search_record_type)`` is ``false``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "sequence_rule_search_record_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "osid.assessment.authoring.records.SequenceRuleSearchRecord", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.assessment.authoring.records.SequenceRuleSearchRecord", 
         "shortname": "SequenceRuleSearchRecord", 
         "category": "records", 
         "doc": {
            "headline": "A record for a ``SequenceRuleSearch``.", 
            "body": "    The methods specified by the record type are available through the\n    underlying object."
         }, 
         "inherit_fullnames": [
            "osid.OsidRecord"
         ], 
         "inherit_shortnames": [
            "OsidRecord"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidRecord"
            }
         ], 
         "method_names": [], 
         "methods": []
      }, 
      {
         "fullname": "osid.assessment.authoring.SequenceRuleSearchResults", 
         "shortname": "SequenceRuleSearchResults", 
         "category": "searches", 
         "doc": {
            "headline": "This interface provides a means to capture results of a search.", 
            "body": ""
         }, 
         "inherit_fullnames": [
            "osid.OsidSearchResults"
         ], 
         "inherit_shortnames": [
            "OsidSearchResults"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidSearchResults"
            }
         ], 
         "method_names": [
            "get_sequence_rules", 
            "get_sequence_rule_query_inspector", 
            "get_sequence_rule_search_results_record"
         ], 
         "methods": [
            {
               "name": "get_sequence_rules", 
               "doc": {
                  "headline": "Gets the ``SequenceRuleList`` resulting from a search.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.assessment.authoring.SequenceRuleList) - the\n                sequence rule list", 
               "error_doc": "        raise:  IllegalState - list has already been retrieved", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the sequence rule list\n        :rtype: ``osid.assessment.authoring.SequenceRuleList``", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- list has already been retrieved", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.assessment.authoring.SequenceRuleList", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract"
               }
            }, 
            {
               "name": "get_sequence_rule_query_inspector", 
               "doc": {
                  "headline": "Gets the inspector for the query to examine the terms used in the search.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.assessment.authoring.SequenceRuleQueryInspector) -\n                the sequence rule query inspector", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the sequence rule query inspector\n        :rtype: ``osid.assessment.authoring.SequenceRuleQueryInspector``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.assessment.authoring.SequenceRuleQueryInspector", 
               "errors": {}
            }, 
            {
               "name": "get_sequence_rule_search_results_record", 
               "doc": {
                  "headline": "Gets the sequence rule search results record corresponding to the given sequence rule search record ``Type``.", 
                  "body": "        This method must be used to retrieve an object implementing the\n        requested record."
               }, 
               "arg_doc": "        arg:    sequence_rule_search_record_type (osid.type.Type): a\n                sequence rule search record type\n", 
               "return_doc": "        return: (osid.assessment.authoring.records.SequenceRuleSearchRes\n                ultsRecord) - the sequence rule search results record", 
               "error_doc": "        raise:  NullArgument - ``sequence_rule_search_record_type`` is\n                ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure occurred\n        raise:  Unsupported -\n                ``has_record_type(sequence_rule_search_record_type)`` is\n                ``false``", 
               "sphinx_param_doc": "        :param sequence_rule_search_record_type: a sequence rule search record type\n        :type sequence_rule_search_record_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "        :return: the sequence rule search results record\n        :rtype: ``osid.assessment.authoring.records.SequenceRuleSearchResultsRecord``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``sequence_rule_search_record_type`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure occurred\n        :raise: ``Unsupported`` -- ``has_record_type(sequence_rule_search_record_type)`` is ``false``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "sequence_rule_search_record_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "osid.assessment.authoring.records.SequenceRuleSearchResultsRecord", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.assessment.authoring.records.SequenceRuleSearchResultsRecord", 
         "shortname": "SequenceRuleSearchResultsRecord", 
         "category": "records", 
         "doc": {
            "headline": "A record for a ``SequenceRuleSearchResults``.", 
            "body": "    The methods specified by the record type are available through the\n    underlying object."
         }, 
         "inherit_fullnames": [
            "osid.OsidRecord"
         ], 
         "inherit_shortnames": [
            "OsidRecord"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidRecord"
            }
         ], 
         "method_names": [], 
         "methods": []
      }, 
      {
         "fullname": "osid.assessment.authoring.SequenceRuleReceiver", 
         "shortname": "SequenceRuleReceiver", 
         "category": "receivers", 
         "doc": {
            "headline": "The sequence rule receiver is the consumer supplied interface for receiving notifications pertaining to new, updated or deleted sequence rules.", 
            "body": ""
         }, 
         "inherit_fullnames": [
            "osid.OsidReceiver"
         ], 
         "inherit_shortnames": [
            "OsidReceiver"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidReceiver"
            }
         ], 
         "method_names": [
            "new_sequence_rule", 
            "changed_sequence_rule", 
            "deleted_sequence_rule"
         ], 
         "methods": [
            {
               "name": "new_sequence_rule", 
               "doc": {
                  "headline": "The callback for notifications of new sequence rules.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    sequence_rule_id (osid.id.Id): the ``Id`` of the new\n                ``SequenceRule``\n", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "        :param sequence_rule_id: the ``Id`` of the new ``SequenceRule``\n        :type sequence_rule_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "sequence_rule_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "changed_sequence_rule", 
               "doc": {
                  "headline": "The callback for notification of updated sequence rules.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    sequence_rule_id (osid.id.Id): the ``Id`` of the updated\n                ``SequenceRule``\n", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "        :param sequence_rule_id: the ``Id`` of the updated ``SequenceRule``\n        :type sequence_rule_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "sequence_rule_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "deleted_sequence_rule", 
               "doc": {
                  "headline": "The callback for notification of deleted sequence rules.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    sequence_rule_id (osid.id.Id): the ``Id`` of the deleted\n                ``SequenceRule``\n", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "        :param sequence_rule_id: the ``Id`` of the deleted ``SequenceRule``\n        :type sequence_rule_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "sequence_rule_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {}
            }
         ]
      }, 
      {
         "fullname": "osid.assessment.authoring.SequenceRuleList", 
         "shortname": "SequenceRuleList", 
         "category": "objects", 
         "doc": {
            "headline": "Like all ``OsidLists,``  ``SequenceRuleList`` provides a means for accessing ``SequenceRule`` elements sequentially either one at a time or many at a time.", 
            "body": "    Examples: while (srl.hasNext()) { AssessmentSequenceRule rule =\n    srl.getNextAssessmentSequenceRule(); }\n\n    or\n      while (srl.hasNext()) {\n           AssessmentSequenceRule[] rules = srl.getNextAssessmentSequenceRules(srl.available());\n      }\n    \n"
         }, 
         "inherit_fullnames": [
            "osid.OsidList"
         ], 
         "inherit_shortnames": [
            "OsidList"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidList"
            }
         ], 
         "method_names": [
            "get_next_sequence_rule", 
            "get_next_sequence_rules"
         ], 
         "methods": [
            {
               "name": "get_next_sequence_rule", 
               "doc": {
                  "headline": "Gets the next ``SequenceRule`` in this list.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.assessment.authoring.SequenceRule) - the next\n                ``SequenceRule`` in this list. The ``has_next()`` method\n                should be used to test that a next ``SequenceRule`` is\n                available before calling this method.", 
               "error_doc": "        raise:  IllegalState - no more elements available in this list\n        raise:  OperationFailed - unable to complete request", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the next ``SequenceRule`` in this list. The ``has_next()`` method should be used to test that a next ``SequenceRule`` is available before calling this method.\n        :rtype: ``osid.assessment.authoring.SequenceRule``", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- no more elements available in this list\n        :raise: ``OperationFailed`` -- unable to complete request", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.assessment.authoring.SequenceRule", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational"
               }
            }, 
            {
               "name": "get_next_sequence_rules", 
               "doc": {
                  "headline": "Gets the next set of ``SequenceRule`` elements in this list which must be less than or equal to the number returned from ``available()``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    n (cardinal): the number of ``SequenceRule`` elements\n                requested which should be less than or equal to\n                ``available()``\n", 
               "return_doc": "        return: (osid.assessment.authoring.SequenceRule) - an array of\n                ``SequenceRule`` elements.The length of the array is\n                less than or equal to the number specified.", 
               "error_doc": "        raise:  IllegalState - no more elements available in this list\n        raise:  OperationFailed - unable to complete request", 
               "sphinx_param_doc": "        :param n: the number of ``SequenceRule`` elements requested which should be less than or equal to ``available()``\n        :type n: ``cardinal``\n", 
               "sphinx_return_doc": "        :return: an array of ``SequenceRule`` elements.The length of the array is less than or equal to the number specified.\n        :rtype: ``osid.assessment.authoring.SequenceRule``", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- no more elements available in this list\n        :raise: ``OperationFailed`` -- unable to complete request", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "cardinal", 
                     "var_name": "n", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "cardinal"
               ], 
               "return_type": "osid.assessment.authoring.SequenceRule", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.assessment.authoring.SequenceRuleEnabler", 
         "shortname": "SequenceRuleEnabler", 
         "category": "objects", 
         "doc": {
            "headline": "A ``SequenceRuleEnabler`` describes the rules for making a ``SequenceRule`` effective.", 
            "body": ""
         }, 
         "inherit_fullnames": [
            "osid.OsidEnabler"
         ], 
         "inherit_shortnames": [
            "OsidEnabler"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidEnabler"
            }
         ], 
         "method_names": [
            "get_sequence_rule_enabler_record"
         ], 
         "methods": [
            {
               "name": "get_sequence_rule_enabler_record", 
               "doc": {
                  "headline": "Gets the sequence rule enabler record corresponding to the given ``SequenceRuleEnabler`` record ``Type``.", 
                  "body": "        This method is used to retrieve an object implementing the\n        requested record. The ``sequence_rule_enabler_record_type`` may\n        be the ``Type`` returned in ``get_record_types()`` or any of its\n        parents in a ``Type`` hierarchy where\n        ``has_record_type(sequence_rule_enabler_record_type)`` is\n        ``true`` ."
               }, 
               "arg_doc": "        arg:    sequence_rule_enabler_record_type (osid.type.Type): the\n                type of sequence rule enabler record to retrieve\n", 
               "return_doc": "        return:\n                (osid.assessment.authoring.records.SequenceRuleEnablerRe\n                cord) - the sequence rule enabler record", 
               "error_doc": "        raise:  NullArgument - ``sequence_rule_enabler_record_type`` is\n                ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unsupported -\n                ``has_record_type(sequence_rule_enabler_record_type)``\n                is ``false``", 
               "sphinx_param_doc": "        :param sequence_rule_enabler_record_type: the type of sequence rule enabler record to retrieve\n        :type sequence_rule_enabler_record_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "        :return: the sequence rule enabler record\n        :rtype: ``osid.assessment.authoring.records.SequenceRuleEnablerRecord``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``sequence_rule_enabler_record_type`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unsupported`` -- ``has_record_type(sequence_rule_enabler_record_type)`` is ``false``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "sequence_rule_enabler_record_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "osid.assessment.authoring.records.SequenceRuleEnablerRecord", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.assessment.authoring.records.SequenceRuleEnablerRecord", 
         "shortname": "SequenceRuleEnablerRecord", 
         "category": "records", 
         "doc": {
            "headline": "A record for a ``SequenceRuleEnabler``.", 
            "body": "    The methods specified by the record type are available through the\n    underlying object."
         }, 
         "inherit_fullnames": [
            "osid.OsidRecord"
         ], 
         "inherit_shortnames": [
            "OsidRecord"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidRecord"
            }
         ], 
         "method_names": [], 
         "methods": []
      }, 
      {
         "fullname": "osid.assessment.authoring.SequenceRuleEnablerQuery", 
         "shortname": "SequenceRuleEnablerQuery", 
         "category": "queries", 
         "doc": {
            "headline": "This is the query for searching sequence rule enablers.", 
            "body": "    Each method match specifies a ``AND`` term while multiple\n    invocations of the same method produce a nested ``OR``."
         }, 
         "inherit_fullnames": [
            "osid.OsidEnablerQuery"
         ], 
         "inherit_shortnames": [
            "OsidEnablerQuery"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidEnablerQuery"
            }
         ], 
         "method_names": [
            "match_ruled_sequence_rule_id", 
            "clear_ruled_sequence_rule_id_terms", 
            "supports_ruled_sequence_rule_query", 
            "get_ruled_sequence_rule_query", 
            "match_any_ruled_sequence_rule", 
            "clear_ruled_sequence_rule_terms", 
            "match_bank_id", 
            "clear_bank_id_terms", 
            "supports_bank_query", 
            "get_bank_query", 
            "clear_bank_terms", 
            "get_sequence_rule_enabler_query_record"
         ], 
         "methods": [
            {
               "name": "match_ruled_sequence_rule_id", 
               "doc": {
                  "headline": "Matches enablers mapped to the sequence rule.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    sequence_rule_id (osid.id.Id): the sequence rule ``Id``\n        arg:    match (boolean): ``true`` for a positive match,\n                ``false`` for a negative match\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``sequence_rule_id`` is ``null``", 
               "sphinx_param_doc": "        :param sequence_rule_id: the sequence rule ``Id``\n        :type sequence_rule_id: ``osid.id.Id``\n        :param match: ``true`` for a positive match, ``false`` for a negative match\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``sequence_rule_id`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "sequence_rule_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "clear_ruled_sequence_rule_id_terms", 
               "doc": {
                  "headline": "Clears the sequence rule ``Id`` query terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "supports_ruled_sequence_rule_query", 
               "doc": {
                  "headline": "Tests if a ``SequenceRuleQuery`` is available.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if a sequence rule query is\n                available, ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if a sequence rule query is available, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "get_ruled_sequence_rule_query", 
               "doc": {
                  "headline": "Gets the query for a sequence rule.", 
                  "body": "        Multiple retrievals produce a nested ``OR`` term."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.assessment.authoring.SequenceRuleQuery) - the\n                sequence rule query", 
               "error_doc": "        raise:  Unimplemented - ``supports_ruled_sequence_rule_query()``\n                is ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the sequence rule query\n        :rtype: ``osid.assessment.authoring.SequenceRuleQuery``", 
               "sphinx_error_doc": "        :raise: ``Unimplemented`` -- ``supports_ruled_sequence_rule_query()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_ruled_sequence_rule_query()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.assessment.authoring.SequenceRuleQuery", 
               "errors": {
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "match_any_ruled_sequence_rule", 
               "doc": {
                  "headline": "Matches enablers mapped to any sequence rule.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    match (boolean): ``true`` for enablers mapped to any\n                sequence rule, ``false`` to match enablers mapped to no\n                sequence rules\n", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "        :param match: ``true`` for enablers mapped to any sequence rule, ``false`` to match enablers mapped to no sequence rules\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "clear_ruled_sequence_rule_terms", 
               "doc": {
                  "headline": "Clears the sequence rule query terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "match_bank_id", 
               "doc": {
                  "headline": "Matches enablers mapped to the bank.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    bank_id (osid.id.Id): the bank ``Id``\n        arg:    match (boolean): ``true`` for a positive match,\n                ``false`` for a negative match\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``bank_id`` is ``null``", 
               "sphinx_param_doc": "        :param bank_id: the bank ``Id``\n        :type bank_id: ``osid.id.Id``\n        :param match: ``true`` for a positive match, ``false`` for a negative match\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``bank_id`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "bank_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "clear_bank_id_terms", 
               "doc": {
                  "headline": "Clears the bank ``Id`` query terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "supports_bank_query", 
               "doc": {
                  "headline": "Tests if an ``BankQuery`` is available.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if a bank query is available,\n                ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if a bank query is available, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "get_bank_query", 
               "doc": {
                  "headline": "Gets the query for a bank.", 
                  "body": "        Multiple retrievals produce a nested ``OR`` term."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.assessment.BankQuery) - the bank query", 
               "error_doc": "        raise:  Unimplemented - ``supports_bank_query()`` is ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the bank query\n        :rtype: ``osid.assessment.BankQuery``", 
               "sphinx_error_doc": "        :raise: ``Unimplemented`` -- ``supports_bank_query()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_bank_query()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.assessment.BankQuery", 
               "errors": {
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "clear_bank_terms", 
               "doc": {
                  "headline": "Clears the bank query terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "get_sequence_rule_enabler_query_record", 
               "doc": {
                  "headline": "Gets the sequence rule enabler query record corresponding to the given ``SequenceRuleEnabler`` record ``Type``.", 
                  "body": "        Multiple record retrievals produce a nested ``OR`` term."
               }, 
               "arg_doc": "        arg:    sequence_rule_enabler_record_type (osid.type.Type): a\n                sequence rule enabler record type\n", 
               "return_doc": "        return: (osid.assessment.authoring.records.SequenceRuleEnablerQu\n                eryRecord) - the sequence rule enabler query record", 
               "error_doc": "        raise:  NullArgument - ``sequence_rule_enabler_record_type`` is\n                ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unsupported -\n                ``has_record_type(sequence_rule_enabler_record_type)``\n                is ``false``", 
               "sphinx_param_doc": "        :param sequence_rule_enabler_record_type: a sequence rule enabler record type\n        :type sequence_rule_enabler_record_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "        :return: the sequence rule enabler query record\n        :rtype: ``osid.assessment.authoring.records.SequenceRuleEnablerQueryRecord``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``sequence_rule_enabler_record_type`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unsupported`` -- ``has_record_type(sequence_rule_enabler_record_type)`` is ``false``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "sequence_rule_enabler_record_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "osid.assessment.authoring.records.SequenceRuleEnablerQueryRecord", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.assessment.authoring.records.SequenceRuleEnablerQueryRecord", 
         "shortname": "SequenceRuleEnablerQueryRecord", 
         "category": "records", 
         "doc": {
            "headline": "A record for a ``SequenceRuleEnablerQuery``.", 
            "body": "    The methods specified by the record type are available through the\n    underlying object."
         }, 
         "inherit_fullnames": [
            "osid.OsidRecord"
         ], 
         "inherit_shortnames": [
            "OsidRecord"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidRecord"
            }
         ], 
         "method_names": [], 
         "methods": []
      }, 
      {
         "fullname": "osid.assessment.authoring.SequenceRuleEnablerQueryInspector", 
         "shortname": "SequenceRuleEnablerQueryInspector", 
         "category": "query_inspectors", 
         "doc": {
            "headline": "This is the query inspector for examining sequence rule enabler queries.", 
            "body": ""
         }, 
         "inherit_fullnames": [
            "osid.OsidEnablerQueryInspector"
         ], 
         "inherit_shortnames": [
            "OsidEnablerQueryInspector"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidEnablerQueryInspector"
            }
         ], 
         "method_names": [
            "get_ruled_sequence_rule_id_terms", 
            "get_ruled_sequence_rule_terms", 
            "get_bank_id_terms", 
            "get_bank_terms", 
            "get_sequence_rule_enabler_query_inspector_record"
         ], 
         "methods": [
            {
               "name": "get_ruled_sequence_rule_id_terms", 
               "doc": {
                  "headline": "Gets the sequence rule ``Id`` query terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.search.terms.IdTerm) - the query terms", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the query terms\n        :rtype: ``osid.search.terms.IdTerm``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.search.terms.IdTerm", 
               "errors": {}
            }, 
            {
               "name": "get_ruled_sequence_rule_terms", 
               "doc": {
                  "headline": "Gets the sequence rule query terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.assessment.authoring.SequenceRuleQueryInspector) -\n                the query terms", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the query terms\n        :rtype: ``osid.assessment.authoring.SequenceRuleQueryInspector``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.assessment.authoring.SequenceRuleQueryInspector", 
               "errors": {}
            }, 
            {
               "name": "get_bank_id_terms", 
               "doc": {
                  "headline": "Gets the bank ``Id`` query terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.search.terms.IdTerm) - the query terms", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the query terms\n        :rtype: ``osid.search.terms.IdTerm``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.search.terms.IdTerm", 
               "errors": {}
            }, 
            {
               "name": "get_bank_terms", 
               "doc": {
                  "headline": "Gets the bank query terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.assessment.BankQueryInspector) - the query terms", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the query terms\n        :rtype: ``osid.assessment.BankQueryInspector``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.assessment.BankQueryInspector", 
               "errors": {}
            }, 
            {
               "name": "get_sequence_rule_enabler_query_inspector_record", 
               "doc": {
                  "headline": "Gets the sequence rule enabler query inspector record corresponding to the given ``SequenceRuleEnabler`` record ``Type``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    sequence_rule_enabler_record_type (osid.type.Type): a\n                sequence rule enabler record type\n", 
               "return_doc": "        return: (osid.assessment.authoring.records.SequenceRuleEnablerQu\n                eryInspectorRecord) - the sequence rule enabler query\n                inspector record", 
               "error_doc": "        raise:  NullArgument - ``sequence_rule_enabler_record_type`` is\n                ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unsupported -\n                ``has_record_type(sequence_rule_enabler_record_type)``\n                is ``false``", 
               "sphinx_param_doc": "        :param sequence_rule_enabler_record_type: a sequence rule enabler record type\n        :type sequence_rule_enabler_record_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "        :return: the sequence rule enabler query inspector record\n        :rtype: ``osid.assessment.authoring.records.SequenceRuleEnablerQueryInspectorRecord``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``sequence_rule_enabler_record_type`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unsupported`` -- ``has_record_type(sequence_rule_enabler_record_type)`` is ``false``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "sequence_rule_enabler_record_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "osid.assessment.authoring.records.SequenceRuleEnablerQueryInspectorRecord", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.assessment.authoring.records.SequenceRuleEnablerQueryInspectorRecord", 
         "shortname": "SequenceRuleEnablerQueryInspectorRecord", 
         "category": "records", 
         "doc": {
            "headline": "A record for a ``SequenceRuleEnablerQueryInspector``.", 
            "body": "    The methods specified by the record type are available through the\n    underlying object."
         }, 
         "inherit_fullnames": [
            "osid.OsidRecord"
         ], 
         "inherit_shortnames": [
            "OsidRecord"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidRecord"
            }
         ], 
         "method_names": [], 
         "methods": []
      }, 
      {
         "fullname": "osid.assessment.authoring.SequenceRuleEnablerForm", 
         "shortname": "SequenceRuleEnablerForm", 
         "category": "objects", 
         "doc": {
            "headline": "This is the form for creating and updating ``SequenceRuleEnablers``.", 
            "body": "    Like all ``OsidForm`` objects, various data elements may be set here\n    for use in the create and update methods in the\n    ``SequenceRuleEnablerAdminSession``. For each data element that may\n    be set, metadata may be examined to provide display hints or data\n    constraints."
         }, 
         "inherit_fullnames": [
            "osid.OsidEnablerForm"
         ], 
         "inherit_shortnames": [
            "OsidEnablerForm"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidEnablerForm"
            }
         ], 
         "method_names": [
            "get_sequence_rule_enabler_form_record"
         ], 
         "methods": [
            {
               "name": "get_sequence_rule_enabler_form_record", 
               "doc": {
                  "headline": "Gets the ``SequenceRuleEnablerFormRecord`` corresponding to the given sequence rule enabler record ``Type``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    sequence_rule_enabler_record_type (osid.type.Type): a\n                sequence rule enabler record type\n", 
               "return_doc": "        return: (osid.assessment.authoring.records.SequenceRuleEnablerFo\n                rmRecord) - the sequence rule enabler form record", 
               "error_doc": "        raise:  NullArgument - ``sequence_rule_enabler_record_type`` is\n                ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unsupported -\n                ``has_record_type(sequence_rule_enabler_record_type)``\n                is ``false``", 
               "sphinx_param_doc": "        :param sequence_rule_enabler_record_type: a sequence rule enabler record type\n        :type sequence_rule_enabler_record_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "        :return: the sequence rule enabler form record\n        :rtype: ``osid.assessment.authoring.records.SequenceRuleEnablerFormRecord``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``sequence_rule_enabler_record_type`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unsupported`` -- ``has_record_type(sequence_rule_enabler_record_type)`` is ``false``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "sequence_rule_enabler_record_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "osid.assessment.authoring.records.SequenceRuleEnablerFormRecord", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.assessment.authoring.records.SequenceRuleEnablerFormRecord", 
         "shortname": "SequenceRuleEnablerFormRecord", 
         "category": "objects", 
         "doc": {
            "headline": "A record for a ``SequenceRuleEnablerForm``.", 
            "body": "    The methods specified by the record type are available through the\n    underlying object."
         }, 
         "inherit_fullnames": [
            "osid.OsidRuleForm"
         ], 
         "inherit_shortnames": [
            "OsidRuleForm"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidRuleForm"
            }
         ], 
         "method_names": [], 
         "methods": []
      }, 
      {
         "fullname": "osid.assessment.authoring.SequenceRuleEnablerSearchOrder", 
         "shortname": "SequenceRuleEnablerSearchOrder", 
         "category": "search_orders", 
         "doc": {
            "headline": "An interface for specifying the ordering of search results.", 
            "body": ""
         }, 
         "inherit_fullnames": [
            "osid.OsidEnablerSearchOrder"
         ], 
         "inherit_shortnames": [
            "OsidEnablerSearchOrder"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidEnablerSearchOrder"
            }
         ], 
         "method_names": [
            "get_sequence_rule_enabler_search_order_record"
         ], 
         "methods": [
            {
               "name": "get_sequence_rule_enabler_search_order_record", 
               "doc": {
                  "headline": "Gets the sequence rule enabler search order record corresponding to the given sequence rule enabler record ``Type``.", 
                  "body": "        Multiple retrievals return the same underlying object."
               }, 
               "arg_doc": "        arg:    sequence_rule_enabler_record_type (osid.type.Type): a\n                sequence rule enabler record type\n", 
               "return_doc": "        return: (osid.assessment.authoring.records.SequenceRuleEnablerSe\n                archOrderRecord) - the sequence rule enabler search\n                order record", 
               "error_doc": "        raise:  NullArgument - ``sequence_rule_enabler_record_type`` is\n                ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unsupported -\n                ``has_record_type(sequence_rule_enabler_record_type)``\n                is ``false``", 
               "sphinx_param_doc": "        :param sequence_rule_enabler_record_type: a sequence rule enabler record type\n        :type sequence_rule_enabler_record_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "        :return: the sequence rule enabler search order record\n        :rtype: ``osid.assessment.authoring.records.SequenceRuleEnablerSearchOrderRecord``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``sequence_rule_enabler_record_type`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unsupported`` -- ``has_record_type(sequence_rule_enabler_record_type)`` is ``false``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "sequence_rule_enabler_record_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "osid.assessment.authoring.records.SequenceRuleEnablerSearchOrderRecord", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.assessment.authoring.records.SequenceRuleEnablerSearchOrderRecord", 
         "shortname": "SequenceRuleEnablerSearchOrderRecord", 
         "category": "records", 
         "doc": {
            "headline": "A record for a ``SequenceRuleEnablerSearchOrder``.", 
            "body": "    The methods specified by the record type are available through the\n    underlying object."
         }, 
         "inherit_fullnames": [
            "osid.OsidRecord"
         ], 
         "inherit_shortnames": [
            "OsidRecord"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidRecord"
            }
         ], 
         "method_names": [], 
         "methods": []
      }, 
      {
         "fullname": "osid.assessment.authoring.SequenceRuleEnablerSearch", 
         "shortname": "SequenceRuleEnablerSearch", 
         "category": "searches", 
         "doc": {
            "headline": "The search interface for governing sequence rule enabler searches.", 
            "body": ""
         }, 
         "inherit_fullnames": [
            "osid.OsidSearch"
         ], 
         "inherit_shortnames": [
            "OsidSearch"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidSearch"
            }
         ], 
         "method_names": [
            "search_among_sequence_rule_enablers", 
            "order_sequence_rule_enabler_results", 
            "get_sequence_rule_enabler_search_record"
         ], 
         "methods": [
            {
               "name": "search_among_sequence_rule_enablers", 
               "doc": {
                  "headline": "Execute this search among the given list of sequence rule enablers.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    sequence_rule_enabler_ids (osid.id.IdList): list of\n                sequence rule enablers\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``sequence_rule_enabler_ids`` is ``null``", 
               "sphinx_param_doc": "        :param sequence_rule_enabler_ids: list of sequence rule enablers\n        :type sequence_rule_enabler_ids: ``osid.id.IdList``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``sequence_rule_enabler_ids`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.IdList", 
                     "var_name": "sequence_rule_enabler_ids", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.IdList"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "order_sequence_rule_enabler_results", 
               "doc": {
                  "headline": "Specify an ordering to the search results.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    sequence_rule_enabler_search_order\n                (osid.assessment.authoring.SequenceRuleEnablerSearchOrde\n                r): sequence rule enabler search order\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``sequence_rule_enabler_search_order`` is\n                ``null``\n        raise:  Unsupported - ``sequence_rule_enabler_search_order`` is\n                not of this service", 
               "sphinx_param_doc": "        :param sequence_rule_enabler_search_order: sequence rule enabler search order\n        :type sequence_rule_enabler_search_order: ``osid.assessment.authoring.SequenceRuleEnablerSearchOrder``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``sequence_rule_enabler_search_order`` is ``null``\n        :raise: ``Unsupported`` -- ``sequence_rule_enabler_search_order`` is not of this service", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.assessment.authoring.SequenceRuleEnablerSearchOrder", 
                     "var_name": "sequence_rule_enabler_search_order", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.assessment.authoring.SequenceRuleEnablerSearchOrder"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_sequence_rule_enabler_search_record", 
               "doc": {
                  "headline": "Gets the sequence rule enabler search record corresponding to the given sequence rule enabler search record ``Type``.", 
                  "body": "        This method is used to retrieve an object implementing the\n        requested record."
               }, 
               "arg_doc": "        arg:    sequence_rule_enabler_search_record_type\n                (osid.type.Type): a sequence rule enabler search record\n                type\n", 
               "return_doc": "        return: (osid.assessment.authoring.records.SequenceRuleEnablerSe\n                archRecord) - the sequence rule enabler search record", 
               "error_doc": "        raise:  NullArgument -\n                ``sequence_rule_enabler_search_record_type`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unsupported -\n                ``has_record_type(sequence_rule_enabler_search_record_ty\n                pe)`` is ``false``", 
               "sphinx_param_doc": "        :param sequence_rule_enabler_search_record_type: a sequence rule enabler search record type\n        :type sequence_rule_enabler_search_record_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "        :return: the sequence rule enabler search record\n        :rtype: ``osid.assessment.authoring.records.SequenceRuleEnablerSearchRecord``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``sequence_rule_enabler_search_record_type`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unsupported`` -- ``has_record_type(sequence_rule_enabler_search_record_type)`` is ``false``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "sequence_rule_enabler_search_record_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "osid.assessment.authoring.records.SequenceRuleEnablerSearchRecord", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.assessment.authoring.records.SequenceRuleEnablerSearchRecord", 
         "shortname": "SequenceRuleEnablerSearchRecord", 
         "category": "records", 
         "doc": {
            "headline": "A record for a ``SequenceRuleEnablerSearch``.", 
            "body": "    The methods specified by the record type are available through the\n    underlying object."
         }, 
         "inherit_fullnames": [
            "osid.OsidRecord"
         ], 
         "inherit_shortnames": [
            "OsidRecord"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidRecord"
            }
         ], 
         "method_names": [], 
         "methods": []
      }, 
      {
         "fullname": "osid.assessment.authoring.SequenceRuleEnablerSearchResults", 
         "shortname": "SequenceRuleEnablerSearchResults", 
         "category": "searches", 
         "doc": {
            "headline": "This interface provides a means to capture results of a search.", 
            "body": ""
         }, 
         "inherit_fullnames": [
            "osid.OsidSearchResults"
         ], 
         "inherit_shortnames": [
            "OsidSearchResults"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidSearchResults"
            }
         ], 
         "method_names": [
            "get_sequence_rule_enablers", 
            "get_sequence_rule_enabler_query_inspector", 
            "get_sequence_rule_enabler_search_results_record"
         ], 
         "methods": [
            {
               "name": "get_sequence_rule_enablers", 
               "doc": {
                  "headline": "Gets the ``SequenceRuleEnablerList`` resulting from a search.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.assessment.authoring.SequenceRuleEnablerList) -\n                the sequence rule enabler list", 
               "error_doc": "        raise:  IllegalState - list has already been retrieved", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the sequence rule enabler list\n        :rtype: ``osid.assessment.authoring.SequenceRuleEnablerList``", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- list has already been retrieved", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.assessment.authoring.SequenceRuleEnablerList", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract"
               }
            }, 
            {
               "name": "get_sequence_rule_enabler_query_inspector", 
               "doc": {
                  "headline": "Gets the inspector for the query to examine the terms used in the search.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return:\n                (osid.assessment.authoring.SequenceRuleEnablerQueryInspe\n                ctor) - the sequence rule enabler query inspector", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the sequence rule enabler query inspector\n        :rtype: ``osid.assessment.authoring.SequenceRuleEnablerQueryInspector``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.assessment.authoring.SequenceRuleEnablerQueryInspector", 
               "errors": {}
            }, 
            {
               "name": "get_sequence_rule_enabler_search_results_record", 
               "doc": {
                  "headline": "Gets the sequence rule enabler search results record corresponding to the given sequence rule enabler search record ``Type``.", 
                  "body": "        This method must be used to retrieve an object implementing the\n        requested record."
               }, 
               "arg_doc": "        arg:    sequence_rule_enabler_search_record_type\n                (osid.type.Type): a sequence rule enabler search record\n                type\n", 
               "return_doc": "        return: (osid.assessment.authoring.records.SequenceRuleEnablerSe\n                archResultsRecord) - the sequence rule enabler search\n                results record", 
               "error_doc": "        raise:  NullArgument -\n                ``sequence_rule_enabler_search_record_type`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure occurred\n        raise:  Unsupported -\n                ``has_record_type(sequence_rule_enabler_search_record_ty\n                pe)`` is ``false``", 
               "sphinx_param_doc": "        :param sequence_rule_enabler_search_record_type: a sequence rule enabler search record type\n        :type sequence_rule_enabler_search_record_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "        :return: the sequence rule enabler search results record\n        :rtype: ``osid.assessment.authoring.records.SequenceRuleEnablerSearchResultsRecord``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``sequence_rule_enabler_search_record_type`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure occurred\n        :raise: ``Unsupported`` -- ``has_record_type(sequence_rule_enabler_search_record_type)`` is ``false``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "sequence_rule_enabler_search_record_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "osid.assessment.authoring.records.SequenceRuleEnablerSearchResultsRecord", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.assessment.authoring.records.SequenceRuleEnablerSearchResultsRecord", 
         "shortname": "SequenceRuleEnablerSearchResultsRecord", 
         "category": "records", 
         "doc": {
            "headline": "A record for a ``SequenceRuleEnablerSearchResults``.", 
            "body": "    The methods specified by the record type are available through the\n    underlying object."
         }, 
         "inherit_fullnames": [
            "osid.OsidRecord"
         ], 
         "inherit_shortnames": [
            "OsidRecord"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidRecord"
            }
         ], 
         "method_names": [], 
         "methods": []
      }, 
      {
         "fullname": "osid.assessment.authoring.SequenceRuleEnablerReceiver", 
         "shortname": "SequenceRuleEnablerReceiver", 
         "category": "receivers", 
         "doc": {
            "headline": "The sequence rule enabler receiver is the consumer supplied interface for receiving notifications pertaining to new, updated or deleted sequence rule enablers.", 
            "body": ""
         }, 
         "inherit_fullnames": [
            "osid.OsidReceiver"
         ], 
         "inherit_shortnames": [
            "OsidReceiver"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidReceiver"
            }
         ], 
         "method_names": [
            "new_sequence_rule_enabler", 
            "changed_sequence_rule_enabler", 
            "deleted_sequence_rule_enabler"
         ], 
         "methods": [
            {
               "name": "new_sequence_rule_enabler", 
               "doc": {
                  "headline": "The callback for notifications of new sequence rule enablers.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    sequence_rule_enabler_id (osid.id.Id): the ``Id`` of the\n                new ``SequenceRuleEnabler``\n", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "        :param sequence_rule_enabler_id: the ``Id`` of the new ``SequenceRuleEnabler``\n        :type sequence_rule_enabler_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "sequence_rule_enabler_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "changed_sequence_rule_enabler", 
               "doc": {
                  "headline": "The callback for notification of updated sequence rule enablers.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    sequence_rule_enabler_id (osid.id.Id): the ``Id`` of the\n                updated ``SequenceRuleEnabler``\n", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "        :param sequence_rule_enabler_id: the ``Id`` of the updated ``SequenceRuleEnabler``\n        :type sequence_rule_enabler_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "sequence_rule_enabler_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "deleted_sequence_rule_enabler", 
               "doc": {
                  "headline": "The callback for notification of deleted sequence rule enablers.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    sequence_rule_enabler_id (osid.id.Id): the ``Id`` of the\n                deleted ``SequenceRuleEnabler``\n", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "        :param sequence_rule_enabler_id: the ``Id`` of the deleted ``SequenceRuleEnabler``\n        :type sequence_rule_enabler_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "sequence_rule_enabler_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {}
            }
         ]
      }, 
      {
         "fullname": "osid.assessment.authoring.SequenceRuleEnablerList", 
         "shortname": "SequenceRuleEnablerList", 
         "category": "objects", 
         "doc": {
            "headline": "Like all ``OsidLists,``  ``SequenceRuleEnablerList`` provides a means for accessing ``SequenceRuleEnabler`` elements sequentially either one at a time or many at a time.", 
            "body": "    Examples: while (scel.hasNext()) { SequenceRuleEnabler enabler =\n    scel.getNextSequenceRuleEnabler(); }\n\n    or\n      while (scel.hasNext()) {\n           SequenceRuleEnabler[] enablers = scel.getNextSequenceRuleEnablers(scel.available());\n      }\n    \n"
         }, 
         "inherit_fullnames": [
            "osid.OsidList"
         ], 
         "inherit_shortnames": [
            "OsidList"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidList"
            }
         ], 
         "method_names": [
            "get_next_sequence_rule_enabler", 
            "get_next_sequence_rule_enablers"
         ], 
         "methods": [
            {
               "name": "get_next_sequence_rule_enabler", 
               "doc": {
                  "headline": "Gets the next ``SequenceRuleEnabler`` in this list.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.assessment.authoring.SequenceRuleEnabler) - the\n                next ``SequenceRuleEnabler`` in this list. The\n                ``has_next()`` method should be used to test that a next\n                ``SequenceRuleEnabler`` is available before calling this\n                method.", 
               "error_doc": "        raise:  IllegalState - no more elements available in this list\n        raise:  OperationFailed - unable to complete request", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the next ``SequenceRuleEnabler`` in this list. The ``has_next()`` method should be used to test that a next ``SequenceRuleEnabler`` is available before calling this method.\n        :rtype: ``osid.assessment.authoring.SequenceRuleEnabler``", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- no more elements available in this list\n        :raise: ``OperationFailed`` -- unable to complete request", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.assessment.authoring.SequenceRuleEnabler", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational"
               }
            }, 
            {
               "name": "get_next_sequence_rule_enablers", 
               "doc": {
                  "headline": "Gets the next set of ``SequenceRuleEnabler`` elements in this list.", 
                  "body": "        The specified amount must be less than or equal to the return\n        from ``available()``."
               }, 
               "arg_doc": "        arg:    n (cardinal): the number of ``SequenceRuleEnabler``\n                elements requested which must be less than or equal to\n                ``available()``\n", 
               "return_doc": "        return: (osid.assessment.authoring.SequenceRuleEnabler) - an\n                array of ``SequenceRuleEnabler`` elements.The length of\n                the array is less than or equal to the number specified.", 
               "error_doc": "        raise:  IllegalState - no more elements available in this list\n        raise:  OperationFailed - unable to complete request", 
               "sphinx_param_doc": "        :param n: the number of ``SequenceRuleEnabler`` elements requested which must be less than or equal to ``available()``\n        :type n: ``cardinal``\n", 
               "sphinx_return_doc": "        :return: an array of ``SequenceRuleEnabler`` elements.The length of the array is less than or equal to the number specified.\n        :rtype: ``osid.assessment.authoring.SequenceRuleEnabler``", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- no more elements available in this list\n        :raise: ``OperationFailed`` -- unable to complete request", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "cardinal", 
                     "var_name": "n", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "cardinal"
               ], 
               "return_type": "osid.assessment.authoring.SequenceRuleEnabler", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational"
               }
            }
         ]
      }
   ], 
   "full_name": "osid.assessment.authoring"
}
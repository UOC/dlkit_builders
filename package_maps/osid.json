{
   "name": "osid", 
   "version": "3.0.0", 
   "title": "Core Service Interface Definitions", 
   "copyright": "Copyright (c) 2002-2004, 2006-2008 Massachusetts Institute of\nTechnology.\n\nCopyright (c) 2009-2012 Ingenescus. All Rights Reserved.", 
   "license": "This Work is being provided by the copyright holder(s) subject to the\nfollowing license. By obtaining, using and/or copying this Work, you\nagree that you have read, understand, and will comply with the following\nterms and conditions.\n\nPermission to use, copy and distribute unmodified versions of this Work,\nfor any purpose, without fee or royalty is hereby granted, provided that\nyou include the above copyright notices and the terms of this license on\nALL copies of the Work or portions thereof.\n\nYou may modify or create Derivatives of this Work only for your internal\npurposes. You shall not distribute or transfer any such Derivative of\nthis Work to any location or to any third party. For the purposes of\nthis license, \"Derivative\" shall mean any derivative of the Work as\ndefined in the United States Copyright Act of 1976, such as a\ntranslation or modification.\n\nThis Work and the information contained herein is provided on an \"AS IS\"\nbasis WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT\nNOT LIMITED TO WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR\nPURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\nHOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN\nAN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\nCONNECTION WITH THE WORK OR THE USE OR OTHER DEALINGS IN THE WORK.\n\nThe export of software employing encryption technology may require a\nspecific license from the United States Government. It is the\nresponsibility of any person or organization contemplating export to\nobtain such a license before exporting this Work.", 
   "summary": "The Open Service Interface Definitions (OSIDs) is a service-based\narchitecture to promote software interoperability. The OSIDs are a large\nsuite of interface contract specifications that describe the integration\npoints among services and system components for the purpose of creating\nchoice among a variety of different and independently developed\napplications and systems, allowing independent evolution of software\ncomponents within a complex system, and federated service providers.\n\nThe OSIDs were initially developed in 2001 as part of the MIT Open\nKnowledge Initiative Project funded by the Andrew W. Mellon Foundation\nto provide an architecture for higher education learning systems. OSID\n3K development began in 2006 to redesign the capabilities of the\nspecifications to apply to a much broader range of service domains and\nintegration challenges among both small and large-scale enterprise\nsystems.\n\nThe ``osid`` package defines the building blocks for the OSIDs which are\ndefined in packages for their respective services. This package defines\nthe top-level interfaces used by all the OSIDs as well as specification\nmetadata and the OSID Runtime interface.\n\nMeta Interfaces and Enumerations\n\n  * ``OSID:`` an enumeration listing the OSIDs defined in the\n    specification.\n  * ``Syntax:`` an enumeration listing primitive types\n  * ``Metadata:`` an interface for describing data constraints on a data\n    element\n\n\nInterface Behavioral Markers\n\nInterface behavioral markers are used to tag a behavioral pattern of the\ninterface used to construct other object interfaces.\n\n  * ``OsidPrimitive:`` marks an OSID interface used as a primitive. OSID\n    primitives may take the form interfaces if not bound to a language\n    primitive. Interfaces used as primitives are marked to indicate that\n    the underlying objects may be constructed by an OSID Consumer and an\n    OSID Provider must honor any OSID primitive regardless of its\n    origin.\n  * ``Identifiable:`` Marks an interface identifiable by an OSID ``Id.``\n  * ``Extensible:`` Marks an interface as extensible through\n    ``OsidRecords.``\n  * ``Browsable:`` Marks an interface as providing ``Property``\n    inspection for its ``OsidRecords.``\n  * ``Suppliable:`` Marks an interface as accepting data from an OSID\n    Consumer.\n  * ``Temporal:`` Marks an interface that has a lifetime with begin an\n    end dates.\n  * ``Subjugateable:`` Mars an interface that is dependent on another\n    object.\n  * ``Aggregateable:`` Marks an interface that contains other objects\n    normally related through other services.\n  * ``Containable:`` Marks an interface that contains a recursive\n    reference to itself.\n  * ``Sourceable:`` Marks an interface as having a provider.\n  * ``Federateable:`` Marks an interface that can be federated using the\n    OSID Hierarchy pattern.\n  * ``Operable:`` Marks an interface as responsible for performing\n    operatons or tasks. ``Operables`` may be enabled or disabled.\n\n\nAbstract service Interfaces\n\n  * ``OsidProfile:`` Defines interoperability methods used by\n    OsidManagers.\n  * ``OsidManager:`` The entry point into an OSID and provides access to\n    ``OsidSessions.``\n  * ``OsidProxyManager:`` Another entry point into an OSID providing a\n    means for proxying data from a middle tier application server to an\n    underlying OSID Provider.\n  * ``OsidSession`` : A service interface accessible from an\n    ``OsidManager`` that defines a set of methods for an aspect of a\n    service.\n\n\nObject-like interfaces are generally defined along lines of\ninteroperability separating issues of data access from data management\nand searching. These interfaces may also implement any of the abstract\nbehavioral interfaces listed above. The OSIDs do not adhere to a DAO/DTO\nmodel in its service definitions in that there are service methods\ndefined on the objects (although they can be implemented using DTOs if\ndesired). For the sake of an outline, we'll pretend they are data\nobjects.\n\n  * ``OsidObject:`` Defines object data. ``OsidObjects`` are accessed\n    from ``OsidSessions.``  ``OsidObjects`` are part of an interface\n    hierarchy whose interfaces include the behavioral markers and a\n    variety of common ``OsidObjects.`` All ``OsidObjects`` are\n    ``Identifiable,``  ``Extensible,`` and have a ``Type.`` There are\n    several variants of ``OsidObjects`` that indicate a more precise\n    behavior.\n  * ``OsidObjectQuery:`` Defines a set of methods to query an OSID for\n    its ``OsidObjects`` . An ``OsidQuery`` is accessed from an\n    ``OsidSession.``\n  * ``OsidObjectQueryInspector:`` Defines a set of methods to examine an\n    ``OsidQuery.``\n  * ``OsidObjectForm:`` Defines a set of methods to create and update\n    data. ``OsidForms`` are accessed from ``OsidSessions.``\n  * ``OsidObjectSearchOrder:`` Defines a set of methods to order search\n    results. ``OsidSearchOrders`` are accessed from ``OsidSessions.``\n\n\nMost objects are or are derived from ``OsidObjects``. Some object\ninterfaces may not implement ``OsidObejct`` but instead derive directly\nfrom interface behavioral markers. Other ``OsidObjects`` may include\ninterface behavioral markers to indicate functionality beyond a plain\nobject. Several categories of ``OsidObjects`` have been defined to\ncluster behaviors to semantically distinguish their function in the\nOSIDs.\n\n  * ``OsidCatalog:`` At the basic level, a catalog represents a\n    collection of other ``OsidObjects.`` The collection may be physical\n    or virtual and may be federated to build larger ``OsidCatalogs``\n    using hierarchy services. ``OsidCatalogs`` may serve as a control\n    point to filter or constrain the ``OsidObjects`` that may be visible\n    or created. Each ``OsidCatalog`` may have its own provider identifty\n    apart from the service provider.\n  * ``OsidRelationship:`` Relates two ``OsidObjects.`` The\n    ``OsidRelationship`` represents the edge in a graph that may have\n    its own relationship type and data. ``OsidRelationships`` are\n    ``Temporal`` in that they have a time in which the relationship came\n    into being and a time when the relationship ends.\n  * ``OsidRule:`` Defines an injection point for logic. An ``OsidRule``\n    may represent some constraint, evaluation, or execution. While\n    authoring of ``OsidRules`` is outside the scope of the OSIDs, an\n    ``OsidRule`` provides the mean to identify the rule and map it to\n    certain ``OsidObjects`` to effect behavior of a service.\n\n\nThe most basic operations of an OSID center on retrieval, search, create\n& update, and notifications on changes to an ``OsidObject``. The more\nadvanced OSIDs model a system behavior where a variety of implicit\nrelationships, constraints and rules come into play.\n\n  * ``OsidGovernator:`` Implies an activity or operation exists in the\n    OSID Provider acting as an ``Operable`` point for a set of rules\n    governing related ``OsidObjects.`` The ``OsidGovernator`` represents\n    an engine of sorts in an OSID Provider and may have its own provider\n    identity.\n  * ``OsidCompendium`` : ``OsidObjects`` which are reports or summaries\n    based on transactional data managed elsewhere.\n\n\nManaging data governing rules occurs in a separate set of interfaces\nfrom the effected ``OsidObjects`` (and often in a separate package).\nThis allows for a normalized set of rules managing a small set of\ncontrol points in a potentially large service.\n\n  * ``OsidEnabler:`` A managed control point to enable or disable the\n    operation or effectiveness of another ``OsidObject`` . Enablers\n    create a dynamic environment where behaviors and relationships can\n    come and go based on rule evauations.\n  * ``OsidConstrainer:`` A managed control point to configure the\n    constraints on the behavior of another ``OsidObject.``\n  * ``OsidProcessor:`` A managed control point to configure the behavior\n    of another ``OsidObject`` where some kins of processing is implied.\n\n\nOther Abstract Interfaces\n\n  * ``OsidSearch:`` Defines set of methods to manage search options for\n    performing searches.\n  * ``OsidSearchResults:`` Defines a set of methods to examine search\n    results.\n\n  * ``OsidReceiver:`` Defines a set of methods invoked for asynchronous\n    notification.\n  * ``OsidList:`` Defines a set of methods to sequentially access a set\n    of objects.\n  * ``OsidNode:`` An interface used by hierarchy nodes.\n  * ``OsidCondition:`` An input or \"statement of fact\" into an\n    ``OsidRule`` evaluation.\n  * ``OsidInput:`` An input of source data into an ``OsidRule``\n    processor.\n  * ``OsidResult:`` The output from processing an ``OsidRule.``\n  * ``OsidRecord:`` An interface marker for an extension to another\n    interface. ``OsidRecord`` are negotiated using OSID ``Types.``\n\n  * ``Property:`` Maps a name to a value. Properties are available in\n    OSID objects to provide a simplified view of data that may exist\n    within a typed interface.\n  * ``PropertyList:`` A list of properties.\n\n\nRuntime\n\n  * ``OsidRuntimeProfile:`` The ``OsidProfile`` for the runtime\n    ``OsidManager.``\n  * ``OsidRuntimeManager:`` The OSID Runtime service.\n\n\nAbstract Flow\n\nGenerally, these definitions are abstract and not accesed directly. They\nare used as building blocks to define interfaces in the OSIDs\nthemselves. OSIDs derive most of their definitions from a definition in\nthe osid package. The methods that are defined at this abstract level\nversus the methods defined directly in a specific OSID is determined by\nthe typing in the method signatures. The osid package interfaces are a\nmeans of ensuring consistency of common methods and not designed to\nfacilitate object polymorphism among different OSIDs. A language binder\nmay elect to alter the interface hierarchy presented in this\nspecification and a provider need not parallel these interfaces in their\nimplementations.\n\nThe flow of control through any OSID can be described in terms of these\ndefinitions. An ``OsidManager`` or ``OsidProxyManager`` is retrieved\nfrom the ``OsidRuntimeManager`` for a given service. Both types of\nmanagers share an interface for describing what they support in the\n``OsidProfile``.\n\n``OsidSessions`` are created from the ``OsidManager``.  ``OsidSessions``\ntend to be organized along clusters of like-functionality. Lookup-\noriented sessions retrieve ``OsidObjects``. Return of multiple\n``OsidObjects`` is done via the ``OsidList``. Search-oriented sessions\nretrieve ``OsidObjects`` through searches provided through the\n``OsidQuery`` and ``OsidSearch`` interfaces.\n\nAdministrative-oriented sessions create and update ``OsidObjects`` using\nthe ``OsidForm`` interface. The ``OsidForm`` makes available\n``Metadata`` to help define its rules for setting and changing various\ndata elements.\n\n``OsidObjects`` can be organized within ``OsidCatalogs``. An\n``OsidCatalog`` is hierarchical and can be traversed through an\n``OsidNode``. An ``OsidQuery`` or an ``OsidSearchOrder`` may be mapped\nto a dynamic ``OsidCatalog``. Such a query may be examined using an\n``OsidQueryInspector``.\n\nA notification session provides a means for subscribing to events, \"a\nnew object has been created\", for example, and these events are received\nfrom an ``OsidReceiver``.\n\nMeta OSID Specification\n\nThe OSID Specification framework defines the interace and method\nstructures as well as the language primitives and errors used throughout\nthe OSIDs. The OSID Specifications are defined completely in terms of\ninterfaces and the elements specified in the meta specification.\n\nLanguage Primitives\n\nThs meta OSID Specification enumerates the allowable language primitives\nthat can be used in OSID method signatures. Parameters and returns in\nOSID methods may be specified in terms of other OSID interfaces or using\none of these primitives. An OSID Binder translates these language\nprimitives into an appropriate language primitive counterpart.\n\nAn OSID Primitive differs from a language primitive. An OSID Primitive\nis an interface used to describe a more complex structure than a simple\nlanguage primitive can support. Both OSID Primitives and language\nprimitives have the same behavior in the OSIDs in that an there is no\nservice encapsulation present allowing OSID Primitives to be consructed\nby an OSID Consumer.\n\nErrors\n\nOSID methods are required to return a value, if specified, or return one\nof the errors specified in the method signature. The meta package\ndefines the set of errors that a method signtaure may use.\n\nErrors should result when the contract of the interface as been violated\nor cannot be fulfilled and it is necessary to disrupt the flow of\ncontrol for a consumer. Different errors are specified where it is\nforseen that a consumer may wish to execute a different action without\nviolating the encapsulation of internal provider operations. Such\nactions do not include debugging or other detailed information which is\nthe responsibility of the provider to manage. As such, the number of\nerrors defined across all the interfaces is kept to a minimum and the\ncontext of the error may vary from method to method in accordance with\nthe spceification.\n\nErrors are categorized to convey the audience to which the error\npertains.\n\n  * User Errors: Errors which may be the result of a user operation\n    intended for the user.\n  * Operational Errors: Errors which may be the result of a system or\n    some other problem intended for the user.\n  * Consumer Contract Errors: Software errors resulting in the use of\n    the OSIDs by an OSID Consumer intended for the application\n    programmer. These also include integration problems where the OSID\n    Consumer bypassed a method to test for support of a service or type.\n  * Provider Contract Errors: Software errors in the use of an OSID by\n    an OSID Provider intended for an implementation programmer.\n\n\nCompliance\n\nOSID methods include a compliance statement indicating whether a method\nis required or optional to implement. An optional OSID method is one\nthat defines an UNIMPLEMENTED error and there is a corresponding method\nto test for the existence of an implementation.\n\nOSID 3K Acknowledgements\n\n  * Tom Coppeto (Editor & Architect)\n  * Scott Thorne (Architect)\n\n\nThe authors gratefully acknowledge the following individuals for their\ntime, wisdom, and contributions in shaping these specifications.\n\n  * Adam Franco, Middlebury College\n  * Jeffrey Merriman, Massachusetts Institute of Technology\n  * Charles Shubert, Massachusetts Insitute of Technology\n\n  * Prof. Marc Alier, Universitat Polit\u00e8cnica de Catalyuna\n  * Joshua Aresty, Massachusetts Institute of Technology\n  * Fabrizio Cardinali, Giunti Labs\n  * Pablo Casado, Universitat Polit\u00e8cnica de Catalyuna\n  * Alex Chapin, Middlebury College\n  * Craig Counterman, Massachusetts Institute of Technology\n  * Francesc Santanach Delisau, Universitat Oberta de Catalyuna\n  * Prof. Lloren\u00e7 Valverde Garcia, Universitat Oberta de Catalyuna\n  * Catherine Iannuzzo, Massachusetts Institute of Technology\n  * Jeffrey Kahn, Verbena Consulting\n  * Michael Korcynski, Tufts University\n  * Anoop Kumar, Tufts University\n  * Eva de Lera, Universitat Oberta de Catalyuna\n  * Roberto Garc\u00eda Marrod\u00e1n, Universitat Oberta de Catalyuna\n  * Andrew McKinney, Massachusetts Institute of Technology\n  * Scott Morris, Apple\n  * Mark Norton, Nolaria Consulting\n  * Mark O'Neill, Dartmouth College\n  * Prof. Charles Severance, University of Michigan\n  * Stuart Sim, Sun Microsystems/Common Need\n  * Colin Smythe, IMS Global Learning Consortium\n  * George Ward, California State University\n  * Peter Wilkins, Massachusetts Institute of Technology\n  * Norman Wright, Massachusetts Institute of Technology\n\n\nO.K.I. Acknowledgements\n\nOSID 3K is based on the O.K.I. OSIDs developed as part of the MIT Open\nKnowledge Initiative (O.K.I) project 2001-2004.\n\n  * Vijay Kumar, O.K.I. Principal Investigator, Massachusetts Insitute\n    of Technology\n  * Jeffrey Merriman, O.K.I. Project Director, Massachusetts Insitute of\n    Technology\n  * Scott Thorne, O.K.I. Chief Architect, Massachusetts Institute of\n    Technology\n  * Charles Shubert, O.K.I. Architect, Massachusetts Institute of\n    Technology\n  * Lois Brooks, Project Coordinator, Stanford University\n  * Mark Brown, O.K.I. Project Manager, Massachusetts Institute of\n    Technology\n  * Bill Fitzgerald, O.K.I. Finance Manager, Massachusetts Institute of\n    Technology\n  * Judson Harward, Educational Systems Architect, Massachusetts\n    Institute of Technology\n  * Charles Kerns, Educational Systems Architect, Stanford University\n  * Jeffrey Kahn, O.K.I. Partner, Verbena Consulting\n  * Judith Leonard, O.K.I. Project Administrator, Massachusetts\n    Institute of Technology\n  * Phil Long, O.K.I. Outreach Coordinator, Massachusetts Institute of\n    Technology\n\n  * Cambridge University, O.K.I. Core Collaborator\n  * Dartmouth College, O.K.I. Core Collaborator\n  * Massachusetts Institute of Technology, O.K.I. Core Collaborator\n  * North Carolina State University, O.K.I. Core Collaborator\n  * Stanford University, O.K.I. Core Collaborator\n  * University of Michigan, O.K.I. Core Collaborator\n  * University of Pennsylvania, O.K.I. Core Collaborator\n  * University of Wisconsin, Madison, O.K.I. Core Collaborator\n", 
   "interfaces": [
      {
         "fullname": "osid.Metadata", 
         "shortname": "Metadata", 
         "category": "metadata", 
         "doc": {
            "headline": "The ``Metadata`` interface defines a set of methods describing a the syntax and rules for creating and updating a data element inside an ``OsidForm``.", 
            "body": "    This interface provides a means to retrieve special restrictions\n    placed upon data elements such as sizes and ranges that may vary\n    from provider to provider or from object to object."
         }, 
         "inherit_fullnames": [], 
         "inherit_shortnames": [], 
         "inherit_pkg_names": [], 
         "inheritance": [], 
         "method_names": [
            "get_element_id", 
            "get_element_label", 
            "get_instructions", 
            "get_syntax", 
            "is_array", 
            "is_required", 
            "is_read_only", 
            "is_linked", 
            "is_value_known", 
            "has_value", 
            "get_units", 
            "get_minimum_elements", 
            "get_maximum_elements", 
            "get_minimum_cardinal", 
            "get_maximum_cardinal", 
            "get_cardinal_set", 
            "get_default_cardinal_values", 
            "get_existing_cardinal_values", 
            "get_coordinate_types", 
            "supports_coordinate_type", 
            "get_axes_for_coordinate_type", 
            "get_minimum_coordinate_values", 
            "get_maximum_coordinate_values", 
            "get_coordinate_set", 
            "get_default_coordinate_values", 
            "get_existing_coordinate_values", 
            "get_currency_types", 
            "supports_currency_type", 
            "get_minimum_currency", 
            "get_maximum_currency", 
            "get_currency_set", 
            "get_default_currency_values", 
            "get_existing_currency_values", 
            "get_date_time_resolution", 
            "get_calendar_types", 
            "supports_calendar_type", 
            "get_time_types", 
            "supports_time_type", 
            "get_minimum_date_time", 
            "get_maximum_date_time", 
            "get_date_time_set", 
            "get_default_date_time_values", 
            "get_existing_date_time_values", 
            "get_decimal_scale", 
            "get_minimum_decimal", 
            "get_maximum_decimal", 
            "get_decimal_set", 
            "get_default_decimal_values", 
            "get_existing_decimal_values", 
            "get_distance_resolution", 
            "get_minimum_distance", 
            "get_maximum_distance", 
            "get_distance_set", 
            "get_default_distance_values", 
            "get_existing_distance_values", 
            "get_minimum_duration", 
            "get_maximum_duration", 
            "get_duration_set", 
            "get_default_duration_values", 
            "get_existing_duration_values", 
            "get_heading_types", 
            "supports_heading_type", 
            "get_axes_for_heading_type", 
            "get_minimum_heading_values", 
            "get_maximum_heading_values", 
            "get_heading_set", 
            "get_default_heading_values", 
            "get_existing_heading_values", 
            "get_id_set", 
            "get_default_id_values", 
            "get_existing_id_values", 
            "get_minimum_integer", 
            "get_maximum_integer", 
            "get_integer_set", 
            "get_default_integer_values", 
            "get_existing_integer_values", 
            "get_object_types", 
            "supports_object_type", 
            "get_object_set", 
            "get_default_object_values", 
            "get_existing_object_values", 
            "get_spatial_unit_record_types", 
            "supports_spatial_unit_record_type", 
            "get_spatial_unit_set", 
            "get_default_spatial_unit_values", 
            "get_existing_spatial_unit_values", 
            "get_minimum_speed", 
            "get_maximum_speed", 
            "get_speed_set", 
            "get_default_speed_values", 
            "get_existing_speed_values", 
            "get_minimum_string_length", 
            "get_maximum_string_length", 
            "get_string_match_types", 
            "supports_string_match_type", 
            "get_string_expression", 
            "get_string_format_types", 
            "get_string_set", 
            "get_default_string_values", 
            "get_existing_string_values", 
            "get_minimum_time", 
            "get_maximum_time", 
            "get_time_set", 
            "get_default_time_values", 
            "get_existing_time_values", 
            "get_type_set", 
            "get_default_type_values", 
            "get_existing_type_values", 
            "get_version_types", 
            "supports_version_type", 
            "get_minimum_version", 
            "get_maximum_version", 
            "get_version_set", 
            "get_default_version_values", 
            "get_existing_version_values"
         ], 
         "methods": [
            {
               "name": "get_element_id", 
               "doc": {
                  "headline": "Gets a unique ``Id`` for the data element.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.id.Id) - an ``Id``", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: an ``Id``\n        :rtype: ``osid.id.Id``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.id.Id", 
               "errors": {}
            }, 
            {
               "name": "get_element_label", 
               "doc": {
                  "headline": "Gets a display label for the data element.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.locale.DisplayText) - a display label", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: a display label\n        :rtype: ``osid.locale.DisplayText``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.locale.DisplayText", 
               "errors": {}
            }, 
            {
               "name": "get_instructions", 
               "doc": {
                  "headline": "Gets instructions for updating this element value.", 
                  "body": "        This is a human readable description of the data element or\n        property that may include special instructions or caveats to the\n        end-user above and beyond what this interface provides."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.locale.DisplayText) - instructions", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: instructions\n        :rtype: ``osid.locale.DisplayText``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.locale.DisplayText", 
               "errors": {}
            }, 
            {
               "name": "get_syntax", 
               "doc": {
                  "headline": "Gets the syntax of this data.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.Syntax) - an enumeration indicating thetype of\n                value", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: an enumeration indicating thetype of value\n        :rtype: ``osid.Syntax``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.Syntax", 
               "errors": {}
            }, 
            {
               "name": "is_array", 
               "doc": {
                  "headline": "Tests if this data element is an array.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if this data is an array, ``false``\n                if a single element", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if this data is an array, ``false`` if a single element\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "is_required", 
               "doc": {
                  "headline": "Tests if this data element is required for creating new objects.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if this element value is required,\n                ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if this element value is required, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "is_read_only", 
               "doc": {
                  "headline": "Tests if this data can be updated.", 
                  "body": "        This may indicate the result of a pre-authorization but is not a\n        guarantee that an authorization failure will not occur when the\n        create or update transaction is issued."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if this data is not updatable,\n                ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if this data is not updatable, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "is_linked", 
               "doc": {
                  "headline": "Tests if this data element is linked to other data in the object.", 
                  "body": "        Updating linked data elements should refresh all metadata and\n        revalidate object elements."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - true if this element is linked, false if\n                updates have no side effect", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: true if this element is linked, false if updates have no side effect\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "is_value_known", 
               "doc": {
                  "headline": "Tests if an existing value is known for this data element.", 
                  "body": "        If it is known that a value does not exist, then this method\n        returns ``true``."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if the element value is known,\n                ``false`` if the element value is not known", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if the element value is known, ``false`` if the element value is not known\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "has_value", 
               "doc": {
                  "headline": "Tests if this data element has a set non-default value.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if this element value has been set,\n                ``false`` otherwise", 
               "error_doc": "        raise:  IllegalState - ``is_value_known()`` is ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if this element value has been set, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- ``is_value_known()`` is ``false``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract"
               }
            }, 
            {
               "name": "get_units", 
               "doc": {
                  "headline": "Gets the units of this data for display purposes ('lbs', 'gills', 'furlongs').", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.locale.DisplayText) - the display units of this\n                data or an empty string if not applicable", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the display units of this data or an empty string if not applicable\n        :rtype: ``osid.locale.DisplayText``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.locale.DisplayText", 
               "errors": {}
            }, 
            {
               "name": "get_minimum_elements", 
               "doc": {
                  "headline": "In the case where an array or list of elements is specified in an ``OsidForm,`` this specifies the minimum number of elements that must be included.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (cardinal) - the minimum elements or ``1`` if\n                ``is_array()`` is ``false``", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the minimum elements or ``1`` if ``is_array()`` is ``false``\n        :rtype: ``cardinal``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "cardinal", 
               "errors": {}
            }, 
            {
               "name": "get_maximum_elements", 
               "doc": {
                  "headline": "In the case where an array or list of elements is specified in an ``OsidForm,`` this specifies the maximum number of elements that can be specified.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (cardinal) - the maximum elements or ``1`` if\n                ``is_array()`` is ``false``", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the maximum elements or ``1`` if ``is_array()`` is ``false``\n        :rtype: ``cardinal``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "cardinal", 
               "errors": {}
            }, 
            {
               "name": "get_minimum_cardinal", 
               "doc": {
                  "headline": "Gets the minimum cardinal value.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (cardinal) - the minimum cardinal", 
               "error_doc": "        raise:  IllegalState - syntax is not a ``CARDINAL``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the minimum cardinal\n        :rtype: ``cardinal``", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- syntax is not a ``CARDINAL``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "cardinal", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract"
               }
            }, 
            {
               "name": "get_maximum_cardinal", 
               "doc": {
                  "headline": "Gets the maximum cardinal value.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (cardinal) - the maximum cardinal", 
               "error_doc": "        raise:  IllegalState - syntax is not a ``CARDINAL``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the maximum cardinal\n        :rtype: ``cardinal``", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- syntax is not a ``CARDINAL``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "cardinal", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract"
               }
            }, 
            {
               "name": "get_cardinal_set", 
               "doc": {
                  "headline": "Gets the set of acceptable cardinal values.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (cardinal) - a set of cardinals or an empty array if not\n                restricted", 
               "error_doc": "        raise:  IllegalState - syntax is not a ``CARDINAL``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: a set of cardinals or an empty array if not restricted\n        :rtype: ``cardinal``", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- syntax is not a ``CARDINAL``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "cardinal", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract"
               }
            }, 
            {
               "name": "get_default_cardinal_values", 
               "doc": {
                  "headline": "Gets the default cardinal values.", 
                  "body": "        These are the values used if the element value is not provided\n        or is cleared. If ``is_array()`` is false, then this method\n        returns at most a single value."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (cardinal) - the default cardinal values", 
               "error_doc": "        raise:  IllegalState - syntax is not a ``CARDINAL`` or\n                ``is_required()`` is ``true``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the default cardinal values\n        :rtype: ``cardinal``", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- syntax is not a ``CARDINAL`` or ``is_required()`` is ``true``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "cardinal", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract"
               }
            }, 
            {
               "name": "get_existing_cardinal_values", 
               "doc": {
                  "headline": "Gets the existing cardinal values.", 
                  "body": "        If ``has_value()`` and ``is_required()`` are ``false,`` then\n        these values are the default values ````. If ``is_array()`` is\n        false, then this method returns at most a single value."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (cardinal) - the existing cardinal values", 
               "error_doc": "        raise:  IllegalState - syntax is not a ``CARDINAL`` or\n                ``is_value_known()`` is ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the existing cardinal values\n        :rtype: ``cardinal``", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- syntax is not a ``CARDINAL`` or ``is_value_known()`` is ``false``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "cardinal", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract"
               }
            }, 
            {
               "name": "get_coordinate_types", 
               "doc": {
                  "headline": "Gets the set of acceptable coordinate types.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.type.Type) - the set of coordinate types", 
               "error_doc": "        raise:  IllegalState - syntax is not a ``COORDINATE or\n                SPATIALUNIT``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the set of coordinate types\n        :rtype: ``osid.type.Type``", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- syntax is not a ``COORDINATE or SPATIALUNIT``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.type.Type", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract"
               }
            }, 
            {
               "name": "supports_coordinate_type", 
               "doc": {
                  "headline": "Tests if the given coordinate type is supported.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    coordinate_type (osid.type.Type): a coordinate Type\n", 
               "return_doc": "        return: (boolean) - ``true`` if the type is supported, ``false``\n                otherwise", 
               "error_doc": "        raise:  IllegalState - syntax is not a ``COORDINATE``\n        raise:  NullArgument - ``coordinate_type`` is ``null``", 
               "sphinx_param_doc": "        :param coordinate_type: a coordinate Type\n        :type coordinate_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "        :return: ``true`` if the type is supported, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- syntax is not a ``COORDINATE``\n        :raise: ``NullArgument`` -- ``coordinate_type`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "coordinate_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "boolean", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract", 
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "get_axes_for_coordinate_type", 
               "doc": {
                  "headline": "Gets the number of axes for a given supported coordinate type.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    coordinate_type (osid.type.Type): a coordinate Type\n", 
               "return_doc": "        return: (cardinal) - the number of axes", 
               "error_doc": "        raise:  IllegalState - syntax is not a ``COORDINATE``\n        raise:  NullArgument - ``coordinate_type`` is ``null``\n        raise:  Unsupported -\n                ``supports_coordinate_type(coordinate_type)`` is\n                ``false``", 
               "sphinx_param_doc": "        :param coordinate_type: a coordinate Type\n        :type coordinate_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "        :return: the number of axes\n        :rtype: ``cardinal``", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- syntax is not a ``COORDINATE``\n        :raise: ``NullArgument`` -- ``coordinate_type`` is ``null``\n        :raise: ``Unsupported`` -- ``supports_coordinate_type(coordinate_type)`` is ``false``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "coordinate_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "cardinal", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_minimum_coordinate_values", 
               "doc": {
                  "headline": "Gets the minimum coordinate values given supported coordinate type.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    coordinate_type (osid.type.Type): a coordinate Type\n", 
               "return_doc": "        return: (decimal) - the minimum coordinate values", 
               "error_doc": "        raise:  IllegalState - syntax is not a ``COORDINATE``\n        raise:  NullArgument - ``coordinate_type`` is ``null``\n        raise:  Unsupported -\n                ``supports_coordinate_type(coordinate_type)`` is\n                ``false``", 
               "sphinx_param_doc": "        :param coordinate_type: a coordinate Type\n        :type coordinate_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "        :return: the minimum coordinate values\n        :rtype: ``decimal``", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- syntax is not a ``COORDINATE``\n        :raise: ``NullArgument`` -- ``coordinate_type`` is ``null``\n        :raise: ``Unsupported`` -- ``supports_coordinate_type(coordinate_type)`` is ``false``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "coordinate_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "decimal", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_maximum_coordinate_values", 
               "doc": {
                  "headline": "Gets the maximum coordinate values given supported coordinate type.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    coordinate_type (osid.type.Type): a coordinate Type\n", 
               "return_doc": "        return: (decimal) - the maximum coordinate values", 
               "error_doc": "        raise:  IllegalState - syntax is not a ``COORDINATE``\n        raise:  NullArgument - ``coordinate_type`` is ``null``\n        raise:  Unsupported -\n                ``supports_coordinate_type(coordinate_type)`` is\n                ``false``", 
               "sphinx_param_doc": "        :param coordinate_type: a coordinate Type\n        :type coordinate_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "        :return: the maximum coordinate values\n        :rtype: ``decimal``", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- syntax is not a ``COORDINATE``\n        :raise: ``NullArgument`` -- ``coordinate_type`` is ``null``\n        :raise: ``Unsupported`` -- ``supports_coordinate_type(coordinate_type)`` is ``false``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "coordinate_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "decimal", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_coordinate_set", 
               "doc": {
                  "headline": "Gets the set of acceptable coordinate values.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.mapping.Coordinate) - a set of coordinates or an\n                empty array if not restricted", 
               "error_doc": "        raise:  IllegalState - syntax is not a ``COORDINATE``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: a set of coordinates or an empty array if not restricted\n        :rtype: ``osid.mapping.Coordinate``", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- syntax is not a ``COORDINATE``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.mapping.Coordinate", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract"
               }
            }, 
            {
               "name": "get_default_coordinate_values", 
               "doc": {
                  "headline": "Gets the default coordinate values.", 
                  "body": "        These are the values used if the element value is not provided\n        or is cleared. If ``is_array()`` is false, then this method\n        returns at most a single value."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.mapping.Coordinate) - the default coordinate\n                values", 
               "error_doc": "        raise:  IllegalState - syntax is not a ``COORDINATE`` or\n                ``is_required()`` is ``true``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the default coordinate values\n        :rtype: ``osid.mapping.Coordinate``", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- syntax is not a ``COORDINATE`` or ``is_required()`` is ``true``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.mapping.Coordinate", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract"
               }
            }, 
            {
               "name": "get_existing_coordinate_values", 
               "doc": {
                  "headline": "Gets the existing coordinate values.", 
                  "body": "        If ``has_value()`` and ``is_required()`` are ``false,`` then\n        these values are the default values ````. If ``is_array()`` is\n        false, then this method returns at most a single value."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.mapping.Coordinate) - the existing coordinate\n                values", 
               "error_doc": "        raise:  IllegalState - syntax is not a ``COORDINATE`` or\n                ``is_value_known()`` is ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the existing coordinate values\n        :rtype: ``osid.mapping.Coordinate``", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- syntax is not a ``COORDINATE`` or ``is_value_known()`` is ``false``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.mapping.Coordinate", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract"
               }
            }, 
            {
               "name": "get_currency_types", 
               "doc": {
                  "headline": "Gets the set of acceptable currency types.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.type.Type) - the set of currency types", 
               "error_doc": "        raise:  IllegalState - syntax is not a ``CURRENCY``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the set of currency types\n        :rtype: ``osid.type.Type``", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- syntax is not a ``CURRENCY``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.type.Type", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract"
               }
            }, 
            {
               "name": "supports_currency_type", 
               "doc": {
                  "headline": "Tests if the given currency type is supported.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    currency_type (osid.type.Type): a currency Type\n", 
               "return_doc": "        return: (boolean) - ``true`` if the type is supported, ``false``\n                otherwise", 
               "error_doc": "        raise:  IllegalState - syntax is not a ``CURRENCY``\n        raise:  NullArgument - ``currency_type`` is ``null``", 
               "sphinx_param_doc": "        :param currency_type: a currency Type\n        :type currency_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "        :return: ``true`` if the type is supported, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- syntax is not a ``CURRENCY``\n        :raise: ``NullArgument`` -- ``currency_type`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "currency_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "boolean", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract", 
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "get_minimum_currency", 
               "doc": {
                  "headline": "Gets the minimum currency value.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.financials.Currency) - the minimum currency", 
               "error_doc": "        raise:  IllegalState - syntax is not a ``CURRENCY``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the minimum currency\n        :rtype: ``osid.financials.Currency``", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- syntax is not a ``CURRENCY``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.financials.Currency", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract"
               }
            }, 
            {
               "name": "get_maximum_currency", 
               "doc": {
                  "headline": "Gets the maximum currency value.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.financials.Currency) - the maximum currency", 
               "error_doc": "        raise:  IllegalState - syntax is not a ``CURRENCY``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the maximum currency\n        :rtype: ``osid.financials.Currency``", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- syntax is not a ``CURRENCY``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.financials.Currency", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract"
               }
            }, 
            {
               "name": "get_currency_set", 
               "doc": {
                  "headline": "Gets the set of acceptable currency values.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.financials.Currency) - a set of currencies or an\n                empty array if not restricted", 
               "error_doc": "        raise:  IllegalState - syntax is not a ``CURRENCY``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: a set of currencies or an empty array if not restricted\n        :rtype: ``osid.financials.Currency``", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- syntax is not a ``CURRENCY``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.financials.Currency", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract"
               }
            }, 
            {
               "name": "get_default_currency_values", 
               "doc": {
                  "headline": "Gets the default currency values.", 
                  "body": "        These are the values used if the element value is not provided\n        or is cleared. If ``is_array()`` is false, then this method\n        returns at most a single value."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.financials.Currency) - the default currency values", 
               "error_doc": "        raise:  IllegalState - syntax is not a ``CURRENCY`` or\n                ``is_required()`` is ``true``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the default currency values\n        :rtype: ``osid.financials.Currency``", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- syntax is not a ``CURRENCY`` or ``is_required()`` is ``true``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.financials.Currency", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract"
               }
            }, 
            {
               "name": "get_existing_currency_values", 
               "doc": {
                  "headline": "Gets the existing currency values.", 
                  "body": "        If ``has_value()`` and ``is_required()`` are ``false,`` then\n        these values are the default values ````. If ``is_array()`` is\n        false, then this method returns at most a single value."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.financials.Currency) - the existing currency\n                values", 
               "error_doc": "        raise:  IllegalState - syntax is not a ``CURRENCY`` or\n                ``is_value_known()`` is ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the existing currency values\n        :rtype: ``osid.financials.Currency``", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- syntax is not a ``CURRENCY`` or ``is_value_known()`` is ``false``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.financials.Currency", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract"
               }
            }, 
            {
               "name": "get_date_time_resolution", 
               "doc": {
                  "headline": "Gets the smallest resolution of the date time value.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.DateTimeResolution) - the resolution", 
               "error_doc": "        raise:  IllegalState - syntax is not a ``DATETIME, DURATION`` ,\n                or ``TIME``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the resolution\n        :rtype: ``osid.calendaring.DateTimeResolution``", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- syntax is not a ``DATETIME, DURATION`` , or ``TIME``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.DateTimeResolution", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract"
               }
            }, 
            {
               "name": "get_calendar_types", 
               "doc": {
                  "headline": "Gets the set of acceptable calendar types.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.type.Type) - the set of calendar types", 
               "error_doc": "        raise:  IllegalState - syntax is not a ``DATETIME`` or\n                ``DURATION``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the set of calendar types\n        :rtype: ``osid.type.Type``", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- syntax is not a ``DATETIME`` or ``DURATION``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.type.Type", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract"
               }
            }, 
            {
               "name": "supports_calendar_type", 
               "doc": {
                  "headline": "Tests if the given calendar type is supported.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    calendar_type (osid.type.Type): a calendar Type\n", 
               "return_doc": "        return: (boolean) - ``true`` if the type is supported, ``false``\n                otherwise", 
               "error_doc": "        raise:  IllegalState - syntax is not a ``DATETIME`` or\n                ``DURATION``\n        raise:  NullArgument - ``calendar_type`` is ``null``", 
               "sphinx_param_doc": "        :param calendar_type: a calendar Type\n        :type calendar_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "        :return: ``true`` if the type is supported, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- syntax is not a ``DATETIME`` or ``DURATION``\n        :raise: ``NullArgument`` -- ``calendar_type`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "calendar_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "boolean", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract", 
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "get_time_types", 
               "doc": {
                  "headline": "Gets the set of acceptable time types.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.type.Type) - a set of time types or an empty array\n                if not restricted", 
               "error_doc": "        raise:  IllegalState - syntax is not a ``DATETIME, DURATION,``\n                or ``TIME``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: a set of time types or an empty array if not restricted\n        :rtype: ``osid.type.Type``", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- syntax is not a ``DATETIME, DURATION,`` or ``TIME``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.type.Type", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract"
               }
            }, 
            {
               "name": "supports_time_type", 
               "doc": {
                  "headline": "Tests if the given time type is supported.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    time_type (osid.type.Type): a time Type\n", 
               "return_doc": "        return: (boolean) - ``true`` if the type is supported, ``false``\n                otherwise", 
               "error_doc": "        raise:  IllegalState - syntax is not a ``DATETIME, DURATION,``\n                or ``TIME``\n        raise:  NullArgument - ``time_type`` is ``null``", 
               "sphinx_param_doc": "        :param time_type: a time Type\n        :type time_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "        :return: ``true`` if the type is supported, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- syntax is not a ``DATETIME, DURATION,`` or ``TIME``\n        :raise: ``NullArgument`` -- ``time_type`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "time_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "boolean", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract", 
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "get_minimum_date_time", 
               "doc": {
                  "headline": "Gets the minimum date time value.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.DateTime) - the minimum value", 
               "error_doc": "        raise:  IllegalState - syntax is not a ``DATETIME``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the minimum value\n        :rtype: ``osid.calendaring.DateTime``", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- syntax is not a ``DATETIME``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.DateTime", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract"
               }
            }, 
            {
               "name": "get_maximum_date_time", 
               "doc": {
                  "headline": "Gets the maximum date time value.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.DateTime) - the maximum value", 
               "error_doc": "        raise:  IllegalState - syntax is not a ``DATETIME``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the maximum value\n        :rtype: ``osid.calendaring.DateTime``", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- syntax is not a ``DATETIME``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.DateTime", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract"
               }
            }, 
            {
               "name": "get_date_time_set", 
               "doc": {
                  "headline": "Gets the set of acceptable date time values.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.DateTime) - a set of values or an\n                empty array if not restricted", 
               "error_doc": "        raise:  IllegalState - syntax is not a ``DATETIME``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: a set of values or an empty array if not restricted\n        :rtype: ``osid.calendaring.DateTime``", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- syntax is not a ``DATETIME``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.DateTime", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract"
               }
            }, 
            {
               "name": "get_default_date_time_values", 
               "doc": {
                  "headline": "Gets the default date time values.", 
                  "body": "        These are the values used if the element value is not provided\n        or is cleared. If ``is_array()`` is false, then this method\n        returns at most a single value."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.DateTime) - the default date time\n                values", 
               "error_doc": "        raise:  IllegalState - syntax is not a ``DATETIME`` or\n                ``is_required()`` is ``true``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the default date time values\n        :rtype: ``osid.calendaring.DateTime``", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- syntax is not a ``DATETIME`` or ``is_required()`` is ``true``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.DateTime", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract"
               }
            }, 
            {
               "name": "get_existing_date_time_values", 
               "doc": {
                  "headline": "Gets the existing date time values.", 
                  "body": "        If ``has_value()`` and ``is_required()`` are ``false,`` then\n        these values are the default values ````. If ``is_array()`` is\n        false, then this method returns at most a single value."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.DateTime) - the existing date time\n                values", 
               "error_doc": "        raise:  IllegalState - syntax is not a ``DATETIME`` or\n                ``is_value_known()`` is ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the existing date time values\n        :rtype: ``osid.calendaring.DateTime``", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- syntax is not a ``DATETIME`` or ``is_value_known()`` is ``false``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.DateTime", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract"
               }
            }, 
            {
               "name": "get_decimal_scale", 
               "doc": {
                  "headline": "Gets the number of digits to the right of the decimal point.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (cardinal) - the scale", 
               "error_doc": "        raise:  IllegalState - syntax is not a ``DECIMAL``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the scale\n        :rtype: ``cardinal``", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- syntax is not a ``DECIMAL``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "cardinal", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract"
               }
            }, 
            {
               "name": "get_minimum_decimal", 
               "doc": {
                  "headline": "Gets the minimum decimal value.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (decimal) - the minimum decimal", 
               "error_doc": "        raise:  IllegalState - syntax is not a ``DECIMAL``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the minimum decimal\n        :rtype: ``decimal``", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- syntax is not a ``DECIMAL``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "decimal", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract"
               }
            }, 
            {
               "name": "get_maximum_decimal", 
               "doc": {
                  "headline": "Gets the maximum decimal value.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (decimal) - the maximum decimal", 
               "error_doc": "        raise:  IllegalState - syntax is not a ``DECIMAL``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the maximum decimal\n        :rtype: ``decimal``", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- syntax is not a ``DECIMAL``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "decimal", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract"
               }
            }, 
            {
               "name": "get_decimal_set", 
               "doc": {
                  "headline": "Gets the set of acceptable decimal values.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (decimal) - a set of decimals or an empty array if not\n                restricted", 
               "error_doc": "        raise:  IllegalState - syntax is not a ``DECIMAL``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: a set of decimals or an empty array if not restricted\n        :rtype: ``decimal``", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- syntax is not a ``DECIMAL``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "decimal", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract"
               }
            }, 
            {
               "name": "get_default_decimal_values", 
               "doc": {
                  "headline": "Gets the default decimal values.", 
                  "body": "        These are the values used if the element value is not provided\n        or is cleared. If ``is_array()`` is false, then this method\n        returns at most a single value."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (decimal) - the default decimal values", 
               "error_doc": "        raise:  IllegalState - syntax is not a ``DECIMAL`` or\n                ``is_required()`` is ``true``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the default decimal values\n        :rtype: ``decimal``", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- syntax is not a ``DECIMAL`` or ``is_required()`` is ``true``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "decimal", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract"
               }
            }, 
            {
               "name": "get_existing_decimal_values", 
               "doc": {
                  "headline": "Gets the existing decimal values.", 
                  "body": "        If ``has_value()`` and ``is_required()`` are ``false,`` then\n        these values are the default values ````. If ``is_array()`` is\n        false, then this method returns at most a single value."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (decimal) - the existing decimal values", 
               "error_doc": "        raise:  IllegalState - syntax is not a ``DECIMAL`` or\n                ``is_value_known()`` is ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the existing decimal values\n        :rtype: ``decimal``", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- syntax is not a ``DECIMAL`` or ``is_value_known()`` is ``false``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "decimal", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract"
               }
            }, 
            {
               "name": "get_distance_resolution", 
               "doc": {
                  "headline": "Gets the smallest resolution of the distance value.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.mapping.DistanceResolution) - the resolution", 
               "error_doc": "        raise:  IllegalState - syntax is not a ``DISTANCE``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the resolution\n        :rtype: ``osid.mapping.DistanceResolution``", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- syntax is not a ``DISTANCE``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.mapping.DistanceResolution", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract"
               }
            }, 
            {
               "name": "get_minimum_distance", 
               "doc": {
                  "headline": "Gets the minimum distance value.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.mapping.Distance) - the minimum value", 
               "error_doc": "        raise:  IllegalState - syntax is not a ``DISTANCE``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the minimum value\n        :rtype: ``osid.mapping.Distance``", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- syntax is not a ``DISTANCE``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.mapping.Distance", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract"
               }
            }, 
            {
               "name": "get_maximum_distance", 
               "doc": {
                  "headline": "Gets the maximum distance value.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.mapping.Distance) - the maximum value", 
               "error_doc": "        raise:  IllegalState - syntax is not a ``DISTANCE``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the maximum value\n        :rtype: ``osid.mapping.Distance``", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- syntax is not a ``DISTANCE``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.mapping.Distance", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract"
               }
            }, 
            {
               "name": "get_distance_set", 
               "doc": {
                  "headline": "Gets the set of acceptable distance values.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.mapping.Distance) - a set of values or an empty\n                array if not restricted", 
               "error_doc": "        raise:  IllegalState - syntax is not a ``DISTANCE``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: a set of values or an empty array if not restricted\n        :rtype: ``osid.mapping.Distance``", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- syntax is not a ``DISTANCE``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.mapping.Distance", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract"
               }
            }, 
            {
               "name": "get_default_distance_values", 
               "doc": {
                  "headline": "Gets the default distance values.", 
                  "body": "        These are the values used if the element value is not provided\n        or is cleared. If ``is_array()`` is false, then this method\n        returns at most a single value."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.mapping.Distance) - the default distance values", 
               "error_doc": "        raise:  IllegalState - syntax is not a ``DISTANCE`` or\n                ``is_required()`` is ``true``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the default distance values\n        :rtype: ``osid.mapping.Distance``", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- syntax is not a ``DISTANCE`` or ``is_required()`` is ``true``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.mapping.Distance", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract"
               }
            }, 
            {
               "name": "get_existing_distance_values", 
               "doc": {
                  "headline": "Gets the existing distance values.", 
                  "body": "        If ``has_value()`` and ``is_required()`` are ``false,`` then\n        these values are the default values ````. If ``is_array()`` is\n        false, then this method returns at most a single value."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.mapping.Distance) - the existing distance values", 
               "error_doc": "        raise:  IllegalState - syntax is not a ``DISTANCE`` or\n                ``is_value_known()`` is ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the existing distance values\n        :rtype: ``osid.mapping.Distance``", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- syntax is not a ``DISTANCE`` or ``is_value_known()`` is ``false``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.mapping.Distance", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract"
               }
            }, 
            {
               "name": "get_minimum_duration", 
               "doc": {
                  "headline": "Gets the minimum duration.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.Duration) - the minimum duration", 
               "error_doc": "        raise:  IllegalState - syntax is not a ``DURATION``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the minimum duration\n        :rtype: ``osid.calendaring.Duration``", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- syntax is not a ``DURATION``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.Duration", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract"
               }
            }, 
            {
               "name": "get_maximum_duration", 
               "doc": {
                  "headline": "Gets the maximum duration.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.Duration) - the maximum duration", 
               "error_doc": "        raise:  IllegalState - syntax is not a ``DURATION``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the maximum duration\n        :rtype: ``osid.calendaring.Duration``", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- syntax is not a ``DURATION``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.Duration", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract"
               }
            }, 
            {
               "name": "get_duration_set", 
               "doc": {
                  "headline": "Gets the set of acceptable duration values.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.Duration) - a set of durations or an\n                empty array if not restricted", 
               "error_doc": "        raise:  IllegalState - syntax is not a ``DURATION``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: a set of durations or an empty array if not restricted\n        :rtype: ``osid.calendaring.Duration``", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- syntax is not a ``DURATION``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.Duration", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract"
               }
            }, 
            {
               "name": "get_default_duration_values", 
               "doc": {
                  "headline": "Gets the default duration values.", 
                  "body": "        These are the values used if the element value is not provided\n        or is cleared. If ``is_array()`` is false, then this method\n        returns at most at most a single value."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.Duration) - the default duration\n                values", 
               "error_doc": "        raise:  IllegalState - syntax is not a DURATION or\n                ``is_required()`` is ``true``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the default duration values\n        :rtype: ``osid.calendaring.Duration``", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- syntax is not a DURATION or ``is_required()`` is ``true``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.Duration", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract"
               }
            }, 
            {
               "name": "get_existing_duration_values", 
               "doc": {
                  "headline": "Gets the existing duration values.", 
                  "body": "        If ``has_value()`` and ``is_required()`` are ``false,`` then\n        these values are the default values ````. If ``is_array()`` is\n        false, then this method returns at most a single value."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.Duration) - the existing duration\n                values", 
               "error_doc": "        raise:  IllegalState - syntax is not a ``DURATION`` or\n                ``is_value_known()`` is ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the existing duration values\n        :rtype: ``osid.calendaring.Duration``", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- syntax is not a ``DURATION`` or ``is_value_known()`` is ``false``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.Duration", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract"
               }
            }, 
            {
               "name": "get_heading_types", 
               "doc": {
                  "headline": "Gets the set of acceptable heading types.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.type.Type) - a set of heading types or an empty\n                array if not restricted", 
               "error_doc": "        raise:  IllegalState - syntax is not a ``HEADING``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: a set of heading types or an empty array if not restricted\n        :rtype: ``osid.type.Type``", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- syntax is not a ``HEADING``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.type.Type", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract"
               }
            }, 
            {
               "name": "supports_heading_type", 
               "doc": {
                  "headline": "Tests if the given heading type is supported.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    heading_type (osid.type.Type): a heading Type\n", 
               "return_doc": "        return: (boolean) - ``true`` if the type is supported, ``false``\n                otherwise", 
               "error_doc": "        raise:  IllegalState - syntax is not a ``HEADING``\n        raise:  NullArgument - ``heading_type`` is ``null``", 
               "sphinx_param_doc": "        :param heading_type: a heading Type\n        :type heading_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "        :return: ``true`` if the type is supported, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- syntax is not a ``HEADING``\n        :raise: ``NullArgument`` -- ``heading_type`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "heading_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "boolean", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract", 
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "get_axes_for_heading_type", 
               "doc": {
                  "headline": "Gets the number of axes for a given supported heading type.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    heading_type (osid.type.Type): a heading Type\n", 
               "return_doc": "        return: (cardinal) - the number of axes", 
               "error_doc": "        raise:  IllegalState - syntax is not a ``HEADING``\n        raise:  NullArgument - ``heading_type`` is ``null``\n        raise:  Unsupported - ``supports_heading_type(heading_type)`` is\n                ``false``", 
               "sphinx_param_doc": "        :param heading_type: a heading Type\n        :type heading_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "        :return: the number of axes\n        :rtype: ``cardinal``", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- syntax is not a ``HEADING``\n        :raise: ``NullArgument`` -- ``heading_type`` is ``null``\n        :raise: ``Unsupported`` -- ``supports_heading_type(heading_type)`` is ``false``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "heading_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "cardinal", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_minimum_heading_values", 
               "doc": {
                  "headline": "Gets the minimum heading values given supported heading type.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    heading_type (osid.type.Type): a heading Type\n", 
               "return_doc": "        return: (decimal) - the minimum heading values", 
               "error_doc": "        raise:  IllegalState - syntax is not a ``HEADING``\n        raise:  NullArgument - ``heading_type`` is ``null``\n        raise:  Unsupported - ``supports_heading_type(heading_type)`` is\n                ``false``", 
               "sphinx_param_doc": "        :param heading_type: a heading Type\n        :type heading_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "        :return: the minimum heading values\n        :rtype: ``decimal``", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- syntax is not a ``HEADING``\n        :raise: ``NullArgument`` -- ``heading_type`` is ``null``\n        :raise: ``Unsupported`` -- ``supports_heading_type(heading_type)`` is ``false``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "heading_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "decimal", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_maximum_heading_values", 
               "doc": {
                  "headline": "Gets the maximum heading values given supported heading type.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    heading_type (osid.type.Type): a heading Type\n", 
               "return_doc": "        return: (decimal) - the maximum heading values", 
               "error_doc": "        raise:  IllegalState - syntax is not a ``HEADING``\n        raise:  NullArgument - ``heading_type`` is ``null``\n        raise:  Unsupported - ``supports_heading_type(heading_type)`` is\n                ``false``", 
               "sphinx_param_doc": "        :param heading_type: a heading Type\n        :type heading_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "        :return: the maximum heading values\n        :rtype: ``decimal``", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- syntax is not a ``HEADING``\n        :raise: ``NullArgument`` -- ``heading_type`` is ``null``\n        :raise: ``Unsupported`` -- ``supports_heading_type(heading_type)`` is ``false``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "heading_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "decimal", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_heading_set", 
               "doc": {
                  "headline": "Gets the set of acceptable heading values.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.mapping.Heading) - the set of heading", 
               "error_doc": "        raise:  IllegalState - syntax is not a ``HEADING``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the set of heading\n        :rtype: ``osid.mapping.Heading``", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- syntax is not a ``HEADING``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.mapping.Heading", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract"
               }
            }, 
            {
               "name": "get_default_heading_values", 
               "doc": {
                  "headline": "Gets the default heading values.", 
                  "body": "        These are the values used if the element value is not provided\n        or is cleared. If ``is_array()`` is false, then this method\n        returns at most a single value."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.mapping.Heading) - the default heading values", 
               "error_doc": "        raise:  IllegalState - syntax is not a ``HEADING`` or\n                ``is_required()`` is ``true``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the default heading values\n        :rtype: ``osid.mapping.Heading``", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- syntax is not a ``HEADING`` or ``is_required()`` is ``true``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.mapping.Heading", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract"
               }
            }, 
            {
               "name": "get_existing_heading_values", 
               "doc": {
                  "headline": "Gets the existing heading values.", 
                  "body": "        If ``has_value()`` and ``is_required()`` are ``false,`` then\n        these values are the default values ````. If ``is_array()`` is\n        false, then this method returns at most a single value."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.mapping.Heading) - the existing heading values", 
               "error_doc": "        raise:  IllegalState - syntax is not a ``HEADING`` or\n                ``is_value_known()`` is ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the existing heading values\n        :rtype: ``osid.mapping.Heading``", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- syntax is not a ``HEADING`` or ``is_value_known()`` is ``false``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.mapping.Heading", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract"
               }
            }, 
            {
               "name": "get_id_set", 
               "doc": {
                  "headline": "Gets the set of acceptable ``Ids``.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.id.Id) - a set of ``Ids`` or an empty array if not\n                restricted", 
               "error_doc": "        raise:  IllegalState - syntax is not an ``ID``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: a set of ``Ids`` or an empty array if not restricted\n        :rtype: ``osid.id.Id``", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- syntax is not an ``ID``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.id.Id", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract"
               }
            }, 
            {
               "name": "get_default_id_values", 
               "doc": {
                  "headline": "Gets the default ``Id`` values.", 
                  "body": "        These are the values used if the element value is not provided\n        or is cleared. If ``is_array()`` is false, then this method\n        returns at most a single value."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.id.Id) - the default ``Id`` values", 
               "error_doc": "        raise:  IllegalState - syntax is not an ``ID`` or\n                ``is_required()`` is ``true``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the default ``Id`` values\n        :rtype: ``osid.id.Id``", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- syntax is not an ``ID`` or ``is_required()`` is ``true``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.id.Id", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract"
               }
            }, 
            {
               "name": "get_existing_id_values", 
               "doc": {
                  "headline": "Gets the existing ``Id`` values.", 
                  "body": "        If ``has_value()`` and ``is_required()`` are ``false,`` then\n        these values are the default values ````. If ``is_array()`` is\n        false, then this method returns at most a single value."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.id.Id) - the existing ``Id`` values", 
               "error_doc": "        raise:  IllegalState - syntax is not an ``ID``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the existing ``Id`` values\n        :rtype: ``osid.id.Id``", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- syntax is not an ``ID``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.id.Id", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract"
               }
            }, 
            {
               "name": "get_minimum_integer", 
               "doc": {
                  "headline": "Gets the minimum integer value.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (integer) - the minimum value", 
               "error_doc": "        raise:  IllegalState - syntax is not an ``INTEGER``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the minimum value\n        :rtype: ``integer``", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- syntax is not an ``INTEGER``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "integer", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract"
               }
            }, 
            {
               "name": "get_maximum_integer", 
               "doc": {
                  "headline": "Gets the maximum integer value.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (integer) - the maximum value", 
               "error_doc": "        raise:  IllegalState - syntax is not an ``INTEGER``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the maximum value\n        :rtype: ``integer``", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- syntax is not an ``INTEGER``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "integer", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract"
               }
            }, 
            {
               "name": "get_integer_set", 
               "doc": {
                  "headline": "Gets the set of acceptable integer values.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (integer) - a set of values or an empty array if not\n                restricted", 
               "error_doc": "        raise:  IllegalState - syntax is not an ``INTEGER``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: a set of values or an empty array if not restricted\n        :rtype: ``integer``", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- syntax is not an ``INTEGER``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "integer", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract"
               }
            }, 
            {
               "name": "get_default_integer_values", 
               "doc": {
                  "headline": "Gets the default integer values.", 
                  "body": "        These are the values used if the element value is not provided\n        or is cleared. If ``is_array()`` is false, then this method\n        returns at most a single value."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (integer) - the default integer values", 
               "error_doc": "        raise:  IllegalState - syntax is not an ``INTEGER`` or\n                ``is_required()`` is ``true``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the default integer values\n        :rtype: ``integer``", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- syntax is not an ``INTEGER`` or ``is_required()`` is ``true``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "integer", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract"
               }
            }, 
            {
               "name": "get_existing_integer_values", 
               "doc": {
                  "headline": "Gets the existing integer values.", 
                  "body": "        If ``has_value()`` and ``is_required()`` are ``false,`` then\n        these values are the default values ````. If ``is_array()`` is\n        false, then this method returns at most a single value."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (integer) - the existing integer values", 
               "error_doc": "        raise:  IllegalState - syntax is not a ``INTEGER`` or\n                isValueKnown() is false", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the existing integer values\n        :rtype: ``integer``", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- syntax is not a ``INTEGER`` or isValueKnown() is false", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "integer", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract"
               }
            }, 
            {
               "name": "get_object_types", 
               "doc": {
                  "headline": "Gets the set of acceptable ``Types`` for an arbitrary object.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.type.Type) - a set of ``Types`` or an empty array\n                if not restricted", 
               "error_doc": "        raise:  IllegalState - syntax is not an ``OBJECT``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: a set of ``Types`` or an empty array if not restricted\n        :rtype: ``osid.type.Type``", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- syntax is not an ``OBJECT``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.type.Type", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract"
               }
            }, 
            {
               "name": "supports_object_type", 
               "doc": {
                  "headline": "Tests if the given object type is supported.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    object_type (osid.type.Type): an object Type\n", 
               "return_doc": "        return: (boolean) - ``true`` if the type is supported, ``false``\n                otherwise", 
               "error_doc": "        raise:  IllegalState - syntax is not an ``OBJECT``\n        raise:  NullArgument - ``object_type`` is ``null``", 
               "sphinx_param_doc": "        :param object_type: an object Type\n        :type object_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "        :return: ``true`` if the type is supported, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- syntax is not an ``OBJECT``\n        :raise: ``NullArgument`` -- ``object_type`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "object_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "boolean", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract", 
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "get_object_set", 
               "doc": {
                  "headline": "Gets the set of acceptable object values.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (object) - a set of values or an empty array if not\n                restricted", 
               "error_doc": "        raise:  IllegalState - syntax is not an ``OBJECT``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: a set of values or an empty array if not restricted\n        :rtype: ``object``", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- syntax is not an ``OBJECT``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "object", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract"
               }
            }, 
            {
               "name": "get_default_object_values", 
               "doc": {
                  "headline": "Gets the default object values.", 
                  "body": "        These are the values used if the element value is not provided\n        or is cleared. If ``is_array()`` is false, then this method\n        returns at most a single value."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (object) - the default object values", 
               "error_doc": "        raise:  IllegalState - syntax is not an ``OBJECT`` or\n                ``is_required()`` is ``true``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the default object values\n        :rtype: ``object``", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- syntax is not an ``OBJECT`` or ``is_required()`` is ``true``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "object", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract"
               }
            }, 
            {
               "name": "get_existing_object_values", 
               "doc": {
                  "headline": "Gets the existing object values.", 
                  "body": "        If ``has_value()`` and ``is_required()`` are ``false,`` then\n        these values are the default values ````. If ``is_array()`` is\n        false, then this method returns at most a single value."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (object) - the existing object values", 
               "error_doc": "        raise:  IllegalState - syntax is not an OBJECT or\n                ``is_value_known()`` is ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the existing object values\n        :rtype: ``object``", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- syntax is not an OBJECT or ``is_value_known()`` is ``false``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "object", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract"
               }
            }, 
            {
               "name": "get_spatial_unit_record_types", 
               "doc": {
                  "headline": "Gets the set of acceptable spatial unit record types.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.type.Type) - the set of spatial unit types", 
               "error_doc": "        raise:  IllegalState - syntax is not ``SPATIALUNIT``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the set of spatial unit types\n        :rtype: ``osid.type.Type``", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- syntax is not ``SPATIALUNIT``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.type.Type", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract"
               }
            }, 
            {
               "name": "supports_spatial_unit_record_type", 
               "doc": {
                  "headline": "Tests if the given spatial unit record type is supported.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    spatial_unit_record_type (osid.type.Type): a spatial\n                unit record Type\n", 
               "return_doc": "        return: (boolean) - ``true`` if the type is supported, ``false``\n                otherwise", 
               "error_doc": "        raise:  IllegalState - syntax is not an ``SPATIALUNIT``\n        raise:  NullArgument - ``spatial_unit_record_type`` is ``null``", 
               "sphinx_param_doc": "        :param spatial_unit_record_type: a spatial unit record Type\n        :type spatial_unit_record_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "        :return: ``true`` if the type is supported, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- syntax is not an ``SPATIALUNIT``\n        :raise: ``NullArgument`` -- ``spatial_unit_record_type`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "spatial_unit_record_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "boolean", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract", 
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "get_spatial_unit_set", 
               "doc": {
                  "headline": "Gets the set of acceptable spatial unit values.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.mapping.SpatialUnit) - a set of spatial units or\n                an empty array if not restricted", 
               "error_doc": "        raise:  IllegalState - syntax is not a ``SPATIALUNIT``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: a set of spatial units or an empty array if not restricted\n        :rtype: ``osid.mapping.SpatialUnit``", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- syntax is not a ``SPATIALUNIT``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.mapping.SpatialUnit", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract"
               }
            }, 
            {
               "name": "get_default_spatial_unit_values", 
               "doc": {
                  "headline": "Gets the default spatial unit values.", 
                  "body": "        These are the values used if the element value is not provided\n        or is cleared. If ``is_array()`` is false, then this method\n        returns at most a single value."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.mapping.SpatialUnit) - the default spatial unit\n                values", 
               "error_doc": "        raise:  IllegalState - syntax is not a ``SPATIALUNIT`` or\n                ``is_required()`` is ``true``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the default spatial unit values\n        :rtype: ``osid.mapping.SpatialUnit``", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- syntax is not a ``SPATIALUNIT`` or ``is_required()`` is ``true``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.mapping.SpatialUnit", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract"
               }
            }, 
            {
               "name": "get_existing_spatial_unit_values", 
               "doc": {
                  "headline": "Gets the existing spatial unit values.", 
                  "body": "        If ``has_value()`` and ``is_required()`` are ``false,`` then\n        these values are the default values ````. If ``is_array()`` is\n        false, then this method returns at most a single value."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.mapping.SpatialUnit) - the existing spatial unit\n                values", 
               "error_doc": "        raise:  IllegalState - syntax is not a SPATIALUNIT or\n                ``is_value_known()`` is ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the existing spatial unit values\n        :rtype: ``osid.mapping.SpatialUnit``", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- syntax is not a SPATIALUNIT or ``is_value_known()`` is ``false``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.mapping.SpatialUnit", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract"
               }
            }, 
            {
               "name": "get_minimum_speed", 
               "doc": {
                  "headline": "Gets the minimum speed value.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.mapping.Speed) - the minimum speed", 
               "error_doc": "        raise:  IllegalState - syntax is not a ``SPEED``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the minimum speed\n        :rtype: ``osid.mapping.Speed``", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- syntax is not a ``SPEED``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.mapping.Speed", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract"
               }
            }, 
            {
               "name": "get_maximum_speed", 
               "doc": {
                  "headline": "Gets the maximum speed value.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.mapping.Speed) - the maximum speed", 
               "error_doc": "        raise:  IllegalState - syntax is not a ``SPEED``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the maximum speed\n        :rtype: ``osid.mapping.Speed``", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- syntax is not a ``SPEED``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.mapping.Speed", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract"
               }
            }, 
            {
               "name": "get_speed_set", 
               "doc": {
                  "headline": "Gets the set of acceptable speed values.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.mapping.Speed) - a set of speeds or an empty array\n                if not restricted", 
               "error_doc": "        raise:  IllegalState - syntax is not a ``SPEED``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: a set of speeds or an empty array if not restricted\n        :rtype: ``osid.mapping.Speed``", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- syntax is not a ``SPEED``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.mapping.Speed", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract"
               }
            }, 
            {
               "name": "get_default_speed_values", 
               "doc": {
                  "headline": "Gets the default speed values.", 
                  "body": "        These are the values used if the element value is not provided\n        or is cleared. If ``is_array()`` is false, then this method\n        returns at most a single value."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.mapping.Speed) - the default speed values", 
               "error_doc": "        raise:  IllegalState - syntax is not a ``SPEED`` or\n                ``is_required()`` is ``true``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the default speed values\n        :rtype: ``osid.mapping.Speed``", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- syntax is not a ``SPEED`` or ``is_required()`` is ``true``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.mapping.Speed", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract"
               }
            }, 
            {
               "name": "get_existing_speed_values", 
               "doc": {
                  "headline": "Gets the existing speed values.", 
                  "body": "        If ``has_value()`` and ``is_required()`` are ``false,`` then\n        these values are the default values ````. If ``is_array()`` is\n        false, then this method returns at most a single value."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.mapping.Speed) - the existing speed values", 
               "error_doc": "        raise:  IllegalState - syntax is not a ``SPEED`` or\n                ``is_value_known()`` is ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the existing speed values\n        :rtype: ``osid.mapping.Speed``", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- syntax is not a ``SPEED`` or ``is_value_known()`` is ``false``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.mapping.Speed", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract"
               }
            }, 
            {
               "name": "get_minimum_string_length", 
               "doc": {
                  "headline": "Gets the minimum string length.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (cardinal) - the minimum string length", 
               "error_doc": "        raise:  IllegalState - syntax is not a ``STRING``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the minimum string length\n        :rtype: ``cardinal``", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- syntax is not a ``STRING``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "cardinal", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract"
               }
            }, 
            {
               "name": "get_maximum_string_length", 
               "doc": {
                  "headline": "Gets the maximum string length.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (cardinal) - the maximum string length", 
               "error_doc": "        raise:  IllegalState - syntax is not a ``STRING``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the maximum string length\n        :rtype: ``cardinal``", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- syntax is not a ``STRING``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "cardinal", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract"
               }
            }, 
            {
               "name": "get_string_match_types", 
               "doc": {
                  "headline": "Gets the set of valid string match types for use in validating a string.", 
                  "body": "        If the string match type indicates a regular expression then\n        ``get_string_expression()`` returns a regular expression."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.type.Type) - the set of string match types", 
               "error_doc": "        raise:  IllegalState - syntax is not a ``STRING``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the set of string match types\n        :rtype: ``osid.type.Type``", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- syntax is not a ``STRING``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.type.Type", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract"
               }
            }, 
            {
               "name": "supports_string_match_type", 
               "doc": {
                  "headline": "Tests if the given string match type is supported.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    string_match_type (osid.type.Type): a string match type\n", 
               "return_doc": "        return: (boolean) - ``true`` if the given string match type Is\n                supported, ``false`` otherwise", 
               "error_doc": "        raise:  IllegalState - syntax is not a ``STRING``\n        raise:  NullArgument - ``string_match_type`` is ``null``", 
               "sphinx_param_doc": "        :param string_match_type: a string match type\n        :type string_match_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "        :return: ``true`` if the given string match type Is supported, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- syntax is not a ``STRING``\n        :raise: ``NullArgument`` -- ``string_match_type`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "string_match_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "boolean", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract", 
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "get_string_expression", 
               "doc": {
                  "headline": "Gets the regular expression of an acceptable string for the given string match type.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    string_match_type (osid.type.Type): a string match type\n", 
               "return_doc": "        return: (string) - the regular expression", 
               "error_doc": "        raise:  NullArgument - ``string_match_type`` is ``null``\n        raise:  IllegalState - syntax is not a ``STRING``\n        raise:  Unsupported -\n                ``supports_string_match_type(string_match_type`` ) is\n                ``false``", 
               "sphinx_param_doc": "        :param string_match_type: a string match type\n        :type string_match_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "        :return: the regular expression\n        :rtype: ``string``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``string_match_type`` is ``null``\n        :raise: ``IllegalState`` -- syntax is not a ``STRING``\n        :raise: ``Unsupported`` -- ``supports_string_match_type(string_match_type`` ) is ``false``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "string_match_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "string", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "ILLEGAL_STATE": "ConsumerContract", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_string_format_types", 
               "doc": {
                  "headline": "Gets the set of valid string formats.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.type.Type) - the set of valid text format types", 
               "error_doc": "        raise:  IllegalState - syntax is not a ``STRING``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the set of valid text format types\n        :rtype: ``osid.type.Type``", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- syntax is not a ``STRING``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.type.Type", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract"
               }
            }, 
            {
               "name": "get_string_set", 
               "doc": {
                  "headline": "Gets the set of acceptable string values.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (string) - a set of strings or an empty array if not\n                restricted", 
               "error_doc": "        raise:  IllegalState - syntax is not a ``STRING``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: a set of strings or an empty array if not restricted\n        :rtype: ``string``", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- syntax is not a ``STRING``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "string", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract"
               }
            }, 
            {
               "name": "get_default_string_values", 
               "doc": {
                  "headline": "Gets the default string values.", 
                  "body": "        These are the values used if the element value is not provided\n        or is cleared. If ``is_array()`` is false, then this method\n        returns at most a single value."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (string) - the default string values", 
               "error_doc": "        raise:  IllegalState - syntax is not a ``STRING`` or\n                ``is_required()`` is ``true``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the default string values\n        :rtype: ``string``", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- syntax is not a ``STRING`` or ``is_required()`` is ``true``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "string", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract"
               }
            }, 
            {
               "name": "get_existing_string_values", 
               "doc": {
                  "headline": "Gets the existing string values.", 
                  "body": "        If ``has_value()`` and ``is_required()`` are ``false,`` then\n        these values are the default values ````. If ``is_array()`` is\n        false, then this method returns at most a single value."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (string) - the existing string values", 
               "error_doc": "        raise:  IllegalState - syntax is not a ``STRING`` or\n                ``is_value_known()`` is ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the existing string values\n        :rtype: ``string``", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- syntax is not a ``STRING`` or ``is_value_known()`` is ``false``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "string", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract"
               }
            }, 
            {
               "name": "get_minimum_time", 
               "doc": {
                  "headline": "Gets the minimum time value.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.Time) - the minimum time", 
               "error_doc": "        raise:  IllegalState - syntax is not a ``TIME``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the minimum time\n        :rtype: ``osid.calendaring.Time``", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- syntax is not a ``TIME``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.Time", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract"
               }
            }, 
            {
               "name": "get_maximum_time", 
               "doc": {
                  "headline": "Gets the maximum time value.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.Time) - the maximum time", 
               "error_doc": "        raise:  IllegalState - syntax is not a ``TIME``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the maximum time\n        :rtype: ``osid.calendaring.Time``", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- syntax is not a ``TIME``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.Time", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract"
               }
            }, 
            {
               "name": "get_time_set", 
               "doc": {
                  "headline": "Gets the set of acceptable time values.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.Time) - a set of times or an empty\n                array if not restricted", 
               "error_doc": "        raise:  IllegalState - syntax is not a ``TIME``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: a set of times or an empty array if not restricted\n        :rtype: ``osid.calendaring.Time``", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- syntax is not a ``TIME``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.Time", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract"
               }
            }, 
            {
               "name": "get_default_time_values", 
               "doc": {
                  "headline": "Gets the default time values.", 
                  "body": "        These are the values used if the element value is not provided\n        or is cleared. If ``is_array()`` is false, then this method\n        returns at most a single value."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.Time) - the default time values", 
               "error_doc": "        raise:  IllegalState - syntax is not a ``TIME`` or\n                ``is_required()`` is ``true``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the default time values\n        :rtype: ``osid.calendaring.Time``", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- syntax is not a ``TIME`` or ``is_required()`` is ``true``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.Time", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract"
               }
            }, 
            {
               "name": "get_existing_time_values", 
               "doc": {
                  "headline": "Gets the existing time values.", 
                  "body": "        If ``has_value()`` and ``is_required()`` are ``false,`` then\n        these values are the default values ````. If ``is_array()`` is\n        false, then this method returns at most a single value."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.Time) - the existing time values", 
               "error_doc": "        raise:  IllegalState - syntax is not a ``TIME`` or\n                ``is_value_known()`` is ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the existing time values\n        :rtype: ``osid.calendaring.Time``", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- syntax is not a ``TIME`` or ``is_value_known()`` is ``false``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.Time", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract"
               }
            }, 
            {
               "name": "get_type_set", 
               "doc": {
                  "headline": "Gets the set of acceptable ``Types``.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.type.Type) - a set of ``Types`` or an empty array\n                if not restricted", 
               "error_doc": "        raise:  IllegalState - syntax is not a ``TYPE``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: a set of ``Types`` or an empty array if not restricted\n        :rtype: ``osid.type.Type``", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- syntax is not a ``TYPE``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.type.Type", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract"
               }
            }, 
            {
               "name": "get_default_type_values", 
               "doc": {
                  "headline": "Gets the default type values.", 
                  "body": "        These are the values used if the element value is not provided\n        or is cleared. If ``is_array()`` is false, then this method\n        returns at most a single value."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.type.Type) - the default type values", 
               "error_doc": "        raise:  IllegalState - syntax is not a ``TYPE`` or\n                ``is_required()`` is ``true``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the default type values\n        :rtype: ``osid.type.Type``", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- syntax is not a ``TYPE`` or ``is_required()`` is ``true``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.type.Type", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract"
               }
            }, 
            {
               "name": "get_existing_type_values", 
               "doc": {
                  "headline": "Gets the existing type values.", 
                  "body": "        If ``has_value()`` and ``is_required()`` are ``false,`` then\n        these values are the default values ````. If ``is_array()`` is\n        false, then this method returns at most a single value."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.type.Type) - the existing type values", 
               "error_doc": "        raise:  IllegalState - syntax is not a ``TYPE`` or\n                ``is_value_known()`` is ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the existing type values\n        :rtype: ``osid.type.Type``", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- syntax is not a ``TYPE`` or ``is_value_known()`` is ``false``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.type.Type", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract"
               }
            }, 
            {
               "name": "get_version_types", 
               "doc": {
                  "headline": "Gets the set of acceptable version types.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.type.Type) - the set of version types", 
               "error_doc": "        raise:  IllegalState - syntax is not a ``VERSION``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the set of version types\n        :rtype: ``osid.type.Type``", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- syntax is not a ``VERSION``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.type.Type", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract"
               }
            }, 
            {
               "name": "supports_version_type", 
               "doc": {
                  "headline": "Tests if the given version type is supported.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    version_type (osid.type.Type): a version Type\n", 
               "return_doc": "        return: (boolean) - ``true`` if the type is supported, ``false``\n                otherwise", 
               "error_doc": "        raise:  IllegalState - syntax is not a ``VERSION``\n        raise:  NullArgument - ``version_type`` is ``null``", 
               "sphinx_param_doc": "        :param version_type: a version Type\n        :type version_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "        :return: ``true`` if the type is supported, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- syntax is not a ``VERSION``\n        :raise: ``NullArgument`` -- ``version_type`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "version_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "boolean", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract", 
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "get_minimum_version", 
               "doc": {
                  "headline": "Gets the minumim acceptable ``Version``.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.installation.Version) - the minumim ``Version``", 
               "error_doc": "        raise:  IllegalState - syntax is not a ``VERSION``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the minumim ``Version``\n        :rtype: ``osid.installation.Version``", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- syntax is not a ``VERSION``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.installation.Version", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract"
               }
            }, 
            {
               "name": "get_maximum_version", 
               "doc": {
                  "headline": "Gets the maximum acceptable ``Version``.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.installation.Version) - the maximum ``Version``", 
               "error_doc": "        raise:  IllegalState - syntax is not a ``VERSION``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the maximum ``Version``\n        :rtype: ``osid.installation.Version``", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- syntax is not a ``VERSION``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.installation.Version", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract"
               }
            }, 
            {
               "name": "get_version_set", 
               "doc": {
                  "headline": "Gets the set of acceptable ``Versions``.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.installation.Version) - a set of ``Versions`` or\n                an empty array if not restricted", 
               "error_doc": "        raise:  IllegalState - syntax is not a ``VERSION``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: a set of ``Versions`` or an empty array if not restricted\n        :rtype: ``osid.installation.Version``", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- syntax is not a ``VERSION``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.installation.Version", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract"
               }
            }, 
            {
               "name": "get_default_version_values", 
               "doc": {
                  "headline": "Gets the default version values.", 
                  "body": "        These are the values used if the element value is not provided\n        or is cleared. If ``is_array()`` is false, then this method\n        returns at most a single value."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.installation.Version) - the default version values", 
               "error_doc": "        raise:  IllegalState - syntax is not a TIME or isValueKnown() is\n                false", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the default version values\n        :rtype: ``osid.installation.Version``", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- syntax is not a TIME or isValueKnown() is false", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.installation.Version", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract"
               }
            }, 
            {
               "name": "get_existing_version_values", 
               "doc": {
                  "headline": "Gets the existing version values.", 
                  "body": "        If ``has_value()`` and ``is_required()`` are ``false,`` then\n        these values are the default values ````. If ``is_array()`` is\n        false, then this method returns at most a single value."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.installation.Version) - the existing version\n                values", 
               "error_doc": "        raise:  IllegalState - syntax is not a ``VERSION`` or\n                ``is_value_known()`` is ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the existing version values\n        :rtype: ``osid.installation.Version``", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- syntax is not a ``VERSION`` or ``is_value_known()`` is ``false``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.installation.Version", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.OsidPrimitive", 
         "shortname": "OsidPrimitive", 
         "category": "markers", 
         "doc": {
            "headline": "A marker interface for an interface that behaves like a language primitive.", 
            "body": "    Primitive types, such as numbers and strings, do not encapsulate\n    behaviors supplied by an OSID Provider. More complex primitives are\n    expressed through interface definitions but are treated in a similar\n    fashion as a language primitive. OSID Primitives supplied by an OSID\n    Consumer must be consumable by any OSID Provider."
         }, 
         "inherit_fullnames": [], 
         "inherit_shortnames": [], 
         "inherit_pkg_names": [], 
         "inheritance": [], 
         "method_names": [], 
         "methods": []
      }, 
      {
         "fullname": "osid.Identifiable", 
         "shortname": "Identifiable", 
         "category": "markers", 
         "doc": {
            "headline": "A marker interface for objects uniquely identified with an OSID ``Id``.", 
            "body": ""
         }, 
         "inherit_fullnames": [], 
         "inherit_shortnames": [], 
         "inherit_pkg_names": [], 
         "inheritance": [], 
         "method_names": [
            "get_id", 
            "is_current"
         ], 
         "methods": [
            {
               "name": "get_id", 
               "doc": {
                  "headline": "Gets the Id associated with this instance of this OSID object.", 
                  "body": "        Persisting any reference to this object is done by persisting\n        the Id returned from this method. The Id returned may be\n        different than the Id used to query this object. In this case,\n        the new Id should be preferred over the old one for future\n        queries."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.id.Id) - the ``Id``", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the ``Id``\n        :rtype: ``osid.id.Id``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "        *implementation notes*: The ``Id`` is intended to be constant\n        and persistent. A consumer may at any time persist the ``Id``\n        for retrieval at any future time. Ideally, the Id should\n        consistently resolve into the designated object and not be\n        reused. In cases where objects are deactivated after a certain\n        lifetime the provider should endeavor not to obliterate the\n        object or its ``Id`` but instead should update the properties of\n        the object including the deactiavted status and the elimination\n        of any unwanted pieces of data. As such, there is no means for\n        updating an ``Id`` and providers should consider carefully the\n        identification scheme to implement.  ``Id`` assignments for\n        objects are strictly in the realm of the provider and any errors\n        should be fixed directly with the backend supporting system.\n        Once an Id has been assigned in a production service it should\n        be honored such that it may be necessary for the backend system\n        to support Id aliasing to redirect the lookup to the current\n        ``Id``. Use of an Id OSID may be helpful to accomplish this task\n        in a modular manner.\n", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.id.Id", 
               "errors": {}
            }, 
            {
               "name": "is_current", 
               "doc": {
                  "headline": "Tests to see if the last method invoked retrieved up-to-date data.", 
                  "body": "        Simple retrieval methods do not specify errors as, generally,\n        the data is retrieved once at the time this object is\n        instantiated. Some implementations may provide real-time data\n        though the application may not always care. An implementation\n        providing a real-time service may fall back to a previous\n        snapshot in case of error. This method returns false if the data\n        last retrieved was stale."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if the last data retrieval was up\n                to date, ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if the last data retrieval was up to date, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "        *implementation notes*: Providers should return false unless all\n        getters are implemented using real-time queries, or some trigger\n        process keeps the data in this object current. Providers should\n        populate basic data elements at the time this object is\n        instantiated, or set an error, to ensure some data availability.\n", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }
         ]
      }, 
      {
         "fullname": "osid.Extensible", 
         "shortname": "Extensible", 
         "category": "markers", 
         "doc": {
            "headline": "A marker interface for objects that contain ``OsidRecords``.", 
            "body": ""
         }, 
         "inherit_fullnames": [], 
         "inherit_shortnames": [], 
         "inherit_pkg_names": [], 
         "inheritance": [], 
         "method_names": [
            "get_record_types", 
            "has_record_type"
         ], 
         "methods": [
            {
               "name": "get_record_types", 
               "doc": {
                  "headline": "Gets the record types available in this object.", 
                  "body": "        A record ``Type`` explicitly indicates the specification of an\n        interface to the record. A record may or may not inherit other\n        record interfaces through interface inheritance in which case\n        support of a record type may not be explicit in the returned\n        list. Interoperability with the typed interface to this object\n        should be performed through ``hasRecordType()``."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.type.TypeList) - the record types available", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the record types available\n        :rtype: ``osid.type.TypeList``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.type.TypeList", 
               "errors": {}
            }, 
            {
               "name": "has_record_type", 
               "doc": {
                  "headline": "Tests if this object supports the given record ``Type``.", 
                  "body": "        The given record type may be supported by the object through\n        interface/type inheritence. This method should be checked before\n        retrieving the record interface."
               }, 
               "arg_doc": "        arg:    record_type (osid.type.Type): a type\n", 
               "return_doc": "        return: (boolean) - ``true`` if a record of the given record\n                ``Type`` is available, ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "        :param record_type: a type\n        :type record_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "        :return: ``true`` if a record of the given record ``Type`` is available, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "record_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "boolean", 
               "errors": {}
            }
         ]
      }, 
      {
         "fullname": "osid.Browsable", 
         "shortname": "Browsable", 
         "category": "markers", 
         "doc": {
            "headline": "A marker interface for objects that offer property inspection.", 
            "body": ""
         }, 
         "inherit_fullnames": [], 
         "inherit_shortnames": [], 
         "inherit_pkg_names": [], 
         "inheritance": [], 
         "method_names": [
            "get_properties", 
            "get_properties_by_record_type"
         ], 
         "methods": [
            {
               "name": "get_properties", 
               "doc": {
                  "headline": "Gets a list of properties.", 
                  "body": "        Properties provide a means for applications to display a\n        representation of the contents of a record without understanding\n        its ``Type`` specification. Applications needing to examine a\n        specific property should use the extension interface defined by\n        its ``Type``."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.PropertyList) - a list of properties", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - an authorization failure occurred", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: a list of properties\n        :rtype: ``osid.PropertyList``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- an authorization failure occurred", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.PropertyList", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_properties_by_record_type", 
               "doc": {
                  "headline": "Gets a list of properties corresponding to the specified record type.", 
                  "body": "        Properties provide a means for applications to display a\n        representation of the contents of a record without understanding\n        its record interface specification. Applications needing to\n        examine a specific propertyshould use the methods defined by the\n        record ``Type``. The resulting set includes properties specified\n        by parents of the record ``type`` in the case a record's\n        interface extends another."
               }, 
               "arg_doc": "        arg:    record_type (osid.type.Type): the record type\n                corresponding to the properties set to retrieve\n", 
               "return_doc": "        return: (osid.PropertyList) - a list of properties", 
               "error_doc": "        raise:  NullArgument - ``record_type`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - an authorization failure occurred\n        raise:  Unsupported - ``has_record_type(record_type)`` is\n                ``false``", 
               "sphinx_param_doc": "        :param record_type: the record type corresponding to the properties set to retrieve\n        :type record_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "        :return: a list of properties\n        :rtype: ``osid.PropertyList``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``record_type`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- an authorization failure occurred\n        :raise: ``Unsupported`` -- ``has_record_type(record_type)`` is ``false``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "record_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "osid.PropertyList", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.Suppliable", 
         "shortname": "Suppliable", 
         "category": "markers", 
         "doc": {
            "headline": "A marker interface for OSID Provider-owned objects used to supply input from an OSID Consumer.", 
            "body": ""
         }, 
         "inherit_fullnames": [], 
         "inherit_shortnames": [], 
         "inherit_pkg_names": [], 
         "inheritance": [], 
         "method_names": [], 
         "methods": []
      }, 
      {
         "fullname": "osid.Temporal", 
         "shortname": "Temporal", 
         "category": "markers", 
         "doc": {
            "headline": "``Temporal`` is used to indicate the object endures for a period of time.", 
            "body": ""
         }, 
         "inherit_fullnames": [], 
         "inherit_shortnames": [], 
         "inherit_pkg_names": [], 
         "inheritance": [], 
         "method_names": [
            "is_effective", 
            "get_start_date", 
            "get_end_date"
         ], 
         "methods": [
            {
               "name": "is_effective", 
               "doc": {
                  "headline": "Tests if the current date is within the start end end dates inclusive.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if this is effective, ``false``\n                otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if this is effective, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "get_start_date", 
               "doc": {
                  "headline": "Gets the start date.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.DateTime) - the start date", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the start date\n        :rtype: ``osid.calendaring.DateTime``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.DateTime", 
               "errors": {}
            }, 
            {
               "name": "get_end_date", 
               "doc": {
                  "headline": "Gets the end date.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.DateTime) - the end date", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the end date\n        :rtype: ``osid.calendaring.DateTime``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.DateTime", 
               "errors": {}
            }
         ]
      }, 
      {
         "fullname": "osid.Subjugateable", 
         "shortname": "Subjugateable", 
         "category": "markers", 
         "doc": {
            "headline": "A ``Subjugateable`` is an ``OsidObject`` dependent upon another ``OsidObject``.", 
            "body": "    A ``Subjugateable`` is created in the context of the administering\n    ``OsidObject`` that may not be reassigned.\n\n    A ``Subjugateable`` always has a fixed Id of it administering\n    ``OsidObject``."
         }, 
         "inherit_fullnames": [], 
         "inherit_shortnames": [], 
         "inherit_pkg_names": [], 
         "inheritance": [], 
         "method_names": [], 
         "methods": []
      }, 
      {
         "fullname": "osid.Aggregateable", 
         "shortname": "Aggregateable", 
         "category": "markers", 
         "doc": {
            "headline": "``Aggregateable`` is used for an ``OsidObject`` to indicate that some or all of the definition is based on an included set of other ``OsidObjects`` which are directly accessible and do not exist outside the context of the parent object.", 
            "body": "    ``Aggregateables`` allow for an ``OsidObject`` to stand alone\n    without knowledge of the originating service.\n\n    An ``Asset`` is an example of an aggregate by including the\n    ``AssetContents``. An Asset also contains a provider however in this\n    case the provider is categorized as a simple data attribute of the\n    ``Asset`` that can be changed by updating the ``Asset`` using an\n    ``AssetForm``. The ``AssetContent`` differs in there exists a\n    explicit mapping to the ``Asset`` managed through an ``OsidSession``\n    but accessible directly within the ``Asset`` to enable its\n    consumption outside the Repository OSID.\n    \n    This marker has little practicality other than to identify a service\n    pattern that is neither a data attribute nor a separately accessible\n    relationship or mapping."
         }, 
         "inherit_fullnames": [], 
         "inherit_shortnames": [], 
         "inherit_pkg_names": [], 
         "inheritance": [], 
         "method_names": [], 
         "methods": []
      }, 
      {
         "fullname": "osid.Containable", 
         "shortname": "Containable", 
         "category": "markers", 
         "doc": {
            "headline": "A ``Containable`` is a kind of aggregate where an ``OsidObject`` is defined as a recursive composition of itself directly accessible without knowledge of the originating service.", 
            "body": ""
         }, 
         "inherit_fullnames": [
            "osid.Aggregateable"
         ], 
         "inherit_shortnames": [
            "Aggregateable"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "Aggregateable"
            }
         ], 
         "method_names": [
            "is_sequestered"
         ], 
         "methods": [
            {
               "name": "is_sequestered", 
               "doc": {
                  "headline": "Tests if this ``Containable`` is sequestered in that it should not appear outside of its aggregated composition.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if this containable is sequestered,\n                ``false`` if this containable may appear outside its\n                aggregate", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if this containable is sequestered, ``false`` if this containable may appear outside its aggregate\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }
         ]
      }, 
      {
         "fullname": "osid.Sourceable", 
         "shortname": "Sourceable", 
         "category": "markers", 
         "doc": {
            "headline": "``Sourceble`` is used for ``OsidObjects`` where information about a provider is appropriate.", 
            "body": "    Examples of ``Sourceables`` are catalogs, compositions, and\n    services."
         }, 
         "inherit_fullnames": [], 
         "inherit_shortnames": [], 
         "inherit_pkg_names": [], 
         "inheritance": [], 
         "method_names": [
            "get_provider_id", 
            "get_provider", 
            "get_branding_ids", 
            "get_branding", 
            "get_license"
         ], 
         "methods": [
            {
               "name": "get_provider_id", 
               "doc": {
                  "headline": "Gets the ``Id`` of the provider.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.id.Id) - the provider ``Id``", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the provider ``Id``\n        :rtype: ``osid.id.Id``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.id.Id", 
               "errors": {}
            }, 
            {
               "name": "get_provider", 
               "doc": {
                  "headline": "Gets the ``Resource`` representing the provider.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.resource.Resource) - the provider", 
               "error_doc": "        raise:  OperationFailed - unable to complete request", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the provider\n        :rtype: ``osid.resource.Resource``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.resource.Resource", 
               "errors": {
                  "OPERATION_FAILED": "Operational"
               }
            }, 
            {
               "name": "get_branding_ids", 
               "doc": {
                  "headline": "Gets the branding asset ``Ids``.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.id.IdList) - a list of asset ``Ids``", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: a list of asset ``Ids``\n        :rtype: ``osid.id.IdList``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.id.IdList", 
               "errors": {}
            }, 
            {
               "name": "get_branding", 
               "doc": {
                  "headline": "Gets a branding, such as an image or logo, expressed using the ``Asset`` interface.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.repository.AssetList) - a list of assets", 
               "error_doc": "        raise:  OperationFailed - unable to complete request", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: a list of assets\n        :rtype: ``osid.repository.AssetList``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.repository.AssetList", 
               "errors": {
                  "OPERATION_FAILED": "Operational"
               }
            }, 
            {
               "name": "get_license", 
               "doc": {
                  "headline": "Gets the terms of usage.", 
                  "body": "        An empty license means the terms are unknown."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.locale.DisplayText) - the license", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the license\n        :rtype: ``osid.locale.DisplayText``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.locale.DisplayText", 
               "errors": {}
            }
         ]
      }, 
      {
         "fullname": "osid.Federateable", 
         "shortname": "Federateable", 
         "category": "markers", 
         "doc": {
            "headline": "``Federateable`` is used to indicate an ``OsidObject`` can be federated using the OSID Hierarchy pattern.", 
            "body": "    An OSID federation of ``OsidObjects`` is where it is inferred from\n    the hiererarchy that any ``OsidObject`` \"includes\" its children."
         }, 
         "inherit_fullnames": [], 
         "inherit_shortnames": [], 
         "inherit_pkg_names": [], 
         "inheritance": [], 
         "method_names": [], 
         "methods": []
      }, 
      {
         "fullname": "osid.Operable", 
         "shortname": "Operable", 
         "category": "markers", 
         "doc": {
            "headline": "``Operable`` is used to indicate an ``OsidObject`` performs operations.", 
            "body": "    The active status indicates if the ``Operable`` is on or off. The\n    active status is determined from the operational status and the\n    enabling rules.\n\n    The operational status indicates the Operable is functioning. This\n    status is not set administratively but instead refelects suitable\n    conditions for operation.\n    \n    Operables may be administratively turned on of off through the\n    enabled and disabled administrative overrides. If there are no\n    related ``OsidEnabler`` rules, then ``is_enabled()`` should be set\n    to ``true`` and ``is_disabled()`` set to ``false`` for the\n    ``Operable`` to be on and ``is_enabled()`` set to ``false`` and\n    ``is_disabled()`` set to true for the ``Operable`` to be ``off``.\n    ``is_enabled()`` and ``is_disabled()`` cannot both be ``tru`` e.\n    \n    If there are related ``OsidEnabler`` rules, the active status of at\n    least one ``OsidEnabler`` results in a ``true`` value for\n    ``isOperational()``. This active status can be overridden by setting\n    ``is_disabled()`` to ``true``. If there are no active\n    ``OsidEnabler`` rules, ``is_operational()`` is false resulting in an\n    ``off``  ``Operable`` unless ``is_enabled()`` is ``true`` .\n    \n    For the active status to be completely determined by the\n    ``OsidEnablers,`` both ``is_enabled()`` and ``is_disabled()`` should\n    be ``false`` where the ``is_active()`` status is completely driven\n    from ``isOperational()``."
         }, 
         "inherit_fullnames": [], 
         "inherit_shortnames": [], 
         "inherit_pkg_names": [], 
         "inheritance": [], 
         "method_names": [
            "is_active", 
            "is_enabled", 
            "is_disabled", 
            "is_operational"
         ], 
         "methods": [
            {
               "name": "is_active", 
               "doc": {
                  "headline": "Tests if this operable is active.", 
                  "body": "        ``is_active()`` is ``true`` if ``is_operational()`` is ``true``\n        and ``is_disabled()`` is ``false,`` or ``is_enabled()`` is\n        ``true``."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if this operable is on, ``false``\n                if it is off", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if this operable is on, ``false`` if it is off\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "is_enabled", 
               "doc": {
                  "headline": "Tests if this operable is administravely enabled.", 
                  "body": "        Administratively enabling overrides any applied ``OsidEnabler``.\n        If this method returns ``true`` then ``is_disabled()`` must\n        return ``false``."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if this operable is enabled,\n                ``false`` if the active status is determined by other\n                rules", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if this operable is enabled, ``false`` if the active status is determined by other rules\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "is_disabled", 
               "doc": {
                  "headline": "Tests if this operable is administravely disabled.", 
                  "body": "        Administratively disabling overrides any applied\n        ``OsidEnabler``. If this method returns ``true`` then\n        ``is_enabled()`` must return ``false``."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if this operable is disabled,\n                ``false`` if the active status is determined by other\n                rules", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if this operable is disabled, ``false`` if the active status is determined by other rules\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "is_operational", 
               "doc": {
                  "headline": "Tests if this ``Operable`` is operational.", 
                  "body": "        This Operable is operational if any of the applied\n        ``OsidEnablers`` are ``true``."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if this operable is operational,\n                ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if this operable is operational, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }
         ]
      }, 
      {
         "fullname": "osid.OsidCondition", 
         "shortname": "OsidCondition", 
         "category": "rules", 
         "doc": {
            "headline": "The ``OsidCondition`` is used to input conditions into a rule for evaluation.", 
            "body": ""
         }, 
         "inherit_fullnames": [
            "osid.Extensible", 
            "osid.Suppliable"
         ], 
         "inherit_shortnames": [
            "Extensible", 
            "Suppliable"
         ], 
         "inherit_pkg_names": [
            "osid", 
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "Extensible"
            }, 
            {
               "pkg_name": "osid", 
               "name": "Suppliable"
            }
         ], 
         "method_names": [], 
         "methods": []
      }, 
      {
         "fullname": "osid.OsidInput", 
         "shortname": "OsidInput", 
         "category": "rules", 
         "doc": {
            "headline": "The ``OsidInput`` is used to input conditions into a rule for processing.", 
            "body": ""
         }, 
         "inherit_fullnames": [
            "osid.Extensible", 
            "osid.Suppliable"
         ], 
         "inherit_shortnames": [
            "Extensible", 
            "Suppliable"
         ], 
         "inherit_pkg_names": [
            "osid", 
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "Extensible"
            }, 
            {
               "pkg_name": "osid", 
               "name": "Suppliable"
            }
         ], 
         "method_names": [], 
         "methods": []
      }, 
      {
         "fullname": "osid.OsidResult", 
         "shortname": "OsidResult", 
         "category": "rules", 
         "doc": {
            "headline": "The ``OsidResult`` is used to retrieve the result of processing a rule.", 
            "body": ""
         }, 
         "inherit_fullnames": [
            "osid.Extensible", 
            "osid.Browsable"
         ], 
         "inherit_shortnames": [
            "Extensible", 
            "Browsable"
         ], 
         "inherit_pkg_names": [
            "osid", 
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "Extensible"
            }, 
            {
               "pkg_name": "osid", 
               "name": "Browsable"
            }
         ], 
         "method_names": [], 
         "methods": []
      }, 
      {
         "fullname": "osid.OsidProfile", 
         "shortname": "OsidProfile", 
         "category": "managers", 
         "doc": {
            "headline": "The ``OsidProfile`` defines the interoperability areas of an OSID.", 
            "body": "    An ``OsidProfile`` is implemented by an ``OsidManager``. The top\n    level ``OsidProfile`` tests for version compatibility. Each OSID\n    extends this interface to include its own interoperability\n    definitions within its managers."
         }, 
         "inherit_fullnames": [
            "osid.Sourceable"
         ], 
         "inherit_shortnames": [
            "Sourceable"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "Sourceable"
            }
         ], 
         "method_names": [
            "get_id", 
            "get_display_name", 
            "get_description", 
            "get_version", 
            "get_release_date", 
            "supports_osid_version", 
            "get_locales", 
            "supports_journal_rollback", 
            "supports_journal_branching", 
            "get_branch_id", 
            "get_branch", 
            "get_proxy_record_types", 
            "supports_proxy_record_type"
         ], 
         "methods": [
            {
               "name": "get_id", 
               "doc": {
                  "headline": "Gets an identifier for this service implementation.", 
                  "body": "        The identifier is unique among services but multiple\n        instantiations of the same service use the same ``Id``. This\n        identifier is the same identifier used in managing OSID\n        installations."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.id.Id) - the ``Id``", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the ``Id``\n        :rtype: ``osid.id.Id``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.id.Id", 
               "errors": {}
            }, 
            {
               "name": "get_display_name", 
               "doc": {
                  "headline": "Gets a display name for this service implementation.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.locale.DisplayText) - a display name", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: a display name\n        :rtype: ``osid.locale.DisplayText``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.locale.DisplayText", 
               "errors": {}
            }, 
            {
               "name": "get_description", 
               "doc": {
                  "headline": "Gets a description of this service implementation.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.locale.DisplayText) - a description", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: a description\n        :rtype: ``osid.locale.DisplayText``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.locale.DisplayText", 
               "errors": {}
            }, 
            {
               "name": "get_version", 
               "doc": {
                  "headline": "Gets the version of this service implementation.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.installation.Version) - the service implementation\n                version", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the service implementation version\n        :rtype: ``osid.installation.Version``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.installation.Version", 
               "errors": {}
            }, 
            {
               "name": "get_release_date", 
               "doc": {
                  "headline": "Gets the date this service implementation was released.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.DateTime) - the release date", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the release date\n        :rtype: ``osid.calendaring.DateTime``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.DateTime", 
               "errors": {}
            }, 
            {
               "name": "supports_osid_version", 
               "doc": {
                  "headline": "Test for support of an OSID specification version.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    version (osid.installation.Version): the specification\n                version to test\n", 
               "return_doc": "        return: (boolean) - ``true`` if this manager supports the given\n                OSID version, ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "        :param version: the specification version to test\n        :type version: ``osid.installation.Version``\n", 
               "sphinx_return_doc": "        :return: ``true`` if this manager supports the given OSID version, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "        *implementation notes*: An implementation may support multiple\n        versions of an OSID.\n", 
               "args": [
                  {
                     "arg_type": "osid.installation.Version", 
                     "var_name": "version", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.installation.Version"
               ], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "get_locales", 
               "doc": {
                  "headline": "Gets the locales supported in this service.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.locale.LocaleList) - list of locales supported", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: list of locales supported\n        :rtype: ``osid.locale.LocaleList``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.locale.LocaleList", 
               "errors": {}
            }, 
            {
               "name": "supports_journal_rollback", 
               "doc": {
                  "headline": "Test for support of a journaling rollback service.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if this manager supports the\n                journal rollback, ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if this manager supports the journal rollback, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "supports_journal_branching", 
               "doc": {
                  "headline": "Test for support of a journal branching service.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if this manager supports the\n                journal branching, ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if this manager supports the journal branching, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "get_branch_id", 
               "doc": {
                  "headline": "Gets the ``Branch Id`` representing this service branch.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.id.Id) - the branch ``Id``", 
               "error_doc": "        raise:  Unimplemented - ``supports_journal_branching()`` is\n                ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the branch ``Id``\n        :rtype: ``osid.id.Id``", 
               "sphinx_error_doc": "        :raise: ``Unimplemented`` -- ``supports_journal_branching()`` is ``false``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.id.Id", 
               "errors": {
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_branch", 
               "doc": {
                  "headline": "Gets this service branch.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.journaling.Branch) - the service branch", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_journal_branching()`` is\n                ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the service branch\n        :rtype: ``osid.journaling.Branch``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_journal_branching()`` is ``false``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.journaling.Branch", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_proxy_record_types", 
               "doc": {
                  "headline": "Gets the proxy record ``Types`` supported in this service.", 
                  "body": "        If no proxy manager is available, an empty list is returned."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.type.TypeList) - list of proxy record types\n                supported", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: list of proxy record types supported\n        :rtype: ``osid.type.TypeList``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.type.TypeList", 
               "errors": {}
            }, 
            {
               "name": "supports_proxy_record_type", 
               "doc": {
                  "headline": "Test for support of a proxy type.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    proxy_record_type (osid.type.Type): a proxy record type\n", 
               "return_doc": "        return: (boolean) - ``true`` if this service supports the given\n                proxy record type, ``false`` otherwise", 
               "error_doc": "        raise:  NullArgument - ``proxy_record_type`` is ``null``", 
               "sphinx_param_doc": "        :param proxy_record_type: a proxy record type\n        :type proxy_record_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "        :return: ``true`` if this service supports the given proxy record type, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``proxy_record_type`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "proxy_record_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "boolean", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.OsidManager", 
         "shortname": "OsidManager", 
         "category": "managers", 
         "doc": {
            "headline": "The ``OsidManager`` is the top level interface for all OSID managers.", 
            "body": "    An OSID manager is instantiated through the ``OsidRuntimeManager``\n    and represents an instance of a service. An OSID manager is\n    responsible for implementing a profile for a service and creating\n    sessions that, in general, correspond to the profile. An application\n    need only create a single ``OsidManager`` per service and\n    implementors must ensure the ``OsidManager`` is thread-safe ````.\n    The ``OsidSessions`` spawned from an OSID manager are dedicated to\n    single processing threads. The ``OsidManager`` defines methods in\n    common throughout all OSID managers which implement this interface."
         }, 
         "inherit_fullnames": [
            "osid.OsidProfile"
         ], 
         "inherit_shortnames": [
            "OsidProfile"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidProfile"
            }
         ], 
         "method_names": [
            "initialize", 
            "rollback_service", 
            "change_branch"
         ], 
         "methods": [
            {
               "name": "initialize", 
               "doc": {
                  "headline": "Initializes this manager.", 
                  "body": "        A manager is initialized once at the time of creation."
               }, 
               "arg_doc": "        arg:    runtime (osid.OsidRuntimeManager): the runtime\n                environment\n", 
               "return_doc": "", 
               "error_doc": "        raise:  ConfigurationError - an error with implementation\n                configuration\n        raise:  IllegalState - this manager has already been initialized\n                by the ``OsidRuntime``\n        raise:  NullArgument - ``runtime`` is ``null``\n        raise:  OperationFailed - unable to complete request", 
               "sphinx_param_doc": "        :param runtime: the runtime environment\n        :type runtime: ``osid.OsidRuntimeManager``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``ConfigurationError`` -- an error with implementation configuration\n        :raise: ``IllegalState`` -- this manager has already been initialized by the ``OsidRuntime``\n        :raise: ``NullArgument`` -- ``runtime`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "        *implementation notes*: In addition to loading its runtime\n        configuration an implementation may create shared resources such\n        as connection pools to be shared among all sessions of this\n        service and released when this manager is closed. Providers must\n        thread-protect any data stored in the manager.  To maximize\n        interoperability, providers should not honor a second call to\n        ``initialize()`` and must set an ``IllegalState`` error.\n", 
               "args": [
                  {
                     "arg_type": "osid.OsidRuntimeManager", 
                     "var_name": "runtime", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.OsidRuntimeManager"
               ], 
               "return_type": "", 
               "errors": {
                  "CONFIGURATION_ERROR": "Operational", 
                  "ILLEGAL_STATE": "ConsumerContract", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational"
               }
            }, 
            {
               "name": "rollback_service", 
               "doc": {
                  "headline": "Rolls back this service to a point in time.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    rollback_time (timestamp): the requested time\n", 
               "return_doc": "        return: (osid.journaling.JournalEntry) - the journal entry\n                corresponding to the actual state of this service", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure occurred\n        raise:  Unimplemented - ``supports_journal_rollback()`` is\n                ``false``", 
               "sphinx_param_doc": "        :param rollback_time: the requested time\n        :type rollback_time: ``timestamp``\n", 
               "sphinx_return_doc": "        :return: the journal entry corresponding to the actual state of this service\n        :rtype: ``osid.journaling.JournalEntry``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure occurred\n        :raise: ``Unimplemented`` -- ``supports_journal_rollback()`` is ``false``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "timestamp", 
                     "var_name": "rollback_time", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "timestamp"
               ], 
               "return_type": "osid.journaling.JournalEntry", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "change_branch", 
               "doc": {
                  "headline": "Changes the service branch.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    branch_id (osid.id.Id): the new service branch\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NotFound - ``branch_id`` not found\n        raise:  NullArgument - ``branch_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure occurred\n        raise:  Unimplemented - ``supports_journal_branching()`` is\n                ``false``", 
               "sphinx_param_doc": "        :param branch_id: the new service branch\n        :type branch_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``branch_id`` not found\n        :raise: ``NullArgument`` -- ``branch_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure occurred\n        :raise: ``Unimplemented`` -- ``supports_journal_branching()`` is ``false``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "branch_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.OsidProxyManager", 
         "shortname": "OsidProxyManager", 
         "category": "managers", 
         "doc": {
            "headline": "The ``OsidProxyManager`` is the top level interface for all OSID proxy managers.", 
            "body": "    A proxy manager accepts parameters to pass through end-user\n    authentication credentials and other necessary request parameters in\n    a server environment. Native applications should use an\n    ``OsidManager`` to maintain a higher degree of interoperability by\n    avoiding this coupling.\n\n    An OSID proxy manager is instantiated through the\n    ``OsidRuntimeManager`` and represents an instance of a service. An\n    OSID manager is responsible for defining clusters of\n    interoperability within a service and creating sessions that\n    generally correspond to these clusters, An application need only\n    create a single ``OsidProxyManager`` per service and implementors\n    must ensure the ``OsidProxyManager`` is thread-safe ````. The\n    ``OsidSessions`` spawned from an OSID manager are dedicated to\n    single processing threads. The ``OsidProxyManager`` defines methods\n    in common throughout all OSID managers which implement this\n    interface."
         }, 
         "inherit_fullnames": [
            "osid.OsidProfile"
         ], 
         "inherit_shortnames": [
            "OsidProfile"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidProfile"
            }
         ], 
         "method_names": [
            "initialize", 
            "rollback_service", 
            "change_branch"
         ], 
         "methods": [
            {
               "name": "initialize", 
               "doc": {
                  "headline": "Initializes this manager.", 
                  "body": "        A manager is initialized once at the time of creation."
               }, 
               "arg_doc": "        arg:    runtime (osid.OsidRuntimeManager): the runtime\n                environment\n", 
               "return_doc": "", 
               "error_doc": "        raise:  ConfigurationError - an error with implementation\n                configuration\n        raise:  IllegalState - this manager has already been initialized\n                by the ``OsidRuntime``\n        raise:  NullArgument - ``runtime`` is ``null``\n        raise:  OperationFailed - unable to complete request", 
               "sphinx_param_doc": "        :param runtime: the runtime environment\n        :type runtime: ``osid.OsidRuntimeManager``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``ConfigurationError`` -- an error with implementation configuration\n        :raise: ``IllegalState`` -- this manager has already been initialized by the ``OsidRuntime``\n        :raise: ``NullArgument`` -- ``runtime`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "        *implementation notes*: In addition to loading its runtime\n        configuration an implementation may create shared resources such\n        as connection pools to be shared among all sessions of this\n        service and released when this manager is closed. Providers must\n        thread-protect any data stored in the manager.  To maximize\n        interoperability, providers should not honor a second call to\n        ``initialize()`` and must set an ``IllegalState`` error.\n", 
               "args": [
                  {
                     "arg_type": "osid.OsidRuntimeManager", 
                     "var_name": "runtime", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.OsidRuntimeManager"
               ], 
               "return_type": "", 
               "errors": {
                  "CONFIGURATION_ERROR": "Operational", 
                  "ILLEGAL_STATE": "ConsumerContract", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational"
               }
            }, 
            {
               "name": "rollback_service", 
               "doc": {
                  "headline": "Rolls back this service to a point in time.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    rollback_time (timestamp): the requested time\n        arg:    proxy (osid.proxy.Proxy): a proxy\n", 
               "return_doc": "        return: (osid.journaling.JournalEntry) - the journal entry\n                corresponding to the actual state of this service", 
               "error_doc": "        raise:  NullArgument - ``proxy`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure occurred\n        raise:  Unimplemented - ``supports_journal_rollback()`` is\n                ``false``", 
               "sphinx_param_doc": "        :param rollback_time: the requested time\n        :type rollback_time: ``timestamp``\n        :param proxy: a proxy\n        :type proxy: ``osid.proxy.Proxy``\n", 
               "sphinx_return_doc": "        :return: the journal entry corresponding to the actual state of this service\n        :rtype: ``osid.journaling.JournalEntry``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``proxy`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure occurred\n        :raise: ``Unimplemented`` -- ``supports_journal_rollback()`` is ``false``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "timestamp", 
                     "var_name": "rollback_time", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.proxy.Proxy", 
                     "var_name": "proxy", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "timestamp", 
                  "osid.proxy.Proxy"
               ], 
               "return_type": "osid.journaling.JournalEntry", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "change_branch", 
               "doc": {
                  "headline": "Changes the service branch.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    branch_id (osid.id.Id): the new service branch\n        arg:    proxy (osid.proxy.Proxy): a proxy\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NotFound - ``branch_id`` not found\n        raise:  NullArgument - ``branch_id`` or ``proxy`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure occurred\n        raise:  Unimplemented - ``supports_journal_branching()`` is\n                ``false``", 
               "sphinx_param_doc": "        :param branch_id: the new service branch\n        :type branch_id: ``osid.id.Id``\n        :param proxy: a proxy\n        :type proxy: ``osid.proxy.Proxy``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``branch_id`` not found\n        :raise: ``NullArgument`` -- ``branch_id`` or ``proxy`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure occurred\n        :raise: ``Unimplemented`` -- ``supports_journal_branching()`` is ``false``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "branch_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.proxy.Proxy", 
                     "var_name": "proxy", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "osid.proxy.Proxy"
               ], 
               "return_type": "", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.OsidSession", 
         "shortname": "OsidSession", 
         "category": "sessions", 
         "doc": {
            "headline": "The ``OsidSession`` is the top level interface for all OSID sessions.", 
            "body": "    An ``OsidSession`` is created through its corresponding\n    ``OsidManager``. A new ``OsidSession`` should be created for each\n    user of a service and for each processing thread. A session\n    maintains a single authenticated user and is not required to ensure\n    thread-protection. A typical OSID session defines a set of service\n    methods corresponding to some compliance level as defined by the\n    service and is generally responsible for the management and\n    retrieval of ``OsidObjects``.\n\n    ``OsidSession`` defines a set of common methods used throughout all\n    OSID sessions. An OSID session may optionally support transactions\n    through the transaction interface."
         }, 
         "inherit_fullnames": [], 
         "inherit_shortnames": [], 
         "inherit_pkg_names": [], 
         "inheritance": [], 
         "method_names": [
            "get_locale", 
            "is_authenticated", 
            "get_authenticated_agent_id", 
            "get_authenticated_agent", 
            "get_effective_agent_id", 
            "get_effective_agent", 
            "get_date", 
            "get_clock_rate", 
            "get_format_type", 
            "supports_transactions", 
            "start_transaction"
         ], 
         "methods": [
            {
               "name": "get_locale", 
               "doc": {
                  "headline": "Gets the locale indicating the localization preferences in effect for this session.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.locale.Locale) - the locale", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the locale\n        :rtype: ``osid.locale.Locale``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.locale.Locale", 
               "errors": {}
            }, 
            {
               "name": "is_authenticated", 
               "doc": {
                  "headline": "Tests if an agent is authenticated to this session.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if valid authentication credentials\n                exist, ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if valid authentication credentials exist, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "get_authenticated_agent_id", 
               "doc": {
                  "headline": "Gets the ``Id`` of the agent authenticated to this session.", 
                  "body": "        This is the agent for which credentials are used either acquired\n        natively or via an ``OsidProxyManager``."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.id.Id) - the authenticated agent ``Id``", 
               "error_doc": "        raise:  IllegalState - ``is_authenticated()`` is ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the authenticated agent ``Id``\n        :rtype: ``osid.id.Id``", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- ``is_authenticated()`` is ``false``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.id.Id", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract"
               }
            }, 
            {
               "name": "get_authenticated_agent", 
               "doc": {
                  "headline": "Gets the agent authenticated to this session.", 
                  "body": "        This is the agent for which credentials are used either acquired\n        natively or via an ``OsidProxyManager``."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.authentication.Agent) - the authenticated agent", 
               "error_doc": "        raise:  IllegalState - ``is_authenticated()`` is ``false``\n        raise:  OperationFailed - unable to complete request", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the authenticated agent\n        :rtype: ``osid.authentication.Agent``", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- ``is_authenticated()`` is ``false``\n        :raise: ``OperationFailed`` -- unable to complete request", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.authentication.Agent", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational"
               }
            }, 
            {
               "name": "get_effective_agent_id", 
               "doc": {
                  "headline": "Gets the ``Id`` of the effective agent in use by this session.", 
                  "body": "        If ``is_authenticated()`` is true, then the effective agent may\n        be the same as the agent returned by\n        ``getAuthenticatedAgent()``. If ``is_authenticated()`` is\n        ``false,`` then the effective agent may be a default agent used\n        for authorization by an unknwon or anonymous user."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.id.Id) - the effective agent", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the effective agent\n        :rtype: ``osid.id.Id``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.id.Id", 
               "errors": {}
            }, 
            {
               "name": "get_effective_agent", 
               "doc": {
                  "headline": "Gets the effective agent in use by this session.", 
                  "body": "        If ``is_authenticated()`` is true, then the effective agent may\n        be the same as the agent returned by\n        ``getAuthenticatedAgent()``. If ``is_authenticated()`` is\n        ``false,`` then the effective agent may be a default agent used\n        for authorization by an unknwon or anonymous user."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.authentication.Agent) - the effective agent", 
               "error_doc": "        raise:  OperationFailed - unable to complete request", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the effective agent\n        :rtype: ``osid.authentication.Agent``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.authentication.Agent", 
               "errors": {
                  "OPERATION_FAILED": "Operational"
               }
            }, 
            {
               "name": "get_date", 
               "doc": {
                  "headline": "Gets the service date which may be the current date or the effective date in which this session exists.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (timestamp) - the service date", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the service date\n        :rtype: ``timestamp``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "timestamp", 
               "errors": {}
            }, 
            {
               "name": "get_clock_rate", 
               "doc": {
                  "headline": "Gets the rate of the service clock.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (decimal) - the clock rate", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the clock rate\n        :rtype: ``decimal``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "decimal", 
               "errors": {}
            }, 
            {
               "name": "get_format_type", 
               "doc": {
                  "headline": "Gets the ``DisplayText`` format ``Type`` preference in effect for this session.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.type.Type) - the effective ``DisplayText`` format\n                ``Type``", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the effective ``DisplayText`` format ``Type``\n        :rtype: ``osid.type.Type``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.type.Type", 
               "errors": {}
            }, 
            {
               "name": "supports_transactions", 
               "doc": {
                  "headline": "Tests for the availability of transactions.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if transaction methods are\n                available, ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if transaction methods are available, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "start_transaction", 
               "doc": {
                  "headline": "Starts a new transaction for this sesson.", 
                  "body": "        Transactions are a means for an OSID to provide an all-or-\n        nothing set of operations within a session and may be used to\n        coordinate this service from an external transaction manager. A\n        session supports one transaction at a time. Starting a second\n        transaction before the previous has been committed or aborted\n        results in an ``IllegalState`` error."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.transaction.Transaction) - a new transaction", 
               "error_doc": "        raise:  IllegalState - a transaction is already open\n        raise:  OperationFailed - unable to complete request\n        raise:  Unsupported - transactions not supported", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: a new transaction\n        :rtype: ``osid.transaction.Transaction``", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- a transaction is already open\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unsupported`` -- transactions not supported", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_transactions()`` is true.*\n", 
               "impl_notes_doc": "        *implementation notes*: Ideally, a provider that supports\n        transactions should guarantee atomicity, consistency, isolation\n        and durability in a 2 phase commit process. This is not always\n        possible in distributed systems and a transaction provider may\n        simply allow for a means of processing bulk updates.  To\n        maximize interoperability, providers should honor the one-\n        transaction-at-a-time rule.\n", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.transaction.Transaction", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.OsidObject", 
         "shortname": "OsidObject", 
         "category": "objects", 
         "doc": {
            "headline": "``OsidObject`` is the top level interface for all OSID Objects.", 
            "body": "    An OSID Object is an object identified by an OSID ``Id`` and may\n    implements optional interfaces. OSID Objects also contain a display\n    name and a description. These fields are required but may be used\n    for a variety of purposes ranging from a primary name and\n    description of the object to a more user friendly display of various\n    attributes.\n\n    Creation of OSID Objects and the modification of their data is\n    managed through the associated ``OsidSession`` which removes the\n    dependency of updating data elements upon object retrieval.The\n    ``OsidManager`` should be used to test if updates are available and\n    determine what ``PropertyTypes`` are supported. The ``OsidManager``\n    is also used to create the appropriate ``OsidSession`` for object\n    creation, updates and deletes.\n    \n    All ``OsidObjects`` are identified by an immutable ``Id``. An ``Id``\n    is assigned to an object upon creation of the object and cannot be\n    changed once assigned.\n    \n    An ``OsidObject`` may support one or more supplementary records\n    which are expressed in the form of interfaces. Each record interface\n    is identified by a Type. A record interface may extend another\n    record interface where support of the parent record interface is\n    implied. In this case of interface inheritance, support of the\n    parent record type may be implied through ``has_record_type()`` and\n    not explicit in ``getRecordTypes()``.\n    \n    For example, if recordB extends recordA, typeB is a child of typeA.\n    If a record implements typeB, than it also implements typeA. An\n    application that only knows about typeA retrieves recordA. An\n    application that knows about typeB, retrieves recordB which is the\n    union of methods specified in typeA and typeB. If an application\n    requests typeA, it may not attempt to access methods defined in\n    typeB as they may not exist until explicitly requested. The\n    mechanics of this polymorphism is defined by the language binder.\n    One mechanism might be the use of casting.\n    \n    In addition to the record ``Types,`` OSID Objects also have a genus\n    ``Type``. A genus ``Type`` indicates a classification or kind of the\n    object where an \"is a\" relationship exists. The purpose of of the\n    genus ``Type`` is to avoid the creation of unnecessary record types\n    that may needlessly complicate an interface hierarchy or introduce\n    interoperability issues. For example, an OSID object may have a\n    record ``Type`` of ``Publication`` that defines methods pertinent to\n    publications, such as an ISBN number. A provider may wish to\n    distinguish between books and journals without having the need of\n    new record interfaces. In this case, the genus ``Type`` may be one\n    of ``Book`` or ``Journal``. While this distinction can aid a search,\n    these genres should be treated in such a way that do not introduce\n    interoperability problems.\n    \n    Like record Types, the genus Types may also exist in an implicit\n    type hierarchy. An OSID object always has at least one genus. Genus\n    types should not be confused with subject tagging, which is managed\n    externally to the object. Unlike record ``Types,`` an object's genus\n    may be modified. However, once an object's record is created with a\n    record ``Type,`` it cannot be changed.\n    \n    Methods that return values are not permitted to return nulls. If a\n    value is not set, it is indicated in the ``Metadata`` of the update\n    form."
         }, 
         "inherit_fullnames": [
            "osid.Identifiable", 
            "osid.Extensible", 
            "osid.Browsable"
         ], 
         "inherit_shortnames": [
            "Identifiable", 
            "Extensible", 
            "Browsable"
         ], 
         "inherit_pkg_names": [
            "osid", 
            "osid", 
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "Identifiable"
            }, 
            {
               "pkg_name": "osid", 
               "name": "Extensible"
            }, 
            {
               "pkg_name": "osid", 
               "name": "Browsable"
            }
         ], 
         "method_names": [
            "get_display_name", 
            "get_description", 
            "get_genus_type", 
            "is_of_genus_type"
         ], 
         "methods": [
            {
               "name": "get_display_name", 
               "doc": {
                  "headline": "Gets the preferred display name associated with this instance of this OSID object appropriate for display to the user.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.locale.DisplayText) - the display name", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the display name\n        :rtype: ``osid.locale.DisplayText``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "        *implementation notes*: A display name is a string used for\n        identifying an object in human terms. A provider may wish to\n        initialize the display name based on one or more object\n        attributes. In some cases, the display name may not map to a\n        specific or significant object attribute but simply be used as a\n        preferred display name that can be modified. A provider may also\n        wish to translate the display name into a specific locale using\n        the Locale service. Some OSIDs define methods for more detailed\n        naming.\n", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.locale.DisplayText", 
               "errors": {}
            }, 
            {
               "name": "get_description", 
               "doc": {
                  "headline": "Gets the description associated with this instance of this OSID object.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.locale.DisplayText) - the description", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the description\n        :rtype: ``osid.locale.DisplayText``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "        *implementation notes*: A description is a string used for\n        describing an object in human terms and may not have\n        significance in the underlying system. A provider may wish to\n        initialize the description based on one or more object\n        attributes and/or treat it as an auxiliary piece of data that\n        can be modified. A provider may also wish to translate the\n        description into a specific locale using the Locale service.\n", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.locale.DisplayText", 
               "errors": {}
            }, 
            {
               "name": "get_genus_type", 
               "doc": {
                  "headline": "Gets the genus type of this object.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.type.Type) - the genus type of this object", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the genus type of this object\n        :rtype: ``osid.type.Type``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.type.Type", 
               "errors": {}
            }, 
            {
               "name": "is_of_genus_type", 
               "doc": {
                  "headline": "Tests if this object is of the given genus ``Type``.", 
                  "body": "        The given genus type may be supported by the object through the\n        type hierarchy."
               }, 
               "arg_doc": "        arg:    genus_type (osid.type.Type): a genus type\n", 
               "return_doc": "        return: (boolean) - ``true`` if this object is of the given\n                genus ``Type,``  ``false`` otherwise", 
               "error_doc": "        raise:  NullArgument - ``genus_type`` is ``null``", 
               "sphinx_param_doc": "        :param genus_type: a genus type\n        :type genus_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "        :return: ``true`` if this object is of the given genus ``Type,``  ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``genus_type`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "genus_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "boolean", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.OsidRelationship", 
         "shortname": "OsidRelationship", 
         "category": "objects", 
         "doc": {
            "headline": "A ``Relationship`` associates two OSID objects.", 
            "body": "    Relationships are transient. They define a date range for which they\n    are in effect.\n\n    Unlike other ``OsidObjects`` that rely on the auxiliary Journaling\n    OSID to track variance over time, ``OsidRelationships`` introduce a\n    different concept of time independent from journaling. For example,\n    in the present, a student was registered in a course and dropped it.\n    The relationship between the student and the course remains\n    pertinent, independent of any journaled changes that may have\n    occurred to either the student or the course.\n    \n    Once the student has dropped the course, the relationship has\n    expired such that ``is_effective()`` becomes false. It can be\n    inferred that during the period of the effective dates, the student\n    was actively registered in the course. Here is an example:\n    \n      * T1. September 1: Student registers for course for grades\n      * T2. September 10: Student drops course\n      * T3. September 15: Student re-registers for course pass/fail\n\n    \n    The relationships are:\n      T1. R1 {effective,   September 1  -> end of term,  data=grades}\n      T2. R1 {ineffective, September 1  -> September 10, data=grades}\n      T3. R1 {ineffective, September 1  -> September 10, data=grades}\n          R2 {effective,   September 10 -> end of term,  data=p/f}\n    \n\n    \n    An OSID Provider may also permit dates to be set in the future in\n    which case the relationship can become automatically become\n    effective at a future time and later expire. More complex\n    effectiveness management can be done through other rule-based\n    services.\n    \n    OSID Consumer lookups and queries of relationships need to consider\n    that it may be only effective relationshps are of interest."
         }, 
         "inherit_fullnames": [
            "osid.OsidObject", 
            "osid.Temporal"
         ], 
         "inherit_shortnames": [
            "OsidObject", 
            "Temporal"
         ], 
         "inherit_pkg_names": [
            "osid", 
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidObject"
            }, 
            {
               "pkg_name": "osid", 
               "name": "Temporal"
            }
         ], 
         "method_names": [
            "has_end_reason", 
            "get_end_reason_id", 
            "get_end_reason"
         ], 
         "methods": [
            {
               "name": "has_end_reason", 
               "doc": {
                  "headline": "Tests if a reason this relationship came to an end is known.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if an end reason is available,\n                ``false`` otherwise", 
               "error_doc": "        raise:  IllegalState - ``is_effective()`` is ``true``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if an end reason is available, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- ``is_effective()`` is ``true``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract"
               }
            }, 
            {
               "name": "get_end_reason_id", 
               "doc": {
                  "headline": "Gets a state ``Id`` indicating why this relationship has ended.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.id.Id) - a state ``Id``", 
               "error_doc": "        raise:  IllegalState - ``has_end_reason()`` is ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: a state ``Id``\n        :rtype: ``osid.id.Id``", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- ``has_end_reason()`` is ``false``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.id.Id", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract"
               }
            }, 
            {
               "name": "get_end_reason", 
               "doc": {
                  "headline": "Gets a state indicating why this relationship has ended.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.process.State) - a state", 
               "error_doc": "        raise:  IllegalState - ``has_end_reason()`` is ``false``\n        raise:  OperationFailed - unable to complete request", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: a state\n        :rtype: ``osid.process.State``", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- ``has_end_reason()`` is ``false``\n        :raise: ``OperationFailed`` -- unable to complete request", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.process.State", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.OsidCatalog", 
         "shortname": "OsidCatalog", 
         "category": "objects", 
         "doc": {
            "headline": "``OsidCatalog`` is the top level interface for all OSID catalog-like objects.", 
            "body": "    A catalog relates to other OSID objects for the purpose of\n    organization and federation and almost always are hierarchical. An\n    example catalog is a ``Repository`` that relates to a collection of\n    ``Assets``.\n\n    ``OsidCatalogs`` allow for the retrieval of a provider identity and\n    branding.\n    \n    Collections visible through an ``OsidCatalog`` may be the output of\n    a dynamic query or some other rules-based evaluation. The facts\n    surrounding the evaluation are the ``OsidObjects`` visible to the\n    ``OsidCatalog`` from its position in the federated hierarchy. The\n    input conditions may satisifed on a service-wide basis using an\n    ``OsidQuery`` or environmental conditions supplied to the services\n    via a ``Proxy`` .\n    \n    Often, the selection of an ``OsidCatalog`` in instantiating an\n    ``OsidSession`` provides access to a set of ``OsidObjects`` .\n    Because the view inside an ``OsidCatalog`` can also be produced\n    behaviorally using a rules evaluation, the ``Id`` (or well-known\n    alias) of the ``OsidCatalog`` may be used as an abstract means of\n    requesting a predefined set of behaviors or data constraints from an\n    OSID Provider.\n    \n    The flexibility of interpretation together with its central role in\n    federation to build a rich and complex service from a set of\n    individual OSID Providers makes cataloging an essential pattern to\n    achieve abstraction from implementations in the OSIDs without loss\n    of functionality. Most OSIDs include a cataloging pattern."
         }, 
         "inherit_fullnames": [
            "osid.OsidObject", 
            "osid.Sourceable", 
            "osid.Federateable"
         ], 
         "inherit_shortnames": [
            "OsidObject", 
            "Sourceable", 
            "Federateable"
         ], 
         "inherit_pkg_names": [
            "osid", 
            "osid", 
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidObject"
            }, 
            {
               "pkg_name": "osid", 
               "name": "Sourceable"
            }, 
            {
               "pkg_name": "osid", 
               "name": "Federateable"
            }
         ], 
         "method_names": [], 
         "methods": []
      }, 
      {
         "fullname": "osid.OsidRule", 
         "shortname": "OsidRule", 
         "category": "objects", 
         "doc": {
            "headline": "An ``OsidRule`` identifies an explicit or implicit rule evaluation.", 
            "body": "    An associated ``Rule`` may be available in cases where the behavior\n    of the object can be explicitly modified using a defined rule. In\n    many cases, an ``OsidObject`` may define specific methods to manage\n    certain common behavioral aspects and delegate anything above and\n    beyond what has been defined to a rule evaluation.\n\n    Rules are defined to be operable. In the case of a statement\n    evaluation, an enabled rule overrides any evaluation to return\n    ``true`` and a disabled rule overrides any evaluation to return\n    ``false``.\n    \n    ``Rules`` are never required to consume or implement. They serve as\n    a mechanism to offer a level of management not attainable in the\n    immediate service definition. Each Rule implies evaluating a set of\n    facts known to the service to produce a resulting beavior. Rule\n    evaluations may also accept input data or conditions, however,\n    ``OsidRules`` as they appear in throughout the services may or may\n    not provide a means of supplying ``OsidConditions`` directly. In the\n    services where an explicit ``OsidCondition`` is absent they may be\n    masquerading as another interface such as a ``Proxy`` or an\n    ``OsidQuery`` ."
         }, 
         "inherit_fullnames": [
            "osid.OsidObject", 
            "osid.Operable"
         ], 
         "inherit_shortnames": [
            "OsidObject", 
            "Operable"
         ], 
         "inherit_pkg_names": [
            "osid", 
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidObject"
            }, 
            {
               "pkg_name": "osid", 
               "name": "Operable"
            }
         ], 
         "method_names": [
            "has_rule", 
            "get_rule_id", 
            "get_rule"
         ], 
         "methods": [
            {
               "name": "has_rule", 
               "doc": {
                  "headline": "Tests if an explicit rule is available.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if an explicit rule is available,\n                ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if an explicit rule is available, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "get_rule_id", 
               "doc": {
                  "headline": "Gets the explicit rule ``Id``.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.id.Id) - the rule ``Id``", 
               "error_doc": "        raise:  IllegalState - ``has_rule()`` is ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the rule ``Id``\n        :rtype: ``osid.id.Id``", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- ``has_rule()`` is ``false``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.id.Id", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract"
               }
            }, 
            {
               "name": "get_rule", 
               "doc": {
                  "headline": "Gets the explicit rule.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.rules.Rule) - the rule", 
               "error_doc": "        raise:  IllegalState - ``has_rule()`` is ``false``\n        raise:  OperationFailed - unable to complete request", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the rule\n        :rtype: ``osid.rules.Rule``", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- ``has_rule()`` is ``false``\n        :raise: ``OperationFailed`` -- unable to complete request", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.rules.Rule", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.OsidEnabler", 
         "shortname": "OsidEnabler", 
         "category": "objects", 
         "doc": {
            "headline": "``OsidEnabler`` is used to manage the effectiveness, enabledness, or operation of an ``OsidObejct``.", 
            "body": "    The ``OsidEnabler`` itself is active or inactive When an\n    ``OsidEnabler`` is active, any ``OsidObject`` mapped to it is \"on.\"\n    When all ``OsidEnablers`` mapped to an ``OsidObject`` are inactive,\n    then the ``OsidObject`` is \"off.\"\n\n    The managed ``OsidObject`` may have varying semantics as to what its\n    on/off status means and in particular, which methods are used to\n    indicate the effect of an ``OsidEnabler``. Some axamples:\n    \n      * ``Operables:``  ``OsidEnablers`` effect the operational status.\n      * ``Temporals:``  ``OsidEnablers`` may be used to extend or\n        shorten the effectiveness of a ``Temporal`` such as an\n        ``OsidRelationship.``\n\n    \n    In the case where an ``OsidEnabler`` may cause a discontinuity in a\n    ``Temporal,`` the ``OsidEnabler`` may cause the creation of new\n    ``Temporals`` to capture the gap in effectiveness.\n    \n    For example, An ``OsidRelationship`` that began in 2007 may be\n    brought to an end in 2008 due to the absence of any active\n    ``OsidEnablers``. When an effective ``OsidEnabler`` appears in 2009,\n    a new ``OsidRelationship`` is created with a starting effective date\n    of 2009 leaving the existing ``OsidRelationship`` with effective\n    dates from 2007 to 2008.\n    \n    An ``OsidEnabler`` itself is both a ``Temporal`` and an ``OsidRule``\n    whose activity status of the object may be controlled\n    administratively, using a span of effective dates, through an\n    external rule, or all three. The ``OsidEnabler`` defines a set of\n    canned rules based on dates, events, and cyclic events."
         }, 
         "inherit_fullnames": [
            "osid.OsidRule", 
            "osid.Temporal"
         ], 
         "inherit_shortnames": [
            "OsidRule", 
            "Temporal"
         ], 
         "inherit_pkg_names": [
            "osid", 
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidRule"
            }, 
            {
               "pkg_name": "osid", 
               "name": "Temporal"
            }
         ], 
         "method_names": [
            "is_effective_by_schedule", 
            "get_schedule_id", 
            "get_schedule", 
            "is_effective_by_event", 
            "get_event_id", 
            "get_event", 
            "is_effective_by_cyclic_event", 
            "get_cyclic_event_id", 
            "get_cyclic_event", 
            "is_effective_for_demographic", 
            "get_demographic_id", 
            "get_demographic"
         ], 
         "methods": [
            {
               "name": "is_effective_by_schedule", 
               "doc": {
                  "headline": "Tests if the effectiveness of the enabler is governed by a ``Schedule``.", 
                  "body": "        If a schedule exists, it is bounded by the effective dates of\n        this enabler. If ``is_effective_by_schedule()`` is ``true,``\n        ``is_effective_by_event()`` and\n        ``is_effective_by_cyclic_event()`` must be ``false``."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if the enabler is governed by\n                schedule, ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if the enabler is governed by schedule, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "get_schedule_id", 
               "doc": {
                  "headline": "Gets the schedule ``Id``.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.id.Id) - the schedule ``Id``", 
               "error_doc": "        raise:  IllegalState - ``is_effective_by_schedule()`` is\n                ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the schedule ``Id``\n        :rtype: ``osid.id.Id``", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- ``is_effective_by_schedule()`` is ``false``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.id.Id", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract"
               }
            }, 
            {
               "name": "get_schedule", 
               "doc": {
                  "headline": "Gets the schedule.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.Schedule) - the schedule", 
               "error_doc": "        raise:  IllegalState - ``is_effective_by_schedule()`` is\n                ``false``\n        raise:  OperationFailed - unable to complete request", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the schedule\n        :rtype: ``osid.calendaring.Schedule``", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- ``is_effective_by_schedule()`` is ``false``\n        :raise: ``OperationFailed`` -- unable to complete request", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.Schedule", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational"
               }
            }, 
            {
               "name": "is_effective_by_event", 
               "doc": {
                  "headline": "Tests if the effectiveness of the enabler is governed by an ``Event`` such that the start and end dates of the event govern the effectiveness.", 
                  "body": "        The event may also be a ``RecurringEvent`` in which case the\n        enabler is effective for start and end dates of each event in\n        the series If an event exists, it is bounded by the effective\n        dates of this enabler. If ``is_effective_by_event()`` is\n        ``true,`` ``is_effective_by_schedule()`` and\n        ``is_effective_by_cyclic_event()`` must be ``false``."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if the enabler is governed by an\n                event, ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if the enabler is governed by an event, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "get_event_id", 
               "doc": {
                  "headline": "Gets the event ``Id``.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.id.Id) - the event ``Id``", 
               "error_doc": "        raise:  IllegalState - ``is_effective_by_event()`` is ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the event ``Id``\n        :rtype: ``osid.id.Id``", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- ``is_effective_by_event()`` is ``false``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.id.Id", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract"
               }
            }, 
            {
               "name": "get_event", 
               "doc": {
                  "headline": "Gets the event.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.Event) - the event", 
               "error_doc": "        raise:  IllegalState - ``is_effective_by_event()`` is ``false``\n        raise:  OperationFailed - unable to complete request", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the event\n        :rtype: ``osid.calendaring.Event``", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- ``is_effective_by_event()`` is ``false``\n        :raise: ``OperationFailed`` -- unable to complete request", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.Event", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational"
               }
            }, 
            {
               "name": "is_effective_by_cyclic_event", 
               "doc": {
                  "headline": "Tests if the effectiveness of the enabler is governed by a ``CyclicEvent``.", 
                  "body": "        If a cyclic event exists, it is evaluated by the accompanying\n        cyclic time period. If ``is_effective_by_cyclic_event()`` is\n        ``true,`` ``is_effective_by_schedule()`` and\n        ``is_effective_by_event()`` must be ``false``."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if the enabler is governed by a\n                cyclic event, ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if the enabler is governed by a cyclic event, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "get_cyclic_event_id", 
               "doc": {
                  "headline": "Gets the cyclic event ``Id``.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.id.Id) - the cyclic event ``Id``", 
               "error_doc": "        raise:  IllegalState - ``is_effective_by_cyclic_event()`` is\n                ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the cyclic event ``Id``\n        :rtype: ``osid.id.Id``", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- ``is_effective_by_cyclic_event()`` is ``false``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.id.Id", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract"
               }
            }, 
            {
               "name": "get_cyclic_event", 
               "doc": {
                  "headline": "Gets the cyclic event.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.cycle.CyclicEvent) - the cyclic event", 
               "error_doc": "        raise:  IllegalState - ``is_effective_by_cyclic_event()`` is\n                ``false``\n        raise:  OperationFailed - unable to complete request", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the cyclic event\n        :rtype: ``osid.calendaring.cycle.CyclicEvent``", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- ``is_effective_by_cyclic_event()`` is ``false``\n        :raise: ``OperationFailed`` -- unable to complete request", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.cycle.CyclicEvent", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational"
               }
            }, 
            {
               "name": "is_effective_for_demographic", 
               "doc": {
                  "headline": "Tests if the effectiveness of the enabler applies to a demographic resource.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if the rule apples to a\n                demographic. ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if the rule apples to a demographic. ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "get_demographic_id", 
               "doc": {
                  "headline": "Gets the demographic resource ``Id``.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.id.Id) - the resource ``Id``", 
               "error_doc": "        raise:  IllegalState - ``is_effective_for_demographic()`` is\n                ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the resource ``Id``\n        :rtype: ``osid.id.Id``", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- ``is_effective_for_demographic()`` is ``false``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.id.Id", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract"
               }
            }, 
            {
               "name": "get_demographic", 
               "doc": {
                  "headline": "Gets the demographic resource.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.resource.Resource) - the resource representing the\n                demographic", 
               "error_doc": "        raise:  IllegalState - ``is_effective_for_demographic()`` is\n                ``false``\n        raise:  OperationFailed - unable to complete request", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the resource representing the demographic\n        :rtype: ``osid.resource.Resource``", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- ``is_effective_for_demographic()`` is ``false``\n        :raise: ``OperationFailed`` -- unable to complete request", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.resource.Resource", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.OsidConstrainer", 
         "shortname": "OsidConstrainer", 
         "category": "objects", 
         "doc": {
            "headline": "An ``OsidConstrainer`` marks an interface as a control point to constrain another object.", 
            "body": "    A constrainer may define specific methods to describe the\n    constrainment or incorporate external logic using a rule."
         }, 
         "inherit_fullnames": [
            "osid.OsidRule"
         ], 
         "inherit_shortnames": [
            "OsidRule"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidRule"
            }
         ], 
         "method_names": [], 
         "methods": []
      }, 
      {
         "fullname": "osid.OsidProcessor", 
         "shortname": "OsidProcessor", 
         "category": "objects", 
         "doc": {
            "headline": "An ``OsidProcessor`` is an interface describing the operation of another object.", 
            "body": "    A processor may define specific methods to manage processing, or\n    incorporate external logic using a rule."
         }, 
         "inherit_fullnames": [
            "osid.OsidRule"
         ], 
         "inherit_shortnames": [
            "OsidRule"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidRule"
            }
         ], 
         "method_names": [], 
         "methods": []
      }, 
      {
         "fullname": "osid.OsidGovernator", 
         "shortname": "OsidGovernator", 
         "category": "objects", 
         "doc": {
            "headline": "An ``OsidGovernator`` is a control point to govern the behavior of a service.", 
            "body": "    ``OsidGovernators`` generally indicate the presence of\n    ``OsidEnablers`` and other rule governing interfaces to provide a\n    means of managing service operations and constraints from a \"behind\n    the scenes\" perspective. The ``OsidGovernator`` is a focal point for\n    these various rules.\n\n    ``OsidGovernators`` are ``Sourceable``. An ``OsidGovernator``\n    implies a governance that often corresponds to a provider of a\n    process as opposed to a catalog provider of ``OsidObjects``.\n    \n    ``OsidGovernators`` are ``Operable``. They indicate an active and\n    operational status and related rules may be administratively\n    overridden using this control point. Administratively setting the\n    enabled or disabled flags in the operator overrides any enabling\n    rule mapped to this ``OsidGovernator``."
         }, 
         "inherit_fullnames": [
            "osid.OsidObject", 
            "osid.Operable", 
            "osid.Sourceable"
         ], 
         "inherit_shortnames": [
            "OsidObject", 
            "Operable", 
            "Sourceable"
         ], 
         "inherit_pkg_names": [
            "osid", 
            "osid", 
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidObject"
            }, 
            {
               "pkg_name": "osid", 
               "name": "Operable"
            }, 
            {
               "pkg_name": "osid", 
               "name": "Sourceable"
            }
         ], 
         "method_names": [], 
         "methods": []
      }, 
      {
         "fullname": "osid.OsidCompendium", 
         "shortname": "OsidCompendium", 
         "category": "objects", 
         "doc": {
            "headline": "``OsidCompendium`` is the top level interface for reports based on measurements, calculations, summaries, or views of transactional activity within periods of time.", 
            "body": "    This time dimension of this report may align with managed time\n    periods, specific dates, or both. Oh my.\n\n    Reports are often derived dynamically based on an examination of\n    data managed elsewhere in an OSID. Reports may also be directly\n    managed outside where it is desirable to capture summaries without\n    the detail of the implied evaluated data. The behavior of a direct\n    create or update of a report is not specified but is not limited to\n    an override or a cascading update of underlying data.\n    \n    The start and end date represents the date range used in the\n    evaluation of the transactional data on which this report is based.\n    The start and end date may be the same indicating that the\n    evaluation occurred at a point in time rather than across a date\n    range. The start and end date requested may differ from the start\n    and end date indicated in this report because of the inability to\n    interpolate or extrapolate the date. These dates should be examined\n    to understand what actually occurred and to what dates the\n    information in this report pertains.\n    \n    These dates differ from the dates the report itself was requested,\n    created, or modified. The dates refer to the context of the\n    evaluation. In a managed report, the dates are simply the dates to\n    which the report information pertains. The history of a single\n    report may be examined in the Journaling OSID.\n    \n    For example, the Location of a Resource at 12:11pm is reported to be\n    in Longwood and at 12:23pm is reported to be at Chestnut Hill. A\n    request of a ``ResourceLocation``. A data correction may update the\n    Longwood time to be 12:09pm. The update of the ``ResourceLocation``\n    from 12:11pm to 12:09pm may be examined in the Journaling OSID while\n    the 12:11pm time would not longer be visible in current versions of\n    this report.\n    \n    Reports may be indexed by a managed time period such as a ``Term``\n    or ``FiscalPeriod``. The evaluation dates may map to the opening and\n    closing dates of the time period. Evaluation dates that differ from\n    the time period may indicate that the transactional data is\n    incomplete for that time period or that the report was calculated\n    using a requested date range.\n    \n    ``OsidCompendiums`` are subjugates to other ``OsidObjects`` in that\n    what is reported is tied to an instance of a dimension such as a\n    person, account, or an ``OsidCatalog`` ."
         }, 
         "inherit_fullnames": [
            "osid.OsidObject", 
            "osid.Subjugateable"
         ], 
         "inherit_shortnames": [
            "OsidObject", 
            "Subjugateable"
         ], 
         "inherit_pkg_names": [
            "osid", 
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidObject"
            }, 
            {
               "pkg_name": "osid", 
               "name": "Subjugateable"
            }
         ], 
         "method_names": [
            "get_start_date", 
            "get_end_date", 
            "is_interpolated", 
            "is_extrapolated"
         ], 
         "methods": [
            {
               "name": "get_start_date", 
               "doc": {
                  "headline": "Gets the start date used in the evaluation of the transactional data on which this report is based.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.DateTime) - the date", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the date\n        :rtype: ``osid.calendaring.DateTime``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.DateTime", 
               "errors": {}
            }, 
            {
               "name": "get_end_date", 
               "doc": {
                  "headline": "Gets the end date used in the evaluation of the transactional data on which this report is based.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.DateTime) - the date", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the date\n        :rtype: ``osid.calendaring.DateTime``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.DateTime", 
               "errors": {}
            }, 
            {
               "name": "is_interpolated", 
               "doc": {
                  "headline": "Tests if this report is interpolated within measured data or known transactions.", 
                  "body": "        Interpolation may occur if the start or end date fall between\n        two known facts or managed time period."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if this report is interpolated,\n                ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if this report is interpolated, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "is_extrapolated", 
               "doc": {
                  "headline": "Tests if this report is extrapolated outside measured data or known transactions.", 
                  "body": "        Extrapolation may occur if the start or end date fall outside\n        two known facts or managed time period. Extrapolation may occur\n        within a managed time period in progress where the results of\n        the entire time period are projected."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if this report is extrapolated,\n                ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if this report is extrapolated, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }
         ]
      }, 
      {
         "fullname": "osid.OsidCapsule", 
         "shortname": "OsidCapsule", 
         "category": "objects", 
         "doc": {
            "headline": "``OsidCapsule`` wraps other objects.", 
            "body": "    The interface has no meaning other than to return a set of\n    semantically unrelated objects from a method."
         }, 
         "inherit_fullnames": [], 
         "inherit_shortnames": [], 
         "inherit_pkg_names": [], 
         "inheritance": [], 
         "method_names": [], 
         "methods": []
      }, 
      {
         "fullname": "osid.OsidQuery", 
         "shortname": "OsidQuery", 
         "category": "queries", 
         "doc": {
            "headline": "The ``OsidQuery`` is used to assemble search queries.", 
            "body": "    An ``OsidQuery`` is available from an ``OsidQuerySession`` and\n    defines methods to match objects. Once the desired parameters are\n    set, the ``OsidQuery`` is given to the designated search method. The\n    same ``OsidQuery`` returned from the session must be used in the\n    search as the provider may utilize implementation-specific data\n    wiithin the object.\n\n    If multiple data elements are set in this interface, the results\n    matching all the given data (eg: AND) are returned.\n    \n    Any match method inside an ``OsidQuery`` may be invoked multiple\n    times. In the case of a match method, each invocation adds an\n    element to an ``OR`` expression. Any of these terms may also be\n    negated through the ``match`` flag.\n      OsidQuery { OsidQuery.matchDisplayName AND (OsidQuery.matchDescription OR OsidQuery.matchDescription)}\n    \n\n    \n    ``OsidObjects`` allow for the definition of an additonal records and\n    the ``OsidQuery`` parallels this mechanism. An interface type of an\n    ``OsidObject`` record must also define the corresponding\n    ``OsidQuery`` record which is available through query interfaces.\n    Multiple requests of these typed interfaces may return the same\n    underlying object and thus it is only useful to request once.\n    \n    An ``OsidQuery`` may be used to query for set or unset values using\n    the \"match any\" methods. A field that has not bee explicitly\n    assigned may default to a value. If multiple language translations\n    exist and the query session is placed in a non-default locale,\n    fields that have not been explicitly assigned in the non-default\n    locale are considered unset even if the values from the default\n    locale appear in the objects."
         }, 
         "inherit_fullnames": [
            "osid.Suppliable"
         ], 
         "inherit_shortnames": [
            "Suppliable"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "Suppliable"
            }
         ], 
         "method_names": [
            "get_string_match_types", 
            "supports_string_match_type", 
            "match_keyword", 
            "clear_keyword_terms", 
            "match_any", 
            "clear_any_terms"
         ], 
         "methods": [
            {
               "name": "get_string_match_types", 
               "doc": {
                  "headline": "Gets the string matching types supported.", 
                  "body": "        A string match type specifies the syntax of the string query,\n        such as matching a word or including a wildcard or regular\n        expression."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.type.TypeList) - a list containing the supported\n                string match types", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: a list containing the supported string match types\n        :rtype: ``osid.type.TypeList``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.type.TypeList", 
               "errors": {}
            }, 
            {
               "name": "supports_string_match_type", 
               "doc": {
                  "headline": "Tests if the given string matching type is supported.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    string_match_type (osid.type.Type): a ``Type``\n                indicating a string match type\n", 
               "return_doc": "        return: (boolean) - ``true`` if the given Type is supported,\n                ``false`` otherwise", 
               "error_doc": "        raise:  NullArgument - ``string_match_type`` is ``null``", 
               "sphinx_param_doc": "        :param string_match_type: a ``Type`` indicating a string match type\n        :type string_match_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "        :return: ``true`` if the given Type is supported, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``string_match_type`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "string_match_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "boolean", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "match_keyword", 
               "doc": {
                  "headline": "Adds a keyword to match.", 
                  "body": "        Multiple keywords can be added to perform a boolean ``OR`` among\n        them. A keyword may be applied to any of the elements defined in\n        this object such as the display name, description or any method\n        defined in an interface implemented by this object."
               }, 
               "arg_doc": "        arg:    keyword (string): keyword to match\n        arg:    string_match_type (osid.type.Type): the string match\n                type\n        arg:    match (boolean): ``true`` for a positive match,\n                ``false`` for a negative match\n", 
               "return_doc": "", 
               "error_doc": "        raise:  InvalidArgument - ``keyword`` is not of\n                ``string_match_type``\n        raise:  NullArgument - ``keyword`` or ``string_match_type`` is\n                ``null``\n        raise:  Unsupported -\n                ``supports_string_match_type(string_match_type)`` is\n                ``false``", 
               "sphinx_param_doc": "        :param keyword: keyword to match\n        :type keyword: ``string``\n        :param string_match_type: the string match type\n        :type string_match_type: ``osid.type.Type``\n        :param match: ``true`` for a positive match, ``false`` for a negative match\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``InvalidArgument`` -- ``keyword`` is not of ``string_match_type``\n        :raise: ``NullArgument`` -- ``keyword`` or ``string_match_type`` is ``null``\n        :raise: ``Unsupported`` -- ``supports_string_match_type(string_match_type)`` is ``false``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "string", 
                     "var_name": "keyword", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "string_match_type", 
                     "array": false
                  }, 
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "string", 
                  "osid.type.Type", 
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {
                  "INVALID_ARGUMENT": "ConsumerContract", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }, 
            {
               "name": "clear_keyword_terms", 
               "doc": {
                  "headline": "Clears all keyword terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "match_any", 
               "doc": {
                  "headline": "Matches any object.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    match (boolean): ``true`` to match any object ``,``\n                ``false`` to match no objects\n", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "        :param match: ``true`` to match any object ``,``  ``false`` to match no objects\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "clear_any_terms", 
               "doc": {
                  "headline": "Clears the match any terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }
         ]
      }, 
      {
         "fullname": "osid.OsidIdentifiableQuery", 
         "shortname": "OsidIdentifiableQuery", 
         "category": "queries", 
         "doc": {
            "headline": "The ``OsidIdentiableQuery`` is used to assemble search queries for ``Identifiable`` objects.", 
            "body": "    An ``OsidIdentifiableQuery`` is available from an\n    ``OsidQuerySession`` and defines methods to match objects. Once the\n    desired parameters are set, the ``OsidIdentifiableQuery`` is given\n    to the designated search method. The same ``OsidIdentifiableQuery``\n    returned from the session must be used in the search as the provider\n    may utilize implementation-specific data wiithin the object.\n\n    If multiple data elements are set in this interface, the results\n    matching all the given data (eg: AND) are returned."
         }, 
         "inherit_fullnames": [
            "osid.OsidQuery"
         ], 
         "inherit_shortnames": [
            "OsidQuery"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidQuery"
            }
         ], 
         "method_names": [
            "match_id", 
            "clear_id_terms"
         ], 
         "methods": [
            {
               "name": "match_id", 
               "doc": {
                  "headline": "Adds an ``Id`` to match.", 
                  "body": "        Multiple ``Ids`` can be added to perform a boolean ``OR`` among\n        them."
               }, 
               "arg_doc": "        arg:    id (osid.id.Id): ``Id`` to match\n        arg:    match (boolean): ``true`` for a positive match,\n                ``false`` for a negative match\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``id`` is ``null``", 
               "sphinx_param_doc": "        :param id: ``Id`` to match\n        :type id: ``osid.id.Id``\n        :param match: ``true`` for a positive match, ``false`` for a negative match\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``id`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "id_", 
                     "array": false
                  }, 
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "clear_id_terms", 
               "doc": {
                  "headline": "Clears all ``Id`` terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }
         ]
      }, 
      {
         "fullname": "osid.OsidExtensibleQuery", 
         "shortname": "OsidExtensibleQuery", 
         "category": "queries", 
         "doc": {
            "headline": "The ``OsidExtensibleQuery`` is used to assemble search queries for ``Extensible`` objects.", 
            "body": "    An ``OsidExtensibleQuery`` is available from an ``OsidQuerySession``\n    and defines methods to match objects. Once the desired parameters\n    are set, the ``OsidExtensibleQuery`` is given to the designated\n    search method. The same ``OsidExtensibleQuery`` returned from the\n    session must be used in the search as the provider may utilize\n    implementation-specific data wiithin the object.\n\n    If multiple data elements are set in this interface, the results\n    matching all the given data (eg: AND) are returned."
         }, 
         "inherit_fullnames": [
            "osid.OsidQuery", 
            "osid.Extensible"
         ], 
         "inherit_shortnames": [
            "OsidQuery", 
            "Extensible"
         ], 
         "inherit_pkg_names": [
            "osid", 
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidQuery"
            }, 
            {
               "pkg_name": "osid", 
               "name": "Extensible"
            }
         ], 
         "method_names": [
            "match_record_type", 
            "match_any_record", 
            "clear_record_terms"
         ], 
         "methods": [
            {
               "name": "match_record_type", 
               "doc": {
                  "headline": "Sets a ``Type`` for querying objects having records implementing a given record type.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    record_type (osid.type.Type): a record type\n        arg:    match (boolean): ``true`` for a positive match,\n                ``false`` for a negative match\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``record_type`` is ``null``", 
               "sphinx_param_doc": "        :param record_type: a record type\n        :type record_type: ``osid.type.Type``\n        :param match: ``true`` for a positive match, ``false`` for a negative match\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``record_type`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "record_type", 
                     "array": false
                  }, 
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type", 
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "match_any_record", 
               "doc": {
                  "headline": "Matches an object that has any record.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    match (boolean): ``true`` to match any record, ``false``\n                to match objects with no records\n", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "        :param match: ``true`` to match any record, ``false`` to match objects with no records\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "clear_record_terms", 
               "doc": {
                  "headline": "Clears all record ``Type`` terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }
         ]
      }, 
      {
         "fullname": "osid.OsidBrowsableQuery", 
         "shortname": "OsidBrowsableQuery", 
         "category": "queries", 
         "doc": {
            "headline": "The ``OsidBrowsableQuery`` is used to assemble search queries for ``Browsable`` objects.", 
            "body": "    An ``OsidBrowsableQuery`` is available from an ``OsidQuerySession``\n    and defines methods to match objects. Once the desired parameters\n    are set, the ``OsidBrowsableQuery`` is given to the designated\n    search method. The same ``OsidBrowsableQuery`` returned from the\n    session must be used in the search as the provider may utilize\n    implementation-specific data wiithin the object.\n\n    If multiple data elements are set in this interface, the results\n    matching all the given data (eg: AND) are returned."
         }, 
         "inherit_fullnames": [
            "osid.OsidQuery"
         ], 
         "inherit_shortnames": [
            "OsidQuery"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidQuery"
            }
         ], 
         "method_names": [], 
         "methods": []
      }, 
      {
         "fullname": "osid.OsidTemporalQuery", 
         "shortname": "OsidTemporalQuery", 
         "category": "queries", 
         "doc": {
            "headline": "This is the query interface for searching temporal objects.", 
            "body": "    Each method specifies an ``AND`` term while multiple invocations of\n    the same method produce a nested ``OR``."
         }, 
         "inherit_fullnames": [
            "osid.OsidQuery"
         ], 
         "inherit_shortnames": [
            "OsidQuery"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidQuery"
            }
         ], 
         "method_names": [
            "match_effective", 
            "clear_effective_terms", 
            "match_start_date", 
            "match_any_start_date", 
            "clear_start_date_terms", 
            "match_end_date", 
            "match_any_end_date", 
            "clear_end_date_terms", 
            "match_date", 
            "clear_date_terms"
         ], 
         "methods": [
            {
               "name": "match_effective", 
               "doc": {
                  "headline": "Match effective objects where the current date falls within the start and end dates inclusive.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    match (boolean): ``true`` to match any effective,\n                ``false`` to match ineffective\n", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "        :param match: ``true`` to match any effective, ``false`` to match ineffective\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "clear_effective_terms", 
               "doc": {
                  "headline": "Clears the effective query terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "match_start_date", 
               "doc": {
                  "headline": "Matches temporals whose start date falls in between the given dates inclusive.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    start (osid.calendaring.DateTime): start of date range\n        arg:    end (osid.calendaring.DateTime): end of date range\n        arg:    match (boolean): ``true`` if a positive match, ``false``\n                for a negative match\n", 
               "return_doc": "", 
               "error_doc": "        raise:  InvalidArgument - ``start`` is less than ``end``\n        raise:  NullArgument - ``start`` or ``end`` is ``null``", 
               "sphinx_param_doc": "        :param start: start of date range\n        :type start: ``osid.calendaring.DateTime``\n        :param end: end of date range\n        :type end: ``osid.calendaring.DateTime``\n        :param match: ``true`` if a positive match, ``false`` for a negative match\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``InvalidArgument`` -- ``start`` is less than ``end``\n        :raise: ``NullArgument`` -- ``start`` or ``end`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.calendaring.DateTime", 
                     "var_name": "start", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.calendaring.DateTime", 
                     "var_name": "end", 
                     "array": false
                  }, 
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.calendaring.DateTime", 
                  "osid.calendaring.DateTime", 
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {
                  "INVALID_ARGUMENT": "ConsumerContract", 
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "match_any_start_date", 
               "doc": {
                  "headline": "Matches temporals with any start date set.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    match (boolean): ``true`` to match any start date,\n                ``false`` to match no start date\n", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "        :param match: ``true`` to match any start date, ``false`` to match no start date\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "clear_start_date_terms", 
               "doc": {
                  "headline": "Clears the start date query terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "match_end_date", 
               "doc": {
                  "headline": "Matches temporals whose effective end date falls in between the given dates inclusive.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    start (osid.calendaring.DateTime): start of date range\n        arg:    end (osid.calendaring.DateTime): end of date range\n        arg:    match (boolean): ``true`` if a positive match, ``false``\n                for negative match\n", 
               "return_doc": "", 
               "error_doc": "        raise:  InvalidArgument - ``start`` is less than ``end``\n        raise:  NullArgument - ``start`` or ``end`` is ``null``", 
               "sphinx_param_doc": "        :param start: start of date range\n        :type start: ``osid.calendaring.DateTime``\n        :param end: end of date range\n        :type end: ``osid.calendaring.DateTime``\n        :param match: ``true`` if a positive match, ``false`` for negative match\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``InvalidArgument`` -- ``start`` is less than ``end``\n        :raise: ``NullArgument`` -- ``start`` or ``end`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.calendaring.DateTime", 
                     "var_name": "start", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.calendaring.DateTime", 
                     "var_name": "end", 
                     "array": false
                  }, 
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.calendaring.DateTime", 
                  "osid.calendaring.DateTime", 
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {
                  "INVALID_ARGUMENT": "ConsumerContract", 
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "match_any_end_date", 
               "doc": {
                  "headline": "Matches temporals with any end date set.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    match (boolean): ``true`` to match any end date,\n                ``false`` to match no start date\n", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "        :param match: ``true`` to match any end date, ``false`` to match no start date\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "clear_end_date_terms", 
               "doc": {
                  "headline": "Clears the end date query terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "match_date", 
               "doc": {
                  "headline": "Matches temporals where the given date range falls entirely between the start and end dates inclusive.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    from (osid.calendaring.DateTime): start date\n        arg:    to (osid.calendaring.DateTime): end date\n        arg:    match (boolean): ``true`` if a positive match, ``false``\n                for a negative match\n", 
               "return_doc": "", 
               "error_doc": "        raise:  InvalidArgument - ``from`` is less than ``to``\n        raise:  NullArgument - ``from`` or ``to`` is ``null``", 
               "sphinx_param_doc": "        :param from: start date\n        :type from: ``osid.calendaring.DateTime``\n        :param to: end date\n        :type to: ``osid.calendaring.DateTime``\n        :param match: ``true`` if a positive match, ``false`` for a negative match\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``InvalidArgument`` -- ``from`` is less than ``to``\n        :raise: ``NullArgument`` -- ``from`` or ``to`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.calendaring.DateTime", 
                     "var_name": "from_", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.calendaring.DateTime", 
                     "var_name": "to", 
                     "array": false
                  }, 
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.calendaring.DateTime", 
                  "osid.calendaring.DateTime", 
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {
                  "INVALID_ARGUMENT": "ConsumerContract", 
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "clear_date_terms", 
               "doc": {
                  "headline": "Clears the date query terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }
         ]
      }, 
      {
         "fullname": "osid.OsidSubjugateableQuery", 
         "shortname": "OsidSubjugateableQuery", 
         "category": "queries", 
         "doc": {
            "headline": "The ``OsidSubjugateableQuery`` is used to assemble search queries for dependent objects.", 
            "body": ""
         }, 
         "inherit_fullnames": [
            "osid.OsidQuery"
         ], 
         "inherit_shortnames": [
            "OsidQuery"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidQuery"
            }
         ], 
         "method_names": [], 
         "methods": []
      }, 
      {
         "fullname": "osid.OsidAggregateableQuery", 
         "shortname": "OsidAggregateableQuery", 
         "category": "queries", 
         "doc": {
            "headline": "The ``OsidAggregateableQuery`` is used to assemble search queries for assemblages.", 
            "body": ""
         }, 
         "inherit_fullnames": [
            "osid.OsidQuery"
         ], 
         "inherit_shortnames": [
            "OsidQuery"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidQuery"
            }
         ], 
         "method_names": [], 
         "methods": []
      }, 
      {
         "fullname": "osid.OsidContainableQuery", 
         "shortname": "OsidContainableQuery", 
         "category": "queries", 
         "doc": {
            "headline": "This is the query interface for searching containers.", 
            "body": "    Each method specifies an ``AND`` term while multiple invocations of\n    the same method produce a nested ``OR``."
         }, 
         "inherit_fullnames": [
            "osid.OsidAggregateableQuery"
         ], 
         "inherit_shortnames": [
            "OsidAggregateableQuery"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidAggregateableQuery"
            }
         ], 
         "method_names": [
            "match_sequestered", 
            "clear_sequestered_terms"
         ], 
         "methods": [
            {
               "name": "match_sequestered", 
               "doc": {
                  "headline": "Match containables that are sequestered.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    match (boolean): ``true`` to match any sequestered\n                containables, ``false`` to match non- sequestered\n                containables\n", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "        :param match: ``true`` to match any sequestered containables, ``false`` to match non-sequestered containables\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "clear_sequestered_terms", 
               "doc": {
                  "headline": "Clears the sequestered query terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }
         ]
      }, 
      {
         "fullname": "osid.OsidSourceableQuery", 
         "shortname": "OsidSourceableQuery", 
         "category": "queries", 
         "doc": {
            "headline": "The ``OsidSourceableQuery`` is used to assemble search queries for sourceables.", 
            "body": ""
         }, 
         "inherit_fullnames": [
            "osid.OsidQuery"
         ], 
         "inherit_shortnames": [
            "OsidQuery"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidQuery"
            }
         ], 
         "method_names": [
            "match_provider_id", 
            "clear_provider_id_terms", 
            "supports_provider_query", 
            "get_provider_query", 
            "match_any_provider", 
            "clear_provider_terms", 
            "match_branding_id", 
            "clear_branding_id_terms", 
            "supports_branding_query", 
            "get_branding_query", 
            "match_any_branding", 
            "clear_branding_terms", 
            "match_license", 
            "match_any_license", 
            "clear_license_terms"
         ], 
         "methods": [
            {
               "name": "match_provider_id", 
               "doc": {
                  "headline": "Match the ``Id`` of the provider resource.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    resource_id (osid.id.Id): ``Id`` to match\n        arg:    match (boolean): ``true`` if for a positive match,\n                ``false`` for a negative match\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``resource_id`` is ``null``", 
               "sphinx_param_doc": "        :param resource_id: ``Id`` to match\n        :type resource_id: ``osid.id.Id``\n        :param match: ``true`` if for a positive match, ``false`` for a negative match\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``resource_id`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "resource_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "clear_provider_id_terms", 
               "doc": {
                  "headline": "Clears all provider ``Id`` terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "supports_provider_query", 
               "doc": {
                  "headline": "Tests if a ``ResourceQuery`` for the provider is available.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if a resource query is available,\n                ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if a resource query is available, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "get_provider_query", 
               "doc": {
                  "headline": "Gets the query for the provider.", 
                  "body": "        Each retrieval performs a boolean ``OR``."
               }, 
               "arg_doc": "        arg:    match (boolean): ``true`` if for a positive match,\n                ``false`` for a negative match\n", 
               "return_doc": "        return: (osid.resource.ResourceQuery) - the provider query", 
               "error_doc": "        raise:  Unimplemented - ``supports_provider_query()`` is\n                ``false``", 
               "sphinx_param_doc": "        :param match: ``true`` if for a positive match, ``false`` for a negative match\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "        :return: the provider query\n        :rtype: ``osid.resource.ResourceQuery``", 
               "sphinx_error_doc": "        :raise: ``Unimplemented`` -- ``supports_provider_query()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_provider_query()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "boolean"
               ], 
               "return_type": "osid.resource.ResourceQuery", 
               "errors": {
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "match_any_provider", 
               "doc": {
                  "headline": "Match sourceables with a provider value.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    match (boolean): ``true`` to match sourceables with any\n                provider, ``false`` to match sourceables with no\n                providers\n", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "        :param match: ``true`` to match sourceables with any provider, ``false`` to match sourceables with no providers\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "clear_provider_terms", 
               "doc": {
                  "headline": "Clears all provider terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "match_branding_id", 
               "doc": {
                  "headline": "Match the ``Id`` of an asset used for branding.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    asset_id (osid.id.Id): ``Id`` to match\n        arg:    match (boolean): ``true`` if for a positive match,\n                ``false`` for a negative match\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``asset_id`` is ``null``", 
               "sphinx_param_doc": "        :param asset_id: ``Id`` to match\n        :type asset_id: ``osid.id.Id``\n        :param match: ``true`` if for a positive match, ``false`` for a negative match\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``asset_id`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "asset_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "clear_branding_id_terms", 
               "doc": {
                  "headline": "Clears all asset ``Id`` terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "supports_branding_query", 
               "doc": {
                  "headline": "Tests if an ``AssetQuery`` for the branding is available.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if a asset query is available,\n                ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if a asset query is available, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "get_branding_query", 
               "doc": {
                  "headline": "Gets the query for an asset.", 
                  "body": "        Each retrieval performs a boolean ``OR``."
               }, 
               "arg_doc": "        arg:    match (boolean): ``true`` if for a positive match,\n                ``false`` for a negative match\n", 
               "return_doc": "        return: (osid.repository.AssetQuery) - the asset query", 
               "error_doc": "        raise:  Unimplemented - ``supports_branding_query()`` is\n                ``false``", 
               "sphinx_param_doc": "        :param match: ``true`` if for a positive match, ``false`` for a negative match\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "        :return: the asset query\n        :rtype: ``osid.repository.AssetQuery``", 
               "sphinx_error_doc": "        :raise: ``Unimplemented`` -- ``supports_branding_query()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_branding_query()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "boolean"
               ], 
               "return_type": "osid.repository.AssetQuery", 
               "errors": {
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "match_any_branding", 
               "doc": {
                  "headline": "Match sourceables with any branding.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    match (boolean): ``true`` to match any asset, ``false``\n                to match no assets\n", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "        :param match: ``true`` to match any asset, ``false`` to match no assets\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "clear_branding_terms", 
               "doc": {
                  "headline": "Clears all branding terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "match_license", 
               "doc": {
                  "headline": "Adds a license to match.", 
                  "body": "        Multiple license matches can be added to perform a boolean\n        ``OR`` among them."
               }, 
               "arg_doc": "        arg:    license (string): a string to match\n        arg:    string_match_type (osid.type.Type): the string match\n                type\n        arg:    match (boolean): ``true`` for a positive match,\n                ``false`` for a negative match\n", 
               "return_doc": "", 
               "error_doc": "        raise:  InvalidArgument - ``license`` is not of\n                ``string_match_type``\n        raise:  NullArgument - ``license`` or ``string_match_type`` is\n                ``null``\n        raise:  Unsupported -\n                ``supports_string_match_type(string_match_type)`` is\n                ``false``", 
               "sphinx_param_doc": "        :param license: a string to match\n        :type license: ``string``\n        :param string_match_type: the string match type\n        :type string_match_type: ``osid.type.Type``\n        :param match: ``true`` for a positive match, ``false`` for a negative match\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``InvalidArgument`` -- ``license`` is not of ``string_match_type``\n        :raise: ``NullArgument`` -- ``license`` or ``string_match_type`` is ``null``\n        :raise: ``Unsupported`` -- ``supports_string_match_type(string_match_type)`` is ``false``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "string", 
                     "var_name": "license", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "string_match_type", 
                     "array": false
                  }, 
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "string", 
                  "osid.type.Type", 
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {
                  "INVALID_ARGUMENT": "ConsumerContract", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }, 
            {
               "name": "match_any_license", 
               "doc": {
                  "headline": "Matches any object with a license.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    match (boolean): ``true`` to match any license,\n                ``false`` to match objects with no license\n", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "        :param match: ``true`` to match any license, ``false`` to match objects with no license\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "clear_license_terms", 
               "doc": {
                  "headline": "Clears all license terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }
         ]
      }, 
      {
         "fullname": "osid.OsidFederateableQuery", 
         "shortname": "OsidFederateableQuery", 
         "category": "queries", 
         "doc": {
            "headline": "The ``OsidFederateableQuery`` is used to assemble search queries for federated objects.", 
            "body": ""
         }, 
         "inherit_fullnames": [
            "osid.OsidQuery"
         ], 
         "inherit_shortnames": [
            "OsidQuery"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidQuery"
            }
         ], 
         "method_names": [], 
         "methods": []
      }, 
      {
         "fullname": "osid.OsidOperableQuery", 
         "shortname": "OsidOperableQuery", 
         "category": "queries", 
         "doc": {
            "headline": "This is the query interface for searching operables.", 
            "body": "    Each method specifies an ``AND`` term while multiple invocations of\n    the same method produce a nested ``OR``."
         }, 
         "inherit_fullnames": [
            "osid.OsidQuery"
         ], 
         "inherit_shortnames": [
            "OsidQuery"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidQuery"
            }
         ], 
         "method_names": [
            "match_active", 
            "clear_active_terms", 
            "match_enabled", 
            "clear_enabled_terms", 
            "match_disabled", 
            "clear_disabled_terms", 
            "match_operational", 
            "clear_operational_terms"
         ], 
         "methods": [
            {
               "name": "match_active", 
               "doc": {
                  "headline": "Matches active.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    match (boolean): ``true`` to match active, ``false`` to\n                match inactive\n", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "        :param match: ``true`` to match active, ``false`` to match inactive\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "clear_active_terms", 
               "doc": {
                  "headline": "Clears the active query terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "match_enabled", 
               "doc": {
                  "headline": "Matches administratively enabled.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    match (boolean): ``true`` to match administratively\n                enabled, ``false`` otherwise\n", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "        :param match: ``true`` to match administratively enabled, ``false`` otherwise\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "clear_enabled_terms", 
               "doc": {
                  "headline": "Clears the administratively enabled query terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "match_disabled", 
               "doc": {
                  "headline": "Matches administratively disabled.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    match (boolean): ``true`` to match administratively\n                disabled, ``false`` otherwise\n", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "        :param match: ``true`` to match administratively disabled, ``false`` otherwise\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "clear_disabled_terms", 
               "doc": {
                  "headline": "Clears the administratively disabled query terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "match_operational", 
               "doc": {
                  "headline": "Matches operational operables.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    match (boolean): ``true`` to match operational,\n                ``false`` to match not operational\n", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "        :param match: ``true`` to match operational, ``false`` to match not operational\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "clear_operational_terms", 
               "doc": {
                  "headline": "Clears the operational query terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }
         ]
      }, 
      {
         "fullname": "osid.OsidObjectQuery", 
         "shortname": "OsidObjectQuery", 
         "category": "queries", 
         "doc": {
            "headline": "The ``OsidObjectQuery`` is used to assemble search queries.", 
            "body": "    An ``OsidObjectQuery`` is available from an ``OsidSession`` and\n    defines methods to query for an ``OsidObject`` that includes setting\n    a display name and a description. Once the desired parameters are\n    set, the ``OsidQuery`` is given to the designated search method. The\n    same ``OsidQuery`` returned from the session must be used in the\n    search as the provider may utilize implementation-specific data\n    wiithin the object.\n\n    If multiple data elements are set in this interface, the results\n    matching all the given data (eg: AND) are returned.\n    \n    Any match method inside an ``OsidObjectQuery`` may be invoked\n    multiple times. In the case of a match method, each invocation adds\n    an element to an ``OR`` expression. Any of these terms may also be\n    negated through the ``match`` flag.\n      OsidObjectQuery { OsidQuery.matchDisplayName AND (OsidQuery.matchDescription OR OsidObjectQuery.matchDescription)}\n    \n\n    \n    ``OsidObjects`` allow for the definition of an additonal records and\n    the ``OsidQuery`` parallels this mechanism. An interface type of an\n    ``OsidObject`` record must also define the corresponding\n    ``OsidQuery`` record which is available through query interfaces.\n    Multiple requests of these typed interfaces may return the same\n    underlying object and thus it is only useful to request once.\n    \n    String searches are described using a string search ``Type`` that\n    indicates the type of regular expression or wildcarding encoding.\n    Compatibility with a strings search ``Type`` can be tested within\n    this interface.\n    \n    As with all aspects of OSIDs,nulls cannot be used. Separate tests\n    are available for querying for unset values except for required\n    fields.\n    \n    An example to find all objects whose name starts with \"Fred\" or\n    whose name starts with \"Barney\", but the word \"dinosaur\" does not\n    appear in the description and not the color is not purple.\n    ``ColorQuery`` is a record of the object that defines a color.\n      ObjectObjectQuery query;\n      query = session.getObjectQuery();\n      query.matchDisplayName(\"Fred*\", wildcardStringMatchType, true);\n      query.matchDisplayName(\"Barney*\", wildcardStringMatchType, true);\n      query.matchDescriptionMatch(\"dinosaur\", wordStringMatchType, false);\n      \n      ColorQuery recordQuery;\n      recordQuery = query.getObjectRecord(colorRecordType);\n      recordQuery.matchColor(\"purple\", false);\n      ObjectList list = session.getObjectsByQuery(query);\n    \n"
         }, 
         "inherit_fullnames": [
            "osid.OsidIdentifiableQuery", 
            "osid.OsidExtensibleQuery", 
            "osid.OsidBrowsableQuery"
         ], 
         "inherit_shortnames": [
            "OsidIdentifiableQuery", 
            "OsidExtensibleQuery", 
            "OsidBrowsableQuery"
         ], 
         "inherit_pkg_names": [
            "osid", 
            "osid", 
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidIdentifiableQuery"
            }, 
            {
               "pkg_name": "osid", 
               "name": "OsidExtensibleQuery"
            }, 
            {
               "pkg_name": "osid", 
               "name": "OsidBrowsableQuery"
            }
         ], 
         "method_names": [
            "match_display_name", 
            "match_any_display_name", 
            "clear_display_name_terms", 
            "match_description", 
            "match_any_description", 
            "clear_description_terms", 
            "match_genus_type", 
            "match_any_genus_type", 
            "clear_genus_type_terms", 
            "match_parent_genus_type", 
            "clear_parent_genus_type_terms", 
            "match_subject_id", 
            "clear_subject_id_terms", 
            "supports_subject_query", 
            "get_subject_query", 
            "match_any_subject", 
            "clear_subject_terms", 
            "supports_subject_relevancy_query", 
            "get_subject_relevancy_query", 
            "clear_subject_relevancy_terms", 
            "match_state_id", 
            "clear_state_id_terms", 
            "supports_state_query", 
            "get_state_query", 
            "match_any_state", 
            "clear_state_terms", 
            "match_comment_id", 
            "clear_comment_id_terms", 
            "supports_comment_query", 
            "get_comment_query", 
            "match_any_comment", 
            "clear_comment_terms", 
            "match_journal_entry_id", 
            "clear_journal_entry_id_terms", 
            "supports_journal_entry_query", 
            "get_journal_entry_query", 
            "match_any_journal_entry", 
            "clear_journal_entry_terms", 
            "supports_statistic_query", 
            "get_statistic_query", 
            "match_any_statistic", 
            "clear_statistic_terms", 
            "match_credit_id", 
            "clear_credit_id_terms", 
            "supports_credit_query", 
            "get_credit_query", 
            "match_any_credit", 
            "clear_credit_terms", 
            "match_relationship_id", 
            "clear_relationship_id_terms", 
            "supports_relationship_query", 
            "get_relationship_query", 
            "match_any_relationship", 
            "clear_relationship_terms", 
            "match_relationship_peer_id", 
            "clear_relationship_peer_id_terms"
         ], 
         "methods": [
            {
               "name": "match_display_name", 
               "doc": {
                  "headline": "Adds a display name to match.", 
                  "body": "        Multiple display name matches can be added to perform a boolean\n        ``OR`` among them."
               }, 
               "arg_doc": "        arg:    display_name (string): display name to match\n        arg:    string_match_type (osid.type.Type): the string match\n                type\n        arg:    match (boolean): ``true`` for a positive match,\n                ``false`` for a negative match\n", 
               "return_doc": "", 
               "error_doc": "        raise:  InvalidArgument - ``display_name`` is not of\n                ``string_match_type``\n        raise:  NullArgument - ``display_name`` or ``string_match_type``\n                is ``null``\n        raise:  Unsupported -\n                ``supports_string_match_type(string_match_type)`` is\n                ``false``", 
               "sphinx_param_doc": "        :param display_name: display name to match\n        :type display_name: ``string``\n        :param string_match_type: the string match type\n        :type string_match_type: ``osid.type.Type``\n        :param match: ``true`` for a positive match, ``false`` for a negative match\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``InvalidArgument`` -- ``display_name`` is not of ``string_match_type``\n        :raise: ``NullArgument`` -- ``display_name`` or ``string_match_type`` is ``null``\n        :raise: ``Unsupported`` -- ``supports_string_match_type(string_match_type)`` is ``false``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "string", 
                     "var_name": "display_name", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "string_match_type", 
                     "array": false
                  }, 
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "string", 
                  "osid.type.Type", 
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {
                  "INVALID_ARGUMENT": "ConsumerContract", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }, 
            {
               "name": "match_any_display_name", 
               "doc": {
                  "headline": "Matches any object with a display name.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    match (boolean): ``true`` to match any display name,\n                ``false`` to match objects with no display name\n", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "        :param match: ``true`` to match any display name, ``false`` to match objects with no display name\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "clear_display_name_terms", 
               "doc": {
                  "headline": "Clears all display name terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "match_description", 
               "doc": {
                  "headline": "Adds a description name to match.", 
                  "body": "        Multiple description matches can be added to perform a boolean\n        ``OR`` among them."
               }, 
               "arg_doc": "        arg:    description (string): description to match\n        arg:    string_match_type (osid.type.Type): the string match\n                type\n        arg:    match (boolean): ``true`` for a positive match,\n                ``false`` for a negative match\n", 
               "return_doc": "", 
               "error_doc": "        raise:  InvalidArgument - ``description`` is not of\n                ``string_match_type``\n        raise:  NullArgument - ``description`` or ``string_match_type``\n                is ``null``\n        raise:  Unsupported -\n                ``supports_string_match_type(string_match_type)`` is\n                ``false``", 
               "sphinx_param_doc": "        :param description: description to match\n        :type description: ``string``\n        :param string_match_type: the string match type\n        :type string_match_type: ``osid.type.Type``\n        :param match: ``true`` for a positive match, ``false`` for a negative match\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``InvalidArgument`` -- ``description`` is not of ``string_match_type``\n        :raise: ``NullArgument`` -- ``description`` or ``string_match_type`` is ``null``\n        :raise: ``Unsupported`` -- ``supports_string_match_type(string_match_type)`` is ``false``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "string", 
                     "var_name": "description", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "string_match_type", 
                     "array": false
                  }, 
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "string", 
                  "osid.type.Type", 
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {
                  "INVALID_ARGUMENT": "ConsumerContract", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }, 
            {
               "name": "match_any_description", 
               "doc": {
                  "headline": "Matches a description that has any value.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    match (boolean): ``true`` to match any description,\n                ``false`` to match descriptions with no values\n", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "        :param match: ``true`` to match any description, ``false`` to match descriptions with no values\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "clear_description_terms", 
               "doc": {
                  "headline": "Clears all description terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "match_genus_type", 
               "doc": {
                  "headline": "Sets a ``Type`` for querying objects of a given genus.", 
                  "body": "        A genus type matches if the specified type is the same genus as\n        the object genus type."
               }, 
               "arg_doc": "        arg:    genus_type (osid.type.Type): the object genus type\n        arg:    match (boolean): ``true`` for a positive match,\n                ``false`` for a negative match\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``genus_type`` is ``null``", 
               "sphinx_param_doc": "        :param genus_type: the object genus type\n        :type genus_type: ``osid.type.Type``\n        :param match: ``true`` for a positive match, ``false`` for a negative match\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``genus_type`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "genus_type", 
                     "array": false
                  }, 
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type", 
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "match_any_genus_type", 
               "doc": {
                  "headline": "Matches an object that has any genus type.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    match (boolean): ``true`` to match any genus type,\n                ``false`` to match objects with no genus type\n", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "        :param match: ``true`` to match any genus type, ``false`` to match objects with no genus type\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "clear_genus_type_terms", 
               "doc": {
                  "headline": "Clears all genus type terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "match_parent_genus_type", 
               "doc": {
                  "headline": "Sets a ``Type`` for querying objects of a given genus.", 
                  "body": "        A genus type matches if the specified type is the same genus as\n        the object or if the specified type is an ancestor of the object\n        genus in a type hierarchy."
               }, 
               "arg_doc": "        arg:    genus_type (osid.type.Type): the object genus type\n        arg:    match (boolean): ``true`` for a positive match,\n                ``false`` for a negative match\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``genus_type`` is ``null``", 
               "sphinx_param_doc": "        :param genus_type: the object genus type\n        :type genus_type: ``osid.type.Type``\n        :param match: ``true`` for a positive match, ``false`` for a negative match\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``genus_type`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "genus_type", 
                     "array": false
                  }, 
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type", 
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "clear_parent_genus_type_terms", 
               "doc": {
                  "headline": "Clears all genus type terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "match_subject_id", 
               "doc": {
                  "headline": "Matches an object with a relationship to the given subject.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    subject_id (osid.id.Id): a subject ``Id``\n        arg:    match (boolean): ``true`` for a positive match,\n                ``false`` for a negative match\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``subject_id`` is ``null``", 
               "sphinx_param_doc": "        :param subject_id: a subject ``Id``\n        :type subject_id: ``osid.id.Id``\n        :param match: ``true`` for a positive match, ``false`` for a negative match\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``subject_id`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "subject_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "clear_subject_id_terms", 
               "doc": {
                  "headline": "Clears all subject ``Id`` terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "supports_subject_query", 
               "doc": {
                  "headline": "Tests if a ``SubjectQuery`` is available.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if a subject query is available,\n                ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if a subject query is available, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "get_subject_query", 
               "doc": {
                  "headline": "Gets the query for a subject.", 
                  "body": "        Multiple retrievals produce a nested ``OR`` term."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.ontology.SubjectQuery) - the subject query", 
               "error_doc": "        raise:  Unimplemented - ``supports_subject_query()`` is\n                ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the subject query\n        :rtype: ``osid.ontology.SubjectQuery``", 
               "sphinx_error_doc": "        :raise: ``Unimplemented`` -- ``supports_subject_query()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_subject_query()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.ontology.SubjectQuery", 
               "errors": {
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "match_any_subject", 
               "doc": {
                  "headline": "Matches an object that has any relationship to a ``Subject``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    match (boolean): ``true`` to match any subject,\n                ``false`` to match objects with no subjects\n", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "        :param match: ``true`` to match any subject, ``false`` to match objects with no subjects\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "clear_subject_terms", 
               "doc": {
                  "headline": "Clears all subject terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "supports_subject_relevancy_query", 
               "doc": {
                  "headline": "Tests if a ``RelevancyQuery`` is available to provide queries about the relationships to ``Subjects``.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if a relevancy entry query is\n                available, ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if a relevancy entry query is available, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "get_subject_relevancy_query", 
               "doc": {
                  "headline": "Gets the query for a subject relevancy.", 
                  "body": "        Multiple retrievals produce a nested ``OR`` term."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.ontology.RelevancyQuery) - the relevancy query", 
               "error_doc": "        raise:  Unimplemented - ``supports_subject_relevancy_query()``\n                is ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the relevancy query\n        :rtype: ``osid.ontology.RelevancyQuery``", 
               "sphinx_error_doc": "        :raise: ``Unimplemented`` -- ``supports_subject_relevancy_query()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_subject_relevancy_query()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.ontology.RelevancyQuery", 
               "errors": {
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "clear_subject_relevancy_terms", 
               "doc": {
                  "headline": "Clears all subject relevancy terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "match_state_id", 
               "doc": {
                  "headline": "Matches an object mapped to the given state.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    state_id (osid.id.Id): a state ``Id``\n        arg:    match (boolean): ``true`` for a positive match,\n                ``false`` for a negative match\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``state_id`` is ``null``", 
               "sphinx_param_doc": "        :param state_id: a state ``Id``\n        :type state_id: ``osid.id.Id``\n        :param match: ``true`` for a positive match, ``false`` for a negative match\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``state_id`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "state_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "clear_state_id_terms", 
               "doc": {
                  "headline": "Clears all state ``Id`` terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "supports_state_query", 
               "doc": {
                  "headline": "Tests if a ``StateQuery`` is available to provide queries of processed objects.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if a state query is available,\n                ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if a state query is available, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "get_state_query", 
               "doc": {
                  "headline": "Gets the query for a state.", 
                  "body": "        Multiple retrievals produce a nested ``OR`` term."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.process.StateQuery) - the journal entry query", 
               "error_doc": "        raise:  Unimplemented - ``supports_state_query()`` is ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the journal entry query\n        :rtype: ``osid.process.StateQuery``", 
               "sphinx_error_doc": "        :raise: ``Unimplemented`` -- ``supports_state_query()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_state_query()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.process.StateQuery", 
               "errors": {
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "match_any_state", 
               "doc": {
                  "headline": "Matches an object that has any mapping to a ``State`` in the given ``Process``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    match (boolean): ``true`` to match any state, ``false``\n                to match objects with no states\n", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "        :param match: ``true`` to match any state, ``false`` to match objects with no states\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "clear_state_terms", 
               "doc": {
                  "headline": "Clears all state terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "match_comment_id", 
               "doc": {
                  "headline": "Matches an object that has the given comment.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    comment_id (osid.id.Id): a comment ``Id``\n        arg:    match (boolean): ``true`` for a positive match,\n                ``false`` for a negative match\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``comment_id`` is ``null``", 
               "sphinx_param_doc": "        :param comment_id: a comment ``Id``\n        :type comment_id: ``osid.id.Id``\n        :param match: ``true`` for a positive match, ``false`` for a negative match\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``comment_id`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "comment_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "clear_comment_id_terms", 
               "doc": {
                  "headline": "Clears all comment ``Id`` terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "supports_comment_query", 
               "doc": {
                  "headline": "Tests if a ``CommentQuery`` is available.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if a comment query is available,\n                ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if a comment query is available, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "get_comment_query", 
               "doc": {
                  "headline": "Gets the query for a comment.", 
                  "body": "        Multiple retrievals produce a nested ``OR`` term."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.commenting.CommentQuery) - the comment query", 
               "error_doc": "        raise:  Unimplemented - ``supports_comment_query()`` is\n                ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the comment query\n        :rtype: ``osid.commenting.CommentQuery``", 
               "sphinx_error_doc": "        :raise: ``Unimplemented`` -- ``supports_comment_query()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_comment_query()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.commenting.CommentQuery", 
               "errors": {
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "match_any_comment", 
               "doc": {
                  "headline": "Matches an object that has any ``Comment`` in the given ``Book``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    match (boolean): ``true`` to match any comment,\n                ``false`` to match objects with no comments\n", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "        :param match: ``true`` to match any comment, ``false`` to match objects with no comments\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "clear_comment_terms", 
               "doc": {
                  "headline": "Clears all comment terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "match_journal_entry_id", 
               "doc": {
                  "headline": "Matches an object that has the given journal entry.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    journal_entry_id (osid.id.Id): a journal entry ``Id``\n        arg:    match (boolean): ``true`` for a positive match,\n                ``false`` for a negative match\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``journal_entry_id`` is ``null``", 
               "sphinx_param_doc": "        :param journal_entry_id: a journal entry ``Id``\n        :type journal_entry_id: ``osid.id.Id``\n        :param match: ``true`` for a positive match, ``false`` for a negative match\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``journal_entry_id`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "journal_entry_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "clear_journal_entry_id_terms", 
               "doc": {
                  "headline": "Clears all journal entry ``Id`` terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "supports_journal_entry_query", 
               "doc": {
                  "headline": "Tests if a ``JournalEntry`` is available to provide queries of journaled ``OsidObjects``.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if a journal entry query is\n                available, ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if a journal entry query is available, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "get_journal_entry_query", 
               "doc": {
                  "headline": "Gets the query for a journal entry.", 
                  "body": "        Multiple retrievals produce a nested ``OR`` term."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.journaling.JournalEntryQuery) - the journal entry\n                query", 
               "error_doc": "        raise:  Unimplemented - ``supports_journal_entry_query()`` is\n                ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the journal entry query\n        :rtype: ``osid.journaling.JournalEntryQuery``", 
               "sphinx_error_doc": "        :raise: ``Unimplemented`` -- ``supports_journal_entry_query()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_journal_entry_query()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.journaling.JournalEntryQuery", 
               "errors": {
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "match_any_journal_entry", 
               "doc": {
                  "headline": "Matches an object that has any ``JournalEntry`` in the given ``Journal``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    match (boolean): ``true`` to match any journal entry,\n                ``false`` to match objects with no journal entries\n", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "        :param match: ``true`` to match any journal entry, ``false`` to match objects with no journal entries\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "clear_journal_entry_terms", 
               "doc": {
                  "headline": "Clears all journal entry terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "supports_statistic_query", 
               "doc": {
                  "headline": "Tests if a ``StatisticQuery`` is available to provide statistical queries.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if a statistic query is available,\n                ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if a statistic query is available, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "get_statistic_query", 
               "doc": {
                  "headline": "Gets the query for a statistic.", 
                  "body": "        Multiple retrievals produce a nested ``OR`` term."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.metering.StatisticQuery) - the statistic query", 
               "error_doc": "        raise:  Unimplemented - ``supports_statistic_query()`` is\n                ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the statistic query\n        :rtype: ``osid.metering.StatisticQuery``", 
               "sphinx_error_doc": "        :raise: ``Unimplemented`` -- ``supports_statistic_query()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_statistic_query()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.metering.StatisticQuery", 
               "errors": {
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "match_any_statistic", 
               "doc": {
                  "headline": "Matches an object that has any ``Statistic``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    match (boolean): ``true`` to match any statistic,\n                ``false`` to match objects with no statistics\n", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "        :param match: ``true`` to match any statistic, ``false`` to match objects with no statistics\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "clear_statistic_terms", 
               "doc": {
                  "headline": "Clears all statistic terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "match_credit_id", 
               "doc": {
                  "headline": "Matches an object that has the given credit.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    credit_id (osid.id.Id): a credit ``Id``\n        arg:    match (boolean): ``true`` for a positive match,\n                ``false`` for a negative match\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``credit_id`` is ``null``", 
               "sphinx_param_doc": "        :param credit_id: a credit ``Id``\n        :type credit_id: ``osid.id.Id``\n        :param match: ``true`` for a positive match, ``false`` for a negative match\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``credit_id`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "credit_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "clear_credit_id_terms", 
               "doc": {
                  "headline": "Clears all credit ``Id`` terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "supports_credit_query", 
               "doc": {
                  "headline": "Tests if a ``CreditQuery`` is available to provide queries of related acknowledgements.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if a credit query is available,\n                ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if a credit query is available, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "get_credit_query", 
               "doc": {
                  "headline": "Gets the query for an ackowledgement credit.", 
                  "body": "        Multiple retrievals produce a nested ``OR`` term."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.acknowledgement.CreditQuery) - the credit query", 
               "error_doc": "        raise:  Unimplemented - ``supports_credit_query()`` is ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the credit query\n        :rtype: ``osid.acknowledgement.CreditQuery``", 
               "sphinx_error_doc": "        :raise: ``Unimplemented`` -- ``supports_credit_query()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_credit_query()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.acknowledgement.CreditQuery", 
               "errors": {
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "match_any_credit", 
               "doc": {
                  "headline": "Matches an object that has any ``Credit``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    match (boolean): ``true`` to match any credit, ``false``\n                to match objects with no credits\n", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "        :param match: ``true`` to match any credit, ``false`` to match objects with no credits\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "clear_credit_terms", 
               "doc": {
                  "headline": "Clears all credit terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "match_relationship_id", 
               "doc": {
                  "headline": "Matches an object that has the given relationship.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    relationship_id (osid.id.Id): a relationship ``Id``\n        arg:    match (boolean): ``true`` for a positive match,\n                ``false`` for a negative match\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``relationship_id`` is ``null``", 
               "sphinx_param_doc": "        :param relationship_id: a relationship ``Id``\n        :type relationship_id: ``osid.id.Id``\n        :param match: ``true`` for a positive match, ``false`` for a negative match\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``relationship_id`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "relationship_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "clear_relationship_id_terms", 
               "doc": {
                  "headline": "Clears all relationship ``Id`` terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "supports_relationship_query", 
               "doc": {
                  "headline": "Tests if a ``RelationshipQuery`` is available.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if a relationship query is\n                available, ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if a relationship query is available, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "get_relationship_query", 
               "doc": {
                  "headline": "Gets the query for relationship.", 
                  "body": "        Multiple retrievals produce a nested ``OR`` term."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.relationship.RelationshipQuery) - the relationship\n                query", 
               "error_doc": "        raise:  Unimplemented - ``supports_relationship_query()`` is\n                ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the relationship query\n        :rtype: ``osid.relationship.RelationshipQuery``", 
               "sphinx_error_doc": "        :raise: ``Unimplemented`` -- ``supports_relationship_query()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_relationship_query()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.relationship.RelationshipQuery", 
               "errors": {
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "match_any_relationship", 
               "doc": {
                  "headline": "Matches an object that has any ``Relationship``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    match (boolean): ``true`` to match any relationship,\n                ``false`` to match objects with no relationships\n", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "        :param match: ``true`` to match any relationship, ``false`` to match objects with no relationships\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "clear_relationship_terms", 
               "doc": {
                  "headline": "Clears all relationship terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "match_relationship_peer_id", 
               "doc": {
                  "headline": "Matches an object that has a relationship to the given peer ``Id``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    peer_id (osid.id.Id): a relationship peer ``Id``\n        arg:    match (boolean): ``true`` for a positive match,\n                ``false`` for a negative match\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``peer_id`` is ``null``", 
               "sphinx_param_doc": "        :param peer_id: a relationship peer ``Id``\n        :type peer_id: ``osid.id.Id``\n        :param match: ``true`` for a positive match, ``false`` for a negative match\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``peer_id`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "peer_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "clear_relationship_peer_id_terms", 
               "doc": {
                  "headline": "Clears all relationship ``Id`` terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }
         ]
      }, 
      {
         "fullname": "osid.OsidRelationshipQuery", 
         "shortname": "OsidRelationshipQuery", 
         "category": "queries", 
         "doc": {
            "headline": "This is the query interface for searching relationships.", 
            "body": "    Each method specifies an ``AND`` term while multiple invocations of\n    the same method produce a nested ``OR``."
         }, 
         "inherit_fullnames": [
            "osid.OsidObjectQuery", 
            "osid.OsidTemporalQuery"
         ], 
         "inherit_shortnames": [
            "OsidObjectQuery", 
            "OsidTemporalQuery"
         ], 
         "inherit_pkg_names": [
            "osid", 
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidObjectQuery"
            }, 
            {
               "pkg_name": "osid", 
               "name": "OsidTemporalQuery"
            }
         ], 
         "method_names": [
            "match_end_reason_id", 
            "clear_end_reason_id_terms", 
            "supports_end_reason_query", 
            "get_end_reason_query", 
            "match_any_end_reason", 
            "clear_end_reason_terms"
         ], 
         "methods": [
            {
               "name": "match_end_reason_id", 
               "doc": {
                  "headline": "Match the ``Id`` of the end reason state.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    state_id (osid.id.Id): ``Id`` to match\n        arg:    match (boolean): ``true`` if for a positive match,\n                ``false`` for a negative match\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``rule_id`` is ``null``", 
               "sphinx_param_doc": "        :param state_id: ``Id`` to match\n        :type state_id: ``osid.id.Id``\n        :param match: ``true`` if for a positive match, ``false`` for a negative match\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``rule_id`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "state_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "clear_end_reason_id_terms", 
               "doc": {
                  "headline": "Clears all state ``Id`` terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "supports_end_reason_query", 
               "doc": {
                  "headline": "Tests if a ``StateQuery`` for the end reason is available.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if a end reason query is available,\n                ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if a end reason query is available, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "get_end_reason_query", 
               "doc": {
                  "headline": "Gets the query for the end reason state.", 
                  "body": "        Each retrieval performs a boolean ``OR``."
               }, 
               "arg_doc": "        arg:    match (boolean): ``true`` if for a positive match,\n                ``false`` for a negative match\n", 
               "return_doc": "        return: (osid.process.StateQuery) - the state query", 
               "error_doc": "        raise:  Unimplemented - ``supports_end_reason_query()`` is\n                ``false``", 
               "sphinx_param_doc": "        :param match: ``true`` if for a positive match, ``false`` for a negative match\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "        :return: the state query\n        :rtype: ``osid.process.StateQuery``", 
               "sphinx_error_doc": "        :raise: ``Unimplemented`` -- ``supports_end_reason_query()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_end_reason_query()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "boolean"
               ], 
               "return_type": "osid.process.StateQuery", 
               "errors": {
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "match_any_end_reason", 
               "doc": {
                  "headline": "Match any end reason state.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    match (boolean): ``true`` to match any state, ``false``\n                to match no state\n", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "        :param match: ``true`` to match any state, ``false`` to match no state\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "clear_end_reason_terms", 
               "doc": {
                  "headline": "Clears all end reason state terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }
         ]
      }, 
      {
         "fullname": "osid.OsidCatalogQuery", 
         "shortname": "OsidCatalogQuery", 
         "category": "queries", 
         "doc": {
            "headline": "The ``OsidCatalogQuery`` is used to assemble search queries for catalogs.", 
            "body": ""
         }, 
         "inherit_fullnames": [
            "osid.OsidObjectQuery", 
            "osid.OsidSourceableQuery", 
            "osid.OsidFederateableQuery"
         ], 
         "inherit_shortnames": [
            "OsidObjectQuery", 
            "OsidSourceableQuery", 
            "OsidFederateableQuery"
         ], 
         "inherit_pkg_names": [
            "osid", 
            "osid", 
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidObjectQuery"
            }, 
            {
               "pkg_name": "osid", 
               "name": "OsidSourceableQuery"
            }, 
            {
               "pkg_name": "osid", 
               "name": "OsidFederateableQuery"
            }
         ], 
         "method_names": [], 
         "methods": []
      }, 
      {
         "fullname": "osid.OsidRuleQuery", 
         "shortname": "OsidRuleQuery", 
         "category": "queries", 
         "doc": {
            "headline": "This is the query interface for searching rules.", 
            "body": "    Each method specifies an ``AND`` term while multiple invocations of\n    the same method produce a nested ``OR``."
         }, 
         "inherit_fullnames": [
            "osid.OsidObjectQuery", 
            "osid.OsidOperableQuery"
         ], 
         "inherit_shortnames": [
            "OsidObjectQuery", 
            "OsidOperableQuery"
         ], 
         "inherit_pkg_names": [
            "osid", 
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidObjectQuery"
            }, 
            {
               "pkg_name": "osid", 
               "name": "OsidOperableQuery"
            }
         ], 
         "method_names": [
            "match_rule_id", 
            "clear_rule_id_terms", 
            "supports_rule_query", 
            "get_rule_query", 
            "match_any_rule", 
            "clear_rule_terms"
         ], 
         "methods": [
            {
               "name": "match_rule_id", 
               "doc": {
                  "headline": "Match the ``Id`` of the rule.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    rule_id (osid.id.Id): ``Id`` to match\n        arg:    match (boolean): ``true`` if for a positive match,\n                ``false`` for a negative match\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``rule_id`` is ``null``", 
               "sphinx_param_doc": "        :param rule_id: ``Id`` to match\n        :type rule_id: ``osid.id.Id``\n        :param match: ``true`` if for a positive match, ``false`` for a negative match\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``rule_id`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "rule_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "clear_rule_id_terms", 
               "doc": {
                  "headline": "Clears all rule ``Id`` terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "supports_rule_query", 
               "doc": {
                  "headline": "Tests if a ``RuleQuery`` for the rule is available.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if a rule query is available,\n                ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if a rule query is available, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "get_rule_query", 
               "doc": {
                  "headline": "Gets the query for the rule.", 
                  "body": "        Each retrieval performs a boolean ``OR``."
               }, 
               "arg_doc": "        arg:    match (boolean): ``true`` if for a positive match,\n                ``false`` for a negative match\n", 
               "return_doc": "        return: (osid.rules.RuleQuery) - the rule query", 
               "error_doc": "        raise:  Unimplemented - ``supports_rule_query()`` is ``false``", 
               "sphinx_param_doc": "        :param match: ``true`` if for a positive match, ``false`` for a negative match\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "        :return: the rule query\n        :rtype: ``osid.rules.RuleQuery``", 
               "sphinx_error_doc": "        :raise: ``Unimplemented`` -- ``supports_rule_query()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_rule_query()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "boolean"
               ], 
               "return_type": "osid.rules.RuleQuery", 
               "errors": {
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "match_any_rule", 
               "doc": {
                  "headline": "Match any associated rule.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    match (boolean): ``true`` to match any rule, ``false``\n                to match no rules\n", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "        :param match: ``true`` to match any rule, ``false`` to match no rules\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "clear_rule_terms", 
               "doc": {
                  "headline": "Clears all rule terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }
         ]
      }, 
      {
         "fullname": "osid.OsidEnablerQuery", 
         "shortname": "OsidEnablerQuery", 
         "category": "queries", 
         "doc": {
            "headline": "This is the query interface for searching enablers.", 
            "body": "    Each method specifies an ``AND`` term while multiple invocations of\n    the same method produce a nested ``OR``."
         }, 
         "inherit_fullnames": [
            "osid.OsidRuleQuery", 
            "osid.OsidTemporalQuery"
         ], 
         "inherit_shortnames": [
            "OsidRuleQuery", 
            "OsidTemporalQuery"
         ], 
         "inherit_pkg_names": [
            "osid", 
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidRuleQuery"
            }, 
            {
               "pkg_name": "osid", 
               "name": "OsidTemporalQuery"
            }
         ], 
         "method_names": [
            "match_schedule_id", 
            "clear_schedule_id_terms", 
            "supports_schedule_query", 
            "get_schedule_query", 
            "match_any_schedule", 
            "clear_schedule_terms", 
            "match_event_id", 
            "clear_event_id_terms", 
            "supports_event_query", 
            "get_event_query", 
            "match_any_event", 
            "clear_event_terms", 
            "match_cyclic_event_id", 
            "clear_cyclic_event_id_terms", 
            "supports_cyclic_event_query", 
            "get_cyclic_event_query", 
            "match_any_cyclic_event", 
            "clear_cyclic_event_terms", 
            "match_demographic_id", 
            "clear_demographic_id_terms", 
            "supports_demographic_query", 
            "get_demographic_query", 
            "match_any_demographic", 
            "clear_demographic_terms"
         ], 
         "methods": [
            {
               "name": "match_schedule_id", 
               "doc": {
                  "headline": "Match the ``Id`` of an associated schedule.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    schedule_id (osid.id.Id): ``Id`` to match\n        arg:    match (boolean): ``true`` if for a positive match,\n                ``false`` for a negative match\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``schedule_id`` is ``null``", 
               "sphinx_param_doc": "        :param schedule_id: ``Id`` to match\n        :type schedule_id: ``osid.id.Id``\n        :param match: ``true`` if for a positive match, ``false`` for a negative match\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``schedule_id`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "schedule_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "clear_schedule_id_terms", 
               "doc": {
                  "headline": "Clears all schedule ``Id`` terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "supports_schedule_query", 
               "doc": {
                  "headline": "Tests if a ``ScheduleQuery`` for the rule is available.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if a schedule query is available,\n                ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if a schedule query is available, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "get_schedule_query", 
               "doc": {
                  "headline": "Gets the query for the schedule.", 
                  "body": "        Each retrieval performs a boolean ``OR``."
               }, 
               "arg_doc": "        arg:    match (boolean): ``true`` if for a positive match,\n                ``false`` for a negative match\n", 
               "return_doc": "        return: (osid.calendaring.ScheduleQuery) - the schedule query", 
               "error_doc": "        raise:  Unimplemented - ``supports_schedule_query()`` is\n                ``false``", 
               "sphinx_param_doc": "        :param match: ``true`` if for a positive match, ``false`` for a negative match\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "        :return: the schedule query\n        :rtype: ``osid.calendaring.ScheduleQuery``", 
               "sphinx_error_doc": "        :raise: ``Unimplemented`` -- ``supports_schedule_query()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_schedule_query()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "boolean"
               ], 
               "return_type": "osid.calendaring.ScheduleQuery", 
               "errors": {
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "match_any_schedule", 
               "doc": {
                  "headline": "Match any associated schedule.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    match (boolean): ``true`` to match any schedule,\n                ``false`` to match no schedules\n", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "        :param match: ``true`` to match any schedule, ``false`` to match no schedules\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "clear_schedule_terms", 
               "doc": {
                  "headline": "Clears all schedule terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "match_event_id", 
               "doc": {
                  "headline": "Match the ``Id`` of an associated event.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    event_id (osid.id.Id): ``Id`` to match\n        arg:    match (boolean): ``true`` if for a positive match,\n                ``false`` for a negative match\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``event_id`` is ``null``", 
               "sphinx_param_doc": "        :param event_id: ``Id`` to match\n        :type event_id: ``osid.id.Id``\n        :param match: ``true`` if for a positive match, ``false`` for a negative match\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``event_id`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "event_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "clear_event_id_terms", 
               "doc": {
                  "headline": "Clears all event ``Id`` terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "supports_event_query", 
               "doc": {
                  "headline": "Tests if a ``EventQuery`` for the rule is available.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if an event query is available,\n                ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if an event query is available, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "get_event_query", 
               "doc": {
                  "headline": "Gets the query for the event.", 
                  "body": "        Each retrieval performs a boolean ``OR``."
               }, 
               "arg_doc": "        arg:    match (boolean): ``true`` if for a positive match,\n                ``false`` for a negative match\n", 
               "return_doc": "        return: (osid.calendaring.EventQuery) - the event query", 
               "error_doc": "        raise:  Unimplemented - ``supports_event_query()`` is ``false``", 
               "sphinx_param_doc": "        :param match: ``true`` if for a positive match, ``false`` for a negative match\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "        :return: the event query\n        :rtype: ``osid.calendaring.EventQuery``", 
               "sphinx_error_doc": "        :raise: ``Unimplemented`` -- ``supports_event_query()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_event_query()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "boolean"
               ], 
               "return_type": "osid.calendaring.EventQuery", 
               "errors": {
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "match_any_event", 
               "doc": {
                  "headline": "Match any associated event.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    match (boolean): ``true`` to match any event, ``false``\n                to match no events\n", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "        :param match: ``true`` to match any event, ``false`` to match no events\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "clear_event_terms", 
               "doc": {
                  "headline": "Clears all recurirng event terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "match_cyclic_event_id", 
               "doc": {
                  "headline": "Sets the cyclic event ``Id`` for this query.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    cyclic_event_id (osid.id.Id): the cyclic event ``Id``\n        arg:    match (boolean): ``true`` for a positive match,\n                ``false`` for a negative match\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``cyclic_event_id`` is ``null``", 
               "sphinx_param_doc": "        :param cyclic_event_id: the cyclic event ``Id``\n        :type cyclic_event_id: ``osid.id.Id``\n        :param match: ``true`` for a positive match, ``false`` for a negative match\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``cyclic_event_id`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "cyclic_event_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "clear_cyclic_event_id_terms", 
               "doc": {
                  "headline": "Clears the cyclic event ``Id`` query terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "supports_cyclic_event_query", 
               "doc": {
                  "headline": "Tests if a ``CyclicEventQuery`` is available.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if a cyclic event query is\n                available, ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if a cyclic event query is available, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "get_cyclic_event_query", 
               "doc": {
                  "headline": "Gets the query for a cyclic event.", 
                  "body": "        Multiple retrievals produce a nested ``OR`` term."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.cycle.CyclicEventQuery) - the cyclic\n                event query", 
               "error_doc": "        raise:  Unimplemented - ``supports_cyclic_event_query()`` is\n                ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the cyclic event query\n        :rtype: ``osid.calendaring.cycle.CyclicEventQuery``", 
               "sphinx_error_doc": "        :raise: ``Unimplemented`` -- ``supports_cyclic_event_query()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_cyclic_event_query()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.cycle.CyclicEventQuery", 
               "errors": {
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "match_any_cyclic_event", 
               "doc": {
                  "headline": "Matches any enabler with a cyclic event.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    match (boolean): ``true`` to match any enablers with a\n                cyclic event, ``false`` to match enablers with no cyclic\n                events\n", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "        :param match: ``true`` to match any enablers with a cyclic event, ``false`` to match enablers with no cyclic events\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "clear_cyclic_event_terms", 
               "doc": {
                  "headline": "Clears the cyclic event query terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "match_demographic_id", 
               "doc": {
                  "headline": "Match the ``Id`` of the demographic resource.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    resource_id (osid.id.Id): ``Id`` to match\n        arg:    match (boolean): ``true`` if for a positive match,\n                ``false`` for a negative match\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``resource_id`` is ``null``", 
               "sphinx_param_doc": "        :param resource_id: ``Id`` to match\n        :type resource_id: ``osid.id.Id``\n        :param match: ``true`` if for a positive match, ``false`` for a negative match\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``resource_id`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "resource_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "clear_demographic_id_terms", 
               "doc": {
                  "headline": "Clears all resource ``Id`` terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "supports_demographic_query", 
               "doc": {
                  "headline": "Tests if a ``ResourceQuery`` for the demographic is available.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if a resource query is available,\n                ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if a resource query is available, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "get_demographic_query", 
               "doc": {
                  "headline": "Gets the query for the resource.", 
                  "body": "        Each retrieval performs a boolean ``OR``."
               }, 
               "arg_doc": "        arg:    match (boolean): ``true`` if for a positive match,\n                ``false`` for a negative match\n", 
               "return_doc": "        return: (osid.resource.ResourceQuery) - the resource query", 
               "error_doc": "        raise:  Unimplemented - ``supports_resource_query()`` is\n                ``false``", 
               "sphinx_param_doc": "        :param match: ``true`` if for a positive match, ``false`` for a negative match\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "        :return: the resource query\n        :rtype: ``osid.resource.ResourceQuery``", 
               "sphinx_error_doc": "        :raise: ``Unimplemented`` -- ``supports_resource_query()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_resource_query()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "boolean"
               ], 
               "return_type": "osid.resource.ResourceQuery", 
               "errors": {
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "match_any_demographic", 
               "doc": {
                  "headline": "Match any associated resource.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    match (boolean): ``true`` to match any demographic,\n                ``false`` to match no rules\n", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "        :param match: ``true`` to match any demographic, ``false`` to match no rules\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "clear_demographic_terms", 
               "doc": {
                  "headline": "Clears all demographic terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }
         ]
      }, 
      {
         "fullname": "osid.OsidConstrainerQuery", 
         "shortname": "OsidConstrainerQuery", 
         "category": "queries", 
         "doc": {
            "headline": "This is the query interface for searching constrainers.", 
            "body": "    Each method specifies an ``AND`` term while multiple invocations of\n    the same method produce a nested ``OR``."
         }, 
         "inherit_fullnames": [
            "osid.OsidRuleQuery"
         ], 
         "inherit_shortnames": [
            "OsidRuleQuery"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidRuleQuery"
            }
         ], 
         "method_names": [], 
         "methods": []
      }, 
      {
         "fullname": "osid.OsidProcessorQuery", 
         "shortname": "OsidProcessorQuery", 
         "category": "queries", 
         "doc": {
            "headline": "This is the query interface for searching processors.", 
            "body": "    Each method specifies an ``AND`` term while multiple invocations of\n    the same method produce a nested ``OR``."
         }, 
         "inherit_fullnames": [
            "osid.OsidRuleQuery"
         ], 
         "inherit_shortnames": [
            "OsidRuleQuery"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidRuleQuery"
            }
         ], 
         "method_names": [], 
         "methods": []
      }, 
      {
         "fullname": "osid.OsidGovernatorQuery", 
         "shortname": "OsidGovernatorQuery", 
         "category": "queries", 
         "doc": {
            "headline": "This is the query interface for searching governers.", 
            "body": "    Each method specifies an ``AND`` term while multiple invocations of\n    the same method produce a nested ``OR``."
         }, 
         "inherit_fullnames": [
            "osid.OsidObjectQuery", 
            "osid.OsidOperableQuery", 
            "osid.OsidSourceableQuery"
         ], 
         "inherit_shortnames": [
            "OsidObjectQuery", 
            "OsidOperableQuery", 
            "OsidSourceableQuery"
         ], 
         "inherit_pkg_names": [
            "osid", 
            "osid", 
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidObjectQuery"
            }, 
            {
               "pkg_name": "osid", 
               "name": "OsidOperableQuery"
            }, 
            {
               "pkg_name": "osid", 
               "name": "OsidSourceableQuery"
            }
         ], 
         "method_names": [], 
         "methods": []
      }, 
      {
         "fullname": "osid.OsidCompendiumQuery", 
         "shortname": "OsidCompendiumQuery", 
         "category": "queries", 
         "doc": {
            "headline": "This is the query interface for searching reports.", 
            "body": "    Each method specifies an ``AND`` term while multiple invocations of\n    the same method produce a nested ``OR``."
         }, 
         "inherit_fullnames": [
            "osid.OsidObjectQuery", 
            "osid.OsidSubjugateableQuery"
         ], 
         "inherit_shortnames": [
            "OsidObjectQuery", 
            "OsidSubjugateableQuery"
         ], 
         "inherit_pkg_names": [
            "osid", 
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidObjectQuery"
            }, 
            {
               "pkg_name": "osid", 
               "name": "OsidSubjugateableQuery"
            }
         ], 
         "method_names": [
            "match_start_date", 
            "match_any_start_date", 
            "clear_start_date_terms", 
            "match_end_date", 
            "match_any_end_date", 
            "clear_end_date_terms", 
            "match_interpolated", 
            "clear_interpolated_terms", 
            "match_extrapolated", 
            "clear_extrapolated_terms"
         ], 
         "methods": [
            {
               "name": "match_start_date", 
               "doc": {
                  "headline": "Matches reports whose start date falls in between the given dates inclusive.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    start (osid.calendaring.DateTime): start of date range\n        arg:    end (osid.calendaring.DateTime): end of date range\n        arg:    match (boolean): ``true`` if a positive match, ``false``\n                for a negative match\n", 
               "return_doc": "", 
               "error_doc": "        raise:  InvalidArgument - ``start`` is less than ``end``\n        raise:  NullArgument - ``start`` or ``end`` is ``null``", 
               "sphinx_param_doc": "        :param start: start of date range\n        :type start: ``osid.calendaring.DateTime``\n        :param end: end of date range\n        :type end: ``osid.calendaring.DateTime``\n        :param match: ``true`` if a positive match, ``false`` for a negative match\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``InvalidArgument`` -- ``start`` is less than ``end``\n        :raise: ``NullArgument`` -- ``start`` or ``end`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.calendaring.DateTime", 
                     "var_name": "start", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.calendaring.DateTime", 
                     "var_name": "end", 
                     "array": false
                  }, 
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.calendaring.DateTime", 
                  "osid.calendaring.DateTime", 
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {
                  "INVALID_ARGUMENT": "ConsumerContract", 
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "match_any_start_date", 
               "doc": {
                  "headline": "Matches reports with any start date set.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    match (boolean): ``true`` to match any start date,\n                ``false`` to match no start date\n", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "        :param match: ``true`` to match any start date, ``false`` to match no start date\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "clear_start_date_terms", 
               "doc": {
                  "headline": "Clears the start date query terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "match_end_date", 
               "doc": {
                  "headline": "Matches reports whose effective end date falls in between the given dates inclusive.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    start (osid.calendaring.DateTime): start of date range\n        arg:    end (osid.calendaring.DateTime): end of date range\n        arg:    match (boolean): ``true`` if a positive match, ``false``\n                for negative match\n", 
               "return_doc": "", 
               "error_doc": "        raise:  InvalidArgument - ``start`` is less than ``end``\n        raise:  NullArgument - ``start`` or ``end`` is ``null``", 
               "sphinx_param_doc": "        :param start: start of date range\n        :type start: ``osid.calendaring.DateTime``\n        :param end: end of date range\n        :type end: ``osid.calendaring.DateTime``\n        :param match: ``true`` if a positive match, ``false`` for negative match\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``InvalidArgument`` -- ``start`` is less than ``end``\n        :raise: ``NullArgument`` -- ``start`` or ``end`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.calendaring.DateTime", 
                     "var_name": "start", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.calendaring.DateTime", 
                     "var_name": "end", 
                     "array": false
                  }, 
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.calendaring.DateTime", 
                  "osid.calendaring.DateTime", 
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {
                  "INVALID_ARGUMENT": "ConsumerContract", 
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "match_any_end_date", 
               "doc": {
                  "headline": "Matches reports with any end date set.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    match (boolean): ``true`` to match any end date,\n                ``false`` to match no start date\n", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "        :param match: ``true`` to match any end date, ``false`` to match no start date\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "clear_end_date_terms", 
               "doc": {
                  "headline": "Clears the end date query terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "match_interpolated", 
               "doc": {
                  "headline": "Match reports that are interpolated.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    match (boolean): ``true`` to match any interpolated\n                reports, ``false`` to match non- interpolated reports\n", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "        :param match: ``true`` to match any interpolated reports, ``false`` to match non-interpolated reports\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "clear_interpolated_terms", 
               "doc": {
                  "headline": "Clears the interpolated query terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "match_extrapolated", 
               "doc": {
                  "headline": "Match reports that are extrapolated.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    match (boolean): ``true`` to match any extrapolated\n                reports, ``false`` to match non- extrapolated reports\n", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "        :param match: ``true`` to match any extrapolated reports, ``false`` to match non-extrapolated reports\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "clear_extrapolated_terms", 
               "doc": {
                  "headline": "Clears the extrapolated query terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }
         ]
      }, 
      {
         "fullname": "osid.OsidCapsuleQuery", 
         "shortname": "OsidCapsuleQuery", 
         "category": "queries", 
         "doc": {
            "headline": "This is the query interface for searching capsulating interfaces.", 
            "body": "    Each method specifies an ``AND`` term while multiple invocations of\n    the same method produce a nested ``OR``."
         }, 
         "inherit_fullnames": [
            "osid.OsidQuery"
         ], 
         "inherit_shortnames": [
            "OsidQuery"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidQuery"
            }
         ], 
         "method_names": [], 
         "methods": []
      }, 
      {
         "fullname": "osid.OsidQueryInspector", 
         "shortname": "OsidQueryInspector", 
         "category": "query_inspectors", 
         "doc": {
            "headline": "The query inspectors provide a means of accessing the match terms of a query.", 
            "body": "    These interfaces are used to examine the actual query terms used in\n    a search or that may be used to create a smart catalog. Query\n    inspectors may be converted to an ``OsidQuery`` for reuse or\n    modification in the search sessions."
         }, 
         "inherit_fullnames": [], 
         "inherit_shortnames": [], 
         "inherit_pkg_names": [], 
         "inheritance": [], 
         "method_names": [
            "get_keyword_terms", 
            "get_any_terms"
         ], 
         "methods": [
            {
               "name": "get_keyword_terms", 
               "doc": {
                  "headline": "Gets the keyword query terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.search.terms.StringTerm) - the keyword string\n                terms", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the keyword string terms\n        :rtype: ``osid.search.terms.StringTerm``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.search.terms.StringTerm", 
               "errors": {}
            }, 
            {
               "name": "get_any_terms", 
               "doc": {
                  "headline": "Gets the any query terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.search.terms.BooleanTerm) - the any terms", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the any terms\n        :rtype: ``osid.search.terms.BooleanTerm``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.search.terms.BooleanTerm", 
               "errors": {}
            }
         ]
      }, 
      {
         "fullname": "osid.OsidIdentifiableQueryInspector", 
         "shortname": "OsidIdentifiableQueryInspector", 
         "category": "query_inspectors", 
         "doc": {
            "headline": "The query inspectors provide a means of accessing the match terms of a query.", 
            "body": "    These interfaces are used to examine the actual query terms used in\n    a search or that may be used to create a smart catalog. Query\n    inspectors may be converted to an ``OsidQuery`` for reuse or\n    modification in the search sessions."
         }, 
         "inherit_fullnames": [
            "osid.OsidQueryInspector"
         ], 
         "inherit_shortnames": [
            "OsidQueryInspector"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidQueryInspector"
            }
         ], 
         "method_names": [
            "get_id_terms"
         ], 
         "methods": [
            {
               "name": "get_id_terms", 
               "doc": {
                  "headline": "Gets the ``Id`` query terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.search.terms.IdTerm) - the ``Id`` terms", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the ``Id`` terms\n        :rtype: ``osid.search.terms.IdTerm``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.search.terms.IdTerm", 
               "errors": {}
            }
         ]
      }, 
      {
         "fullname": "osid.OsidExtensibleQueryInspector", 
         "shortname": "OsidExtensibleQueryInspector", 
         "category": "query_inspectors", 
         "doc": {
            "headline": "The query inspectors provide a means of accessing the match terms of a query.", 
            "body": "    These interfaces are used to examine the actual query terms used in\n    a search or that may be used to create a smart catalog. Query\n    inspectors may be converted to an ``OsidQuery`` for reuse or\n    modification in the search sessions."
         }, 
         "inherit_fullnames": [
            "osid.OsidQueryInspector", 
            "osid.Extensible"
         ], 
         "inherit_shortnames": [
            "OsidQueryInspector", 
            "Extensible"
         ], 
         "inherit_pkg_names": [
            "osid", 
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidQueryInspector"
            }, 
            {
               "pkg_name": "osid", 
               "name": "Extensible"
            }
         ], 
         "method_names": [
            "get_record_type_terms"
         ], 
         "methods": [
            {
               "name": "get_record_type_terms", 
               "doc": {
                  "headline": "Gets the record type query terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.search.terms.TypeTerm) - the record type terms", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the record type terms\n        :rtype: ``osid.search.terms.TypeTerm``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.search.terms.TypeTerm", 
               "errors": {}
            }
         ]
      }, 
      {
         "fullname": "osid.OsidBrowsableQueryInspector", 
         "shortname": "OsidBrowsableQueryInspector", 
         "category": "query_inspectors", 
         "doc": {
            "headline": "The query inspectors provide a means of accessing the match terms of a query.", 
            "body": "    These interfaces are used to examine the actual query terms used in\n    a search or that may be used to create a smart catalog. Query\n    inspectors may be converted to an ``OsidQuery`` for reuse or\n    modification in the search sessions."
         }, 
         "inherit_fullnames": [
            "osid.OsidQueryInspector"
         ], 
         "inherit_shortnames": [
            "OsidQueryInspector"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidQueryInspector"
            }
         ], 
         "method_names": [], 
         "methods": []
      }, 
      {
         "fullname": "osid.OsidTemporalQueryInspector", 
         "shortname": "OsidTemporalQueryInspector", 
         "category": "query_inspectors", 
         "doc": {
            "headline": "The query inspectors provide a means of accessing the match terms of a query.", 
            "body": "    These interfaces are used to examine the actual query terms used in\n    a search or that may be used to create a smart catalog. Query\n    inspectors may be converted to an ``OsidQuery`` for reuse or\n    modification in the search sessions."
         }, 
         "inherit_fullnames": [
            "osid.OsidQueryInspector"
         ], 
         "inherit_shortnames": [
            "OsidQueryInspector"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidQueryInspector"
            }
         ], 
         "method_names": [
            "get_effective_terms", 
            "get_start_date_terms", 
            "get_end_date_terms", 
            "get_date_terms"
         ], 
         "methods": [
            {
               "name": "get_effective_terms", 
               "doc": {
                  "headline": "Gets the effective query terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.search.terms.BooleanTerm) - the query terms", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the query terms\n        :rtype: ``osid.search.terms.BooleanTerm``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.search.terms.BooleanTerm", 
               "errors": {}
            }, 
            {
               "name": "get_start_date_terms", 
               "doc": {
                  "headline": "Gets the start date query terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.search.terms.DateTimeRangeTerm) - the query terms", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the query terms\n        :rtype: ``osid.search.terms.DateTimeRangeTerm``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.search.terms.DateTimeRangeTerm", 
               "errors": {}
            }, 
            {
               "name": "get_end_date_terms", 
               "doc": {
                  "headline": "Gets the end date query terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.search.terms.DateTimeRangeTerm) - the query terms", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the query terms\n        :rtype: ``osid.search.terms.DateTimeRangeTerm``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.search.terms.DateTimeRangeTerm", 
               "errors": {}
            }, 
            {
               "name": "get_date_terms", 
               "doc": {
                  "headline": "Gets the date query terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.search.terms.DateTimeRangeTerm) - the query terms", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the query terms\n        :rtype: ``osid.search.terms.DateTimeRangeTerm``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.search.terms.DateTimeRangeTerm", 
               "errors": {}
            }
         ]
      }, 
      {
         "fullname": "osid.OsidSubjugateableQueryInspector", 
         "shortname": "OsidSubjugateableQueryInspector", 
         "category": "query_inspectors", 
         "doc": {
            "headline": "The query inspectors provide a means of accessing the match terms of a query.", 
            "body": "    These interfaces are used to examine the actual query terms used in\n    a search or that may be used to create a smart catalog. Query\n    inspectors may be converted to an ``OsidQuery`` for reuse or\n    modification in the search sessions."
         }, 
         "inherit_fullnames": [
            "osid.OsidQueryInspector"
         ], 
         "inherit_shortnames": [
            "OsidQueryInspector"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidQueryInspector"
            }
         ], 
         "method_names": [], 
         "methods": []
      }, 
      {
         "fullname": "osid.OsidAggregateableQueryInspector", 
         "shortname": "OsidAggregateableQueryInspector", 
         "category": "query_inspectors", 
         "doc": {
            "headline": "The query inspectors provide a means of accessing the match terms of a query.", 
            "body": "    These interfaces are used to examine the actual query terms used in\n    a search or that may be used to create a smart catalog. Query\n    inspectors may be converted to an ``OsidQuery`` for reuse or\n    modification in the search sessions."
         }, 
         "inherit_fullnames": [
            "osid.OsidQueryInspector"
         ], 
         "inherit_shortnames": [
            "OsidQueryInspector"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidQueryInspector"
            }
         ], 
         "method_names": [], 
         "methods": []
      }, 
      {
         "fullname": "osid.OsidContainableQueryInspector", 
         "shortname": "OsidContainableQueryInspector", 
         "category": "query_inspectors", 
         "doc": {
            "headline": "The query inspectors provide a means of accessing the match terms of a query.", 
            "body": "    These interfaces are used to examine the actual query terms used in\n    a search or that may be used to create a smart catalog. Query\n    inspectors may be converted to an ``OsidQuery`` for reuse or\n    modification in the search sessions."
         }, 
         "inherit_fullnames": [
            "osid.OsidAggregateableQueryInspector"
         ], 
         "inherit_shortnames": [
            "OsidAggregateableQueryInspector"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidAggregateableQueryInspector"
            }
         ], 
         "method_names": [
            "get_sequestered_terms"
         ], 
         "methods": [
            {
               "name": "get_sequestered_terms", 
               "doc": {
                  "headline": "Gets the sequestered query terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.search.terms.BooleanTerm) - the query terms", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the query terms\n        :rtype: ``osid.search.terms.BooleanTerm``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.search.terms.BooleanTerm", 
               "errors": {}
            }
         ]
      }, 
      {
         "fullname": "osid.OsidSourceableQueryInspector", 
         "shortname": "OsidSourceableQueryInspector", 
         "category": "query_inspectors", 
         "doc": {
            "headline": "The query inspectors provide a means of accessing the match terms of a query.", 
            "body": "    These interfaces are used to examine the actual query terms used in\n    a search or that may be used to create a smart catalog. Query\n    inspectors may be converted to an ``OsidQuery`` for reuse or\n    modification in the search sessions."
         }, 
         "inherit_fullnames": [
            "osid.OsidQueryInspector"
         ], 
         "inherit_shortnames": [
            "OsidQueryInspector"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidQueryInspector"
            }
         ], 
         "method_names": [
            "get_provider_id_terms", 
            "get_provider_terms", 
            "get_branding_id_terms", 
            "get_branding_terms", 
            "get_license_terms"
         ], 
         "methods": [
            {
               "name": "get_provider_id_terms", 
               "doc": {
                  "headline": "Gets the provider ``Id`` query terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.search.terms.IdTerm) - the provider ``Id`` terms", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the provider ``Id`` terms\n        :rtype: ``osid.search.terms.IdTerm``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.search.terms.IdTerm", 
               "errors": {}
            }, 
            {
               "name": "get_provider_terms", 
               "doc": {
                  "headline": "Gets the provider query terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.resource.ResourceQueryInspector) - the provider\n                terms", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the provider terms\n        :rtype: ``osid.resource.ResourceQueryInspector``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.resource.ResourceQueryInspector", 
               "errors": {}
            }, 
            {
               "name": "get_branding_id_terms", 
               "doc": {
                  "headline": "Gets the asset ``Id`` query terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.search.terms.IdTerm) - the asset ``Id`` terms", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the asset ``Id`` terms\n        :rtype: ``osid.search.terms.IdTerm``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.search.terms.IdTerm", 
               "errors": {}
            }, 
            {
               "name": "get_branding_terms", 
               "doc": {
                  "headline": "Gets the asset query terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.repository.AssetQueryInspector) - the branding\n                terms", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the branding terms\n        :rtype: ``osid.repository.AssetQueryInspector``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.repository.AssetQueryInspector", 
               "errors": {}
            }, 
            {
               "name": "get_license_terms", 
               "doc": {
                  "headline": "Gets the license query terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.search.terms.StringTerm) - the license terms", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the license terms\n        :rtype: ``osid.search.terms.StringTerm``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.search.terms.StringTerm", 
               "errors": {}
            }
         ]
      }, 
      {
         "fullname": "osid.OsidFederateableQueryInspector", 
         "shortname": "OsidFederateableQueryInspector", 
         "category": "query_inspectors", 
         "doc": {
            "headline": "The query inspectors provide a means of accessing the match terms of a query.", 
            "body": "    These interfaces are used to examine the actual query terms used in\n    a search or that may be used to create a smart catalog. Query\n    inspectors may be converted to an ``OsidQuery`` for reuse or\n    modification in the search sessions."
         }, 
         "inherit_fullnames": [
            "osid.OsidQueryInspector"
         ], 
         "inherit_shortnames": [
            "OsidQueryInspector"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidQueryInspector"
            }
         ], 
         "method_names": [], 
         "methods": []
      }, 
      {
         "fullname": "osid.OsidOperableQueryInspector", 
         "shortname": "OsidOperableQueryInspector", 
         "category": "query_inspectors", 
         "doc": {
            "headline": "The query inspectors provide a means of accessing the match terms of a query.", 
            "body": "    These interfaces are used to examine the actual query terms used in\n    a search or that may be used to create a smart catalog. Query\n    inspectors may be converted to an ``OsidQuery`` for reuse or\n    modification in the search sessions."
         }, 
         "inherit_fullnames": [
            "osid.OsidQueryInspector"
         ], 
         "inherit_shortnames": [
            "OsidQueryInspector"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidQueryInspector"
            }
         ], 
         "method_names": [
            "get_active_terms", 
            "get_enabled_terms", 
            "get_disabled_terms", 
            "get_operational_terms"
         ], 
         "methods": [
            {
               "name": "get_active_terms", 
               "doc": {
                  "headline": "Gets the active query terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.search.terms.BooleanTerm) - the query terms", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the query terms\n        :rtype: ``osid.search.terms.BooleanTerm``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.search.terms.BooleanTerm", 
               "errors": {}
            }, 
            {
               "name": "get_enabled_terms", 
               "doc": {
                  "headline": "Gets the administratively enabled query terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.search.terms.BooleanTerm) - the query terms", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the query terms\n        :rtype: ``osid.search.terms.BooleanTerm``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.search.terms.BooleanTerm", 
               "errors": {}
            }, 
            {
               "name": "get_disabled_terms", 
               "doc": {
                  "headline": "Gets the administratively disabled query terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.search.terms.BooleanTerm) - the query terms", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the query terms\n        :rtype: ``osid.search.terms.BooleanTerm``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.search.terms.BooleanTerm", 
               "errors": {}
            }, 
            {
               "name": "get_operational_terms", 
               "doc": {
                  "headline": "Gets the operational query terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.search.terms.BooleanTerm) - the query terms", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the query terms\n        :rtype: ``osid.search.terms.BooleanTerm``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.search.terms.BooleanTerm", 
               "errors": {}
            }
         ]
      }, 
      {
         "fullname": "osid.OsidObjectQueryInspector", 
         "shortname": "OsidObjectQueryInspector", 
         "category": "query_inspectors", 
         "doc": {
            "headline": "The query inspectors provide a means of accessing the match terms of a query.", 
            "body": "    These interfaces are used to examine the actual query terms used in\n    a search or that may be used to create a smart catalog. Query\n    inspectors may be converted to an ``OsidQuery`` for reuse or\n    modification in the search sessions."
         }, 
         "inherit_fullnames": [
            "osid.OsidIdentifiableQueryInspector", 
            "osid.OsidExtensibleQueryInspector", 
            "osid.OsidBrowsableQueryInspector"
         ], 
         "inherit_shortnames": [
            "OsidIdentifiableQueryInspector", 
            "OsidExtensibleQueryInspector", 
            "OsidBrowsableQueryInspector"
         ], 
         "inherit_pkg_names": [
            "osid", 
            "osid", 
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidIdentifiableQueryInspector"
            }, 
            {
               "pkg_name": "osid", 
               "name": "OsidExtensibleQueryInspector"
            }, 
            {
               "pkg_name": "osid", 
               "name": "OsidBrowsableQueryInspector"
            }
         ], 
         "method_names": [
            "get_display_name_terms", 
            "get_description_terms", 
            "get_genus_type_terms", 
            "get_parent_genus_type_terms", 
            "get_subject_id_terms", 
            "get_subject_terms", 
            "get_subject_relevancy_terms", 
            "get_state_id_terms", 
            "get_state_terms", 
            "get_comment_id_terms", 
            "get_comment_terms", 
            "get_journal_entry_id_terms", 
            "get_journal_entry_terms", 
            "get_statistic_terms", 
            "get_credit_id_terms", 
            "get_credit_terms", 
            "get_relationship_id_terms", 
            "get_relationship_terms", 
            "get_relationship_peer_id_terms"
         ], 
         "methods": [
            {
               "name": "get_display_name_terms", 
               "doc": {
                  "headline": "Gets the display name query terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.search.terms.StringTerm) - the display name terms", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the display name terms\n        :rtype: ``osid.search.terms.StringTerm``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.search.terms.StringTerm", 
               "errors": {}
            }, 
            {
               "name": "get_description_terms", 
               "doc": {
                  "headline": "Gets the description query terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.search.terms.StringTerm) - the description terms", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the description terms\n        :rtype: ``osid.search.terms.StringTerm``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.search.terms.StringTerm", 
               "errors": {}
            }, 
            {
               "name": "get_genus_type_terms", 
               "doc": {
                  "headline": "Gets the genus type query terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.search.terms.TypeTerm) - the genus type terms", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the genus type terms\n        :rtype: ``osid.search.terms.TypeTerm``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.search.terms.TypeTerm", 
               "errors": {}
            }, 
            {
               "name": "get_parent_genus_type_terms", 
               "doc": {
                  "headline": "Gets the parent genus type query terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.search.terms.TypeTerm) - the parent genus type\n                terms", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the parent genus type terms\n        :rtype: ``osid.search.terms.TypeTerm``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.search.terms.TypeTerm", 
               "errors": {}
            }, 
            {
               "name": "get_subject_id_terms", 
               "doc": {
                  "headline": "Gets the subject ``Id`` query terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.search.terms.IdTerm) - the subject ``Id`` terms", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the subject ``Id`` terms\n        :rtype: ``osid.search.terms.IdTerm``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.search.terms.IdTerm", 
               "errors": {}
            }, 
            {
               "name": "get_subject_terms", 
               "doc": {
                  "headline": "Gets the subject query terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.ontology.SubjectQueryInspector) - the subject\n                query terms", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the subject query terms\n        :rtype: ``osid.ontology.SubjectQueryInspector``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.ontology.SubjectQueryInspector", 
               "errors": {}
            }, 
            {
               "name": "get_subject_relevancy_terms", 
               "doc": {
                  "headline": "Gets the subject relevancy query terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.ontology.RelevancyQueryInspector) - the subject\n                relevancy query terms", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the subject relevancy query terms\n        :rtype: ``osid.ontology.RelevancyQueryInspector``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.ontology.RelevancyQueryInspector", 
               "errors": {}
            }, 
            {
               "name": "get_state_id_terms", 
               "doc": {
                  "headline": "Gets the state ``Id`` query terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.search.terms.IdTerm) - the state ``Id`` terms", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the state ``Id`` terms\n        :rtype: ``osid.search.terms.IdTerm``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.search.terms.IdTerm", 
               "errors": {}
            }, 
            {
               "name": "get_state_terms", 
               "doc": {
                  "headline": "Gets the state query terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.process.StateQueryInspector) - the state query\n                terms", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the state query terms\n        :rtype: ``osid.process.StateQueryInspector``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.process.StateQueryInspector", 
               "errors": {}
            }, 
            {
               "name": "get_comment_id_terms", 
               "doc": {
                  "headline": "Gets the comment ``Id`` query terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.search.terms.IdTerm) - the comment ``Id`` terms", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the comment ``Id`` terms\n        :rtype: ``osid.search.terms.IdTerm``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.search.terms.IdTerm", 
               "errors": {}
            }, 
            {
               "name": "get_comment_terms", 
               "doc": {
                  "headline": "Gets the comment query terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.commenting.CommentQueryInspector) - the comment\n                query terms", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the comment query terms\n        :rtype: ``osid.commenting.CommentQueryInspector``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.commenting.CommentQueryInspector", 
               "errors": {}
            }, 
            {
               "name": "get_journal_entry_id_terms", 
               "doc": {
                  "headline": "Gets the journal entry ``Id`` query terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.search.terms.IdTerm) - the journal entry ``Id``\n                terms", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the journal entry ``Id`` terms\n        :rtype: ``osid.search.terms.IdTerm``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.search.terms.IdTerm", 
               "errors": {}
            }, 
            {
               "name": "get_journal_entry_terms", 
               "doc": {
                  "headline": "Gets the journal entry query terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.journaling.JournalEntryQueryInspector) - the\n                journal entry query terms", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the journal entry query terms\n        :rtype: ``osid.journaling.JournalEntryQueryInspector``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.journaling.JournalEntryQueryInspector", 
               "errors": {}
            }, 
            {
               "name": "get_statistic_terms", 
               "doc": {
                  "headline": "Gets the statistic query terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.metering.StatisticQueryInspector) - the statistic\n                query terms", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the statistic query terms\n        :rtype: ``osid.metering.StatisticQueryInspector``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.metering.StatisticQueryInspector", 
               "errors": {}
            }, 
            {
               "name": "get_credit_id_terms", 
               "doc": {
                  "headline": "Gets the credit ``Id`` query terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.search.terms.IdTerm) - the credit ``Id`` terms", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the credit ``Id`` terms\n        :rtype: ``osid.search.terms.IdTerm``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.search.terms.IdTerm", 
               "errors": {}
            }, 
            {
               "name": "get_credit_terms", 
               "doc": {
                  "headline": "Gets the credit query terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.acknowledgement.CreditQueryInspector) - the credit\n                query terms", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the credit query terms\n        :rtype: ``osid.acknowledgement.CreditQueryInspector``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.acknowledgement.CreditQueryInspector", 
               "errors": {}
            }, 
            {
               "name": "get_relationship_id_terms", 
               "doc": {
                  "headline": "Gets the relationship ``Id`` query terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.search.terms.IdTerm) - the relationship ``Id``\n                terms", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the relationship ``Id`` terms\n        :rtype: ``osid.search.terms.IdTerm``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.search.terms.IdTerm", 
               "errors": {}
            }, 
            {
               "name": "get_relationship_terms", 
               "doc": {
                  "headline": "Gets the relationship query terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.relationship.RelationshipQueryInspector) - the\n                relationship query terms", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the relationship query terms\n        :rtype: ``osid.relationship.RelationshipQueryInspector``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.relationship.RelationshipQueryInspector", 
               "errors": {}
            }, 
            {
               "name": "get_relationship_peer_id_terms", 
               "doc": {
                  "headline": "Gets the relationship peer ``Id`` query terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.search.terms.IdTerm) - the relationship peer\n                ``Id`` terms", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the relationship peer ``Id`` terms\n        :rtype: ``osid.search.terms.IdTerm``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.search.terms.IdTerm", 
               "errors": {}
            }
         ]
      }, 
      {
         "fullname": "osid.OsidRelationshipQueryInspector", 
         "shortname": "OsidRelationshipQueryInspector", 
         "category": "query_inspectors", 
         "doc": {
            "headline": "The query inspectors provide a means of accessing the match terms of a query.", 
            "body": "    These interfaces are used to examine the actual query terms used in\n    a search or that may be used to create a smart catalog. Query\n    inspectors may be converted to an ``OsidQuery`` for reuse or\n    modification in the search sessions."
         }, 
         "inherit_fullnames": [
            "osid.OsidObjectQueryInspector", 
            "osid.OsidTemporalQueryInspector"
         ], 
         "inherit_shortnames": [
            "OsidObjectQueryInspector", 
            "OsidTemporalQueryInspector"
         ], 
         "inherit_pkg_names": [
            "osid", 
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidObjectQueryInspector"
            }, 
            {
               "pkg_name": "osid", 
               "name": "OsidTemporalQueryInspector"
            }
         ], 
         "method_names": [
            "get_end_reason_id_terms", 
            "get_end_reason_terms"
         ], 
         "methods": [
            {
               "name": "get_end_reason_id_terms", 
               "doc": {
                  "headline": "Gets the end reaosn state ``Id`` query terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.search.terms.IdTerm) - the state ``Id`` terms", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the state ``Id`` terms\n        :rtype: ``osid.search.terms.IdTerm``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.search.terms.IdTerm", 
               "errors": {}
            }, 
            {
               "name": "get_end_reason_terms", 
               "doc": {
                  "headline": "Gets the end reaosn state query terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.process.StateQueryInspector) - the state query\n                terms", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the state query terms\n        :rtype: ``osid.process.StateQueryInspector``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.process.StateQueryInspector", 
               "errors": {}
            }
         ]
      }, 
      {
         "fullname": "osid.OsidCatalogQueryInspector", 
         "shortname": "OsidCatalogQueryInspector", 
         "category": "query_inspectors", 
         "doc": {
            "headline": "The query inspectors provide a means of accessing the match terms of a query.", 
            "body": "    These interfaces are used to examine the actual query terms used in\n    a search or that may be used to create a smart catalog. Query\n    inspectors may be converted to an ``OsidQuery`` for reuse or\n    modification in the search sessions."
         }, 
         "inherit_fullnames": [
            "osid.OsidObjectQueryInspector", 
            "osid.OsidSourceableQueryInspector", 
            "osid.OsidFederateableQueryInspector"
         ], 
         "inherit_shortnames": [
            "OsidObjectQueryInspector", 
            "OsidSourceableQueryInspector", 
            "OsidFederateableQueryInspector"
         ], 
         "inherit_pkg_names": [
            "osid", 
            "osid", 
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidObjectQueryInspector"
            }, 
            {
               "pkg_name": "osid", 
               "name": "OsidSourceableQueryInspector"
            }, 
            {
               "pkg_name": "osid", 
               "name": "OsidFederateableQueryInspector"
            }
         ], 
         "method_names": [], 
         "methods": []
      }, 
      {
         "fullname": "osid.OsidRuleQueryInspector", 
         "shortname": "OsidRuleQueryInspector", 
         "category": "query_inspectors", 
         "doc": {
            "headline": "The query inspectors provide a means of accessing the match terms of a query.", 
            "body": "    These interfaces are used to examine the actual query terms used in\n    a search or that may be used to create a smart catalog. Query\n    inspectors may be converted to an ``OsidQuery`` for reuse or\n    modification in the search sessions."
         }, 
         "inherit_fullnames": [
            "osid.OsidObjectQueryInspector", 
            "osid.OsidOperableQueryInspector"
         ], 
         "inherit_shortnames": [
            "OsidObjectQueryInspector", 
            "OsidOperableQueryInspector"
         ], 
         "inherit_pkg_names": [
            "osid", 
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidObjectQueryInspector"
            }, 
            {
               "pkg_name": "osid", 
               "name": "OsidOperableQueryInspector"
            }
         ], 
         "method_names": [
            "get_rule_id_terms", 
            "get_rule_terms"
         ], 
         "methods": [
            {
               "name": "get_rule_id_terms", 
               "doc": {
                  "headline": "Gets the rule ``Id`` query terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.search.terms.IdTerm) - the rule ``Id`` terms", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the rule ``Id`` terms\n        :rtype: ``osid.search.terms.IdTerm``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.search.terms.IdTerm", 
               "errors": {}
            }, 
            {
               "name": "get_rule_terms", 
               "doc": {
                  "headline": "Gets the rule query terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.rules.RuleQueryInspector) - the rule query terms", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the rule query terms\n        :rtype: ``osid.rules.RuleQueryInspector``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.rules.RuleQueryInspector", 
               "errors": {}
            }
         ]
      }, 
      {
         "fullname": "osid.OsidEnablerQueryInspector", 
         "shortname": "OsidEnablerQueryInspector", 
         "category": "query_inspectors", 
         "doc": {
            "headline": "The query inspectors provide a means of accessing the match terms of a query.", 
            "body": "    These interfaces are used to examine the actual query terms used in\n    a search or that may be used to create a smart catalog. Query\n    inspectors may be converted to an ``OsidQuery`` for reuse or\n    modification in the search sessions."
         }, 
         "inherit_fullnames": [
            "osid.OsidRuleQueryInspector", 
            "osid.OsidTemporalQueryInspector"
         ], 
         "inherit_shortnames": [
            "OsidRuleQueryInspector", 
            "OsidTemporalQueryInspector"
         ], 
         "inherit_pkg_names": [
            "osid", 
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidRuleQueryInspector"
            }, 
            {
               "pkg_name": "osid", 
               "name": "OsidTemporalQueryInspector"
            }
         ], 
         "method_names": [
            "get_schedule_id_terms", 
            "get_schedule_terms", 
            "get_event_id_terms", 
            "get_event_terms", 
            "get_cyclic_event_id_terms", 
            "get_cyclic_event_terms", 
            "get_demographic_id_terms", 
            "get_demographic_terms"
         ], 
         "methods": [
            {
               "name": "get_schedule_id_terms", 
               "doc": {
                  "headline": "Gets the effective schedule ``Id`` query terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.search.terms.IdTerm) - the effecive schedule\n                ``Id`` terms", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the effecive schedule ``Id`` terms\n        :rtype: ``osid.search.terms.IdTerm``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.search.terms.IdTerm", 
               "errors": {}
            }, 
            {
               "name": "get_schedule_terms", 
               "doc": {
                  "headline": "Gets the effective schedule query terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.ScheduleQueryInspector) - the query\n                terms", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the query terms\n        :rtype: ``osid.calendaring.ScheduleQueryInspector``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.ScheduleQueryInspector", 
               "errors": {}
            }, 
            {
               "name": "get_event_id_terms", 
               "doc": {
                  "headline": "Gets the effective event ``Id`` query terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.search.terms.IdTerm) - the effecive recurring\n                event ``Id`` terms", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the effecive recurring event ``Id`` terms\n        :rtype: ``osid.search.terms.IdTerm``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.search.terms.IdTerm", 
               "errors": {}
            }, 
            {
               "name": "get_event_terms", 
               "doc": {
                  "headline": "Gets the effective event query terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.EventQueryInspector) - the query terms", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the query terms\n        :rtype: ``osid.calendaring.EventQueryInspector``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.EventQueryInspector", 
               "errors": {}
            }, 
            {
               "name": "get_cyclic_event_id_terms", 
               "doc": {
                  "headline": "Gets the cyclic event ``Id`` query terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.search.terms.IdTerm) - the query terms", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the query terms\n        :rtype: ``osid.search.terms.IdTerm``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.search.terms.IdTerm", 
               "errors": {}
            }, 
            {
               "name": "get_cyclic_event_terms", 
               "doc": {
                  "headline": "Gets the cyclic event query terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.cycle.CyclicEventQueryInspector) - the\n                query terms", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the query terms\n        :rtype: ``osid.calendaring.cycle.CyclicEventQueryInspector``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.cycle.CyclicEventQueryInspector", 
               "errors": {}
            }, 
            {
               "name": "get_demographic_id_terms", 
               "doc": {
                  "headline": "Gets the demographic resource ``Id`` query terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.search.terms.IdTerm) - the resource ``Id`` terms", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the resource ``Id`` terms\n        :rtype: ``osid.search.terms.IdTerm``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.search.terms.IdTerm", 
               "errors": {}
            }, 
            {
               "name": "get_demographic_terms", 
               "doc": {
                  "headline": "Gets the demographic resource query terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.resource.ResourceQueryInspector) - the resource\n                query terms", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the resource query terms\n        :rtype: ``osid.resource.ResourceQueryInspector``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.resource.ResourceQueryInspector", 
               "errors": {}
            }
         ]
      }, 
      {
         "fullname": "osid.OsidConstrainerQueryInspector", 
         "shortname": "OsidConstrainerQueryInspector", 
         "category": "query_inspectors", 
         "doc": {
            "headline": "The query inspectors provide a means of accessing the match terms of a query.", 
            "body": "    These interfaces are used to examine the actual query terms used in\n    a search or that may be used to create a smart catalog. Query\n    inspectors may be converted to an ``OsidQuery`` for reuse or\n    modification in the search sessions."
         }, 
         "inherit_fullnames": [
            "osid.OsidRuleQueryInspector"
         ], 
         "inherit_shortnames": [
            "OsidRuleQueryInspector"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidRuleQueryInspector"
            }
         ], 
         "method_names": [], 
         "methods": []
      }, 
      {
         "fullname": "osid.OsidProcessorQueryInspector", 
         "shortname": "OsidProcessorQueryInspector", 
         "category": "query_inspectors", 
         "doc": {
            "headline": "The query inspectors provide a means of accessing the match terms of a query.", 
            "body": "    These interfaces are used to examine the actual query terms used in\n    a search or that may be used to create a smart catalog. Query\n    inspectors may be converted to an ``OsidQuery`` for reuse or\n    modification in the search sessions."
         }, 
         "inherit_fullnames": [
            "osid.OsidRuleQueryInspector"
         ], 
         "inherit_shortnames": [
            "OsidRuleQueryInspector"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidRuleQueryInspector"
            }
         ], 
         "method_names": [], 
         "methods": []
      }, 
      {
         "fullname": "osid.OsidGovernatorQueryInspector", 
         "shortname": "OsidGovernatorQueryInspector", 
         "category": "query_inspectors", 
         "doc": {
            "headline": "The query inspectors provide a means of accessing the match terms of a query.", 
            "body": "    These interfaces are used to examine the actual query terms used in\n    a search or that may be used to create a smart catalog. Query\n    inspectors may be converted to an ``OsidQuery`` for reuse or\n    modification in the search sessions."
         }, 
         "inherit_fullnames": [
            "osid.OsidObjectQueryInspector", 
            "osid.OsidOperableQueryInspector", 
            "osid.OsidSourceableQueryInspector"
         ], 
         "inherit_shortnames": [
            "OsidObjectQueryInspector", 
            "OsidOperableQueryInspector", 
            "OsidSourceableQueryInspector"
         ], 
         "inherit_pkg_names": [
            "osid", 
            "osid", 
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidObjectQueryInspector"
            }, 
            {
               "pkg_name": "osid", 
               "name": "OsidOperableQueryInspector"
            }, 
            {
               "pkg_name": "osid", 
               "name": "OsidSourceableQueryInspector"
            }
         ], 
         "method_names": [], 
         "methods": []
      }, 
      {
         "fullname": "osid.OsidCompendiumQueryInspector", 
         "shortname": "OsidCompendiumQueryInspector", 
         "category": "query_inspectors", 
         "doc": {
            "headline": "The query inspectors provide a means of accessing the match terms of a query.", 
            "body": "    These interfaces are used to examine the actual query terms used in\n    a search or that may be used to create a smart catalog. Query\n    inspectors may be converted to an ``OsidQuery`` for reuse or\n    modification in the search sessions."
         }, 
         "inherit_fullnames": [
            "osid.OsidObjectQueryInspector", 
            "osid.OsidSubjugateableQueryInspector"
         ], 
         "inherit_shortnames": [
            "OsidObjectQueryInspector", 
            "OsidSubjugateableQueryInspector"
         ], 
         "inherit_pkg_names": [
            "osid", 
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidObjectQueryInspector"
            }, 
            {
               "pkg_name": "osid", 
               "name": "OsidSubjugateableQueryInspector"
            }
         ], 
         "method_names": [
            "get_start_date_terms", 
            "get_end_date_terms", 
            "get_interpolated_terms", 
            "get_extrapolated_terms"
         ], 
         "methods": [
            {
               "name": "get_start_date_terms", 
               "doc": {
                  "headline": "Gets the start date query terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.search.terms.DateTimeRangeTerm) - the query terms", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the query terms\n        :rtype: ``osid.search.terms.DateTimeRangeTerm``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.search.terms.DateTimeRangeTerm", 
               "errors": {}
            }, 
            {
               "name": "get_end_date_terms", 
               "doc": {
                  "headline": "Gets the end date query terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.search.terms.DateTimeRangeTerm) - the query terms", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the query terms\n        :rtype: ``osid.search.terms.DateTimeRangeTerm``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.search.terms.DateTimeRangeTerm", 
               "errors": {}
            }, 
            {
               "name": "get_interpolated_terms", 
               "doc": {
                  "headline": "Gets the interpolated query terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.search.terms.BooleanTerm) - the query terms", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the query terms\n        :rtype: ``osid.search.terms.BooleanTerm``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.search.terms.BooleanTerm", 
               "errors": {}
            }, 
            {
               "name": "get_extrapolated_terms", 
               "doc": {
                  "headline": "Gets the extrapolated query terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.search.terms.BooleanTerm) - the query terms", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the query terms\n        :rtype: ``osid.search.terms.BooleanTerm``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.search.terms.BooleanTerm", 
               "errors": {}
            }
         ]
      }, 
      {
         "fullname": "osid.OsidCapsuleQueryInspector", 
         "shortname": "OsidCapsuleQueryInspector", 
         "category": "query_inspectors", 
         "doc": {
            "headline": "The query inspectors provide a means of accessing the match terms of a query.", 
            "body": "    These interfaces are used to examine the actual query terms used in\n    a search or that may be used to create a smart catalog. Query\n    inspectors may be converted to an ``OsidQuery`` for reuse or\n    modification in the search sessions."
         }, 
         "inherit_fullnames": [
            "osid.OsidQueryInspector"
         ], 
         "inherit_shortnames": [
            "OsidQueryInspector"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidQueryInspector"
            }
         ], 
         "method_names": [], 
         "methods": []
      }, 
      {
         "fullname": "osid.OsidForm", 
         "shortname": "OsidForm", 
         "category": "objects", 
         "doc": {
            "headline": "The ``OsidForm`` is the vehicle used to create and update objects.", 
            "body": "    The form is a container for data to be sent to an update or create\n    method of a session. Applications should persist their own data\n    until a form is successfully submitted in an update or create\n    transaction.\n\n    The form may provide some feedback as to the validity of certain\n    data updates before the update transaction is issued to the\n    correspodning session but a successful modification of the form is\n    not a guarantee of success for the update transaction. A consumer\n    may elect to perform all updates within a single update transaction\n    or break up a large update intio smaller units. The tradeoff is the\n    granularity of error feedback vs. the performance gain of a single\n    transaction.\n    \n    ``OsidForms`` are ``Identifiable``. The ``Id`` of the ``OsidForm``\n    is used to uniquely identify the update or create transaction and\n    not that of the object being updated. Currently, it is not necessary\n    to have these ``Ids`` persisted.\n    \n    As with all aspects of the OSIDs, nulls cannot be used. Methods to\n    clear values are also defined in the form.\n    \n    A new ``OsidForm`` should be acquired for each transaction upon an\n    ``OsidObject``. Forms should not be reused from one object to\n    another even if the supplied data is the same as the forms may\n    encapsulate data specific to the object requested. Example of\n    changing a display name and a color defined in a color interface\n    extension:\n      ObjectForm form = session.getObjectFormForUpdate(objectId);\n      form.setDisplayName(\"new name\");\n      ColorForm recordForm = form.getFormRecord(colorRecordType);\n      recordForm.setColor(\"green\");\n      session.updateObject(objectId, form);\n    \n"
         }, 
         "inherit_fullnames": [
            "osid.Identifiable", 
            "osid.Suppliable"
         ], 
         "inherit_shortnames": [
            "Identifiable", 
            "Suppliable"
         ], 
         "inherit_pkg_names": [
            "osid", 
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "Identifiable"
            }, 
            {
               "pkg_name": "osid", 
               "name": "Suppliable"
            }
         ], 
         "method_names": [
            "is_for_update", 
            "get_default_locale", 
            "get_locales", 
            "set_locale", 
            "get_journal_comment_metadata", 
            "set_journal_comment", 
            "is_valid", 
            "get_validation_messages", 
            "get_invalid_metadata"
         ], 
         "methods": [
            {
               "name": "is_for_update", 
               "doc": {
                  "headline": "Tests if this form is for an update operation.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if this form is for an update\n                operation, ``false`` if for a create operation", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if this form is for an update operation, ``false`` if for a create operation\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "get_default_locale", 
               "doc": {
                  "headline": "Gets a default locale for ``DisplayTexts`` when a locale is not specified.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.locale.Locale) - the default locale", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the default locale\n        :rtype: ``osid.locale.Locale``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.locale.Locale", 
               "errors": {}
            }, 
            {
               "name": "get_locales", 
               "doc": {
                  "headline": "Gets a list of locales for available ``DisplayText`` translations that can be performed using this form.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.locale.LocaleList) - a list of available locales\n                or an empty list if no translation operations are\n                available", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: a list of available locales or an empty list if no translation operations are available\n        :rtype: ``osid.locale.LocaleList``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.locale.LocaleList", 
               "errors": {}
            }, 
            {
               "name": "set_locale", 
               "doc": {
                  "headline": "Specifies a language and script type for ``DisplayText`` fields in this form.", 
                  "body": "        Setting a locale to something other than the default locale may\n        affect the ``Metadata`` in this form.\n\n        If multiple locales are available for managing translations, the\n        ``Metadata`` indicates the fields are unset as they may be\n        returning a defeult value based on the default locale."
               }, 
               "arg_doc": "        arg:    language_type (osid.type.Type): the language type\n        arg:    script_type (osid.type.Type): the script type\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``language_type`` or ``script_type`` is\n                null\n        raise:  Unsupported - ``language_type`` and ``script_type`` not\n                available from ``get_locales()``", 
               "sphinx_param_doc": "        :param language_type: the language type\n        :type language_type: ``osid.type.Type``\n        :param script_type: the script type\n        :type script_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``language_type`` or ``script_type`` is null\n        :raise: ``Unsupported`` -- ``language_type`` and ``script_type`` not available from ``get_locales()``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "language_type", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "script_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type", 
                  "osid.type.Type"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_journal_comment_metadata", 
               "doc": {
                  "headline": "Gets the metadata for the comment corresponding to this form submission.", 
                  "body": "        The comment is used for describing the nature of the change to\n        the corresponding object for the purposes of logging and\n        auditing."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.Metadata) - metadata for the comment", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: metadata for the comment\n        :rtype: ``osid.Metadata``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.Metadata", 
               "errors": {}
            }, 
            {
               "name": "set_journal_comment", 
               "doc": {
                  "headline": "Sets a comment.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    comment (string): the new comment\n", 
               "return_doc": "", 
               "error_doc": "        raise:  InvalidArgument - ``comment`` is invalid\n        raise:  NoAccess - ``Metadata.isReadonly()`` is ``true``\n        raise:  NullArgument - ``comment`` is ``null``", 
               "sphinx_param_doc": "        :param comment: the new comment\n        :type comment: ``string``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``InvalidArgument`` -- ``comment`` is invalid\n        :raise: ``NoAccess`` -- ``Metadata.isReadonly()`` is ``true``\n        :raise: ``NullArgument`` -- ``comment`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "string", 
                     "var_name": "comment", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "string"
               ], 
               "return_type": "", 
               "errors": {
                  "INVALID_ARGUMENT": "ConsumerContract", 
                  "NO_ACCESS": "ConsumerContract", 
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "is_valid", 
               "doc": {
                  "headline": "Tests if ths form is in a valid state for submission.", 
                  "body": "        A form is valid if all required data has been supplied compliant\n        with any constraints."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``false`` if there is a known error in this\n                form, ``true`` otherwise", 
               "error_doc": "        raise:  OperationFailed - attempt to perform validation failed", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``false`` if there is a known error in this form, ``true`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- attempt to perform validation failed", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {
                  "OPERATION_FAILED": "Operational"
               }
            }, 
            {
               "name": "get_validation_messages", 
               "doc": {
                  "headline": "Gets text messages corresponding to additional instructions to pass form validation.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.locale.DisplayText) - a list of messages", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: a list of messages\n        :rtype: ``osid.locale.DisplayText``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.locale.DisplayText", 
               "errors": {}
            }, 
            {
               "name": "get_invalid_metadata", 
               "doc": {
                  "headline": "Gets a list of metadata for the elements in this form which are not valid.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.Metadata) - invalid metadata", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: invalid metadata\n        :rtype: ``osid.Metadata``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.Metadata", 
               "errors": {}
            }
         ]
      }, 
      {
         "fullname": "osid.OsidIdentifiableForm", 
         "shortname": "OsidIdentifiableForm", 
         "category": "objects", 
         "doc": {
            "headline": "The ``OsidIdentifiableForm`` is used to create and update identifiable objects.", 
            "body": "    The form is a container for data to be sent to an update or create\n    method of a session."
         }, 
         "inherit_fullnames": [
            "osid.OsidForm"
         ], 
         "inherit_shortnames": [
            "OsidForm"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidForm"
            }
         ], 
         "method_names": [], 
         "methods": []
      }, 
      {
         "fullname": "osid.OsidExtensibleForm", 
         "shortname": "OsidExtensibleForm", 
         "category": "objects", 
         "doc": {
            "headline": "The ``OsidExtensibleForm`` is used to create and update extensible objects.", 
            "body": "    The form is a container for data to be sent to an update or create\n    method of a session."
         }, 
         "inherit_fullnames": [
            "osid.OsidForm", 
            "osid.Extensible"
         ], 
         "inherit_shortnames": [
            "OsidForm", 
            "Extensible"
         ], 
         "inherit_pkg_names": [
            "osid", 
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidForm"
            }, 
            {
               "pkg_name": "osid", 
               "name": "Extensible"
            }
         ], 
         "method_names": [
            "get_required_record_types"
         ], 
         "methods": [
            {
               "name": "get_required_record_types", 
               "doc": {
                  "headline": "Gets the required record types for this form.", 
                  "body": "        The required records may change as a result of other data in\n        this form and should be checked before submission."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.type.TypeList) - a list of required record types", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: a list of required record types\n        :rtype: ``osid.type.TypeList``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.type.TypeList", 
               "errors": {}
            }
         ]
      }, 
      {
         "fullname": "osid.OsidBrowsableForm", 
         "shortname": "OsidBrowsableForm", 
         "category": "objects", 
         "doc": {
            "headline": "The ``OsidBrowsableForm`` is used to create and update browsable objects.", 
            "body": "    The form is a container for data to be sent to an update or create\n    method of a session."
         }, 
         "inherit_fullnames": [
            "osid.OsidForm"
         ], 
         "inherit_shortnames": [
            "OsidForm"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidForm"
            }
         ], 
         "method_names": [], 
         "methods": []
      }, 
      {
         "fullname": "osid.OsidTemporalForm", 
         "shortname": "OsidTemporalForm", 
         "category": "objects", 
         "doc": {
            "headline": "This form is used to create and update temporals.", 
            "body": ""
         }, 
         "inherit_fullnames": [
            "osid.OsidForm"
         ], 
         "inherit_shortnames": [
            "OsidForm"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidForm"
            }
         ], 
         "method_names": [
            "get_start_date_metadata", 
            "set_start_date", 
            "clear_start_date", 
            "get_end_date_metadata", 
            "set_end_date", 
            "clear_end_date"
         ], 
         "methods": [
            {
               "name": "get_start_date_metadata", 
               "doc": {
                  "headline": "Gets the metadata for a start date.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.Metadata) - metadata for the date", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: metadata for the date\n        :rtype: ``osid.Metadata``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.Metadata", 
               "errors": {}
            }, 
            {
               "name": "set_start_date", 
               "doc": {
                  "headline": "Sets the start date.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    date (osid.calendaring.DateTime): the new date\n", 
               "return_doc": "", 
               "error_doc": "        raise:  InvalidArgument - ``date`` is invalid\n        raise:  NoAccess - ``Metadata.isReadOnly()`` is ``true``\n        raise:  NullArgument - ``date`` is ``null``", 
               "sphinx_param_doc": "        :param date: the new date\n        :type date: ``osid.calendaring.DateTime``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``InvalidArgument`` -- ``date`` is invalid\n        :raise: ``NoAccess`` -- ``Metadata.isReadOnly()`` is ``true``\n        :raise: ``NullArgument`` -- ``date`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.calendaring.DateTime", 
                     "var_name": "date", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.calendaring.DateTime"
               ], 
               "return_type": "", 
               "errors": {
                  "INVALID_ARGUMENT": "ConsumerContract", 
                  "NO_ACCESS": "ConsumerContract", 
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "clear_start_date", 
               "doc": {
                  "headline": "Clears the start date.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "        raise:  NoAccess - ``Metadata.isRequired()`` or\n                ``Metadata.isReadOnly()`` is ``true``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NoAccess`` -- ``Metadata.isRequired()`` or ``Metadata.isReadOnly()`` is ``true``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {
                  "NO_ACCESS": "ConsumerContract"
               }
            }, 
            {
               "name": "get_end_date_metadata", 
               "doc": {
                  "headline": "Gets the metadata for an end date.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.Metadata) - metadata for the date", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: metadata for the date\n        :rtype: ``osid.Metadata``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.Metadata", 
               "errors": {}
            }, 
            {
               "name": "set_end_date", 
               "doc": {
                  "headline": "Sets the end date.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    date (osid.calendaring.DateTime): the new date\n", 
               "return_doc": "", 
               "error_doc": "        raise:  InvalidArgument - ``date`` is invalid\n        raise:  NoAccess - ``Metadata.isReadOnly()`` is ``true``\n        raise:  NullArgument - ``date`` is ``null``", 
               "sphinx_param_doc": "        :param date: the new date\n        :type date: ``osid.calendaring.DateTime``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``InvalidArgument`` -- ``date`` is invalid\n        :raise: ``NoAccess`` -- ``Metadata.isReadOnly()`` is ``true``\n        :raise: ``NullArgument`` -- ``date`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.calendaring.DateTime", 
                     "var_name": "date", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.calendaring.DateTime"
               ], 
               "return_type": "", 
               "errors": {
                  "INVALID_ARGUMENT": "ConsumerContract", 
                  "NO_ACCESS": "ConsumerContract", 
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "clear_end_date", 
               "doc": {
                  "headline": "Clears the end date.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "        raise:  NoAccess - ``Metadata.isRequired()`` or\n                ``Metadata.isReadOnly()`` is ``true``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NoAccess`` -- ``Metadata.isRequired()`` or ``Metadata.isReadOnly()`` is ``true``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {
                  "NO_ACCESS": "ConsumerContract"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.OsidSubjugateableForm", 
         "shortname": "OsidSubjugateableForm", 
         "category": "objects", 
         "doc": {
            "headline": "This form is used to create and update dependent objects.", 
            "body": ""
         }, 
         "inherit_fullnames": [
            "osid.OsidForm"
         ], 
         "inherit_shortnames": [
            "OsidForm"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidForm"
            }
         ], 
         "method_names": [], 
         "methods": []
      }, 
      {
         "fullname": "osid.OsidAggregateableForm", 
         "shortname": "OsidAggregateableForm", 
         "category": "objects", 
         "doc": {
            "headline": "This form is used to create and update assemblages.", 
            "body": ""
         }, 
         "inherit_fullnames": [
            "osid.OsidForm"
         ], 
         "inherit_shortnames": [
            "OsidForm"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidForm"
            }
         ], 
         "method_names": [], 
         "methods": []
      }, 
      {
         "fullname": "osid.OsidContainableForm", 
         "shortname": "OsidContainableForm", 
         "category": "objects", 
         "doc": {
            "headline": "This form is used to create and update containers.", 
            "body": ""
         }, 
         "inherit_fullnames": [
            "osid.OsidAggregateableForm"
         ], 
         "inherit_shortnames": [
            "OsidAggregateableForm"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidAggregateableForm"
            }
         ], 
         "method_names": [
            "get_sequestered_metadata", 
            "set_sequestered", 
            "clear_sequestered"
         ], 
         "methods": [
            {
               "name": "get_sequestered_metadata", 
               "doc": {
                  "headline": "Gets the metadata for the sequestered flag.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.Metadata) - metadata for the sequestered flag", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: metadata for the sequestered flag\n        :rtype: ``osid.Metadata``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.Metadata", 
               "errors": {}
            }, 
            {
               "name": "set_sequestered", 
               "doc": {
                  "headline": "Sets the sequestered flag.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    sequestered (boolean): the new sequestered flag\n", 
               "return_doc": "", 
               "error_doc": "        raise:  InvalidArgument - ``sequestered`` is invalid\n        raise:  NoAccess - ``Metadata.isReadOnly()`` is ``true``", 
               "sphinx_param_doc": "        :param sequestered: the new sequestered flag\n        :type sequestered: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``InvalidArgument`` -- ``sequestered`` is invalid\n        :raise: ``NoAccess`` -- ``Metadata.isReadOnly()`` is ``true``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "boolean", 
                     "var_name": "sequestered", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {
                  "INVALID_ARGUMENT": "ConsumerContract", 
                  "NO_ACCESS": "ConsumerContract"
               }
            }, 
            {
               "name": "clear_sequestered", 
               "doc": {
                  "headline": "Clears the sequestered flag.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "        raise:  NoAccess - ``Metadata.isRequired()`` or\n                ``Metadata.isReadOnly()`` is ``true``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NoAccess`` -- ``Metadata.isRequired()`` or ``Metadata.isReadOnly()`` is ``true``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {
                  "NO_ACCESS": "ConsumerContract"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.OsidSourceableForm", 
         "shortname": "OsidSourceableForm", 
         "category": "objects", 
         "doc": {
            "headline": "This form is used to create and update sourceables.", 
            "body": ""
         }, 
         "inherit_fullnames": [
            "osid.OsidForm"
         ], 
         "inherit_shortnames": [
            "OsidForm"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidForm"
            }
         ], 
         "method_names": [
            "get_provider_metadata", 
            "set_provider", 
            "clear_provider", 
            "get_branding_metadata", 
            "set_branding", 
            "clear_branding", 
            "get_license_metadata", 
            "set_license", 
            "clear_license"
         ], 
         "methods": [
            {
               "name": "get_provider_metadata", 
               "doc": {
                  "headline": "Gets the metadata for a provider.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.Metadata) - metadata for the provider", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: metadata for the provider\n        :rtype: ``osid.Metadata``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.Metadata", 
               "errors": {}
            }, 
            {
               "name": "set_provider", 
               "doc": {
                  "headline": "Sets a provider.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    provider_id (osid.id.Id): the new provider\n", 
               "return_doc": "", 
               "error_doc": "        raise:  InvalidArgument - ``provider_id`` is invalid\n        raise:  NoAccess - ``Metadata.isReadOnly()`` is ``true``\n        raise:  NullArgument - ``provider_id`` is ``null``", 
               "sphinx_param_doc": "        :param provider_id: the new provider\n        :type provider_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``InvalidArgument`` -- ``provider_id`` is invalid\n        :raise: ``NoAccess`` -- ``Metadata.isReadOnly()`` is ``true``\n        :raise: ``NullArgument`` -- ``provider_id`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "provider_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {
                  "INVALID_ARGUMENT": "ConsumerContract", 
                  "NO_ACCESS": "ConsumerContract", 
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "clear_provider", 
               "doc": {
                  "headline": "Removes the provider.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "        raise:  NoAccess - ``Metadata.isRequired()`` is ``true`` or\n                ``Metadata.isReadOnly()`` is ``true``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NoAccess`` -- ``Metadata.isRequired()`` is ``true`` or ``Metadata.isReadOnly()`` is ``true``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {
                  "NO_ACCESS": "ConsumerContract"
               }
            }, 
            {
               "name": "get_branding_metadata", 
               "doc": {
                  "headline": "Gets the metadata for the asset branding.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.Metadata) - metadata for the asset branding.", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: metadata for the asset branding.\n        :rtype: ``osid.Metadata``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.Metadata", 
               "errors": {}
            }, 
            {
               "name": "set_branding", 
               "doc": {
                  "headline": "Sets the branding.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    asset_ids (osid.id.Id[]): the new assets\n", 
               "return_doc": "", 
               "error_doc": "        raise:  InvalidArgument - ``asset_ids`` is invalid\n        raise:  NoAccess - ``Metadata.isReadOnly()`` is ``true``\n        raise:  NullArgument - ``asset_ids`` is ``null``", 
               "sphinx_param_doc": "        :param asset_ids: the new assets\n        :type asset_ids: ``osid.id.Id[]``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``InvalidArgument`` -- ``asset_ids`` is invalid\n        :raise: ``NoAccess`` -- ``Metadata.isReadOnly()`` is ``true``\n        :raise: ``NullArgument`` -- ``asset_ids`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id[]", 
                     "var_name": "asset_ids", 
                     "array": true
                  }
               ], 
               "arg_types": [
                  "osid.id.Id[]"
               ], 
               "return_type": "", 
               "errors": {
                  "INVALID_ARGUMENT": "ConsumerContract", 
                  "NO_ACCESS": "ConsumerContract", 
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "clear_branding", 
               "doc": {
                  "headline": "Removes the branding.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "        raise:  NoAccess - ``Metadata.isRequired()`` is ``true`` or\n                ``Metadata.isReadOnly()`` is ``true``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NoAccess`` -- ``Metadata.isRequired()`` is ``true`` or ``Metadata.isReadOnly()`` is ``true``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {
                  "NO_ACCESS": "ConsumerContract"
               }
            }, 
            {
               "name": "get_license_metadata", 
               "doc": {
                  "headline": "Gets the metadata for the license.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.Metadata) - metadata for the license", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: metadata for the license\n        :rtype: ``osid.Metadata``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.Metadata", 
               "errors": {}
            }, 
            {
               "name": "set_license", 
               "doc": {
                  "headline": "Sets the license.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    license (string): the new license\n", 
               "return_doc": "", 
               "error_doc": "        raise:  InvalidArgument - ``license`` is invalid\n        raise:  NoAccess - ``Metadata.isReadOnly()`` is ``true``\n        raise:  NullArgument - ``license`` is ``null``", 
               "sphinx_param_doc": "        :param license: the new license\n        :type license: ``string``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``InvalidArgument`` -- ``license`` is invalid\n        :raise: ``NoAccess`` -- ``Metadata.isReadOnly()`` is ``true``\n        :raise: ``NullArgument`` -- ``license`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "string", 
                     "var_name": "license", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "string"
               ], 
               "return_type": "", 
               "errors": {
                  "INVALID_ARGUMENT": "ConsumerContract", 
                  "NO_ACCESS": "ConsumerContract", 
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "clear_license", 
               "doc": {
                  "headline": "Removes the license.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "        raise:  NoAccess - ``Metadata.isRequired()`` is ``true`` or\n                ``Metadata.isReadOnly()`` is ``true``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NoAccess`` -- ``Metadata.isRequired()`` is ``true`` or ``Metadata.isReadOnly()`` is ``true``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {
                  "NO_ACCESS": "ConsumerContract"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.OsidFederateableForm", 
         "shortname": "OsidFederateableForm", 
         "category": "objects", 
         "doc": {
            "headline": "This form is used to create and update federateables.", 
            "body": ""
         }, 
         "inherit_fullnames": [
            "osid.OsidForm"
         ], 
         "inherit_shortnames": [
            "OsidForm"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidForm"
            }
         ], 
         "method_names": [], 
         "methods": []
      }, 
      {
         "fullname": "osid.OsidOperableForm", 
         "shortname": "OsidOperableForm", 
         "category": "objects", 
         "doc": {
            "headline": "This form is used to create and update operables.", 
            "body": ""
         }, 
         "inherit_fullnames": [
            "osid.OsidForm"
         ], 
         "inherit_shortnames": [
            "OsidForm"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidForm"
            }
         ], 
         "method_names": [
            "get_enabled_metadata", 
            "set_enabled", 
            "clear_enabled", 
            "get_disabled_metadata", 
            "set_disabled", 
            "clear_disabled"
         ], 
         "methods": [
            {
               "name": "get_enabled_metadata", 
               "doc": {
                  "headline": "Gets the metadata for the enabled flag.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.Metadata) - metadata for the enabled flag", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: metadata for the enabled flag\n        :rtype: ``osid.Metadata``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.Metadata", 
               "errors": {}
            }, 
            {
               "name": "set_enabled", 
               "doc": {
                  "headline": "Sets the administratively enabled flag.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    enabled (boolean): the new enabled flag\n", 
               "return_doc": "", 
               "error_doc": "        raise:  InvalidArgument - ``enabled`` is invalid\n        raise:  NoAccess - ``Metadata.isReadOnly()`` is ``true``", 
               "sphinx_param_doc": "        :param enabled: the new enabled flag\n        :type enabled: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``InvalidArgument`` -- ``enabled`` is invalid\n        :raise: ``NoAccess`` -- ``Metadata.isReadOnly()`` is ``true``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "boolean", 
                     "var_name": "enabled", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {
                  "INVALID_ARGUMENT": "ConsumerContract", 
                  "NO_ACCESS": "ConsumerContract"
               }
            }, 
            {
               "name": "clear_enabled", 
               "doc": {
                  "headline": "Removes the administratively enabled flag.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "        raise:  NoAccess - ``Metadata.isRequired()`` is ``true`` or\n                ``Metadata.isReadOnly()`` is ``true``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NoAccess`` -- ``Metadata.isRequired()`` is ``true`` or ``Metadata.isReadOnly()`` is ``true``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {
                  "NO_ACCESS": "ConsumerContract"
               }
            }, 
            {
               "name": "get_disabled_metadata", 
               "doc": {
                  "headline": "Gets the metadata for the disabled flag.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.Metadata) - metadata for the disabled flag", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: metadata for the disabled flag\n        :rtype: ``osid.Metadata``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.Metadata", 
               "errors": {}
            }, 
            {
               "name": "set_disabled", 
               "doc": {
                  "headline": "Sets the administratively disabled flag.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    disabled (boolean): the new disabled flag\n", 
               "return_doc": "", 
               "error_doc": "        raise:  InvalidArgument - ``disabled`` is invalid\n        raise:  NoAccess - ``Metadata.isReadOnly()`` is ``true``", 
               "sphinx_param_doc": "        :param disabled: the new disabled flag\n        :type disabled: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``InvalidArgument`` -- ``disabled`` is invalid\n        :raise: ``NoAccess`` -- ``Metadata.isReadOnly()`` is ``true``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "boolean", 
                     "var_name": "disabled", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {
                  "INVALID_ARGUMENT": "ConsumerContract", 
                  "NO_ACCESS": "ConsumerContract"
               }
            }, 
            {
               "name": "clear_disabled", 
               "doc": {
                  "headline": "Removes the administratively disabled flag.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "        raise:  NoAccess - ``Metadata.isRequired()`` is ``true`` or\n                ``Metadata.isReadOnly()`` is ``true``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NoAccess`` -- ``Metadata.isRequired()`` is ``true`` or ``Metadata.isReadOnly()`` is ``true``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {
                  "NO_ACCESS": "ConsumerContract"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.OsidObjectForm", 
         "shortname": "OsidObjectForm", 
         "category": "objects", 
         "doc": {
            "headline": "The ``OsidObjectForm`` is used to create and update ``OsidObjects``.", 
            "body": "    The form is not an ``OsidObject`` but merely a container for data to\n    be sent to an update or create method of a session. A provider may\n    or may not combine the ``OsidObject`` and ``OsidObjectForm``\n    interfaces into a single object.\n\n    Generally, a set method parallels each get method of an\n    ``OsidObject``. Additionally, ``Metadata`` may be examined for each\n    data element to assist in understanding particular rules concerning\n    acceptable data.\n    \n    The form may provide some feedback as to the validity of certain\n    data updates before the update transaction is issued to the\n    correspodning session but a successful modification of the form is\n    not a guarantee of success for the update transaction. A consumer\n    may elect to perform all updates within a single update transaction\n    or break up a large update intio smaller units. The tradeoff is the\n    granularity of error feedback vs. the performance gain of a single\n    transaction.\n    \n    As with all aspects of the OSIDs, nulls cannot be used. Methods to\n    clear values are also defined in the form.\n    \n    A new ``OsidForm`` should be acquired for each transaction upon an\n    ``OsidObject``. Forms should not be reused from one object to\n    another even if the supplied data is the same as the forms may\n    encapsulate data specific to the object requested. Example of\n    changing a display name and a color defined in a color interface\n    extension:\n      ObjectForm form = session.getObjectFormForUpdate(objectId);\n      form.setDisplayName(\"new name\");\n      ColorForm recordForm = form.getFormRecord(colorRecordType);\n      recordForm.setColor(\"green\");\n      session.updateObject(objectId, form);\n    \n"
         }, 
         "inherit_fullnames": [
            "osid.OsidIdentifiableForm", 
            "osid.OsidExtensibleForm", 
            "osid.OsidBrowsableForm"
         ], 
         "inherit_shortnames": [
            "OsidIdentifiableForm", 
            "OsidExtensibleForm", 
            "OsidBrowsableForm"
         ], 
         "inherit_pkg_names": [
            "osid", 
            "osid", 
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidIdentifiableForm"
            }, 
            {
               "pkg_name": "osid", 
               "name": "OsidExtensibleForm"
            }, 
            {
               "pkg_name": "osid", 
               "name": "OsidBrowsableForm"
            }
         ], 
         "method_names": [
            "get_display_name_metadata", 
            "set_display_name", 
            "clear_display_name", 
            "get_description_metadata", 
            "set_description", 
            "clear_description", 
            "get_genus_type_metadata", 
            "set_genus_type", 
            "clear_genus_type"
         ], 
         "methods": [
            {
               "name": "get_display_name_metadata", 
               "doc": {
                  "headline": "Gets the metadata for a display name.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.Metadata) - metadata for the display name", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: metadata for the display name\n        :rtype: ``osid.Metadata``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.Metadata", 
               "errors": {}
            }, 
            {
               "name": "set_display_name", 
               "doc": {
                  "headline": "Sets a display name.", 
                  "body": "        A display name is required and if not set, will be set by the\n        provider."
               }, 
               "arg_doc": "        arg:    display_name (string): the new display name\n", 
               "return_doc": "", 
               "error_doc": "        raise:  InvalidArgument - ``display_name`` is invalid\n        raise:  NoAccess - ``Metadata.isReadonly()`` is ``true``\n        raise:  NullArgument - ``display_name`` is ``null``", 
               "sphinx_param_doc": "        :param display_name: the new display name\n        :type display_name: ``string``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``InvalidArgument`` -- ``display_name`` is invalid\n        :raise: ``NoAccess`` -- ``Metadata.isReadonly()`` is ``true``\n        :raise: ``NullArgument`` -- ``display_name`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "string", 
                     "var_name": "display_name", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "string"
               ], 
               "return_type": "", 
               "errors": {
                  "INVALID_ARGUMENT": "ConsumerContract", 
                  "NO_ACCESS": "ConsumerContract", 
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "clear_display_name", 
               "doc": {
                  "headline": "Clears the display name.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "        raise:  NoAccess - ``Metadata.isRequired()`` or\n                ``Metadata.isReadOnly()`` is ``true``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NoAccess`` -- ``Metadata.isRequired()`` or ``Metadata.isReadOnly()`` is ``true``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {
                  "NO_ACCESS": "ConsumerContract"
               }
            }, 
            {
               "name": "get_description_metadata", 
               "doc": {
                  "headline": "Gets the metadata for a description.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.Metadata) - metadata for the description", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: metadata for the description\n        :rtype: ``osid.Metadata``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.Metadata", 
               "errors": {}
            }, 
            {
               "name": "set_description", 
               "doc": {
                  "headline": "Sets a description.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    description (string): the new description\n", 
               "return_doc": "", 
               "error_doc": "        raise:  InvalidArgument - ``description`` is invalid\n        raise:  NoAccess - ``Metadata.isReadonly()`` is ``true``\n        raise:  NullArgument - ``description`` is ``null``", 
               "sphinx_param_doc": "        :param description: the new description\n        :type description: ``string``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``InvalidArgument`` -- ``description`` is invalid\n        :raise: ``NoAccess`` -- ``Metadata.isReadonly()`` is ``true``\n        :raise: ``NullArgument`` -- ``description`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "string", 
                     "var_name": "description", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "string"
               ], 
               "return_type": "", 
               "errors": {
                  "INVALID_ARGUMENT": "ConsumerContract", 
                  "NO_ACCESS": "ConsumerContract", 
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "clear_description", 
               "doc": {
                  "headline": "Clears the description.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "        raise:  NoAccess - ``Metadata.isRequired()`` or\n                ``Metadata.isReadOnly()`` is ``true``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NoAccess`` -- ``Metadata.isRequired()`` or ``Metadata.isReadOnly()`` is ``true``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {
                  "NO_ACCESS": "ConsumerContract"
               }
            }, 
            {
               "name": "get_genus_type_metadata", 
               "doc": {
                  "headline": "Gets the metadata for a genus type.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.Metadata) - metadata for the genus", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: metadata for the genus\n        :rtype: ``osid.Metadata``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.Metadata", 
               "errors": {}
            }, 
            {
               "name": "set_genus_type", 
               "doc": {
                  "headline": "Sets a genus.", 
                  "body": "        A genus cannot be cleared because all objects have at minimum a\n        root genus."
               }, 
               "arg_doc": "        arg:    genus_type (osid.type.Type): the new genus\n", 
               "return_doc": "", 
               "error_doc": "        raise:  InvalidArgument - ``genus_type`` is invalid\n        raise:  NoAccess - ``Metadata.isReadonly()`` is ``true``\n        raise:  NullArgument - ``genus_type`` is ``null``", 
               "sphinx_param_doc": "        :param genus_type: the new genus\n        :type genus_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``InvalidArgument`` -- ``genus_type`` is invalid\n        :raise: ``NoAccess`` -- ``Metadata.isReadonly()`` is ``true``\n        :raise: ``NullArgument`` -- ``genus_type`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "genus_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "", 
               "errors": {
                  "INVALID_ARGUMENT": "ConsumerContract", 
                  "NO_ACCESS": "ConsumerContract", 
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "clear_genus_type", 
               "doc": {
                  "headline": "Clears the genus type.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "        raise:  NoAccess - ``Metadata.isRequired()`` or\n                ``Metadata.isReadOnly()`` is ``true``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NoAccess`` -- ``Metadata.isRequired()`` or ``Metadata.isReadOnly()`` is ``true``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {
                  "NO_ACCESS": "ConsumerContract"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.OsidRelationshipForm", 
         "shortname": "OsidRelationshipForm", 
         "category": "objects", 
         "doc": {
            "headline": "This form is used to create and update relationshps.", 
            "body": ""
         }, 
         "inherit_fullnames": [
            "osid.OsidObjectForm", 
            "osid.OsidTemporalForm"
         ], 
         "inherit_shortnames": [
            "OsidObjectForm", 
            "OsidTemporalForm"
         ], 
         "inherit_pkg_names": [
            "osid", 
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidObjectForm"
            }, 
            {
               "pkg_name": "osid", 
               "name": "OsidTemporalForm"
            }
         ], 
         "method_names": [], 
         "methods": []
      }, 
      {
         "fullname": "osid.OsidCatalogForm", 
         "shortname": "OsidCatalogForm", 
         "category": "objects", 
         "doc": {
            "headline": "This form is used to create and update catalogs.", 
            "body": ""
         }, 
         "inherit_fullnames": [
            "osid.OsidObjectForm", 
            "osid.OsidSourceableForm", 
            "osid.OsidFederateableForm"
         ], 
         "inherit_shortnames": [
            "OsidObjectForm", 
            "OsidSourceableForm", 
            "OsidFederateableForm"
         ], 
         "inherit_pkg_names": [
            "osid", 
            "osid", 
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidObjectForm"
            }, 
            {
               "pkg_name": "osid", 
               "name": "OsidSourceableForm"
            }, 
            {
               "pkg_name": "osid", 
               "name": "OsidFederateableForm"
            }
         ], 
         "method_names": [], 
         "methods": []
      }, 
      {
         "fullname": "osid.OsidRuleForm", 
         "shortname": "OsidRuleForm", 
         "category": "objects", 
         "doc": {
            "headline": "This form is used to create and update rules.", 
            "body": ""
         }, 
         "inherit_fullnames": [
            "osid.OsidObjectForm", 
            "osid.OsidOperableForm"
         ], 
         "inherit_shortnames": [
            "OsidObjectForm", 
            "OsidOperableForm"
         ], 
         "inherit_pkg_names": [
            "osid", 
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidObjectForm"
            }, 
            {
               "pkg_name": "osid", 
               "name": "OsidOperableForm"
            }
         ], 
         "method_names": [
            "get_rule_metadata", 
            "set_rule", 
            "clear_rule"
         ], 
         "methods": [
            {
               "name": "get_rule_metadata", 
               "doc": {
                  "headline": "Gets the metadata for an associated rule.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.Metadata) - metadata for the rule", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: metadata for the rule\n        :rtype: ``osid.Metadata``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.Metadata", 
               "errors": {}
            }, 
            {
               "name": "set_rule", 
               "doc": {
                  "headline": "Sets a rule.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    rule_id (osid.id.Id): the new rule\n", 
               "return_doc": "", 
               "error_doc": "        raise:  InvalidArgument - ``rule_id`` is invalid\n        raise:  NoAccess - ``Metadata.isReadOnly()`` is ``true``\n        raise:  NullArgument - ``rule_id`` is ``null``", 
               "sphinx_param_doc": "        :param rule_id: the new rule\n        :type rule_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``InvalidArgument`` -- ``rule_id`` is invalid\n        :raise: ``NoAccess`` -- ``Metadata.isReadOnly()`` is ``true``\n        :raise: ``NullArgument`` -- ``rule_id`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "rule_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {
                  "INVALID_ARGUMENT": "ConsumerContract", 
                  "NO_ACCESS": "ConsumerContract", 
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "clear_rule", 
               "doc": {
                  "headline": "Removes the rule.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "        raise:  NoAccess - ``Metadata.isRequired()`` is ``true`` or\n                ``Metadata.isReadOnly()`` is ``true``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NoAccess`` -- ``Metadata.isRequired()`` is ``true`` or ``Metadata.isReadOnly()`` is ``true``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {
                  "NO_ACCESS": "ConsumerContract"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.OsidEnablerForm", 
         "shortname": "OsidEnablerForm", 
         "category": "objects", 
         "doc": {
            "headline": "This form is used to create and update enablers.", 
            "body": ""
         }, 
         "inherit_fullnames": [
            "osid.OsidRuleForm", 
            "osid.OsidTemporalForm"
         ], 
         "inherit_shortnames": [
            "OsidRuleForm", 
            "OsidTemporalForm"
         ], 
         "inherit_pkg_names": [
            "osid", 
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidRuleForm"
            }, 
            {
               "pkg_name": "osid", 
               "name": "OsidTemporalForm"
            }
         ], 
         "method_names": [
            "get_schedule_metadata", 
            "set_schedule", 
            "clear_schedule", 
            "get_event_metadata", 
            "set_event", 
            "clear_event", 
            "get_cyclic_event_metadata", 
            "set_cyclic_event", 
            "clear_cyclic_event", 
            "get_demographic_metadata", 
            "set_demographic", 
            "clear_demographic"
         ], 
         "methods": [
            {
               "name": "get_schedule_metadata", 
               "doc": {
                  "headline": "Gets the metadata for an associated schedule.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.Metadata) - metadata for the schedule", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: metadata for the schedule\n        :rtype: ``osid.Metadata``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.Metadata", 
               "errors": {}
            }, 
            {
               "name": "set_schedule", 
               "doc": {
                  "headline": "Sets a schedule.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    schedule_id (osid.id.Id): the new schedule\n", 
               "return_doc": "", 
               "error_doc": "        raise:  InvalidArgument - ``schedule_id`` is invalid\n        raise:  NoAccess - ``Metadata.isReadOnly()`` is ``true``\n        raise:  NullArgument - ``schedule_id`` is ``null``", 
               "sphinx_param_doc": "        :param schedule_id: the new schedule\n        :type schedule_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``InvalidArgument`` -- ``schedule_id`` is invalid\n        :raise: ``NoAccess`` -- ``Metadata.isReadOnly()`` is ``true``\n        :raise: ``NullArgument`` -- ``schedule_id`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "schedule_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {
                  "INVALID_ARGUMENT": "ConsumerContract", 
                  "NO_ACCESS": "ConsumerContract", 
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "clear_schedule", 
               "doc": {
                  "headline": "Removes the schedule.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "        raise:  NoAccess - ``Metadata.isRequired()`` is ``true`` or\n                ``Metadata.isReadOnly()`` is ``true``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NoAccess`` -- ``Metadata.isRequired()`` is ``true`` or ``Metadata.isReadOnly()`` is ``true``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {
                  "NO_ACCESS": "ConsumerContract"
               }
            }, 
            {
               "name": "get_event_metadata", 
               "doc": {
                  "headline": "Gets the metadata for an associated event.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.Metadata) - metadata for the event", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: metadata for the event\n        :rtype: ``osid.Metadata``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.Metadata", 
               "errors": {}
            }, 
            {
               "name": "set_event", 
               "doc": {
                  "headline": "Sets an event.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    event_id (osid.id.Id): the new event\n", 
               "return_doc": "", 
               "error_doc": "        raise:  InvalidArgument - ``event_id`` is invalid\n        raise:  NoAccess - ``Metadata.isReadOnly()`` is ``true``\n        raise:  NullArgument - ``event_id`` is ``null``", 
               "sphinx_param_doc": "        :param event_id: the new event\n        :type event_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``InvalidArgument`` -- ``event_id`` is invalid\n        :raise: ``NoAccess`` -- ``Metadata.isReadOnly()`` is ``true``\n        :raise: ``NullArgument`` -- ``event_id`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "event_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {
                  "INVALID_ARGUMENT": "ConsumerContract", 
                  "NO_ACCESS": "ConsumerContract", 
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "clear_event", 
               "doc": {
                  "headline": "Removes the event.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "        raise:  NoAccess - ``Metadata.isRequired()`` is ``true`` or\n                ``Metadata.isReadOnly()`` is ``true``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NoAccess`` -- ``Metadata.isRequired()`` is ``true`` or ``Metadata.isReadOnly()`` is ``true``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {
                  "NO_ACCESS": "ConsumerContract"
               }
            }, 
            {
               "name": "get_cyclic_event_metadata", 
               "doc": {
                  "headline": "Gets the metadata for the cyclic event.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.Metadata) - metadata for the cyclic event", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: metadata for the cyclic event\n        :rtype: ``osid.Metadata``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.Metadata", 
               "errors": {}
            }, 
            {
               "name": "set_cyclic_event", 
               "doc": {
                  "headline": "Sets the cyclic event.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    cyclic_event_id (osid.id.Id): the new cyclic event\n", 
               "return_doc": "", 
               "error_doc": "        raise:  InvalidArgument - ``cyclic_event_id`` is invalid\n        raise:  NoAccess - ``Metadata.isReadOnly()`` is ``true``\n        raise:  NullArgument - ``cyclic_event_id`` is ``null``", 
               "sphinx_param_doc": "        :param cyclic_event_id: the new cyclic event\n        :type cyclic_event_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``InvalidArgument`` -- ``cyclic_event_id`` is invalid\n        :raise: ``NoAccess`` -- ``Metadata.isReadOnly()`` is ``true``\n        :raise: ``NullArgument`` -- ``cyclic_event_id`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "cyclic_event_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {
                  "INVALID_ARGUMENT": "ConsumerContract", 
                  "NO_ACCESS": "ConsumerContract", 
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "clear_cyclic_event", 
               "doc": {
                  "headline": "Removes the cyclic event.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "        raise:  NoAccess - ``Metadata.isRequired()`` is ``true`` or\n                ``Metadata.isReadOnly()`` is ``true``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NoAccess`` -- ``Metadata.isRequired()`` is ``true`` or ``Metadata.isReadOnly()`` is ``true``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {
                  "NO_ACCESS": "ConsumerContract"
               }
            }, 
            {
               "name": "get_demographic_metadata", 
               "doc": {
                  "headline": "Gets the metadata for an associated demographic.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.Metadata) - metadata for the resource.", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: metadata for the resource.\n        :rtype: ``osid.Metadata``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.Metadata", 
               "errors": {}
            }, 
            {
               "name": "set_demographic", 
               "doc": {
                  "headline": "Sets a resource demographic.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    resource_id (osid.id.Id): the new resource\n", 
               "return_doc": "", 
               "error_doc": "        raise:  InvalidArgument - ``resource_id`` is invalid\n        raise:  NoAccess - ``Metadata.isReadOnly()`` is ``true``\n        raise:  NullArgument - ``resource_id`` is ``null``", 
               "sphinx_param_doc": "        :param resource_id: the new resource\n        :type resource_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``InvalidArgument`` -- ``resource_id`` is invalid\n        :raise: ``NoAccess`` -- ``Metadata.isReadOnly()`` is ``true``\n        :raise: ``NullArgument`` -- ``resource_id`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "resource_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {
                  "INVALID_ARGUMENT": "ConsumerContract", 
                  "NO_ACCESS": "ConsumerContract", 
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "clear_demographic", 
               "doc": {
                  "headline": "Removes the resource demographic.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "        raise:  NoAccess - ``Metadata.isRequired()`` is ``true`` or\n                ``Metadata.isReadOnly()`` is ``true``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NoAccess`` -- ``Metadata.isRequired()`` is ``true`` or ``Metadata.isReadOnly()`` is ``true``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {
                  "NO_ACCESS": "ConsumerContract"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.OsidConstrainerForm", 
         "shortname": "OsidConstrainerForm", 
         "category": "objects", 
         "doc": {
            "headline": "This form is used to create and update constrainers.", 
            "body": ""
         }, 
         "inherit_fullnames": [
            "osid.OsidRuleForm"
         ], 
         "inherit_shortnames": [
            "OsidRuleForm"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidRuleForm"
            }
         ], 
         "method_names": [], 
         "methods": []
      }, 
      {
         "fullname": "osid.OsidProcessorForm", 
         "shortname": "OsidProcessorForm", 
         "category": "objects", 
         "doc": {
            "headline": "This form is used to create and update processors.", 
            "body": ""
         }, 
         "inherit_fullnames": [
            "osid.OsidRuleForm"
         ], 
         "inherit_shortnames": [
            "OsidRuleForm"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidRuleForm"
            }
         ], 
         "method_names": [], 
         "methods": []
      }, 
      {
         "fullname": "osid.OsidGovernatorForm", 
         "shortname": "OsidGovernatorForm", 
         "category": "objects", 
         "doc": {
            "headline": "This form is used to create and update governators.", 
            "body": ""
         }, 
         "inherit_fullnames": [
            "osid.OsidObjectForm", 
            "osid.OsidOperableForm", 
            "osid.OsidSourceableForm"
         ], 
         "inherit_shortnames": [
            "OsidObjectForm", 
            "OsidOperableForm", 
            "OsidSourceableForm"
         ], 
         "inherit_pkg_names": [
            "osid", 
            "osid", 
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidObjectForm"
            }, 
            {
               "pkg_name": "osid", 
               "name": "OsidOperableForm"
            }, 
            {
               "pkg_name": "osid", 
               "name": "OsidSourceableForm"
            }
         ], 
         "method_names": [], 
         "methods": []
      }, 
      {
         "fullname": "osid.OsidCompendiumForm", 
         "shortname": "OsidCompendiumForm", 
         "category": "objects", 
         "doc": {
            "headline": "This form is used to create and update governators.", 
            "body": ""
         }, 
         "inherit_fullnames": [
            "osid.OsidObjectForm", 
            "osid.OsidSubjugateableForm"
         ], 
         "inherit_shortnames": [
            "OsidObjectForm", 
            "OsidSubjugateableForm"
         ], 
         "inherit_pkg_names": [
            "osid", 
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidObjectForm"
            }, 
            {
               "pkg_name": "osid", 
               "name": "OsidSubjugateableForm"
            }
         ], 
         "method_names": [
            "get_start_date_metadata", 
            "set_start_date", 
            "clear_start_date", 
            "get_end_date_metadata", 
            "set_end_date", 
            "clear_end_date", 
            "get_interpolated_metadata", 
            "set_interpolated", 
            "clear_interpolated", 
            "get_extrapolated_metadata", 
            "set_extrapolated", 
            "clear_extrapolated"
         ], 
         "methods": [
            {
               "name": "get_start_date_metadata", 
               "doc": {
                  "headline": "Gets the metadata for a start date.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.Metadata) - metadata for the date", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: metadata for the date\n        :rtype: ``osid.Metadata``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.Metadata", 
               "errors": {}
            }, 
            {
               "name": "set_start_date", 
               "doc": {
                  "headline": "Sets the start date.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    date (osid.calendaring.DateTime): the new date\n", 
               "return_doc": "", 
               "error_doc": "        raise:  InvalidArgument - ``date`` is invalid\n        raise:  NoAccess - ``Metadata.isReadOnly()`` is ``true``\n        raise:  NullArgument - ``date`` is ``null``", 
               "sphinx_param_doc": "        :param date: the new date\n        :type date: ``osid.calendaring.DateTime``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``InvalidArgument`` -- ``date`` is invalid\n        :raise: ``NoAccess`` -- ``Metadata.isReadOnly()`` is ``true``\n        :raise: ``NullArgument`` -- ``date`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.calendaring.DateTime", 
                     "var_name": "date", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.calendaring.DateTime"
               ], 
               "return_type": "", 
               "errors": {
                  "INVALID_ARGUMENT": "ConsumerContract", 
                  "NO_ACCESS": "ConsumerContract", 
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "clear_start_date", 
               "doc": {
                  "headline": "Clears the start date.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "        raise:  NoAccess - ``Metadata.isRequired()`` or\n                ``Metadata.isReadOnly()`` is ``true``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NoAccess`` -- ``Metadata.isRequired()`` or ``Metadata.isReadOnly()`` is ``true``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {
                  "NO_ACCESS": "ConsumerContract"
               }
            }, 
            {
               "name": "get_end_date_metadata", 
               "doc": {
                  "headline": "Gets the metadata for an end date.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.Metadata) - metadata for the date", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: metadata for the date\n        :rtype: ``osid.Metadata``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.Metadata", 
               "errors": {}
            }, 
            {
               "name": "set_end_date", 
               "doc": {
                  "headline": "Sets the end date.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    date (osid.calendaring.DateTime): the new date\n", 
               "return_doc": "", 
               "error_doc": "        raise:  InvalidArgument - ``date`` is invalid\n        raise:  NoAccess - ``Metadata.isReadOnly()`` is ``true``\n        raise:  NullArgument - ``date`` is ``null``", 
               "sphinx_param_doc": "        :param date: the new date\n        :type date: ``osid.calendaring.DateTime``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``InvalidArgument`` -- ``date`` is invalid\n        :raise: ``NoAccess`` -- ``Metadata.isReadOnly()`` is ``true``\n        :raise: ``NullArgument`` -- ``date`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.calendaring.DateTime", 
                     "var_name": "date", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.calendaring.DateTime"
               ], 
               "return_type": "", 
               "errors": {
                  "INVALID_ARGUMENT": "ConsumerContract", 
                  "NO_ACCESS": "ConsumerContract", 
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "clear_end_date", 
               "doc": {
                  "headline": "Clears the end date.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "        raise:  NoAccess - ``Metadata.isRequired()`` or\n                ``Metadata.isReadOnly()`` is ``true``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NoAccess`` -- ``Metadata.isRequired()`` or ``Metadata.isReadOnly()`` is ``true``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {
                  "NO_ACCESS": "ConsumerContract"
               }
            }, 
            {
               "name": "get_interpolated_metadata", 
               "doc": {
                  "headline": "Gets the metadata for the interpolated flag.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.Metadata) - metadata for the interpolated flag", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: metadata for the interpolated flag\n        :rtype: ``osid.Metadata``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.Metadata", 
               "errors": {}
            }, 
            {
               "name": "set_interpolated", 
               "doc": {
                  "headline": "Sets the interpolated flag.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    interpolated (boolean): the new interpolated flag\n", 
               "return_doc": "", 
               "error_doc": "        raise:  InvalidArgument - ``interpolated`` is invalid\n        raise:  NoAccess - ``Metadata.isReadOnly()`` is ``true``", 
               "sphinx_param_doc": "        :param interpolated: the new interpolated flag\n        :type interpolated: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``InvalidArgument`` -- ``interpolated`` is invalid\n        :raise: ``NoAccess`` -- ``Metadata.isReadOnly()`` is ``true``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "boolean", 
                     "var_name": "interpolated", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {
                  "INVALID_ARGUMENT": "ConsumerContract", 
                  "NO_ACCESS": "ConsumerContract"
               }
            }, 
            {
               "name": "clear_interpolated", 
               "doc": {
                  "headline": "Clears the interpolated flag.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "        raise:  NoAccess - ``Metadata.isRequired()`` or\n                ``Metadata.isReadOnly()`` is ``true``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NoAccess`` -- ``Metadata.isRequired()`` or ``Metadata.isReadOnly()`` is ``true``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {
                  "NO_ACCESS": "ConsumerContract"
               }
            }, 
            {
               "name": "get_extrapolated_metadata", 
               "doc": {
                  "headline": "Gets the metadata for the extrapolated flag.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.Metadata) - metadata for the extrapolated flag", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: metadata for the extrapolated flag\n        :rtype: ``osid.Metadata``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.Metadata", 
               "errors": {}
            }, 
            {
               "name": "set_extrapolated", 
               "doc": {
                  "headline": "Sets the extrapolated flag.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    extrapolated (boolean): the new extrapolated flag\n", 
               "return_doc": "", 
               "error_doc": "        raise:  InvalidArgument - ``extrapolated`` is invalid\n        raise:  NoAccess - ``Metadata.isReadOnly()`` is ``true``", 
               "sphinx_param_doc": "        :param extrapolated: the new extrapolated flag\n        :type extrapolated: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``InvalidArgument`` -- ``extrapolated`` is invalid\n        :raise: ``NoAccess`` -- ``Metadata.isReadOnly()`` is ``true``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "boolean", 
                     "var_name": "extrapolated", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {
                  "INVALID_ARGUMENT": "ConsumerContract", 
                  "NO_ACCESS": "ConsumerContract"
               }
            }, 
            {
               "name": "clear_extrapolated", 
               "doc": {
                  "headline": "Clears the extrapolated flag.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "        raise:  NoAccess - ``Metadata.isRequired()`` or\n                ``Metadata.isReadOnly()`` is ``true``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NoAccess`` -- ``Metadata.isRequired()`` or ``Metadata.isReadOnly()`` is ``true``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {
                  "NO_ACCESS": "ConsumerContract"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.OsidCapsuleForm", 
         "shortname": "OsidCapsuleForm", 
         "category": "objects", 
         "doc": {
            "headline": "This form is used to create and update capsules.", 
            "body": ""
         }, 
         "inherit_fullnames": [
            "osid.OsidForm"
         ], 
         "inherit_shortnames": [
            "OsidForm"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidForm"
            }
         ], 
         "method_names": [], 
         "methods": []
      }, 
      {
         "fullname": "osid.OsidSearchOrder", 
         "shortname": "OsidSearchOrder", 
         "category": "search_orders", 
         "doc": {
            "headline": "``OsidSearchOrder`` specifies preferred ordering of search results.", 
            "body": "    An ``OsidSearchOrder`` is available from an search session and\n    supplied to an ``OsidSearch`` interface. OsidSearch os =\n    session.getObjectSearch(); os.limitResultSet(1, 25); OsidSearchOrder\n    order = session.getObjectSearchOrder(); order.orderByDisplayName();\n    os.orderResults(order); OsidQuery queru; query =\n    session.getObjectQuery(); query.addDescriptionMatch(\"*food*\",\n    wildcardStringMatchType, true); ObjectSearchResults results =\n    session.getObjectsBySearch(query, os); ObjectList list =\n    results.getObjectList();"
         }, 
         "inherit_fullnames": [
            "osid.Suppliable"
         ], 
         "inherit_shortnames": [
            "Suppliable"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "Suppliable"
            }
         ], 
         "method_names": [], 
         "methods": []
      }, 
      {
         "fullname": "osid.OsidIdentifiableSearchOrder", 
         "shortname": "OsidIdentifiableSearchOrder", 
         "category": "search_orders", 
         "doc": {
            "headline": "``OsidIdentifiableSearchOrder`` specifies preferred ordering of search results.", 
            "body": "    An ``OsidSearchOrder`` is available from an search session and\n    supplied to an ``OsidSearch``."
         }, 
         "inherit_fullnames": [
            "osid.OsidSearchOrder"
         ], 
         "inherit_shortnames": [
            "OsidSearchOrder"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidSearchOrder"
            }
         ], 
         "method_names": [
            "order_by_id"
         ], 
         "methods": [
            {
               "name": "order_by_id", 
               "doc": {
                  "headline": "Specifies a preference for ordering the result set by the ``Id``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    style (osid.SearchOrderStyle): the search order style\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``style`` is ``null``", 
               "sphinx_param_doc": "        :param style: the search order style\n        :type style: ``osid.SearchOrderStyle``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``style`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.SearchOrderStyle", 
                     "var_name": "style", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.SearchOrderStyle"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.OsidExtensibleSearchOrder", 
         "shortname": "OsidExtensibleSearchOrder", 
         "category": "search_orders", 
         "doc": {
            "headline": "``OsidExtensibleSearchOrder`` specifies preferred ordering of search results.", 
            "body": "    An ``OsidSearchOrder`` is available from an search session and\n    supplied to an ``OsidSearch``."
         }, 
         "inherit_fullnames": [
            "osid.OsidSearchOrder", 
            "osid.Extensible"
         ], 
         "inherit_shortnames": [
            "OsidSearchOrder", 
            "Extensible"
         ], 
         "inherit_pkg_names": [
            "osid", 
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidSearchOrder"
            }, 
            {
               "pkg_name": "osid", 
               "name": "Extensible"
            }
         ], 
         "method_names": [], 
         "methods": []
      }, 
      {
         "fullname": "osid.OsidBrowsableSearchOrder", 
         "shortname": "OsidBrowsableSearchOrder", 
         "category": "search_orders", 
         "doc": {
            "headline": "``OsidBrowsableSearchOrder`` specifies preferred ordering of search results.", 
            "body": "    An ``OsidSearchOrder`` is available from an search session and\n    supplied to an ``OsidSearch``."
         }, 
         "inherit_fullnames": [
            "osid.OsidSearchOrder"
         ], 
         "inherit_shortnames": [
            "OsidSearchOrder"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidSearchOrder"
            }
         ], 
         "method_names": [], 
         "methods": []
      }, 
      {
         "fullname": "osid.OsidTemporalSearchOrder", 
         "shortname": "OsidTemporalSearchOrder", 
         "category": "search_orders", 
         "doc": {
            "headline": "An interface for specifying the ordering of search results.", 
            "body": ""
         }, 
         "inherit_fullnames": [
            "osid.OsidSearchOrder"
         ], 
         "inherit_shortnames": [
            "OsidSearchOrder"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidSearchOrder"
            }
         ], 
         "method_names": [
            "order_by_effective", 
            "order_by_start_date", 
            "order_by_end_date"
         ], 
         "methods": [
            {
               "name": "order_by_effective", 
               "doc": {
                  "headline": "Specifies a preference for ordering the result set by the effective status.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    style (osid.SearchOrderStyle): the search order style\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``style`` is ``null``", 
               "sphinx_param_doc": "        :param style: the search order style\n        :type style: ``osid.SearchOrderStyle``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``style`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.SearchOrderStyle", 
                     "var_name": "style", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.SearchOrderStyle"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "order_by_start_date", 
               "doc": {
                  "headline": "Specifies a preference for ordering the result set by the start date.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    style (osid.SearchOrderStyle): the search order style\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``style`` is ``null``", 
               "sphinx_param_doc": "        :param style: the search order style\n        :type style: ``osid.SearchOrderStyle``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``style`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.SearchOrderStyle", 
                     "var_name": "style", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.SearchOrderStyle"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "order_by_end_date", 
               "doc": {
                  "headline": "Specifies a preference for ordering the result set by the end date.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    style (osid.SearchOrderStyle): the search order style\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``style`` is ``null``", 
               "sphinx_param_doc": "        :param style: the search order style\n        :type style: ``osid.SearchOrderStyle``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``style`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.SearchOrderStyle", 
                     "var_name": "style", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.SearchOrderStyle"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.OsidSubjugateableSearchOrder", 
         "shortname": "OsidSubjugateableSearchOrder", 
         "category": "search_orders", 
         "doc": {
            "headline": "An interface for specifying the ordering of dependent object search results.", 
            "body": ""
         }, 
         "inherit_fullnames": [
            "osid.OsidSearchOrder"
         ], 
         "inherit_shortnames": [
            "OsidSearchOrder"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidSearchOrder"
            }
         ], 
         "method_names": [], 
         "methods": []
      }, 
      {
         "fullname": "osid.OsidAggregateableSearchOrder", 
         "shortname": "OsidAggregateableSearchOrder", 
         "category": "search_orders", 
         "doc": {
            "headline": "An interface for specifying the ordering of assemblage search results.", 
            "body": ""
         }, 
         "inherit_fullnames": [
            "osid.OsidSearchOrder"
         ], 
         "inherit_shortnames": [
            "OsidSearchOrder"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidSearchOrder"
            }
         ], 
         "method_names": [], 
         "methods": []
      }, 
      {
         "fullname": "osid.OsidContainableSearchOrder", 
         "shortname": "OsidContainableSearchOrder", 
         "category": "search_orders", 
         "doc": {
            "headline": "An interface for specifying the ordering of search results.", 
            "body": ""
         }, 
         "inherit_fullnames": [
            "osid.OsidAggregateableSearchOrder"
         ], 
         "inherit_shortnames": [
            "OsidAggregateableSearchOrder"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidAggregateableSearchOrder"
            }
         ], 
         "method_names": [
            "order_by_sequestered"
         ], 
         "methods": [
            {
               "name": "order_by_sequestered", 
               "doc": {
                  "headline": "Specifies a preference for ordering the result set by the sequestered flag.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    style (osid.SearchOrderStyle): the search order style\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``style`` is ``null``", 
               "sphinx_param_doc": "        :param style: the search order style\n        :type style: ``osid.SearchOrderStyle``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``style`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.SearchOrderStyle", 
                     "var_name": "style", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.SearchOrderStyle"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.OsidSourceableSearchOrder", 
         "shortname": "OsidSourceableSearchOrder", 
         "category": "search_orders", 
         "doc": {
            "headline": "An interface for specifying the ordering of search results.", 
            "body": ""
         }, 
         "inherit_fullnames": [
            "osid.OsidSearchOrder"
         ], 
         "inherit_shortnames": [
            "OsidSearchOrder"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidSearchOrder"
            }
         ], 
         "method_names": [
            "order_by_provider", 
            "supports_provider_search_order", 
            "get_provider_search_order"
         ], 
         "methods": [
            {
               "name": "order_by_provider", 
               "doc": {
                  "headline": "Specifies a preference for ordering the results by provider.", 
                  "body": "        The element of the provider to order is not specified but may be\n        managed through the provider ordering interface."
               }, 
               "arg_doc": "        arg:    style (osid.SearchOrderStyle): search order style\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``style`` is ``null``", 
               "sphinx_param_doc": "        :param style: search order style\n        :type style: ``osid.SearchOrderStyle``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``style`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.SearchOrderStyle", 
                     "var_name": "style", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.SearchOrderStyle"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "supports_provider_search_order", 
               "doc": {
                  "headline": "Tests if a ``ProviderSearchOrder`` interface is available.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if a provider search order\n                interface is available, ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if a provider search order interface is available, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "get_provider_search_order", 
               "doc": {
                  "headline": "Gets the search order interface for a provider.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.resource.ResourceSearchOrder) - the provider\n                search order interface", 
               "error_doc": "        raise:  Unimplemented - ``supports_provider_search_order()`` is\n                ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the provider search order interface\n        :rtype: ``osid.resource.ResourceSearchOrder``", 
               "sphinx_error_doc": "        :raise: ``Unimplemented`` -- ``supports_provider_search_order()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_provider_search_order()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.resource.ResourceSearchOrder", 
               "errors": {
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.OsidFederateableSearchOrder", 
         "shortname": "OsidFederateableSearchOrder", 
         "category": "search_orders", 
         "doc": {
            "headline": "An interface for specifying the ordering of search results.", 
            "body": ""
         }, 
         "inherit_fullnames": [
            "osid.OsidSearchOrder"
         ], 
         "inherit_shortnames": [
            "OsidSearchOrder"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidSearchOrder"
            }
         ], 
         "method_names": [], 
         "methods": []
      }, 
      {
         "fullname": "osid.OsidOperableSearchOrder", 
         "shortname": "OsidOperableSearchOrder", 
         "category": "search_orders", 
         "doc": {
            "headline": "An interface for specifying the ordering of search results.", 
            "body": ""
         }, 
         "inherit_fullnames": [
            "osid.OsidSearchOrder"
         ], 
         "inherit_shortnames": [
            "OsidSearchOrder"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidSearchOrder"
            }
         ], 
         "method_names": [
            "order_by_active", 
            "order_by_enabled", 
            "order_by_disabled", 
            "order_by_operational"
         ], 
         "methods": [
            {
               "name": "order_by_active", 
               "doc": {
                  "headline": "Specifies a preference for ordering the result set by the active status.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    style (osid.SearchOrderStyle): the search order style\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``style`` is ``null``", 
               "sphinx_param_doc": "        :param style: the search order style\n        :type style: ``osid.SearchOrderStyle``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``style`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.SearchOrderStyle", 
                     "var_name": "style", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.SearchOrderStyle"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "order_by_enabled", 
               "doc": {
                  "headline": "Specifies a preference for ordering the result set by the administratively enabled status.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    style (osid.SearchOrderStyle): the search order style\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``style`` is ``null``", 
               "sphinx_param_doc": "        :param style: the search order style\n        :type style: ``osid.SearchOrderStyle``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``style`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.SearchOrderStyle", 
                     "var_name": "style", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.SearchOrderStyle"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "order_by_disabled", 
               "doc": {
                  "headline": "Specifies a preference for ordering the result set by the administratively disabled status.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    style (osid.SearchOrderStyle): the search order style\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``style`` is ``null``", 
               "sphinx_param_doc": "        :param style: the search order style\n        :type style: ``osid.SearchOrderStyle``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``style`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.SearchOrderStyle", 
                     "var_name": "style", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.SearchOrderStyle"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "order_by_operational", 
               "doc": {
                  "headline": "Specifies a preference for ordering the results by the operational status.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    style (osid.SearchOrderStyle): search order style\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``style`` is ``null``", 
               "sphinx_param_doc": "        :param style: search order style\n        :type style: ``osid.SearchOrderStyle``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``style`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.SearchOrderStyle", 
                     "var_name": "style", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.SearchOrderStyle"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.OsidObjectSearchOrder", 
         "shortname": "OsidObjectSearchOrder", 
         "category": "search_orders", 
         "doc": {
            "headline": "``OsidObjectSearchOrder`` specifies preferred ordering of search results.", 
            "body": "    An ``OsidSearchOrder`` is available from an search session and\n    supplied to an ``OsidSearch``. OsidObjectSearch os =\n    session.getObjectSearch(); os.limitResultSet(1, 25);\n    OsidObjectSearchOrder order = session.getObjectSearchOrder();\n    order.orderByDisplayName(); os.orderResults(order); OsidObjectQuery\n    query; query = session.getObjectQuery();\n    query.addDescriptionMatch(\"*food*\", wildcardStringMatchType, true);\n    ObjectSearchResults results = session.getObjectsBySearch(query, os);\n    ObjectList list = results.getObjectList();"
         }, 
         "inherit_fullnames": [
            "osid.OsidIdentifiableSearchOrder", 
            "osid.OsidExtensibleSearchOrder", 
            "osid.OsidBrowsableSearchOrder"
         ], 
         "inherit_shortnames": [
            "OsidIdentifiableSearchOrder", 
            "OsidExtensibleSearchOrder", 
            "OsidBrowsableSearchOrder"
         ], 
         "inherit_pkg_names": [
            "osid", 
            "osid", 
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidIdentifiableSearchOrder"
            }, 
            {
               "pkg_name": "osid", 
               "name": "OsidExtensibleSearchOrder"
            }, 
            {
               "pkg_name": "osid", 
               "name": "OsidBrowsableSearchOrder"
            }
         ], 
         "method_names": [
            "order_by_display_name", 
            "order_by_description", 
            "order_by_genus_type", 
            "order_by_state", 
            "order_by_cumulative_rating", 
            "order_by_statistic", 
            "order_by_create_time", 
            "order_by_last_modified_time"
         ], 
         "methods": [
            {
               "name": "order_by_display_name", 
               "doc": {
                  "headline": "Specifies a preference for ordering the result set by the display name.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    style (osid.SearchOrderStyle): search order style\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``style`` is ``null``", 
               "sphinx_param_doc": "        :param style: search order style\n        :type style: ``osid.SearchOrderStyle``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``style`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.SearchOrderStyle", 
                     "var_name": "style", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.SearchOrderStyle"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "order_by_description", 
               "doc": {
                  "headline": "Specifies a preference for ordering the result set by the description.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    style (osid.SearchOrderStyle): search order style\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``style`` is ``null``", 
               "sphinx_param_doc": "        :param style: search order style\n        :type style: ``osid.SearchOrderStyle``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``style`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.SearchOrderStyle", 
                     "var_name": "style", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.SearchOrderStyle"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "order_by_genus_type", 
               "doc": {
                  "headline": "Specifies a preference for ordering the result set by the genus type.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    style (osid.SearchOrderStyle): search order style\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``style`` is ``null``", 
               "sphinx_param_doc": "        :param style: search order style\n        :type style: ``osid.SearchOrderStyle``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``style`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.SearchOrderStyle", 
                     "var_name": "style", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.SearchOrderStyle"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "order_by_state", 
               "doc": {
                  "headline": "Orders by the state in a given ``Process``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    process_id (osid.id.Id): a process ``Id``\n        arg:    style (osid.SearchOrderStyle): search order style\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``process_id`` or ``style`` is ``null``", 
               "sphinx_param_doc": "        :param process_id: a process ``Id``\n        :type process_id: ``osid.id.Id``\n        :param style: search order style\n        :type style: ``osid.SearchOrderStyle``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``process_id`` or ``style`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "process_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.SearchOrderStyle", 
                     "var_name": "style", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "osid.SearchOrderStyle"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "order_by_cumulative_rating", 
               "doc": {
                  "headline": "Orders by the cumulative rating in a given ``Book``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    book_id (osid.id.Id): a book ``Id``\n        arg:    style (osid.SearchOrderStyle): search order style\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``book_id`` or ``style`` is ``null``", 
               "sphinx_param_doc": "        :param book_id: a book ``Id``\n        :type book_id: ``osid.id.Id``\n        :param style: search order style\n        :type style: ``osid.SearchOrderStyle``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``book_id`` or ``style`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "book_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.SearchOrderStyle", 
                     "var_name": "style", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "osid.SearchOrderStyle"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "order_by_statistic", 
               "doc": {
                  "headline": "Orders by a statistic for a given ``Meter``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    meter_id (osid.id.Id): a meter ``Id``\n        arg:    style (osid.SearchOrderStyle): search order style\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``meter_id`` or ``style`` is ``null``", 
               "sphinx_param_doc": "        :param meter_id: a meter ``Id``\n        :type meter_id: ``osid.id.Id``\n        :param style: search order style\n        :type style: ``osid.SearchOrderStyle``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``meter_id`` or ``style`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "meter_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.SearchOrderStyle", 
                     "var_name": "style", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "osid.SearchOrderStyle"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "order_by_create_time", 
               "doc": {
                  "headline": "Orders by the timestamp of the first journal entry.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    style (osid.SearchOrderStyle): search order style\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``style`` is ``null``", 
               "sphinx_param_doc": "        :param style: search order style\n        :type style: ``osid.SearchOrderStyle``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``style`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.SearchOrderStyle", 
                     "var_name": "style", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.SearchOrderStyle"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "order_by_last_modified_time", 
               "doc": {
                  "headline": "Orders by the timestamp of the last journal entry.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    style (osid.SearchOrderStyle): search order style\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``style`` is ``null``", 
               "sphinx_param_doc": "        :param style: search order style\n        :type style: ``osid.SearchOrderStyle``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``style`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.SearchOrderStyle", 
                     "var_name": "style", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.SearchOrderStyle"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.OsidRelationshipSearchOrder", 
         "shortname": "OsidRelationshipSearchOrder", 
         "category": "search_orders", 
         "doc": {
            "headline": "An interface for specifying the ordering of search results.", 
            "body": ""
         }, 
         "inherit_fullnames": [
            "osid.OsidObjectSearchOrder", 
            "osid.OsidTemporalSearchOrder"
         ], 
         "inherit_shortnames": [
            "OsidObjectSearchOrder", 
            "OsidTemporalSearchOrder"
         ], 
         "inherit_pkg_names": [
            "osid", 
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidObjectSearchOrder"
            }, 
            {
               "pkg_name": "osid", 
               "name": "OsidTemporalSearchOrder"
            }
         ], 
         "method_names": [
            "order_by_end_reason", 
            "supports_end_reason_search_order", 
            "get_end_reason_search_order"
         ], 
         "methods": [
            {
               "name": "order_by_end_reason", 
               "doc": {
                  "headline": "Specifies a preference for ordering the results by the end reason state.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    style (osid.SearchOrderStyle): search order style\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``style`` is ``null``", 
               "sphinx_param_doc": "        :param style: search order style\n        :type style: ``osid.SearchOrderStyle``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``style`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.SearchOrderStyle", 
                     "var_name": "style", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.SearchOrderStyle"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "supports_end_reason_search_order", 
               "doc": {
                  "headline": "Tests if a ``StateSearchOrder`` is available.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if a state search order is\n                available, ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if a state search order is available, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "get_end_reason_search_order", 
               "doc": {
                  "headline": "Gets the search order for a state.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.process.StateSearchOrder) - the state search order", 
               "error_doc": "        raise:  Unimplemented - ``supports_end_reason_search_order()``\n                is ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the state search order\n        :rtype: ``osid.process.StateSearchOrder``", 
               "sphinx_error_doc": "        :raise: ``Unimplemented`` -- ``supports_end_reason_search_order()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_end_reason_search_order()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.process.StateSearchOrder", 
               "errors": {
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.OsidCatalogSearchOrder", 
         "shortname": "OsidCatalogSearchOrder", 
         "category": "search_orders", 
         "doc": {
            "headline": "An interface for specifying the ordering of catalog search results.", 
            "body": ""
         }, 
         "inherit_fullnames": [
            "osid.OsidObjectSearchOrder", 
            "osid.OsidSourceableSearchOrder", 
            "osid.OsidFederateableSearchOrder"
         ], 
         "inherit_shortnames": [
            "OsidObjectSearchOrder", 
            "OsidSourceableSearchOrder", 
            "OsidFederateableSearchOrder"
         ], 
         "inherit_pkg_names": [
            "osid", 
            "osid", 
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidObjectSearchOrder"
            }, 
            {
               "pkg_name": "osid", 
               "name": "OsidSourceableSearchOrder"
            }, 
            {
               "pkg_name": "osid", 
               "name": "OsidFederateableSearchOrder"
            }
         ], 
         "method_names": [], 
         "methods": []
      }, 
      {
         "fullname": "osid.OsidRuleSearchOrder", 
         "shortname": "OsidRuleSearchOrder", 
         "category": "search_orders", 
         "doc": {
            "headline": "An interface for specifying the ordering of search results.", 
            "body": ""
         }, 
         "inherit_fullnames": [
            "osid.OsidObjectSearchOrder", 
            "osid.OsidOperableSearchOrder"
         ], 
         "inherit_shortnames": [
            "OsidObjectSearchOrder", 
            "OsidOperableSearchOrder"
         ], 
         "inherit_pkg_names": [
            "osid", 
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidObjectSearchOrder"
            }, 
            {
               "pkg_name": "osid", 
               "name": "OsidOperableSearchOrder"
            }
         ], 
         "method_names": [
            "order_by_rule", 
            "supports_rule_search_order", 
            "get_rule_search_order"
         ], 
         "methods": [
            {
               "name": "order_by_rule", 
               "doc": {
                  "headline": "Specifies a preference for ordering the results by the associated rule.", 
                  "body": "        The element of the rule to order is not specified but may be\n        managed through a ``RuleSearchOrder``."
               }, 
               "arg_doc": "        arg:    style (osid.SearchOrderStyle): search order style\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``style`` is ``null``", 
               "sphinx_param_doc": "        :param style: search order style\n        :type style: ``osid.SearchOrderStyle``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``style`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.SearchOrderStyle", 
                     "var_name": "style", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.SearchOrderStyle"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "supports_rule_search_order", 
               "doc": {
                  "headline": "Tests if a ``RuleSearchOrder`` is available.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if a rule search order is\n                available, ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if a rule search order is available, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "get_rule_search_order", 
               "doc": {
                  "headline": "Gets the search order for a rule.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.rules.RuleSearchOrder) - the rule search order", 
               "error_doc": "        raise:  Unimplemented - ``supports_rule_search_order()`` is\n                ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the rule search order\n        :rtype: ``osid.rules.RuleSearchOrder``", 
               "sphinx_error_doc": "        :raise: ``Unimplemented`` -- ``supports_rule_search_order()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_rule_search_order()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.rules.RuleSearchOrder", 
               "errors": {
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.OsidEnablerSearchOrder", 
         "shortname": "OsidEnablerSearchOrder", 
         "category": "search_orders", 
         "doc": {
            "headline": "An interface for specifying the ordering of search results.", 
            "body": ""
         }, 
         "inherit_fullnames": [
            "osid.OsidRuleSearchOrder", 
            "osid.OsidTemporalSearchOrder"
         ], 
         "inherit_shortnames": [
            "OsidRuleSearchOrder", 
            "OsidTemporalSearchOrder"
         ], 
         "inherit_pkg_names": [
            "osid", 
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidRuleSearchOrder"
            }, 
            {
               "pkg_name": "osid", 
               "name": "OsidTemporalSearchOrder"
            }
         ], 
         "method_names": [
            "order_by_schedule", 
            "supports_schedule_search_order", 
            "get_schedule_search_order", 
            "order_by_event", 
            "supports_event_search_order", 
            "get_event_search_order", 
            "order_by_cyclic_event", 
            "supports_cyclic_event_search_order", 
            "get_cyclic_event_search_order", 
            "order_by_demographic", 
            "supports_demographic_search_order", 
            "get_demographic_search_order"
         ], 
         "methods": [
            {
               "name": "order_by_schedule", 
               "doc": {
                  "headline": "Specifies a preference for ordering the results by the associated schedule.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    style (osid.SearchOrderStyle): search order style\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``style`` is ``null``", 
               "sphinx_param_doc": "        :param style: search order style\n        :type style: ``osid.SearchOrderStyle``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``style`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.SearchOrderStyle", 
                     "var_name": "style", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.SearchOrderStyle"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "supports_schedule_search_order", 
               "doc": {
                  "headline": "Tests if a ``ScheduleSearchOrder`` is available.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if a schedule search order is\n                available, ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if a schedule search order is available, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "get_schedule_search_order", 
               "doc": {
                  "headline": "Gets the search order for a schedule.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.ScheduleSearchOrder) - the schedule\n                search order", 
               "error_doc": "        raise:  Unimplemented - ``supports_schedule_search_order() is\n                false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the schedule search order\n        :rtype: ``osid.calendaring.ScheduleSearchOrder``", 
               "sphinx_error_doc": "        :raise: ``Unimplemented`` -- ``supports_schedule_search_order() is false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_schedule_search_order()`` is true.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.ScheduleSearchOrder", 
               "errors": {
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "order_by_event", 
               "doc": {
                  "headline": "Specifies a preference for ordering the results by the associated event.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    style (osid.SearchOrderStyle): search order style\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``style`` is ``null``", 
               "sphinx_param_doc": "        :param style: search order style\n        :type style: ``osid.SearchOrderStyle``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``style`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.SearchOrderStyle", 
                     "var_name": "style", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.SearchOrderStyle"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "supports_event_search_order", 
               "doc": {
                  "headline": "Tests if an ``EventSearchOrder`` is available.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if an event search order is\n                available, ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if an event search order is available, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "get_event_search_order", 
               "doc": {
                  "headline": "Gets the search order for an event.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.EventSearchOrder) - the event search\n                order", 
               "error_doc": "        raise:  Unimplemented - ``supports_event_search_order() is\n                false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the event search order\n        :rtype: ``osid.calendaring.EventSearchOrder``", 
               "sphinx_error_doc": "        :raise: ``Unimplemented`` -- ``supports_event_search_order() is false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_event_search_order()`` is true.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.EventSearchOrder", 
               "errors": {
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "order_by_cyclic_event", 
               "doc": {
                  "headline": "Orders the results by cyclic event.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    style (osid.SearchOrderStyle): search order style\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``style`` is ``null``", 
               "sphinx_param_doc": "        :param style: search order style\n        :type style: ``osid.SearchOrderStyle``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``style`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.SearchOrderStyle", 
                     "var_name": "style", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.SearchOrderStyle"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "supports_cyclic_event_search_order", 
               "doc": {
                  "headline": "Tests if a cyclic event search order is available.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if a cyclic event search order is\n                available, ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if a cyclic event search order is available, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "get_cyclic_event_search_order", 
               "doc": {
                  "headline": "Gets the cyclic event search order.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.cycle.CyclicEventSearchOrder) - the\n                cyclic event search order", 
               "error_doc": "        raise:  IllegalState - ``supports_cyclic_event_search_order()``\n                is ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the cyclic event search order\n        :rtype: ``osid.calendaring.cycle.CyclicEventSearchOrder``", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- ``supports_cyclic_event_search_order()`` is ``false``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.cycle.CyclicEventSearchOrder", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract"
               }
            }, 
            {
               "name": "order_by_demographic", 
               "doc": {
                  "headline": "Specifies a preference for ordering the results by the associated demographic resource.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    style (osid.SearchOrderStyle): search order style\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``style`` is ``null``", 
               "sphinx_param_doc": "        :param style: search order style\n        :type style: ``osid.SearchOrderStyle``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``style`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.SearchOrderStyle", 
                     "var_name": "style", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.SearchOrderStyle"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "supports_demographic_search_order", 
               "doc": {
                  "headline": "Tests if a ``ResourceSearchOrder`` is available.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if a resource search order is\n                available, ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if a resource search order is available, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "get_demographic_search_order", 
               "doc": {
                  "headline": "Gets the search order for a demographic resource.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.resource.ResourceSearchOrder) - the resource\n                search order", 
               "error_doc": "        raise:  Unimplemented - ``supports_demographic_search_order()``\n                is ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the resource search order\n        :rtype: ``osid.resource.ResourceSearchOrder``", 
               "sphinx_error_doc": "        :raise: ``Unimplemented`` -- ``supports_demographic_search_order()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_demographic_search_order()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.resource.ResourceSearchOrder", 
               "errors": {
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.OsidConstrainerSearchOrder", 
         "shortname": "OsidConstrainerSearchOrder", 
         "category": "search_orders", 
         "doc": {
            "headline": "An interface for specifying the ordering of search results.", 
            "body": ""
         }, 
         "inherit_fullnames": [
            "osid.OsidRuleSearchOrder"
         ], 
         "inherit_shortnames": [
            "OsidRuleSearchOrder"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidRuleSearchOrder"
            }
         ], 
         "method_names": [], 
         "methods": []
      }, 
      {
         "fullname": "osid.OsidProcessorSearchOrder", 
         "shortname": "OsidProcessorSearchOrder", 
         "category": "search_orders", 
         "doc": {
            "headline": "An interface for specifying the ordering of search results.", 
            "body": ""
         }, 
         "inherit_fullnames": [
            "osid.OsidRuleSearchOrder"
         ], 
         "inherit_shortnames": [
            "OsidRuleSearchOrder"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidRuleSearchOrder"
            }
         ], 
         "method_names": [], 
         "methods": []
      }, 
      {
         "fullname": "osid.OsidGovernatorSearchOrder", 
         "shortname": "OsidGovernatorSearchOrder", 
         "category": "search_orders", 
         "doc": {
            "headline": "An interface for specifying the ordering of search results.", 
            "body": ""
         }, 
         "inherit_fullnames": [
            "osid.OsidObjectSearchOrder", 
            "osid.OsidOperableSearchOrder", 
            "osid.OsidSourceableSearchOrder"
         ], 
         "inherit_shortnames": [
            "OsidObjectSearchOrder", 
            "OsidOperableSearchOrder", 
            "OsidSourceableSearchOrder"
         ], 
         "inherit_pkg_names": [
            "osid", 
            "osid", 
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidObjectSearchOrder"
            }, 
            {
               "pkg_name": "osid", 
               "name": "OsidOperableSearchOrder"
            }, 
            {
               "pkg_name": "osid", 
               "name": "OsidSourceableSearchOrder"
            }
         ], 
         "method_names": [], 
         "methods": []
      }, 
      {
         "fullname": "osid.OsidCompendiumSearchOrder", 
         "shortname": "OsidCompendiumSearchOrder", 
         "category": "search_orders", 
         "doc": {
            "headline": "An interface for specifying the ordering of search results.", 
            "body": ""
         }, 
         "inherit_fullnames": [
            "osid.OsidObjectSearchOrder", 
            "osid.OsidSubjugateableSearchOrder"
         ], 
         "inherit_shortnames": [
            "OsidObjectSearchOrder", 
            "OsidSubjugateableSearchOrder"
         ], 
         "inherit_pkg_names": [
            "osid", 
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidObjectSearchOrder"
            }, 
            {
               "pkg_name": "osid", 
               "name": "OsidSubjugateableSearchOrder"
            }
         ], 
         "method_names": [
            "order_by_start_date", 
            "order_by_end_date", 
            "order_by_interpolated", 
            "order_by_extrapolated"
         ], 
         "methods": [
            {
               "name": "order_by_start_date", 
               "doc": {
                  "headline": "Specifies a preference for ordering the result set by the start date.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    style (osid.SearchOrderStyle): the search order style\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``style`` is ``null``", 
               "sphinx_param_doc": "        :param style: the search order style\n        :type style: ``osid.SearchOrderStyle``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``style`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.SearchOrderStyle", 
                     "var_name": "style", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.SearchOrderStyle"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "order_by_end_date", 
               "doc": {
                  "headline": "Specifies a preference for ordering the result set by the end date.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    style (osid.SearchOrderStyle): the search order style\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``style`` is ``null``", 
               "sphinx_param_doc": "        :param style: the search order style\n        :type style: ``osid.SearchOrderStyle``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``style`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.SearchOrderStyle", 
                     "var_name": "style", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.SearchOrderStyle"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "order_by_interpolated", 
               "doc": {
                  "headline": "Specifies a preference for ordering the result set by interpolated results.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    style (osid.SearchOrderStyle): the search order style\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``style`` is ``null``", 
               "sphinx_param_doc": "        :param style: the search order style\n        :type style: ``osid.SearchOrderStyle``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``style`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.SearchOrderStyle", 
                     "var_name": "style", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.SearchOrderStyle"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "order_by_extrapolated", 
               "doc": {
                  "headline": "Specifies a preference for ordering the result set by extrapolated results.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    style (osid.SearchOrderStyle): the search order style\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``style`` is ``null``", 
               "sphinx_param_doc": "        :param style: the search order style\n        :type style: ``osid.SearchOrderStyle``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``style`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.SearchOrderStyle", 
                     "var_name": "style", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.SearchOrderStyle"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.OsidCapsuleSearchOrder", 
         "shortname": "OsidCapsuleSearchOrder", 
         "category": "search_orders", 
         "doc": {
            "headline": "An interface for specifying the ordering of search results.", 
            "body": ""
         }, 
         "inherit_fullnames": [
            "osid.OsidSearchOrder"
         ], 
         "inherit_shortnames": [
            "OsidSearchOrder"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidSearchOrder"
            }
         ], 
         "method_names": [], 
         "methods": []
      }, 
      {
         "fullname": "osid.OsidSearch", 
         "shortname": "OsidSearch", 
         "category": "searches", 
         "doc": {
            "headline": "``OsidSearch`` specifies search options used to perform OSID searches.", 
            "body": "    An ``OsidSearch`` is available from an ``OsidSession`` and defines\n    methods to govern the overall search of terms supplied in one or\n    more ``OsidQuery`` interfaces.\n\n    This interface is available from a search session.Example using the\n    search interface to retrieve the first 25 results:\n      OsidSearch os = session.getObjectSearch();\n      os.limitResultSet(1, 25);\n      \n      OsidQuery query;\n      query = session.getObjectQuery();\n      query.addDescriptionMatch(\"*food*\", wildcardStringMatchType, true);\n      \n      ObjectSearchResults results = session.getObjectsBySearch(query, os);\n      ObjectList list = results.getObjectList();\n    \n"
         }, 
         "inherit_fullnames": [
            "osid.OsidCondition"
         ], 
         "inherit_shortnames": [
            "OsidCondition"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidCondition"
            }
         ], 
         "method_names": [
            "limit_result_set"
         ], 
         "methods": [
            {
               "name": "limit_result_set", 
               "doc": {
                  "headline": "By default, searches return all matching results.", 
                  "body": "        This method restricts the number of results by setting the start\n        and end of the result set, starting from 1. The starting and\n        ending results can be used for paging results when a certain\n        ordering is requested. The ending position must be greater than\n        the starting position."
               }, 
               "arg_doc": "        arg:    start (cardinal): the start of the result set\n        arg:    end (cardinal): the end of the result set\n", 
               "return_doc": "", 
               "error_doc": "        raise:  InvalidArgument - ``end`` is less than or equal to\n                ``start``", 
               "sphinx_param_doc": "        :param start: the start of the result set\n        :type start: ``cardinal``\n        :param end: the end of the result set\n        :type end: ``cardinal``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``InvalidArgument`` -- ``end`` is less than or equal to ``start``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "cardinal", 
                     "var_name": "start", 
                     "array": false
                  }, 
                  {
                     "arg_type": "cardinal", 
                     "var_name": "end", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "cardinal", 
                  "cardinal"
               ], 
               "return_type": "", 
               "errors": {
                  "INVALID_ARGUMENT": "ConsumerContract"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.OsidSearchResults", 
         "shortname": "OsidSearchResults", 
         "category": "searches", 
         "doc": {
            "headline": "This interface provides a means to capture results of a search.", 
            "body": "    An example of searching withina result set: OsidSearch os =\n    session.getObjectSearch(); OsidQuery query; query =\n    session.getObjectQuery(); query.matchDescription(\"*food*\",\n    wildcardStringMatchType, true); ObjectSearchResults results =\n    session.getObjectBySearch(query, os); // get information about\n    search ObjectList objects = results.getObjects(); int size =\n    results.getResultSize(); SearchPerformanceRecord record =\n    (SearchPerformanceRecord)\n    results.getObjectSearchResultsRecord(performanceRecodType); Duration\n    duration = record.getTimeForSearch();"
         }, 
         "inherit_fullnames": [
            "osid.OsidResult"
         ], 
         "inherit_shortnames": [
            "OsidResult"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidResult"
            }
         ], 
         "method_names": [
            "get_result_size"
         ], 
         "methods": [
            {
               "name": "get_result_size", 
               "doc": {
                  "headline": "Returns the size of a result set from a search query.", 
                  "body": "        This number serves as an estimate to provide feedback for\n        refining search queries and may not be the number of elements\n        available through an ``OsidList``."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (cardinal) - the result size", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the result size\n        :rtype: ``cardinal``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "cardinal", 
               "errors": {}
            }
         ]
      }, 
      {
         "fullname": "osid.OsidReceiver", 
         "shortname": "OsidReceiver", 
         "category": "receivers", 
         "doc": {
            "headline": "An ``OsidReceiver`` is used to receive asynchronous notifications from a service.", 
            "body": "    The receiver defines the interface to be implemented by the\n    consumer."
         }, 
         "inherit_fullnames": [], 
         "inherit_shortnames": [], 
         "inherit_pkg_names": [], 
         "inheritance": [], 
         "method_names": [
            "up", 
            "down"
         ], 
         "methods": [
            {
               "name": "up", 
               "doc": {
                  "headline": "The callback for notifications that the notification bus is operational.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "down", 
               "doc": {
                  "headline": "The callback for notifications that the notification bus is not operating.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }
         ]
      }, 
      {
         "fullname": "osid.OsidList", 
         "shortname": "OsidList", 
         "category": "objects", 
         "doc": {
            "headline": "``OsidList`` is the top-level interface for all OSID lists.", 
            "body": "    An OSID list provides sequential access, one at a time or many at a\n    time, access to a set of elements. These elements are not required\n    to be OsidObjects but generally are. The element retrieval methods\n    are defined in the sub-interface of ``OsidList`` where the\n    appropriate return type is defined.\n\n    Osid lists are a once pass through iteration of elements. The size\n    of the object set and the means in which the element set is\n    generated or stored is not known. Assumptions based on the length of\n    the element set by copying the entire contents of the list into a\n    fixed buffer should be done with caution a awareness that an\n    implementation may return a number of elements ranging from zero to\n    infinity.\n    \n    Lists are returned by methods when multiple return values are\n    possible. There is no guarantee that successive calls to the same\n    method will return the same set of elements in a list. Unless an\n    order is specified in an interface definition, the order of the\n    elements is not known."
         }, 
         "inherit_fullnames": [], 
         "inherit_shortnames": [], 
         "inherit_pkg_names": [], 
         "inheritance": [], 
         "method_names": [
            "has_next", 
            "available", 
            "skip"
         ], 
         "methods": [
            {
               "name": "has_next", 
               "doc": {
                  "headline": "Tests if there are more elements in this list.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if more elements are available in\n                this list, ``false`` if the end of the list has been\n                reached", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if more elements are available in this list, ``false`` if the end of the list has been reached\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "        *implementation notes*: Any errors that may result from accesing\n        the underlying set of elements are to be deferred until the\n        consumer attempts retrieval in which case the provider must\n        return ``true`` for this method.\n", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "available", 
               "doc": {
                  "headline": "Gets the number of elements available for retrieval.", 
                  "body": "        The number returned by this method may be less than or equal to\n        the total number of elements in this list. To determine if the\n        end of the list has been reached, the method ``has_next()``\n        should be used. This method conveys what is known about the\n        number of remaining elements at a point in time and can be used\n        to determine a minimum size of the remaining elements, if known.\n        A valid return is zero even if ``has_next()`` is true.\n\n        This method does not imply asynchronous usage. All OSID methods\n        may block."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (cardinal) - the number of elements available for\n                retrieval", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the number of elements available for retrieval\n        :rtype: ``cardinal``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "        *implementation notes*: Any errors that may result from accesing\n        the underlying set of elements are to be deferred until the\n        consumer attempts retrieval in which case the provider must\n        return a positive integer for this method so the consumer can\n        continue execution to receive the error. In all other\n        circumstances, the provider must not return a number greater\n        than the number of elements known since this number will be fed\n        as a parameter to the bulk retrieval method.\n", 
               "args": [], 
               "arg_types": [], 
               "return_type": "cardinal", 
               "errors": {}
            }, 
            {
               "name": "skip", 
               "doc": {
                  "headline": "Skip the specified number of elements in the list.", 
                  "body": "        If the number skipped is greater than the number of elements in\n        the list, hasNext() becomes false and available() returns zero\n        as there are no more elements to retrieve."
               }, 
               "arg_doc": "        arg:    n (cardinal): the number of elements to skip\n", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "        :param n: the number of elements to skip\n        :type n: ``cardinal``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "cardinal", 
                     "var_name": "n", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "cardinal"
               ], 
               "return_type": "", 
               "errors": {}
            }
         ]
      }, 
      {
         "fullname": "osid.OsidNode", 
         "shortname": "OsidNode", 
         "category": "objects", 
         "doc": {
            "headline": "A node interface for hierarchical objects.", 
            "body": "    The ``Id`` of the node is the ``Id`` of the object represented at\n    this node."
         }, 
         "inherit_fullnames": [
            "osid.Identifiable", 
            "osid.Containable"
         ], 
         "inherit_shortnames": [
            "Identifiable", 
            "Containable"
         ], 
         "inherit_pkg_names": [
            "osid", 
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "Identifiable"
            }, 
            {
               "pkg_name": "osid", 
               "name": "Containable"
            }
         ], 
         "method_names": [
            "is_root", 
            "has_parents", 
            "get_parent_ids", 
            "is_leaf", 
            "has_children", 
            "get_child_ids"
         ], 
         "methods": [
            {
               "name": "is_root", 
               "doc": {
                  "headline": "Tests if this node is a root in the hierarchy (has no parents).", 
                  "body": "        A node may have no more parents available in this node structure\n        but is not a root in the hierarchy. If both ``is_root()`` and\n        ``has_parents()`` is false, the parents of this node may be\n        accessed thorugh another node structure retrieval."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if this node is a root in the\n                hierarchy, ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if this node is a root in the hierarchy, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "has_parents", 
               "doc": {
                  "headline": "Tests if any parents are available in this node structure.", 
                  "body": "        There may be no more parents in this node structure however\n        there may be parents that exist in the hierarchy."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if this node has parents, ``false``\n                otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if this node has parents, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "get_parent_ids", 
               "doc": {
                  "headline": "Gets the parents of this node.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.id.IdList) - the parents of this node", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the parents of this node\n        :rtype: ``osid.id.IdList``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.id.IdList", 
               "errors": {}
            }, 
            {
               "name": "is_leaf", 
               "doc": {
                  "headline": "Tests if this node is a leaf in the hierarchy (has no children).", 
                  "body": "        A node may have no more children available in this node\n        structure but is not a leaf in the hierarchy. If both\n        ``is_leaf()`` and ``has_children()`` is false, the children of\n        this node may be accessed thorugh another node structure\n        retrieval."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if this node is a leaf in the\n                hierarchy, ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if this node is a leaf in the hierarchy, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "has_children", 
               "doc": {
                  "headline": "Tests if any children are available in this node structure.", 
                  "body": "        There may be no more children available in this node structure\n        but this node may have children in the hierarchy."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if this node has children,\n                ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if this node has children, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "get_child_ids", 
               "doc": {
                  "headline": "Gets the children of this node.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.id.IdList) - the children of this node", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the children of this node\n        :rtype: ``osid.id.IdList``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.id.IdList", 
               "errors": {}
            }
         ]
      }, 
      {
         "fullname": "osid.OsidRecord", 
         "shortname": "OsidRecord", 
         "category": "records", 
         "doc": {
            "headline": "``OsidRecord`` is a top-level interface for all record objects.", 
            "body": "    A record is an auxiliary interface that can be retrieved from an\n    OSID object, query, form or search order that contains method\n    definitions outside the core OSID specification. An OSID record\n    interface specification is identified with a ``Type``."
         }, 
         "inherit_fullnames": [], 
         "inherit_shortnames": [], 
         "inherit_pkg_names": [], 
         "inheritance": [], 
         "method_names": [
            "implements_record_type"
         ], 
         "methods": [
            {
               "name": "implements_record_type", 
               "doc": {
                  "headline": "Tests if the given type is implemented by this record.", 
                  "body": "        Other types than that directly indicated by ``get_type()`` may\n        be supported through an inheritance scheme where the given type\n        specifies a record that is a parent interface of the interface\n        specified by ``getType()``."
               }, 
               "arg_doc": "        arg:    record_type (osid.type.Type): a type\n", 
               "return_doc": "        return: (boolean) - ``true`` if the given record ``Type`` is\n                implemented by this record, ``false`` otherwise", 
               "error_doc": "        raise:  NullArgument - ``record_type`` is ``null``", 
               "sphinx_param_doc": "        :param record_type: a type\n        :type record_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "        :return: ``true`` if the given record ``Type`` is implemented by this record, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``record_type`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "record_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "boolean", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.Property", 
         "shortname": "Property", 
         "category": "properties", 
         "doc": {
            "headline": "A ``Property`` is a representation of data in string form.", 
            "body": "    Properties are exposed in OSID objects as a means of providing a\n    quick gestalt of data elements whose specifics are described through\n    a type specification. A view of an OSID object via Properties allows\n    applications to browse the content without understanding the type\n    specification in place, but any acquisition of specific data, access\n    to an object or other primitive type, or changing the data requires\n    the typed interfaces."
         }, 
         "inherit_fullnames": [], 
         "inherit_shortnames": [], 
         "inherit_pkg_names": [], 
         "inheritance": [], 
         "method_names": [
            "get_display_name", 
            "get_display_label", 
            "get_description", 
            "get_value"
         ], 
         "methods": [
            {
               "name": "get_display_name", 
               "doc": {
                  "headline": "The display name for this property.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.locale.DisplayText) - the display name", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the display name\n        :rtype: ``osid.locale.DisplayText``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.locale.DisplayText", 
               "errors": {}
            }, 
            {
               "name": "get_display_label", 
               "doc": {
                  "headline": "A short display label.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.locale.DisplayText) - the display label", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the display label\n        :rtype: ``osid.locale.DisplayText``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.locale.DisplayText", 
               "errors": {}
            }, 
            {
               "name": "get_description", 
               "doc": {
                  "headline": "A description of this property.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.locale.DisplayText) - the description", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the description\n        :rtype: ``osid.locale.DisplayText``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.locale.DisplayText", 
               "errors": {}
            }, 
            {
               "name": "get_value", 
               "doc": {
                  "headline": "The value of this property.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (string) - the value", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the value\n        :rtype: ``string``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "string", 
               "errors": {}
            }
         ]
      }, 
      {
         "fullname": "osid.PropertyList", 
         "shortname": "PropertyList", 
         "category": "properties", 
         "doc": {
            "headline": "Like all ``OsidLists,``  ``PropertyList`` provides a means for accessing ``Property`` elements sequentially either one at a time or many at a time.", 
            "body": "    Examples: while (pl.hasNext()) { Property property =\n    pl.getNextProperty(); }\n\n    or\n      while (pl.hasNext()) {\n           Property[] properties = pl.getNextProperties(pl.available());\n      }\n    \n"
         }, 
         "inherit_fullnames": [
            "osid.OsidList"
         ], 
         "inherit_shortnames": [
            "OsidList"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidList"
            }
         ], 
         "method_names": [
            "get_next_property", 
            "get_next_properties"
         ], 
         "methods": [
            {
               "name": "get_next_property", 
               "doc": {
                  "headline": "Gets the next ``Property`` in this list.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.Property) - the next ``Property`` in this list.\n                The ``has_next()`` method should be used to test that a\n                next ``Property`` is available before calling this\n                method.", 
               "error_doc": "        raise:  IllegalState - no more elements available in this list\n        raise:  OperationFailed - unable to complete request", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the next ``Property`` in this list. The ``has_next()`` method should be used to test that a next ``Property`` is available before calling this method.\n        :rtype: ``osid.Property``", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- no more elements available in this list\n        :raise: ``OperationFailed`` -- unable to complete request", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.Property", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational"
               }
            }, 
            {
               "name": "get_next_properties", 
               "doc": {
                  "headline": "Gets the next set of ``Property`` elements in this list which must be less than or equal to the number returned from ``available()``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    n (cardinal): the number of ``Property`` elements\n                requested which should be less than or equal to\n                ``available()``\n", 
               "return_doc": "        return: (osid.Property) - an array of ``Property`` elements.The\n                length of the array is less than or equal to the number\n                specified.", 
               "error_doc": "        raise:  IllegalState - no more elements available in this list\n        raise:  OperationFailed - unable to complete request", 
               "sphinx_param_doc": "        :param n: the number of ``Property`` elements requested which should be less than or equal to ``available()``\n        :type n: ``cardinal``\n", 
               "sphinx_return_doc": "        :return: an array of ``Property`` elements.The length of the array is less than or equal to the number specified.\n        :rtype: ``osid.Property``", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- no more elements available in this list\n        :raise: ``OperationFailed`` -- unable to complete request", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "cardinal", 
                     "var_name": "n", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "cardinal"
               ], 
               "return_type": "osid.Property", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.OsidRuntimeProfile", 
         "shortname": "OsidRuntimeProfile", 
         "category": "managers", 
         "doc": {
            "headline": "The ``OsidRuntimeProfile`` defines the service aspects of the OSID runtime service.", 
            "body": ""
         }, 
         "inherit_fullnames": [
            "osid.OsidProfile"
         ], 
         "inherit_shortnames": [
            "OsidProfile"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidProfile"
            }
         ], 
         "method_names": [
            "supports_configuration"
         ], 
         "methods": [
            {
               "name": "supports_configuration", 
               "doc": {
                  "headline": "Tests if a configuration service is provided within this runtime environment.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if a configuration service is\n                available, ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if a configuration service is available, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }
         ]
      }, 
      {
         "fullname": "osid.OsidRuntimeManager", 
         "shortname": "OsidRuntimeManager", 
         "category": "managers", 
         "doc": {
            "headline": "The ``OsidRuntimeManager`` represents and OSID platform and contains the information required for running OSID implementations such as search paths and configurations.", 
            "body": ""
         }, 
         "inherit_fullnames": [
            "osid.OsidManager", 
            "osid.OsidRuntimeProfile"
         ], 
         "inherit_shortnames": [
            "OsidManager", 
            "OsidRuntimeProfile"
         ], 
         "inherit_pkg_names": [
            "osid", 
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidManager"
            }, 
            {
               "pkg_name": "osid", 
               "name": "OsidRuntimeProfile"
            }
         ], 
         "method_names": [
            "get_manager", 
            "get_proxy_manager", 
            "get_configuration"
         ], 
         "methods": [
            {
               "name": "get_manager", 
               "doc": {
                  "headline": "Finds, loads and instantiates providers of OSID managers.", 
                  "body": "        Providers must conform to an OsidManager interface. The\n        interfaces are defined in the OSID enumeration. For all OSID\n        requests, an instance of ``OsidManager`` that implements the\n        ``OsidManager`` interface is returned. In bindings where\n        permitted, this can be safely cast into the requested manager."
               }, 
               "arg_doc": "        arg:    osid (osid.OSID): represents the OSID\n        arg:    impl_class_name (string): the name of the implementation\n        arg:    version (osid.installation.Version): the minimum\n                required OSID specification version\n", 
               "return_doc": "        return: (osid.OsidManager) - the manager of the service", 
               "error_doc": "        raise:  ConfigurationError - an error in configuring the\n                implementation\n        raise:  NotFound - the implementation class was not found\n        raise:  NullArgument - ``impl_class_name`` or ``version`` is\n                ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unsupported - ``impl_class_name`` does not support the\n                requested OSID", 
               "sphinx_param_doc": "        :param osid: represents the OSID\n        :type osid: ``osid.OSID``\n        :param impl_class_name: the name of the implementation\n        :type impl_class_name: ``string``\n        :param version: the minimum required OSID specification version\n        :type version: ``osid.installation.Version``\n", 
               "sphinx_return_doc": "        :return: the manager of the service\n        :rtype: ``osid.OsidManager``", 
               "sphinx_error_doc": "        :raise: ``ConfigurationError`` -- an error in configuring the implementation\n        :raise: ``NotFound`` -- the implementation class was not found\n        :raise: ``NullArgument`` -- ``impl_class_name`` or ``version`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unsupported`` -- ``impl_class_name`` does not support the requested OSID", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "        *implementation notes*: After finding and instantiating the\n        requested ``OsidManager,`` providers must invoke\n        ``OsidManager.initialize(OsidRuntimeManager)`` where the\n        environment is an instance of the current environment that\n        includes the configuration for the service being initialized.\n        The ``OsidRuntimeManager`` passed may include information useful\n        for the configuration such as the identity of the service being\n        instantiated.\n", 
               "args": [
                  {
                     "arg_type": "osid.OSID", 
                     "var_name": "osid", 
                     "array": false
                  }, 
                  {
                     "arg_type": "string", 
                     "var_name": "impl_class_name", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.installation.Version", 
                     "var_name": "version", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.OSID", 
                  "string", 
                  "osid.installation.Version"
               ], 
               "return_type": "osid.OsidManager", 
               "errors": {
                  "CONFIGURATION_ERROR": "Operational", 
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_proxy_manager", 
               "doc": {
                  "headline": "Finds, loads and instantiates providers of OSID managers.", 
                  "body": "        Providers must conform to an ``OsidManager`` interface. The\n        interfaces are defined in the OSID enumeration. For all OSID\n        requests, an instance of ``OsidManager`` that implements the\n        ``OsidManager`` interface is returned. In bindings where\n        permitted, this can be safely cast into the requested manager."
               }, 
               "arg_doc": "        arg:    osid (osid.OSID): represents the OSID\n        arg:    implementation (string): the name of the implementation\n        arg:    version (osid.installation.Version): the minimum\n                required OSID specification version\n", 
               "return_doc": "        return: (osid.OsidProxyManager) - the manager of the service", 
               "error_doc": "        raise:  ConfigurationError - an error in configuring the\n                implementation\n        raise:  NotFound - the implementation class was not found\n        raise:  NullArgument - ``implementation`` or ``version`` is\n                ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unsupported - ``implementation`` does not support the\n                requested OSID", 
               "sphinx_param_doc": "        :param osid: represents the OSID\n        :type osid: ``osid.OSID``\n        :param implementation: the name of the implementation\n        :type implementation: ``string``\n        :param version: the minimum required OSID specification version\n        :type version: ``osid.installation.Version``\n", 
               "sphinx_return_doc": "        :return: the manager of the service\n        :rtype: ``osid.OsidProxyManager``", 
               "sphinx_error_doc": "        :raise: ``ConfigurationError`` -- an error in configuring the implementation\n        :raise: ``NotFound`` -- the implementation class was not found\n        :raise: ``NullArgument`` -- ``implementation`` or ``version`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unsupported`` -- ``implementation`` does not support the requested OSID", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "        *implementation notes*: After finding and instantiating the\n        requested ``OsidManager,`` providers must invoke\n        ``OsidManager.initialize(OsidRuntimeManager)`` where the\n        environment is an instance of the current environment that\n        includes the configuration for the service being initialized.\n        The ``OsidRuntimeManager`` passed may include information useful\n        for the configuration such as the identity of the service being\n        instantiated.\n", 
               "args": [
                  {
                     "arg_type": "osid.OSID", 
                     "var_name": "osid", 
                     "array": false
                  }, 
                  {
                     "arg_type": "string", 
                     "var_name": "implementation", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.installation.Version", 
                     "var_name": "version", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.OSID", 
                  "string", 
                  "osid.installation.Version"
               ], 
               "return_type": "osid.OsidProxyManager", 
               "errors": {
                  "CONFIGURATION_ERROR": "Operational", 
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_configuration", 
               "doc": {
                  "headline": "Gets the current configuration in the runtime environment.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.configuration.ValueLookupSession) - a\n                configuration", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - an authorization failure occured\n        raise:  Unimplemented - a configuration service is not supported", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: a configuration\n        :rtype: ``osid.configuration.ValueLookupSession``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- an authorization failure occured\n        :raise: ``Unimplemented`` -- a configuration service is not supported", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_configuration()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.configuration.ValueLookupSession", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }
         ]
      }
   ], 
   "full_name": "osid"
}
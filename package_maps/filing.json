{
   "name": "filing", 
   "version": "3.0.0", 
   "title": "Filing Open Service Interface Definitions", 
   "copyright": "Copyright (c) 2003-2004, 2007 Massachusetts Institute of Technology.\n\nCopyright (c) 2010, 2014 Ingnescus. All Rights Reserved.", 
   "license": "This Work is being provided by the copyright holder(s) subject to the\nfollowing license. By obtaining, using and/or copying this Work, you\nagree that you have read, understand, and will comply with the following\nterms and conditions.\n\nPermission to use, copy and distribute unmodified versions of this Work,\nfor any purpose, without fee or royalty is hereby granted, provided that\nyou include the above copyright notices and the terms of this license on\nALL copies of the Work or portions thereof.\n\nYou may nodify or create Derivatives of this Work only for your internal\npurposes. You shall not distribute or transfer any such Derivative of\nthis Work to any location or to any third party. For the purposes of\nthis license, \"Derivative\" shall mean any derivative of the Work as\ndefined in the United States Copyright Act of 1976, such as a\ntranslation or modification.\n\nThis Work and the information contained herein is provided on an \"AS IS\"\nbasis WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT\nNOT LIMITED TO WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR\nPURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\nHOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN\nAN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\nCONNECTION WITH THE WORK OR THE USE OR OTHER DEALINGS IN THE WORK.\n\nThe export of software employing encryption technology may require a\nspecific license from the United States Government. It is the\nresponsibility of any person or organization contemplating export to\nobtain such a license before exporting this Work.", 
   "summary": "The Filing OSID provides a means for managing and accessing files and\ndirectories. The Filing OSID is used to abstract assumptions made about\nusing a specific file system, or can be used to provide a file-based\napplication a file system oriented view of other OSIDs.\n\nFiles\n\nThe Filing OSID defines a file access session that maps to a single\n``File``. This is the simplest application of the Filing OSID can be\nused in circumstances when it is desirable to confine knowledge of\ndirectories within a provider.\n\nDirectories\n\n``Directories`` are hierarchical ``OsidCatalogs`` of Files.\n\nDifferences from OSID Patterns\n\nThe Filing OSID assumes the pathname and filename of a ``File`` or\n``Directory`` is globally unique. Typically, only the ``Id`` field is\nunique in an ``OsidObject``. In the Filing OSID, there are two unique\nidentifiers for identifying ``Files`` and Directories.\n\nThe ``Id`` is used to conform to existing OSID patterns and more easily\ncreate relationships to other auxiliary services such as the Journaling\nOSID, Relationship OSID, or the Ontology OSID. However, in a file system\none is accustomed to traversing a file system using path names.\n\nThe standard ``OsidSessions`` refer to ``Files`` and ``Directories``\nusing their ``Ids``. The file system-oriented and content sessions\naccess and manipulate the file system using path names. Access to these\nsessions via the ``OsidManagers`` provide for both a path name and\n``Directory``  ``Id``.\n\nThe cataloging in the file system and content sessions behave\ndifferently than that in other OsidSessions. Typically, one is\nconstrained to ``OsidObjects`` within the ``OsidCatalog,`` and its\nchildren in a federated view. In these sessions which use the path name\nas a key, ``Files`` and ``Directories`` outside the local Directory may\nbe accessed with the use of absolute path names.\n\nFinally, there are no hierarchical service patterns in the ``Directory``\n``OsidCatalog`` and a ``File`` or sub-directory may belong to one and\nonly one ``Directory`` .\n\nExample\n  FilieSession session = filingManager.getFileContentSession();\n  DataInputStream dis = session.getInputStream(\"/etc/passwd\");\n\n\n\nSub Packages\n\nThe Filing OSID contains a Filing Allocation OSID for examining and\nmanaging file system utilization and user quotas.", 
   "interfaces": [
      {
         "fullname": "osid.filing.FilingProfile", 
         "shortname": "FilingProfile", 
         "category": "managers", 
         "doc": {
            "headline": "The filing profile describes the interoperability among filing services.", 
            "body": ""
         }, 
         "inherit_fullnames": [
            "osid.OsidProfile"
         ], 
         "inherit_shortnames": [
            "OsidProfile"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidProfile"
            }
         ], 
         "method_names": [
            "supports_visible_federation", 
            "supports_file_system", 
            "supports_file_system_management", 
            "supports_file_content", 
            "supports_file_lookup", 
            "supports_file_query", 
            "supports_file_search", 
            "supports_file_notification", 
            "supports_file_smart_directory", 
            "supports_directory_lookup", 
            "supports_directory_query", 
            "supports_directory_search", 
            "supports_directory_admin", 
            "supports_directory_notification", 
            "supports_filing_management", 
            "supports_filing_allocation", 
            "get_file_record_types", 
            "supports_file_record_type", 
            "get_file_search_record_types", 
            "supports_file_search_record_type", 
            "get_directory_record_types", 
            "supports_directory_record_type", 
            "get_directory_search_record_types", 
            "supports_directory_search_record_type"
         ], 
         "methods": [
            {
               "name": "supports_visible_federation", 
               "doc": {
                  "headline": "Tests if directory federation is exposed.", 
                  "body": "        Federation is exposed when a specific directory may be\n        identified, selected and used to access a session. Federation is\n        not exposed when a set of directories appears as a single\n        directory."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if federation is visible ``false``\n                otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if federation is visible ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "supports_file_system", 
               "doc": {
                  "headline": "Tests if a ``FileSystemSession`` is supported.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if a ``FileSystemSession`` is\n                available, ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if a ``FileSystemSession`` is available, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "supports_file_system_management", 
               "doc": {
                  "headline": "Tests if a ``FileSystemManagementSession`` is supported.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if a\n                ``FileSystemManagementSession`` is available, ``false``\n                otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if a ``FileSystemManagementSession`` is available, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "supports_file_content", 
               "doc": {
                  "headline": "Tests if a ``FileContentSession`` is supported.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if a ``FileContentSession`` is\n                available, ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if a ``FileContentSession`` is available, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "supports_file_lookup", 
               "doc": {
                  "headline": "Tests if file lookup is supported.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if a ``FileLookupSession`` is\n                available, ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if a ``FileLookupSession`` is available, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "supports_file_query", 
               "doc": {
                  "headline": "Tests if file querying is supported.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if a ``FileQuerySession`` is\n                available, ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if a ``FileQuerySession`` is available, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "supports_file_search", 
               "doc": {
                  "headline": "Tests if file searching is supported.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if a ``FileSearchSession`` is\n                available, ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if a ``FileSearchSession`` is available, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "supports_file_notification", 
               "doc": {
                  "headline": "Tests if file notification is supported.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if a ``FileNotificationSession`` is\n                available, ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if a ``FileNotificationSession`` is available, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "supports_file_smart_directory", 
               "doc": {
                  "headline": "Tests if managing smart directories is supported.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if a ``FileSmartDirectorySession``\n                is available, ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if a ``FileSmartDirectorySession`` is available, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "supports_directory_lookup", 
               "doc": {
                  "headline": "Tests if a ``DirectoryLookupSession`` is supported.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if a ``DirectoryLookupSession`` is\n                available, ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if a ``DirectoryLookupSession`` is available, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "supports_directory_query", 
               "doc": {
                  "headline": "Tests if directory querying is supported.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if a ``DirectoryQuerySession`` is\n                available, ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if a ``DirectoryQuerySession`` is available, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "supports_directory_search", 
               "doc": {
                  "headline": "Tests if directory searching is supported.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if a ``DirectorySearchSession`` is\n                available, ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if a ``DirectorySearchSession`` is available, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "supports_directory_admin", 
               "doc": {
                  "headline": "Tests if directory administration is supported.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if a ``DirectoryAdminSession`` is\n                available, ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if a ``DirectoryAdminSession`` is available, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "supports_directory_notification", 
               "doc": {
                  "headline": "Tests if a directorynotification service is supported.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if a\n                ``DirectoryNotificationSession`` is available, ``false``\n                otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if a ``DirectoryNotificationSession`` is available, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "supports_filing_management", 
               "doc": {
                  "headline": "Tests if a file management service is supported.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if a ``FileManagementSession`` is\n                available, ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if a ``FileManagementSession`` is available, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "supports_filing_allocation", 
               "doc": {
                  "headline": "Tests if a filing allocation service is supported.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if a ``FilingAllocationManager`` is\n                available, ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if a ``FilingAllocationManager`` is available, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "get_file_record_types", 
               "doc": {
                  "headline": "Gets the supported file record types.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.type.TypeList) - a list containing the supported\n                ``File`` record types", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: a list containing the supported ``File`` record types\n        :rtype: ``osid.type.TypeList``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.type.TypeList", 
               "errors": {}
            }, 
            {
               "name": "supports_file_record_type", 
               "doc": {
                  "headline": "Tests if the given file record type is supported.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    file_record_type (osid.type.Type): a ``Type`` indicating\n                a file record type\n", 
               "return_doc": "        return: (boolean) - ``true`` if the given record ``Type`` is\n                supported, ``false`` otherwise", 
               "error_doc": "        raise:  NullArgument - ``file_record_type`` is null", 
               "sphinx_param_doc": "        :param file_record_type: a ``Type`` indicating a file record type\n        :type file_record_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "        :return: ``true`` if the given record ``Type`` is supported, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``file_record_type`` is null", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "file_record_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "boolean", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "get_file_search_record_types", 
               "doc": {
                  "headline": "Gets the supported file search record types.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.type.TypeList) - a list containing the supported\n                ``File`` search record types", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: a list containing the supported ``File`` search record types\n        :rtype: ``osid.type.TypeList``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.type.TypeList", 
               "errors": {}
            }, 
            {
               "name": "supports_file_search_record_type", 
               "doc": {
                  "headline": "Tests if the given file search record type is supported.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    file_search_record_type (osid.type.Type): a ``Type``\n                indicating a file search record type\n", 
               "return_doc": "        return: (boolean) - ``true`` if the given search record ``Type``\n                is supported, ``false`` otherwise", 
               "error_doc": "        raise:  NullArgument - ``file_search_record_type`` is null", 
               "sphinx_param_doc": "        :param file_search_record_type: a ``Type`` indicating a file search record type\n        :type file_search_record_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "        :return: ``true`` if the given search record ``Type`` is supported, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``file_search_record_type`` is null", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "file_search_record_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "boolean", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "get_directory_record_types", 
               "doc": {
                  "headline": "Gets the supported directory record types.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.type.TypeList) - a list containing the supported\n                ``Directory`` record types", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: a list containing the supported ``Directory`` record types\n        :rtype: ``osid.type.TypeList``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.type.TypeList", 
               "errors": {}
            }, 
            {
               "name": "supports_directory_record_type", 
               "doc": {
                  "headline": "Tests if the given directory record type is supported.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    directory_record_type (osid.type.Type): a ``Type``\n                indicating a directory record type\n", 
               "return_doc": "        return: (boolean) - ``true`` if the given record ``Type`` is\n                supported, ``false`` otherwise", 
               "error_doc": "        raise:  NullArgument - ``directory_record_type`` is null", 
               "sphinx_param_doc": "        :param directory_record_type: a ``Type`` indicating a directory record type\n        :type directory_record_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "        :return: ``true`` if the given record ``Type`` is supported, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``directory_record_type`` is null", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "directory_record_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "boolean", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "get_directory_search_record_types", 
               "doc": {
                  "headline": "Gets the supported directory search record types.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.type.TypeList) - a list containing the supported\n                ``Directory`` search record types", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: a list containing the supported ``Directory`` search record types\n        :rtype: ``osid.type.TypeList``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.type.TypeList", 
               "errors": {}
            }, 
            {
               "name": "supports_directory_search_record_type", 
               "doc": {
                  "headline": "Tests if the given directory search record type is supported.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    directory_search_record_type (osid.type.Type): a\n                ``Type`` indicating a directory search record type\n", 
               "return_doc": "        return: (boolean) - ``true`` if the given search record ``Type``\n                is supported, ``false`` otherwise", 
               "error_doc": "        raise:  NullArgument - ``directory_search_record_type`` is null", 
               "sphinx_param_doc": "        :param directory_search_record_type: a ``Type`` indicating a directory search record type\n        :type directory_search_record_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "        :return: ``true`` if the given search record ``Type`` is supported, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``directory_search_record_type`` is null", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "directory_search_record_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "boolean", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.filing.FilingManager", 
         "shortname": "FilingManager", 
         "category": "managers", 
         "doc": {
            "headline": "The filing manager provides access sessions to retrieve and manage files and directories.", 
            "body": "    Some of the federated access methods support pathnames in addition\n    to directory ``Ids``. The sessions included in this manager are:\n\n      * ``FileSystemSession:`` a session for traversing file systems\n      * ``FileSystemManagementSession:`` a session for performing\n        operations across directories\n      * ``FileContentSession:`` a basic session for reading and writing\n        a file\n      * FileLookupSession: a session for looking up files\n      * ``FileQuerySession:`` a session for searching for files\n      * ``FileSearchSession:`` a session for searching for files\n      * ``FileNotificationSession:`` a session for subscribing to\n        changes in files\n      * ``FileSmartDirectorySession:`` a session for managing smart\n        directories of files\n      * ``DirectoryLookupSession:`` a session for looking up a\n        directories\n      * ``DirectorQuerySession:`` a session for searching for\n        directories\n      * ``DirectorySearchSession:`` a session for searching for\n        directories\n      * ``DirectoryNotificationSession:`` a session for subscribing to\n        changes in directories\n"
         }, 
         "inherit_fullnames": [
            "osid.OsidManager", 
            "osid.filing.FilingProfile"
         ], 
         "inherit_shortnames": [
            "OsidManager", 
            "FilingProfile"
         ], 
         "inherit_pkg_names": [
            "osid", 
            "filing"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidManager"
            }, 
            {
               "pkg_name": "filing", 
               "name": "FilingProfile"
            }
         ], 
         "method_names": [
            "get_file_system_session", 
            "get_file_system_session_for_path", 
            "get_file_system_session_for_directory", 
            "get_file_system_management_session", 
            "get_file_system_management_session_for_path", 
            "get_file_system_management_session_for_directory", 
            "get_file_content_session", 
            "get_file_content_session_for_path", 
            "get_file_content_session_for_directory", 
            "get_file_lookup_session", 
            "get_file_lookup_session_for_directory", 
            "get_file_query_session", 
            "get_file_query_session_for_directory", 
            "get_file_search_session", 
            "get_file_search_session_for_directory", 
            "get_file_notification_session", 
            "get_file_notification_session_for_directory", 
            "get_file_smart_directory_session", 
            "get_directory_lookup_session", 
            "get_directory_lookup_session_for_directory", 
            "get_directory_query_session", 
            "get_directory_query_session_for_directory", 
            "get_directory_search_session", 
            "get_directory_search_session_for_directory", 
            "get_directory_admin_session", 
            "get_directory_admin_session_for_directory", 
            "get_directory_notification_session", 
            "get_directory_notification_session_for_directory", 
            "get_filing_allocation_manager"
         ], 
         "methods": [
            {
               "name": "get_file_system_session", 
               "doc": {
                  "headline": "Gets the session for examining file systems.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.filing.FileSystemSession) - a\n                ``FileSystemSession``", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_file_system()`` is ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: a ``FileSystemSession``\n        :rtype: ``osid.filing.FileSystemSession``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_file_system()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_file_system()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.filing.FileSystemSession", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_file_system_session_for_path", 
               "doc": {
                  "headline": "Gets the session for exmaning file systems for the given path.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    path (string): the path to a directory\n", 
               "return_doc": "        return: (osid.filing.FileSystemSession) - a\n                ``FileSystemSession``", 
               "error_doc": "        raise:  NotFound - ``path`` is not found or is not a directory\n        raise:  NullArgument - ``path`` is null\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_file_system()`` is ``false``", 
               "sphinx_param_doc": "        :param path: the path to a directory\n        :type path: ``string``\n", 
               "sphinx_return_doc": "        :return: a ``FileSystemSession``\n        :rtype: ``osid.filing.FileSystemSession``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``path`` is not found or is not a directory\n        :raise: ``NullArgument`` -- ``path`` is null\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_file_system()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_file_system()`` and ``supports_visible_federation()`` are ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "string", 
                     "var_name": "path", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "string"
               ], 
               "return_type": "osid.filing.FileSystemSession", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_file_system_session_for_directory", 
               "doc": {
                  "headline": "Gets the session for exmaning file systems for the given directory.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    directory_id (osid.id.Id): the ``Id`` of a directory\n", 
               "return_doc": "        return: (osid.filing.FileSystemSession) - a\n                ``FileSystemSession``", 
               "error_doc": "        raise:  NotFound - ``directory_id`` is not found\n        raise:  NullArgument - ``directory_id`` is null\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_file_system()`` is ``false``", 
               "sphinx_param_doc": "        :param directory_id: the ``Id`` of a directory\n        :type directory_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: a ``FileSystemSession``\n        :rtype: ``osid.filing.FileSystemSession``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``directory_id`` is not found\n        :raise: ``NullArgument`` -- ``directory_id`` is null\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_file_system()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_file_system()`` and ``supports_visible_federation()`` are ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "directory_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "osid.filing.FileSystemSession", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_file_system_management_session", 
               "doc": {
                  "headline": "Gets the session for manipulating file systems.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.filing.FileSystemManagementSession) - a\n                ``FileSystemManagementSession``", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_file_system_management()`` is\n                ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: a ``FileSystemManagementSession``\n        :rtype: ``osid.filing.FileSystemManagementSession``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_file_system_management()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_file_system_management()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.filing.FileSystemManagementSession", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_file_system_management_session_for_path", 
               "doc": {
                  "headline": "Gets the session for manipulating files for the given path.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    path (string): the path to a directory\n", 
               "return_doc": "        return: (osid.filing.FileSystemManagementSession) - a\n                ``FileSystemManagementSession``", 
               "error_doc": "        raise:  NotFound - ``path`` is not found or is not a directory\n        raise:  NullArgument - ``path`` is null\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_file_system_management()`` is\n                ``false``", 
               "sphinx_param_doc": "        :param path: the path to a directory\n        :type path: ``string``\n", 
               "sphinx_return_doc": "        :return: a ``FileSystemManagementSession``\n        :rtype: ``osid.filing.FileSystemManagementSession``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``path`` is not found or is not a directory\n        :raise: ``NullArgument`` -- ``path`` is null\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_file_system_management()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_file_system_management()`` and ``supports_visible_federation()`` are ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "string", 
                     "var_name": "path", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "string"
               ], 
               "return_type": "osid.filing.FileSystemManagementSession", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_file_system_management_session_for_directory", 
               "doc": {
                  "headline": "Gets the session for manipulating files for the given path.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    directory_id (osid.id.Id): the ``Id`` of a directory\n", 
               "return_doc": "        return: (osid.filing.FileSystemManagementSession) - a\n                ``FileSystemManagementSession``", 
               "error_doc": "        raise:  NotFound - ``directory_id`` is not found\n        raise:  NullArgument - ``directory_id`` is null\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_file_system_management()`` is\n                ``false``", 
               "sphinx_param_doc": "        :param directory_id: the ``Id`` of a directory\n        :type directory_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: a ``FileSystemManagementSession``\n        :rtype: ``osid.filing.FileSystemManagementSession``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``directory_id`` is not found\n        :raise: ``NullArgument`` -- ``directory_id`` is null\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_file_system_management()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_file_system_management()`` and ``supports_visible_federation()`` are ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "directory_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "osid.filing.FileSystemManagementSession", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_file_content_session", 
               "doc": {
                  "headline": "Gets the session for reading and writing files.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.filing.FileContentSession) - a\n                ``FileContentSession``", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_file_content()`` is ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: a ``FileContentSession``\n        :rtype: ``osid.filing.FileContentSession``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_file_content()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_file_content()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.filing.FileContentSession", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_file_content_session_for_path", 
               "doc": {
                  "headline": "Gets the session for reading and writing files for the given path.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    path (string): the path to a directory\n", 
               "return_doc": "        return: (osid.filing.FileContentSession) - a\n                ``FileContentSession``", 
               "error_doc": "        raise:  NotFound - ``path`` is not found or is not a directory\n        raise:  NullArgument - ``path`` is null\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_file_content()`` is ``false``", 
               "sphinx_param_doc": "        :param path: the path to a directory\n        :type path: ``string``\n", 
               "sphinx_return_doc": "        :return: a ``FileContentSession``\n        :rtype: ``osid.filing.FileContentSession``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``path`` is not found or is not a directory\n        :raise: ``NullArgument`` -- ``path`` is null\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_file_content()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_file_content()`` and ``supports_visible_federation()`` are ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "string", 
                     "var_name": "path", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "string"
               ], 
               "return_type": "osid.filing.FileContentSession", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_file_content_session_for_directory", 
               "doc": {
                  "headline": "Gets the session for reading and writing files for the given path.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    directory_id (osid.id.Id): the ``Id`` of a directory\n", 
               "return_doc": "        return: (osid.filing.FileContentSession) - a\n                ``FileContentSession``", 
               "error_doc": "        raise:  NotFound - ``directory_id`` is not found\n        raise:  NullArgument - ``directory_id`` is null\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_file_content()`` is ``false``", 
               "sphinx_param_doc": "        :param directory_id: the ``Id`` of a directory\n        :type directory_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: a ``FileContentSession``\n        :rtype: ``osid.filing.FileContentSession``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``directory_id`` is not found\n        :raise: ``NullArgument`` -- ``directory_id`` is null\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_file_content()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_file_content()`` and ``supports_visible_federation()`` are ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "directory_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "osid.filing.FileContentSession", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_file_lookup_session", 
               "doc": {
                  "headline": "Gets the session for looking up files.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.filing.FileLookupSession) - the\n                ``FileLookupSession``", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_file_lookup()`` is ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the ``FileLookupSession``\n        :rtype: ``osid.filing.FileLookupSession``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_file_lookup()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_file_lookup()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.filing.FileLookupSession", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_file_lookup_session_for_directory", 
               "doc": {
                  "headline": "Gets the session for manipulating files for the given path.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    directory_id (osid.id.Id): the ``Id`` of the directory\n", 
               "return_doc": "        return: (osid.filing.FileLookupSession) - a\n                ``FileLookupSession``", 
               "error_doc": "        raise:  NotFound - ``directory_id`` is not found\n        raise:  NullArgument - ``directory_id`` is null\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_file_lookup()`` is ``false``", 
               "sphinx_param_doc": "        :param directory_id: the ``Id`` of the directory\n        :type directory_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: a ``FileLookupSession``\n        :rtype: ``osid.filing.FileLookupSession``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``directory_id`` is not found\n        :raise: ``NullArgument`` -- ``directory_id`` is null\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_file_lookup()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_file_lookup()`` and ``supports_visible_federation()`` are ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "directory_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "osid.filing.FileLookupSession", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_file_query_session", 
               "doc": {
                  "headline": "Gets the session for querying files.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.filing.FileQuerySession) - the\n                ``FileQuerySession``", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_file_query()`` is ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the ``FileQuerySession``\n        :rtype: ``osid.filing.FileQuerySession``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_file_query()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_file_query()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.filing.FileQuerySession", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_file_query_session_for_directory", 
               "doc": {
                  "headline": "Gets a file query session for the specified directory.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    directory_id (osid.id.Id): the ``Id`` of the directory\n", 
               "return_doc": "        return: (osid.filing.FileQuerySession) - a ``FileQuerySession``", 
               "error_doc": "        raise:  NotFound - ``directory_id`` is not found\n        raise:  NullArgument - ``directory_id`` is null\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_file_query()`` is ``false``", 
               "sphinx_param_doc": "        :param directory_id: the ``Id`` of the directory\n        :type directory_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: a ``FileQuerySession``\n        :rtype: ``osid.filing.FileQuerySession``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``directory_id`` is not found\n        :raise: ``NullArgument`` -- ``directory_id`` is null\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_file_query()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_file_query()`` and ``supports_visible_federation()`` are ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "directory_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "osid.filing.FileQuerySession", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_file_search_session", 
               "doc": {
                  "headline": "Gets the session for searching for files.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.filing.FileSearchSession) - the\n                ``FileSearchSession``", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_file_search()`` is ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the ``FileSearchSession``\n        :rtype: ``osid.filing.FileSearchSession``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_file_search()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_file_search()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.filing.FileSearchSession", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_file_search_session_for_directory", 
               "doc": {
                  "headline": "Gets a file search session for the specified directory.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    directory_id (osid.id.Id): the ``Id`` of the directory\n", 
               "return_doc": "        return: (osid.filing.FileSearchSession) - a\n                ``FileSearchSession``", 
               "error_doc": "        raise:  NotFound - ``directory_id`` is not found\n        raise:  NullArgument - ``directory_id`` is null\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_file_search()`` is ``false``", 
               "sphinx_param_doc": "        :param directory_id: the ``Id`` of the directory\n        :type directory_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: a ``FileSearchSession``\n        :rtype: ``osid.filing.FileSearchSession``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``directory_id`` is not found\n        :raise: ``NullArgument`` -- ``directory_id`` is null\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_file_search()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_file_search()`` and ``supports_visible_federation()`` are ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "directory_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "osid.filing.FileSearchSession", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_file_notification_session", 
               "doc": {
                  "headline": "Gets the session for receiving messages about changes to files.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    file_receiver (osid.filing.FileReceiver): the\n                notification callback\n", 
               "return_doc": "        return: (osid.filing.FileNotificationSession) - ``a\n                FileNotificationSession``", 
               "error_doc": "        raise:  NullArgument - ``file_receiver`` is null\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_file_notification()`` is\n                ``false``", 
               "sphinx_param_doc": "        :param file_receiver: the notification callback\n        :type file_receiver: ``osid.filing.FileReceiver``\n", 
               "sphinx_return_doc": "        :return: ``a FileNotificationSession``\n        :rtype: ``osid.filing.FileNotificationSession``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``file_receiver`` is null\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_file_notification()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_file_notification()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.filing.FileReceiver", 
                     "var_name": "file_receiver", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.filing.FileReceiver"
               ], 
               "return_type": "osid.filing.FileNotificationSession", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_file_notification_session_for_directory", 
               "doc": {
                  "headline": "Gets a file notification session for the specified directory.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    file_receiver (osid.filing.FileReceiver): the\n                notification callback\n        arg:    directory_id (osid.id.Id): the ``Id`` of the directory\n", 
               "return_doc": "        return: (osid.filing.FileNotificationSession) - a\n                ``FileNotificationSession``", 
               "error_doc": "        raise:  NotFound - ``directory_id`` is not found\n        raise:  NullArgument - ``file_receiver`` or ``directory_id`` is\n                null\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_file_notification()`` is\n                ``false``", 
               "sphinx_param_doc": "        :param file_receiver: the notification callback\n        :type file_receiver: ``osid.filing.FileReceiver``\n        :param directory_id: the ``Id`` of the directory\n        :type directory_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: a ``FileNotificationSession``\n        :rtype: ``osid.filing.FileNotificationSession``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``directory_id`` is not found\n        :raise: ``NullArgument`` -- ``file_receiver`` or ``directory_id`` is null\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_file_notification()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_file_notification()`` and ``supports_visible_federation()`` are ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.filing.FileReceiver", 
                     "var_name": "file_receiver", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "directory_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.filing.FileReceiver", 
                  "osid.id.Id"
               ], 
               "return_type": "osid.filing.FileNotificationSession", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_file_smart_directory_session", 
               "doc": {
                  "headline": "Gets the session for managing dynamic directories.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    directory_id (osid.id.Id): the ``Id`` of the directory\n", 
               "return_doc": "        return: (osid.filing.FileSmartDirectorySession) - a\n                ``FileSmartDirectorySession``", 
               "error_doc": "        raise:  NotFound - ``directory_id`` is not found\n        raise:  NullArgument - ``directory_id`` is null\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_file_smart_directory()`` is\n                ``false``", 
               "sphinx_param_doc": "        :param directory_id: the ``Id`` of the directory\n        :type directory_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: a ``FileSmartDirectorySession``\n        :rtype: ``osid.filing.FileSmartDirectorySession``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``directory_id`` is not found\n        :raise: ``NullArgument`` -- ``directory_id`` is null\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_file_smart_directory()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_file_smart_directory()`` and ``supports_visible_federation()`` are ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "directory_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "osid.filing.FileSmartDirectorySession", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_directory_lookup_session", 
               "doc": {
                  "headline": "Gets the session for examining directories.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.filing.DirectoryLookupSession) - a\n                ``DirectoryLookupSession``", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_directory_lookup()`` is\n                ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: a ``DirectoryLookupSession``\n        :rtype: ``osid.filing.DirectoryLookupSession``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_directory_lookup()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_directory_lookup()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.filing.DirectoryLookupSession", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_directory_lookup_session_for_directory", 
               "doc": {
                  "headline": "Gets the session for examining a given directory.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    directory_id (osid.id.Id): the ``Id`` of the directory\n", 
               "return_doc": "        return: (osid.filing.DirectoryLookupSession) - a\n                ``DirectoryLookupSession``", 
               "error_doc": "        raise:  NotFound - ``directory_id`` is not found\n        raise:  NullArgument - ``directory_id`` is null\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_directory_lookup()`` is\n                ``false``", 
               "sphinx_param_doc": "        :param directory_id: the ``Id`` of the directory\n        :type directory_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: a ``DirectoryLookupSession``\n        :rtype: ``osid.filing.DirectoryLookupSession``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``directory_id`` is not found\n        :raise: ``NullArgument`` -- ``directory_id`` is null\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_directory_lookup()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_directory_lookup()`` and ``supports_visible_federation()`` are ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "directory_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "osid.filing.DirectoryLookupSession", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_directory_query_session", 
               "doc": {
                  "headline": "Gets the session for querying directories.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.filing.DirectoryQuerySession) - a\n                ``DirectoryQuerySession``", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_directory_query()`` is\n                ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: a ``DirectoryQuerySession``\n        :rtype: ``osid.filing.DirectoryQuerySession``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_directory_query()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_directory_query()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.filing.DirectoryQuerySession", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_directory_query_session_for_directory", 
               "doc": {
                  "headline": "Gets the session for querying directories within a given directory.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    directory_id (osid.id.Id): the ``Id`` of the directory\n", 
               "return_doc": "        return: (osid.filing.DirectoryQuerySession) - a\n                ``DirectoryQuerySession``", 
               "error_doc": "        raise:  NotFound - ``directory_id`` is not found\n        raise:  NullArgument - ``directory_id`` is null\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_directory_query()`` is\n                ``false``", 
               "sphinx_param_doc": "        :param directory_id: the ``Id`` of the directory\n        :type directory_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: a ``DirectoryQuerySession``\n        :rtype: ``osid.filing.DirectoryQuerySession``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``directory_id`` is not found\n        :raise: ``NullArgument`` -- ``directory_id`` is null\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_directory_query()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_directory_query()`` and ``supports_visible_federation()`` are ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "directory_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "osid.filing.DirectoryQuerySession", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_directory_search_session", 
               "doc": {
                  "headline": "Gets the session for searching for directories.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.filing.DirectorySearchSession) - a\n                ``DirectorySearchSession``", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_directory_search()`` is\n                ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: a ``DirectorySearchSession``\n        :rtype: ``osid.filing.DirectorySearchSession``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_directory_search()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_directory_search()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.filing.DirectorySearchSession", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_directory_search_session_for_directory", 
               "doc": {
                  "headline": "Gets the session for searching for directories within a given directory.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    directory_id (osid.id.Id): the ``Id`` of the directory\n", 
               "return_doc": "        return: (osid.filing.DirectorySearchSession) - a\n                ``DirectorySearchSession``", 
               "error_doc": "        raise:  NotFound - ``directory_id`` is not found\n        raise:  NullArgument - ``directory_id`` is null\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_directory_search()`` is\n                ``false``", 
               "sphinx_param_doc": "        :param directory_id: the ``Id`` of the directory\n        :type directory_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: a ``DirectorySearchSession``\n        :rtype: ``osid.filing.DirectorySearchSession``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``directory_id`` is not found\n        :raise: ``NullArgument`` -- ``directory_id`` is null\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_directory_search()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_directory_search()`` and ``supports_visible_federation()`` are ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "directory_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "osid.filing.DirectorySearchSession", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_directory_admin_session", 
               "doc": {
                  "headline": "Gets the session for creating and removing files.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.filing.DirectoryAdminSession) - a\n                ``DirectoryAdminSession``", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_directory_admin()`` is\n                ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: a ``DirectoryAdminSession``\n        :rtype: ``osid.filing.DirectoryAdminSession``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_directory_admin()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_directory_admin()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.filing.DirectoryAdminSession", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_directory_admin_session_for_directory", 
               "doc": {
                  "headline": "Gets the session for searching for creating and removing files in the given directory.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    directory_id (osid.id.Id): the ``Id`` of the directory\n", 
               "return_doc": "        return: (osid.filing.DirectoryAdminSession) - a\n                ``DirectoryAdminSession``", 
               "error_doc": "        raise:  NotFound - ``directory_id`` is not found\n        raise:  NullArgument - ``directory_id`` is null\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_directory_admin()`` is\n                ``false``", 
               "sphinx_param_doc": "        :param directory_id: the ``Id`` of the directory\n        :type directory_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: a ``DirectoryAdminSession``\n        :rtype: ``osid.filing.DirectoryAdminSession``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``directory_id`` is not found\n        :raise: ``NullArgument`` -- ``directory_id`` is null\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_directory_admin()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_directory_admin()`` and ``supports_visible_federation()`` are ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "directory_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "osid.filing.DirectoryAdminSession", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_directory_notification_session", 
               "doc": {
                  "headline": "Gets the session for receiving messages about changes to directories.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    directory_receiver (osid.filing.DirectoryReceiver): the\n                notification callback\n", 
               "return_doc": "        return: (osid.filing.DirectoryNotificationSession) - a\n                ``DirectoryNotificationSession``", 
               "error_doc": "        raise:  NullArgument - ``directory_receiver`` is null\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_directory_notification()`` is\n                ``false``", 
               "sphinx_param_doc": "        :param directory_receiver: the notification callback\n        :type directory_receiver: ``osid.filing.DirectoryReceiver``\n", 
               "sphinx_return_doc": "        :return: a ``DirectoryNotificationSession``\n        :rtype: ``osid.filing.DirectoryNotificationSession``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``directory_receiver`` is null\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_directory_notification()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_directory_notification()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.filing.DirectoryReceiver", 
                     "var_name": "directory_receiver", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.filing.DirectoryReceiver"
               ], 
               "return_type": "osid.filing.DirectoryNotificationSession", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_directory_notification_session_for_directory", 
               "doc": {
                  "headline": "Gets the session for receiving messages about changes to directories in the given directory.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    directory_receiver (osid.filing.DirectoryReceiver): the\n                notification callback\n        arg:    directory_id (osid.id.Id): the ``Id`` of the directory\n", 
               "return_doc": "        return: (osid.filing.DirectoryNotificationSession) - a\n                ``DirectoryNotificationSession``", 
               "error_doc": "        raise:  NotFound - ``directory_id`` is not found\n        raise:  NullArgument - ``directory_receiver`` or\n                ``directory_id`` is null\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_directory_notification()`` is\n                ``false``", 
               "sphinx_param_doc": "        :param directory_receiver: the notification callback\n        :type directory_receiver: ``osid.filing.DirectoryReceiver``\n        :param directory_id: the ``Id`` of the directory\n        :type directory_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: a ``DirectoryNotificationSession``\n        :rtype: ``osid.filing.DirectoryNotificationSession``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``directory_id`` is not found\n        :raise: ``NullArgument`` -- ``directory_receiver`` or ``directory_id`` is null\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_directory_notification()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_directory_notification()`` and ``supports_visible_federation()`` are ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.filing.DirectoryReceiver", 
                     "var_name": "directory_receiver", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "directory_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.filing.DirectoryReceiver", 
                  "osid.id.Id"
               ], 
               "return_type": "osid.filing.DirectoryNotificationSession", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_filing_allocation_manager", 
               "doc": {
                  "headline": "Gets the ``FilingAllocationManager``.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.filing.allocation.FilingAllocationManager) - a\n                ``FilingAllocationManager``", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_filing_allocation()`` is\n                ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: a ``FilingAllocationManager``\n        :rtype: ``osid.filing.allocation.FilingAllocationManager``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_filing_allocation()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_filing_allocation()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.filing.allocation.FilingAllocationManager", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.filing.FilingProxyManager", 
         "shortname": "FilingProxyManager", 
         "category": "managers", 
         "doc": {
            "headline": "The filing manager provides access sessions to retrieve and manage files and directories.", 
            "body": "    A manager may support federation in that files and directories can\n    be accessed by a specified path. Methods in this manager support the\n    passing of a ``Proxy`` to pass information from server environments.\n    The sessions included in this manager are:\n\n      * ``FileSystemSession:`` a session for traversing file systems\n      * ``FileSystemManagementSession:`` a session for performing\n        operations across directories\n      * ``FileContentSession:`` a basic session for reading and writing\n        a file\n      * FileLookupSession: a session for looking up files\n      * ``FileQuerySession:`` a session for searching for files\n      * ``FileSearchSession:`` a session for searching for files\n      * ``FileNotificationSession:`` a session for subscribing to\n        changes in files\n      * ``FileSmartDirectorySession:`` a session for managing smart\n        directories of files\n      * ``DirectoryLookupSession:`` a session for looking up a\n        directories\n      * ``DirectorQuerySession:`` a session for searching for\n        directories\n      * ``DirectorySearchSession:`` a session for searching for\n        directories\n      * ``DirectoryNotificationSession:`` a session for subscribing to\n        changes in directories\n"
         }, 
         "inherit_fullnames": [
            "osid.OsidProxyManager", 
            "osid.filing.FilingProfile"
         ], 
         "inherit_shortnames": [
            "OsidProxyManager", 
            "FilingProfile"
         ], 
         "inherit_pkg_names": [
            "osid", 
            "filing"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidProxyManager"
            }, 
            {
               "pkg_name": "filing", 
               "name": "FilingProfile"
            }
         ], 
         "method_names": [
            "get_file_system_session", 
            "get_file_system_session_for_path", 
            "get_file_system_session_for_directory", 
            "get_file_system_management_session", 
            "get_file_system_management_session_for_path", 
            "get_file_system_management_session_for_directory", 
            "get_file_content_session", 
            "get_file_content_session_for_path", 
            "get_file_content_session_for_directory", 
            "get_file_lookup_session", 
            "get_file_lookup_session_for_directory", 
            "get_file_query_session", 
            "get_file_query_session_for_directory", 
            "get_file_search_session", 
            "get_file_search_session_for_directory", 
            "get_file_notification_session", 
            "get_file_notification_session_for_directory", 
            "get_file_smart_directory_session", 
            "get_directory_lookup_session", 
            "get_directory_lookup_session_for_directory", 
            "get_directory_query_session", 
            "get_directory_query_session_for_directory", 
            "get_directory_search_session", 
            "get_directory_search_session_for_directory", 
            "get_directory_admin_session", 
            "get_directory_admin_session_for_directory", 
            "get_directory_notification_session", 
            "get_directory_notification_session_for_directory", 
            "get_filing_allocation_proxy_manager"
         ], 
         "methods": [
            {
               "name": "get_file_system_session", 
               "doc": {
                  "headline": "Gets the session for examining file systems.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    proxy (osid.proxy.Proxy): a proxy\n", 
               "return_doc": "        return: (osid.filing.FileSystemSession) - a\n                ``FileSystemSession``", 
               "error_doc": "        raise:  NullArgument - ``proxy`` is null\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_file_system()`` is ``false``", 
               "sphinx_param_doc": "        :param proxy: a proxy\n        :type proxy: ``osid.proxy.Proxy``\n", 
               "sphinx_return_doc": "        :return: a ``FileSystemSession``\n        :rtype: ``osid.filing.FileSystemSession``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``proxy`` is null\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_file_system()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_file_system()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.proxy.Proxy", 
                     "var_name": "proxy", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.proxy.Proxy"
               ], 
               "return_type": "osid.filing.FileSystemSession", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_file_system_session_for_path", 
               "doc": {
                  "headline": "Gets the session for exmaning file systems for the given path.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    path (string): the path to a directory\n        arg:    proxy (osid.proxy.Proxy): a proxy\n", 
               "return_doc": "        return: (osid.filing.FileSystemSession) - a\n                ``FileSystemSession``", 
               "error_doc": "        raise:  NotFound - ``path`` is not found or is not a directory\n        raise:  NullArgument - ``path`` or ``proxy`` is null\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_file_system()`` is ``false``", 
               "sphinx_param_doc": "        :param path: the path to a directory\n        :type path: ``string``\n        :param proxy: a proxy\n        :type proxy: ``osid.proxy.Proxy``\n", 
               "sphinx_return_doc": "        :return: a ``FileSystemSession``\n        :rtype: ``osid.filing.FileSystemSession``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``path`` is not found or is not a directory\n        :raise: ``NullArgument`` -- ``path`` or ``proxy`` is null\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_file_system()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_file_system()`` and ``supports_visible_federation()`` are ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "string", 
                     "var_name": "path", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.proxy.Proxy", 
                     "var_name": "proxy", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "string", 
                  "osid.proxy.Proxy"
               ], 
               "return_type": "osid.filing.FileSystemSession", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_file_system_session_for_directory", 
               "doc": {
                  "headline": "Gets the session for exmaning file systems for the given directory.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    directory_id (osid.id.Id): the ``Id`` of a directory\n        arg:    proxy (osid.proxy.Proxy): a proxy\n", 
               "return_doc": "        return: (osid.filing.FileSystemSession) - a\n                ``FileSystemSession``", 
               "error_doc": "        raise:  NotFound - ``directory_id`` is not found\n        raise:  NullArgument - ``directory_id`` or ``proxy`` is null\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_file_system()`` is ``false``", 
               "sphinx_param_doc": "        :param directory_id: the ``Id`` of a directory\n        :type directory_id: ``osid.id.Id``\n        :param proxy: a proxy\n        :type proxy: ``osid.proxy.Proxy``\n", 
               "sphinx_return_doc": "        :return: a ``FileSystemSession``\n        :rtype: ``osid.filing.FileSystemSession``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``directory_id`` is not found\n        :raise: ``NullArgument`` -- ``directory_id`` or ``proxy`` is null\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_file_system()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_file_system()`` and ``supports_visible_federation()`` are ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "directory_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.proxy.Proxy", 
                     "var_name": "proxy", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "osid.proxy.Proxy"
               ], 
               "return_type": "osid.filing.FileSystemSession", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_file_system_management_session", 
               "doc": {
                  "headline": "Gets the session for manipulating file systems.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    proxy (osid.proxy.Proxy): a proxy\n", 
               "return_doc": "        return: (osid.filing.FileSystemManagementSession) - a\n                ``FileSystemManagementSession``", 
               "error_doc": "        raise:  NullArgument - ``proxy`` is null\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_file_system_management()`` is\n                ``false``", 
               "sphinx_param_doc": "        :param proxy: a proxy\n        :type proxy: ``osid.proxy.Proxy``\n", 
               "sphinx_return_doc": "        :return: a ``FileSystemManagementSession``\n        :rtype: ``osid.filing.FileSystemManagementSession``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``proxy`` is null\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_file_system_management()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_file_system_management()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.proxy.Proxy", 
                     "var_name": "proxy", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.proxy.Proxy"
               ], 
               "return_type": "osid.filing.FileSystemManagementSession", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_file_system_management_session_for_path", 
               "doc": {
                  "headline": "Gets the session for manipulating files for the given path.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    path (string): the path to a directory\n        arg:    proxy (osid.proxy.Proxy): a proxy\n", 
               "return_doc": "        return: (osid.filing.FileSystemManagementSession) - a\n                ``FileSystemManagementSession``", 
               "error_doc": "        raise:  NotFound - ``path`` is not found or is not a directory\n        raise:  NullArgument - ``path`` or ``proxy`` is null\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_file_system_management()`` is\n                ``false``", 
               "sphinx_param_doc": "        :param path: the path to a directory\n        :type path: ``string``\n        :param proxy: a proxy\n        :type proxy: ``osid.proxy.Proxy``\n", 
               "sphinx_return_doc": "        :return: a ``FileSystemManagementSession``\n        :rtype: ``osid.filing.FileSystemManagementSession``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``path`` is not found or is not a directory\n        :raise: ``NullArgument`` -- ``path`` or ``proxy`` is null\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_file_system_management()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_file_system_management()`` and ``supports_visible_federation()`` are ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "string", 
                     "var_name": "path", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.proxy.Proxy", 
                     "var_name": "proxy", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "string", 
                  "osid.proxy.Proxy"
               ], 
               "return_type": "osid.filing.FileSystemManagementSession", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_file_system_management_session_for_directory", 
               "doc": {
                  "headline": "Gets the session for manipulating files for the given path.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    directory_id (osid.id.Id): the ``Id`` of a directory\n        arg:    proxy (osid.proxy.Proxy): a proxy\n", 
               "return_doc": "        return: (osid.filing.FileSystemManagementSession) - a\n                ``FileSystemManagementSession``", 
               "error_doc": "        raise:  NotFound - ``directory_id`` is not found\n        raise:  NullArgument - ``directory_id`` or ``proxy`` is null\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_file_system_management()`` is\n                ``false``", 
               "sphinx_param_doc": "        :param directory_id: the ``Id`` of a directory\n        :type directory_id: ``osid.id.Id``\n        :param proxy: a proxy\n        :type proxy: ``osid.proxy.Proxy``\n", 
               "sphinx_return_doc": "        :return: a ``FileSystemManagementSession``\n        :rtype: ``osid.filing.FileSystemManagementSession``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``directory_id`` is not found\n        :raise: ``NullArgument`` -- ``directory_id`` or ``proxy`` is null\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_file_system_management()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_file_system_management()`` and ``supports_visible_federation()`` are ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "directory_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.proxy.Proxy", 
                     "var_name": "proxy", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "osid.proxy.Proxy"
               ], 
               "return_type": "osid.filing.FileSystemManagementSession", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_file_content_session", 
               "doc": {
                  "headline": "Gets the session for reading and writing files.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    proxy (osid.proxy.Proxy): a proxy\n", 
               "return_doc": "        return: (osid.filing.FileContentSession) - a\n                ``FileContentSession``", 
               "error_doc": "        raise:  NullArgument - ``proxy`` is null\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_file_content()`` is ``false``", 
               "sphinx_param_doc": "        :param proxy: a proxy\n        :type proxy: ``osid.proxy.Proxy``\n", 
               "sphinx_return_doc": "        :return: a ``FileContentSession``\n        :rtype: ``osid.filing.FileContentSession``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``proxy`` is null\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_file_content()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_file_content()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.proxy.Proxy", 
                     "var_name": "proxy", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.proxy.Proxy"
               ], 
               "return_type": "osid.filing.FileContentSession", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_file_content_session_for_path", 
               "doc": {
                  "headline": "Gets the session for reading and writing files for the given path.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    path (string): the path to a directory\n        arg:    proxy (osid.proxy.Proxy): a proxy\n", 
               "return_doc": "        return: (osid.filing.FileContentSession) - a\n                ``FileContentSession``", 
               "error_doc": "        raise:  NotFound - ``path`` is not found or is not a directory\n        raise:  NullArgument - ``path`` or ``proxy`` is null\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_file_content()`` is ``false``", 
               "sphinx_param_doc": "        :param path: the path to a directory\n        :type path: ``string``\n        :param proxy: a proxy\n        :type proxy: ``osid.proxy.Proxy``\n", 
               "sphinx_return_doc": "        :return: a ``FileContentSession``\n        :rtype: ``osid.filing.FileContentSession``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``path`` is not found or is not a directory\n        :raise: ``NullArgument`` -- ``path`` or ``proxy`` is null\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_file_content()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_file_content()`` and ``supports_visible_federation()`` are ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "string", 
                     "var_name": "path", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.proxy.Proxy", 
                     "var_name": "proxy", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "string", 
                  "osid.proxy.Proxy"
               ], 
               "return_type": "osid.filing.FileContentSession", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_file_content_session_for_directory", 
               "doc": {
                  "headline": "Gets the session for reading and writing files for the given path.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    directory_id (osid.id.Id): the ``Id`` of a directory\n        arg:    proxy (osid.proxy.Proxy): a proxy\n", 
               "return_doc": "        return: (osid.filing.FileContentSession) - a\n                ``FileContentSession``", 
               "error_doc": "        raise:  NotFound - ``directory_id`` is not found\n        raise:  NullArgument - ``directory_id`` or ``proxy`` is null\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_file_content()`` is ``false``", 
               "sphinx_param_doc": "        :param directory_id: the ``Id`` of a directory\n        :type directory_id: ``osid.id.Id``\n        :param proxy: a proxy\n        :type proxy: ``osid.proxy.Proxy``\n", 
               "sphinx_return_doc": "        :return: a ``FileContentSession``\n        :rtype: ``osid.filing.FileContentSession``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``directory_id`` is not found\n        :raise: ``NullArgument`` -- ``directory_id`` or ``proxy`` is null\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_file_content()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_file_content()`` and ``supports_visible_federation()`` are ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "directory_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.proxy.Proxy", 
                     "var_name": "proxy", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "osid.proxy.Proxy"
               ], 
               "return_type": "osid.filing.FileContentSession", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_file_lookup_session", 
               "doc": {
                  "headline": "Gets the session for looking up files.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    proxy (osid.proxy.Proxy): a proxy\n", 
               "return_doc": "        return: (osid.filing.FileLookupSession) - the\n                ``FileLookupSession``", 
               "error_doc": "        raise:  NullArgument - ``proxy`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_file_lookup()`` is ``false``", 
               "sphinx_param_doc": "        :param proxy: a proxy\n        :type proxy: ``osid.proxy.Proxy``\n", 
               "sphinx_return_doc": "        :return: the ``FileLookupSession``\n        :rtype: ``osid.filing.FileLookupSession``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``proxy`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_file_lookup()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_file_lookup()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.proxy.Proxy", 
                     "var_name": "proxy", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.proxy.Proxy"
               ], 
               "return_type": "osid.filing.FileLookupSession", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_file_lookup_session_for_directory", 
               "doc": {
                  "headline": "Gets a file lookup session for the specified directory.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    directory_id (osid.id.Id): the ``Id`` to the directory\n        arg:    proxy (osid.proxy.Proxy): a proxy\n", 
               "return_doc": "        return: (osid.filing.FileLookupSession) - a\n                ``FileLookupSession``", 
               "error_doc": "        raise:  NotFound - ``directory_id`` is not found\n        raise:  NullArgument - ``directory_id`` or ``proxy`` is null\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_file_lookup()`` is ``false``", 
               "sphinx_param_doc": "        :param directory_id: the ``Id`` to the directory\n        :type directory_id: ``osid.id.Id``\n        :param proxy: a proxy\n        :type proxy: ``osid.proxy.Proxy``\n", 
               "sphinx_return_doc": "        :return: a ``FileLookupSession``\n        :rtype: ``osid.filing.FileLookupSession``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``directory_id`` is not found\n        :raise: ``NullArgument`` -- ``directory_id`` or ``proxy`` is null\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_file_lookup()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_file_lookup()`` and ``supports_visible_federation()`` are ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "directory_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.proxy.Proxy", 
                     "var_name": "proxy", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "osid.proxy.Proxy"
               ], 
               "return_type": "osid.filing.FileLookupSession", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_file_query_session", 
               "doc": {
                  "headline": "Gets the session for querying files.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    proxy (osid.proxy.Proxy): a proxy\n", 
               "return_doc": "        return: (osid.filing.FileQuerySession) - the\n                ``FileQuerySession``", 
               "error_doc": "        raise:  NullArgument - ``proxy`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_file_query()`` is ``false``", 
               "sphinx_param_doc": "        :param proxy: a proxy\n        :type proxy: ``osid.proxy.Proxy``\n", 
               "sphinx_return_doc": "        :return: the ``FileQuerySession``\n        :rtype: ``osid.filing.FileQuerySession``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``proxy`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_file_query()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_file_query()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.proxy.Proxy", 
                     "var_name": "proxy", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.proxy.Proxy"
               ], 
               "return_type": "osid.filing.FileQuerySession", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_file_query_session_for_directory", 
               "doc": {
                  "headline": "Gets a file query session for the specified directory.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    directory_id (osid.id.Id): the ``Id`` to the directory\n        arg:    proxy (osid.proxy.Proxy): a proxy\n", 
               "return_doc": "        return: (osid.filing.FileQuerySession) - a ``FileQuerySession``", 
               "error_doc": "        raise:  NotFound - ``directory_id`` is not found\n        raise:  NullArgument - ``directory_id`` or ``proxy`` is null\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_file_query()`` is ``false``", 
               "sphinx_param_doc": "        :param directory_id: the ``Id`` to the directory\n        :type directory_id: ``osid.id.Id``\n        :param proxy: a proxy\n        :type proxy: ``osid.proxy.Proxy``\n", 
               "sphinx_return_doc": "        :return: a ``FileQuerySession``\n        :rtype: ``osid.filing.FileQuerySession``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``directory_id`` is not found\n        :raise: ``NullArgument`` -- ``directory_id`` or ``proxy`` is null\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_file_query()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_file_query()`` and ``supports_visible_federation()`` are ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "directory_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.proxy.Proxy", 
                     "var_name": "proxy", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "osid.proxy.Proxy"
               ], 
               "return_type": "osid.filing.FileQuerySession", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_file_search_session", 
               "doc": {
                  "headline": "Gets the session for searching for files.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    proxy (osid.proxy.Proxy): a proxy\n", 
               "return_doc": "        return: (osid.filing.FileSearchSession) - the\n                ``FileSearchSession``", 
               "error_doc": "        raise:  NullArgument - ``proxy`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_file_search()`` is ``false``", 
               "sphinx_param_doc": "        :param proxy: a proxy\n        :type proxy: ``osid.proxy.Proxy``\n", 
               "sphinx_return_doc": "        :return: the ``FileSearchSession``\n        :rtype: ``osid.filing.FileSearchSession``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``proxy`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_file_search()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_file_search()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.proxy.Proxy", 
                     "var_name": "proxy", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.proxy.Proxy"
               ], 
               "return_type": "osid.filing.FileSearchSession", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_file_search_session_for_directory", 
               "doc": {
                  "headline": "Gets a file search session for the specified directory.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    directory_id (osid.id.Id): the ``Id`` to the directory\n        arg:    proxy (osid.proxy.Proxy): a proxy\n", 
               "return_doc": "        return: (osid.filing.FileSearchSession) - a\n                ``FileSearchSession``", 
               "error_doc": "        raise:  NotFound - ``directory_id`` is not found\n        raise:  NullArgument - ``directory_id`` or ``proxy`` is null\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_file_search()`` is ``false``", 
               "sphinx_param_doc": "        :param directory_id: the ``Id`` to the directory\n        :type directory_id: ``osid.id.Id``\n        :param proxy: a proxy\n        :type proxy: ``osid.proxy.Proxy``\n", 
               "sphinx_return_doc": "        :return: a ``FileSearchSession``\n        :rtype: ``osid.filing.FileSearchSession``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``directory_id`` is not found\n        :raise: ``NullArgument`` -- ``directory_id`` or ``proxy`` is null\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_file_search()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_file_search()`` and ``supports_visible_federation()`` are ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "directory_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.proxy.Proxy", 
                     "var_name": "proxy", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "osid.proxy.Proxy"
               ], 
               "return_type": "osid.filing.FileSearchSession", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_file_notification_session", 
               "doc": {
                  "headline": "Gets the session for receiving messages about changes to files.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    file_receiver (osid.filing.FileReceiver): the\n                notification callback\n        arg:    proxy (osid.proxy.Proxy): a proxy\n", 
               "return_doc": "        return: (osid.filing.FileNotificationSession) - ``a\n                FileNotificationSession``", 
               "error_doc": "        raise:  NullArgument - ``file_receiver`` or ``proxy`` is\n                ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_file_notification()`` is\n                ``false``", 
               "sphinx_param_doc": "        :param file_receiver: the notification callback\n        :type file_receiver: ``osid.filing.FileReceiver``\n        :param proxy: a proxy\n        :type proxy: ``osid.proxy.Proxy``\n", 
               "sphinx_return_doc": "        :return: ``a FileNotificationSession``\n        :rtype: ``osid.filing.FileNotificationSession``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``file_receiver`` or ``proxy`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_file_notification()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_file_notification()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.filing.FileReceiver", 
                     "var_name": "file_receiver", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.proxy.Proxy", 
                     "var_name": "proxy", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.filing.FileReceiver", 
                  "osid.proxy.Proxy"
               ], 
               "return_type": "osid.filing.FileNotificationSession", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_file_notification_session_for_directory", 
               "doc": {
                  "headline": "Gets a file notification session for the specified directory.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    file_receiver (osid.filing.FileReceiver): the\n                notification callback\n        arg:    directory_id (osid.id.Id): the ``Id`` to the directory\n        arg:    proxy (osid.proxy.Proxy): a proxy\n", 
               "return_doc": "        return: (osid.filing.FileNotificationSession) - a\n                ``FileNotificationSession``", 
               "error_doc": "        raise:  NotFound - ``directory_path`` is not found\n        raise:  NullArgument - ``file_receiver, directory_id,`` or\n                ``proxy`` is null\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_file_notification()`` is\n                ``false``", 
               "sphinx_param_doc": "        :param file_receiver: the notification callback\n        :type file_receiver: ``osid.filing.FileReceiver``\n        :param directory_id: the ``Id`` to the directory\n        :type directory_id: ``osid.id.Id``\n        :param proxy: a proxy\n        :type proxy: ``osid.proxy.Proxy``\n", 
               "sphinx_return_doc": "        :return: a ``FileNotificationSession``\n        :rtype: ``osid.filing.FileNotificationSession``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``directory_path`` is not found\n        :raise: ``NullArgument`` -- ``file_receiver, directory_id,`` or ``proxy`` is null\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_file_notification()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_file_notification()`` and ``supports_visible_federation()`` are ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.filing.FileReceiver", 
                     "var_name": "file_receiver", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "directory_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.proxy.Proxy", 
                     "var_name": "proxy", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.filing.FileReceiver", 
                  "osid.id.Id", 
                  "osid.proxy.Proxy"
               ], 
               "return_type": "osid.filing.FileNotificationSession", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_file_smart_directory_session", 
               "doc": {
                  "headline": "Gets the session for managing dynamic diectories.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    directory_id (osid.id.Id): the ``Id`` to the directory\n        arg:    proxy (osid.proxy.Proxy): a proxy\n", 
               "return_doc": "        return: (osid.filing.FileSmartDirectorySession) - a\n                ``FileSmartDirectorySession``", 
               "error_doc": "        raise:  NotFound - ``directory_id is not found``\n        raise:  NullArgument - ``directory_id or proxy is null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_file_smart_directory()`` is\n                ``false``", 
               "sphinx_param_doc": "        :param directory_id: the ``Id`` to the directory\n        :type directory_id: ``osid.id.Id``\n        :param proxy: a proxy\n        :type proxy: ``osid.proxy.Proxy``\n", 
               "sphinx_return_doc": "        :return: a ``FileSmartDirectorySession``\n        :rtype: ``osid.filing.FileSmartDirectorySession``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``directory_id is not found``\n        :raise: ``NullArgument`` -- ``directory_id or proxy is null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_file_smart_directory()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_file_smart_directory()`` and ``supports_visible_federation()`` are ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "directory_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.proxy.Proxy", 
                     "var_name": "proxy", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "osid.proxy.Proxy"
               ], 
               "return_type": "osid.filing.FileSmartDirectorySession", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_directory_lookup_session", 
               "doc": {
                  "headline": "Gets the session for examining directories.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    proxy (osid.proxy.Proxy): a proxy\n", 
               "return_doc": "        return: (osid.filing.DirectoryLookupSession) - a\n                ``DirectoryLookupSession``", 
               "error_doc": "        raise:  NullArgument - ``proxy`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_directory_lookup()`` is\n                ``false``", 
               "sphinx_param_doc": "        :param proxy: a proxy\n        :type proxy: ``osid.proxy.Proxy``\n", 
               "sphinx_return_doc": "        :return: a ``DirectoryLookupSession``\n        :rtype: ``osid.filing.DirectoryLookupSession``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``proxy`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_directory_lookup()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_directory_lookup()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.proxy.Proxy", 
                     "var_name": "proxy", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.proxy.Proxy"
               ], 
               "return_type": "osid.filing.DirectoryLookupSession", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_directory_lookup_session_for_directory", 
               "doc": {
                  "headline": "Gets the session for examining a given directory.", 
                  "body": "        If the path is an alias, the target directory is used. The path\n        indicates the file alias and the real path indicates the target\n        directory."
               }, 
               "arg_doc": "        arg:    directory_id (osid.id.Id): the ``Id`` to the directory\n        arg:    proxy (osid.proxy.Proxy): a proxy\n", 
               "return_doc": "        return: (osid.filing.DirectoryLookupSession) - a\n                ``DirectoryLookupSession``", 
               "error_doc": "        raise:  NotFound - ``directory_id is not found``\n        raise:  NullArgument - ``directory_id or proxy is null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_directory_lookup()`` is\n                ``false``", 
               "sphinx_param_doc": "        :param directory_id: the ``Id`` to the directory\n        :type directory_id: ``osid.id.Id``\n        :param proxy: a proxy\n        :type proxy: ``osid.proxy.Proxy``\n", 
               "sphinx_return_doc": "        :return: a ``DirectoryLookupSession``\n        :rtype: ``osid.filing.DirectoryLookupSession``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``directory_id is not found``\n        :raise: ``NullArgument`` -- ``directory_id or proxy is null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_directory_lookup()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_directory_lookup()`` and ``supports_visible_federation()`` are ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "directory_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.proxy.Proxy", 
                     "var_name": "proxy", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "osid.proxy.Proxy"
               ], 
               "return_type": "osid.filing.DirectoryLookupSession", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_directory_query_session", 
               "doc": {
                  "headline": "Gets the session for querying directories.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    proxy (osid.proxy.Proxy): a proxy\n", 
               "return_doc": "        return: (osid.filing.DirectoryQuerySession) - a\n                ``DirectoryQuerySession``", 
               "error_doc": "        raise:  NullArgument - ``proxy`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_directory_query()`` is\n                ``false``", 
               "sphinx_param_doc": "        :param proxy: a proxy\n        :type proxy: ``osid.proxy.Proxy``\n", 
               "sphinx_return_doc": "        :return: a ``DirectoryQuerySession``\n        :rtype: ``osid.filing.DirectoryQuerySession``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``proxy`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_directory_query()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_directory_query()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.proxy.Proxy", 
                     "var_name": "proxy", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.proxy.Proxy"
               ], 
               "return_type": "osid.filing.DirectoryQuerySession", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_directory_query_session_for_directory", 
               "doc": {
                  "headline": "Gets the session for querying directories within a given directory.", 
                  "body": "        If the path is an alias, the target directory is used. The path\n        indicates the file alias and the real path indicates the target\n        directory."
               }, 
               "arg_doc": "        arg:    directory_id (osid.id.Id): the ``Id`` to the directory\n        arg:    proxy (osid.proxy.Proxy): a proxy\n", 
               "return_doc": "        return: (osid.filing.DirectoryQuerySession) - a\n                ``DirectoryQuerySession``", 
               "error_doc": "        raise:  NotFound - ``directory_id is not found``\n        raise:  NullArgument - ``directory_id or proxy is null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_directory_query()`` is\n                ``false``", 
               "sphinx_param_doc": "        :param directory_id: the ``Id`` to the directory\n        :type directory_id: ``osid.id.Id``\n        :param proxy: a proxy\n        :type proxy: ``osid.proxy.Proxy``\n", 
               "sphinx_return_doc": "        :return: a ``DirectoryQuerySession``\n        :rtype: ``osid.filing.DirectoryQuerySession``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``directory_id is not found``\n        :raise: ``NullArgument`` -- ``directory_id or proxy is null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_directory_query()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_directory_query()`` and ``supports_visible_federation()`` are ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "directory_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.proxy.Proxy", 
                     "var_name": "proxy", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "osid.proxy.Proxy"
               ], 
               "return_type": "osid.filing.DirectoryQuerySession", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_directory_search_session", 
               "doc": {
                  "headline": "Gets the session for searching for directories.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    proxy (osid.proxy.Proxy): a proxy\n", 
               "return_doc": "        return: (osid.filing.DirectorySearchSession) - a\n                ``DirectorySearchSession``", 
               "error_doc": "        raise:  NullArgument - ``proxy`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_directory_search()`` is\n                ``false``", 
               "sphinx_param_doc": "        :param proxy: a proxy\n        :type proxy: ``osid.proxy.Proxy``\n", 
               "sphinx_return_doc": "        :return: a ``DirectorySearchSession``\n        :rtype: ``osid.filing.DirectorySearchSession``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``proxy`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_directory_search()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_directory_search()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.proxy.Proxy", 
                     "var_name": "proxy", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.proxy.Proxy"
               ], 
               "return_type": "osid.filing.DirectorySearchSession", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_directory_search_session_for_directory", 
               "doc": {
                  "headline": "Gets the session for searching for directories within a given directory.", 
                  "body": "        If the path is an alias, the target directory is used. The path\n        indicates the file alias and the real path indicates the target\n        directory."
               }, 
               "arg_doc": "        arg:    directory_id (osid.id.Id): the ``Id`` to the directory\n        arg:    proxy (osid.proxy.Proxy): a proxy\n", 
               "return_doc": "        return: (osid.filing.DirectorySearchSession) - a\n                ``DirectorySearchSession``", 
               "error_doc": "        raise:  NotFound - ``directory_id is not found``\n        raise:  NullArgument - ``directory_id or proxy is null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_directory_search()`` is\n                ``false``", 
               "sphinx_param_doc": "        :param directory_id: the ``Id`` to the directory\n        :type directory_id: ``osid.id.Id``\n        :param proxy: a proxy\n        :type proxy: ``osid.proxy.Proxy``\n", 
               "sphinx_return_doc": "        :return: a ``DirectorySearchSession``\n        :rtype: ``osid.filing.DirectorySearchSession``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``directory_id is not found``\n        :raise: ``NullArgument`` -- ``directory_id or proxy is null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_directory_search()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_directory_search()`` and ``supports_visible_federation()`` are ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "directory_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.proxy.Proxy", 
                     "var_name": "proxy", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "osid.proxy.Proxy"
               ], 
               "return_type": "osid.filing.DirectorySearchSession", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_directory_admin_session", 
               "doc": {
                  "headline": "Gets the session for creating and removing files.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    proxy (osid.proxy.Proxy): a proxy\n", 
               "return_doc": "        return: (osid.filing.DirectoryAdminSession) - a\n                ``DirectoryAdminSession``", 
               "error_doc": "        raise:  NullArgument - ``proxy`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_directory_admin()`` is\n                ``false``", 
               "sphinx_param_doc": "        :param proxy: a proxy\n        :type proxy: ``osid.proxy.Proxy``\n", 
               "sphinx_return_doc": "        :return: a ``DirectoryAdminSession``\n        :rtype: ``osid.filing.DirectoryAdminSession``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``proxy`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_directory_admin()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_directory_admin()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.proxy.Proxy", 
                     "var_name": "proxy", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.proxy.Proxy"
               ], 
               "return_type": "osid.filing.DirectoryAdminSession", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_directory_admin_session_for_directory", 
               "doc": {
                  "headline": "Gets the session for searching for creating and removing files in the given directory.", 
                  "body": "        If the path is an alias, the target directory is used. The path\n        indicates the file alias and the real path indicates the target\n        directory."
               }, 
               "arg_doc": "        arg:    directory_id (osid.id.Id): the ``Id`` to the directory\n        arg:    proxy (osid.proxy.Proxy): a proxy\n", 
               "return_doc": "        return: (osid.filing.DirectoryAdminSession) - a\n                ``DirectoryAdminSession``", 
               "error_doc": "        raise:  NotFound - ``directory_id is not found``\n        raise:  NullArgument - ``directory_id or proxy is null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_directory_admin()`` is\n                ``false``", 
               "sphinx_param_doc": "        :param directory_id: the ``Id`` to the directory\n        :type directory_id: ``osid.id.Id``\n        :param proxy: a proxy\n        :type proxy: ``osid.proxy.Proxy``\n", 
               "sphinx_return_doc": "        :return: a ``DirectoryAdminSession``\n        :rtype: ``osid.filing.DirectoryAdminSession``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``directory_id is not found``\n        :raise: ``NullArgument`` -- ``directory_id or proxy is null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_directory_admin()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_directory_admin()`` and ``supports_visible_federation()`` are ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "directory_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.proxy.Proxy", 
                     "var_name": "proxy", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "osid.proxy.Proxy"
               ], 
               "return_type": "osid.filing.DirectoryAdminSession", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_directory_notification_session", 
               "doc": {
                  "headline": "Gets the session for receiving messages about changes to directories.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    directory_receiver (osid.filing.DirectoryReceiver): the\n                notification callback\n        arg:    proxy (osid.proxy.Proxy): a proxy\n", 
               "return_doc": "        return: (osid.filing.DirectoryNotificationSession) - a\n                ``DirectoryNotificationSession``", 
               "error_doc": "        raise:  NullArgument - ``directory_receiver`` or ``proxy`` is\n                ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_directory_notification()`` is\n                ``false``", 
               "sphinx_param_doc": "        :param directory_receiver: the notification callback\n        :type directory_receiver: ``osid.filing.DirectoryReceiver``\n        :param proxy: a proxy\n        :type proxy: ``osid.proxy.Proxy``\n", 
               "sphinx_return_doc": "        :return: a ``DirectoryNotificationSession``\n        :rtype: ``osid.filing.DirectoryNotificationSession``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``directory_receiver`` or ``proxy`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_directory_notification()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_directory_notification()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.filing.DirectoryReceiver", 
                     "var_name": "directory_receiver", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.proxy.Proxy", 
                     "var_name": "proxy", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.filing.DirectoryReceiver", 
                  "osid.proxy.Proxy"
               ], 
               "return_type": "osid.filing.DirectoryNotificationSession", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_directory_notification_session_for_directory", 
               "doc": {
                  "headline": "Gets the session for receiving messages about changes to directories in the given directory.", 
                  "body": "        If the path is an alias, the target directory is used. The path\n        indicates the file alias and the real path indicates the target\n        directory."
               }, 
               "arg_doc": "        arg:    directory_receiver (osid.filing.DirectoryReceiver): the\n                notification callback\n        arg:    directory_id (osid.id.Id): the ``Id`` to the directory\n        arg:    proxy (osid.proxy.Proxy): a proxy\n", 
               "return_doc": "        return: (osid.filing.DirectoryNotificationSession) - a\n                ``DirectoryNotificationSession``", 
               "error_doc": "        raise:  NotFound - ``directory_path`` is not found\n        raise:  NullArgument - ``directory_receiver, directory_id,`` or\n                ``proxy`` is null\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_directory_notification()`` is\n                ``false``", 
               "sphinx_param_doc": "        :param directory_receiver: the notification callback\n        :type directory_receiver: ``osid.filing.DirectoryReceiver``\n        :param directory_id: the ``Id`` to the directory\n        :type directory_id: ``osid.id.Id``\n        :param proxy: a proxy\n        :type proxy: ``osid.proxy.Proxy``\n", 
               "sphinx_return_doc": "        :return: a ``DirectoryNotificationSession``\n        :rtype: ``osid.filing.DirectoryNotificationSession``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``directory_path`` is not found\n        :raise: ``NullArgument`` -- ``directory_receiver, directory_id,`` or ``proxy`` is null\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_directory_notification()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_directory_notification()`` and ``supports_visible_federation()`` are ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.filing.DirectoryReceiver", 
                     "var_name": "directory_receiver", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "directory_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.proxy.Proxy", 
                     "var_name": "proxy", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.filing.DirectoryReceiver", 
                  "osid.id.Id", 
                  "osid.proxy.Proxy"
               ], 
               "return_type": "osid.filing.DirectoryNotificationSession", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_filing_allocation_proxy_manager", 
               "doc": {
                  "headline": "Gets the ``FilingAllocationProxyManager``.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.filing.allocation.FilingAllocationProxyManager) -\n                a ``FilingAllocationProxyManager``", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_filing_allocation()`` is\n                ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: a ``FilingAllocationProxyManager``\n        :rtype: ``osid.filing.allocation.FilingAllocationProxyManager``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_filing_allocation()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_filing_allocation()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.filing.allocation.FilingAllocationProxyManager", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.filing.FileSystemSession", 
         "shortname": "FileSystemSession", 
         "category": "sessions", 
         "doc": {
            "headline": "This session defines methods for examining file systems.", 
            "body": "    A ``FileSystemSession`` is associated with a directory that, unlike\n    other catalogs, behaves as the current directory path for supplying\n    relative path names. Absolute path names can be supplied to access\n    any file or directory in the file system.\n\n    This session defines the following views:\n    \n      * comparative view: elements may be silently omitted or re-ordered\n      * plenary view: provides a complete result set or is an error\n        condition\n      * federated directory view: searches include entries in\n        directories of which this directory is an ancestor\n      * isolated directory view: lookups are restricted to entries in\n        this directory only\n\n    \n    Generally, the comparative view should be used for most applications\n    as it permits operation even if there is data out of sync. Some\n    administrative applications may need to know whether it had\n    retrieved an entire set of objects and may sacrifice some\n    interoperability for the sake of precision using the plenary view."
         }, 
         "inherit_fullnames": [
            "osid.OsidSession"
         ], 
         "inherit_shortnames": [
            "OsidSession"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidSession"
            }
         ], 
         "method_names": [
            "get_directory_id", 
            "get_directory", 
            "can_lookup_directory_entries", 
            "has_parent_directory", 
            "get_parent_directory", 
            "use_comparative_directory_view", 
            "use_plenary_directory_view", 
            "use_federated_directory_view", 
            "use_isolated_directory_view", 
            "exists", 
            "is_file", 
            "is_directory", 
            "is_alias", 
            "get_file", 
            "get_files_by_name", 
            "get_files", 
            "get_subdirectory", 
            "get_subdirectories_by_name", 
            "get_subdirectories"
         ], 
         "methods": [
            {
               "name": "get_directory_id", 
               "doc": {
                  "headline": "Gets the ``Id`` of this directory.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.id.Id) - the ``Id`` of this directory", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the ``Id`` of this directory\n        :rtype: ``osid.id.Id``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.id.Id", 
               "errors": {}
            }, 
            {
               "name": "get_directory", 
               "doc": {
                  "headline": "Gets the directory associated with this session.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.filing.Directory) - the directory associated with\n                this session", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the directory associated with this session\n        :rtype: ``osid.filing.Directory``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.filing.Directory", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "can_lookup_directory_entries", 
               "doc": {
                  "headline": "Tests if this user can perform entry lookups.", 
                  "body": "        A return of true does not guarantee successful authorization. A\n        return of false indicates that it is known all methods in this\n        session will result in a ``PermissionDenied``. This is intended\n        as a hint to an application that may opt not to offer lookup\n        operations."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``false`` if lookup methods are not\n                authorized, ``true`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``false`` if lookup methods are not authorized, ``true`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "has_parent_directory", 
               "doc": {
                  "headline": "Tests if the directory associated with this session has a parent directory.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if a parent exists, ``false``\n                otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if a parent exists, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "get_parent_directory", 
               "doc": {
                  "headline": "Gets the parent of the directory associated with this session.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.filing.Directory) - the parent of the directory\n                associated with this session", 
               "error_doc": "        raise:  IllegalState - ``has_parent_directory()`` is ``false``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the parent of the directory associated with this session\n        :rtype: ``osid.filing.Directory``", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- ``has_parent_directory()`` is ``false``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.filing.Directory", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "use_comparative_directory_view", 
               "doc": {
                  "headline": "The returns from the lookup methods may omit or translate elements based on this session, such as authorization, and not result in an error.", 
                  "body": "        This view is used when greater interoperability is desired at\n        the expense of precision."
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "use_plenary_directory_view", 
               "doc": {
                  "headline": "A complete view of the file or directory returns is desired.", 
                  "body": "        Methods will return what is requested or result in an error.\n        This view is used when greater precision is desired at the\n        expense of interoperability."
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "use_federated_directory_view", 
               "doc": {
                  "headline": "Federates the view for methods in this session.", 
                  "body": "        A federated view will include entries in directories which are\n        children of this directory."
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "use_isolated_directory_view", 
               "doc": {
                  "headline": "Isolates the view for methods in this session.", 
                  "body": "        An isolated view restricts lookups to this directory only."
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "exists", 
               "doc": {
                  "headline": "Tests if a file, directory or alias name exists.", 
                  "body": "        In a federated view, the existence test is performed on this\n        directory and any children of this directory. In an isolated\n        view, the existence test is restrcited to this directory only."
               }, 
               "arg_doc": "        arg:    name (string): a file or directory name\n", 
               "return_doc": "        return: (boolean) - ``true`` if the name exists, ``false``\n                otherwise", 
               "error_doc": "        raise:  NullArgument - ``name`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param name: a file or directory name\n        :type name: ``string``\n", 
               "sphinx_return_doc": "        :return: ``true`` if the name exists, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``name`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "string", 
                     "var_name": "name", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "string"
               ], 
               "return_type": "boolean", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "is_file", 
               "doc": {
                  "headline": "Tests if a name exists and is a file or an alias to a file.", 
                  "body": "        In a federated view, the exietence test is performed on this\n        directory and any children of this directory. In an isolated\n        view, the existence test is restrcited to this directory only."
               }, 
               "arg_doc": "        arg:    name (string): a file name\n", 
               "return_doc": "        return: (boolean) - ``true`` if the name is a file, ``false``\n                otherwise", 
               "error_doc": "        raise:  NullArgument - ``name`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param name: a file name\n        :type name: ``string``\n", 
               "sphinx_return_doc": "        :return: ``true`` if the name is a file, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``name`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "string", 
                     "var_name": "name", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "string"
               ], 
               "return_type": "boolean", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "is_directory", 
               "doc": {
                  "headline": "Tests if a name exists and is a directory or an alias to a directory.", 
                  "body": "        In a federated view, the exietence test is performed on this\n        directory and any children of this directory. In an isolated\n        view, the existence test is restrcited to this directory only."
               }, 
               "arg_doc": "        arg:    name (string): a file or directory name\n", 
               "return_doc": "        return: (boolean) - ``true`` if the path is a directory,\n                ``false`` otherwise", 
               "error_doc": "        raise:  NullArgument - ``name`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param name: a file or directory name\n        :type name: ``string``\n", 
               "sphinx_return_doc": "        :return: ``true`` if the path is a directory, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``name`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "string", 
                     "var_name": "name", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "string"
               ], 
               "return_type": "boolean", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "is_alias", 
               "doc": {
                  "headline": "Tests if a name exists and is an alias.", 
                  "body": "        In a federated view, the exietence test is performed on this\n        directory and any children of this directory. In an isolated\n        view, the existence test is restrcited to this directory only."
               }, 
               "arg_doc": "        arg:    name (string): a file or directory name\n", 
               "return_doc": "        return: (boolean) - ``true`` if the path is an alias, ``false``\n                otherwise", 
               "error_doc": "        raise:  NullArgument - ``name`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param name: a file or directory name\n        :type name: ``string``\n", 
               "sphinx_return_doc": "        :return: ``true`` if the path is an alias, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``name`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "string", 
                     "var_name": "name", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "string"
               ], 
               "return_type": "boolean", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_file", 
               "doc": {
                  "headline": "Gets a specified file or alias to the file by its name in the current directory only.", 
                  "body": "        For federated views, use ``getFilesByName()``."
               }, 
               "arg_doc": "        arg:    name (string): the name to the file\n", 
               "return_doc": "        return: (osid.filing.File) - the file", 
               "error_doc": "        raise:  NotFound - ``name`` is not found or is a directory\n        raise:  NullArgument - ``name`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param name: the name to the file\n        :type name: ``string``\n", 
               "sphinx_return_doc": "        :return: the file\n        :rtype: ``osid.filing.File``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``name`` is not found or is a directory\n        :raise: ``NullArgument`` -- ``name`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "string", 
                     "var_name": "name", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "string"
               ], 
               "return_type": "osid.filing.File", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_files_by_name", 
               "doc": {
                  "headline": "Gets a specified files and aliases to files for the given file name.", 
                  "body": "        In an isolated view, this method behaves like ``getFile()``. Is\n        a federated view, this method returns a list of files by the\n        same name in descendant directories. In plenary mode, the\n        returned list contains all known files or an error results.\n        Otherwise, the returned list may contain only those files that\n        are accessible through this session."
               }, 
               "arg_doc": "        arg:    name (string): the name of the file\n", 
               "return_doc": "        return: (osid.filing.FileList) - the list of files of the given\n                name", 
               "error_doc": "        raise:  NullArgument - ``name`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param name: the name of the file\n        :type name: ``string``\n", 
               "sphinx_return_doc": "        :return: the list of files of the given name\n        :rtype: ``osid.filing.FileList``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``name`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "string", 
                     "var_name": "name", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "string"
               ], 
               "return_type": "osid.filing.FileList", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_files", 
               "doc": {
                  "headline": "Gets the list of files and aliases to files in this directory.", 
                  "body": "        In a federated view, this method returns all files in descendant\n        directories. In plenary mode, the returned list contains all\n        known files or an error results. Otherwise, the returned list\n        may contain only those files that are accessible through this\n        session."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.filing.FileList) - the list of files in this\n                directory", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the list of files in this directory\n        :rtype: ``osid.filing.FileList``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.filing.FileList", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_subdirectory", 
               "doc": {
                  "headline": "Gets a specified directory or alias to the directory by its name in the current directory only.", 
                  "body": "        For federated views, use ``getDirectoriesByName()``."
               }, 
               "arg_doc": "        arg:    name (string): the name of the directory\n", 
               "return_doc": "        return: (osid.filing.Directory) - the directory", 
               "error_doc": "        raise:  NotFound - ``name`` is not found or is a file\n        raise:  NullArgument - ``name`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param name: the name of the directory\n        :type name: ``string``\n", 
               "sphinx_return_doc": "        :return: the directory\n        :rtype: ``osid.filing.Directory``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``name`` is not found or is a file\n        :raise: ``NullArgument`` -- ``name`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "string", 
                     "var_name": "name", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "string"
               ], 
               "return_type": "osid.filing.Directory", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_subdirectories_by_name", 
               "doc": {
                  "headline": "Gets a specified directories and aliases to directories for the given directory name.", 
                  "body": "        In an isolated view, this method behaves like\n        ``getDirectory()``. Is a federated view, this method returns a\n        list of directories by the same name in descedent directories.\n        In plenary mode, the returned list contains all known files or\n        an error results. Otherwise, the returned list may contain only\n        those files that are accessible through this session."
               }, 
               "arg_doc": "        arg:    name (string): the name of the file\n", 
               "return_doc": "        return: (osid.filing.DirectoryList) - the list of files of the\n                given name", 
               "error_doc": "        raise:  NullArgument - ``name`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param name: the name of the file\n        :type name: ``string``\n", 
               "sphinx_return_doc": "        :return: the list of files of the given name\n        :rtype: ``osid.filing.DirectoryList``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``name`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "string", 
                     "var_name": "name", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "string"
               ], 
               "return_type": "osid.filing.DirectoryList", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_subdirectories", 
               "doc": {
                  "headline": "Gets the list of directories and aliases to directories in this directory.", 
                  "body": "        In a federated view, this method returns all directories in\n        descedent directories. In plenary mode, the returned list\n        contains all known files or an error results. Otherwise, the\n        returned list may contain only those files that are accessible\n        through this session."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.filing.DirectoryList) - the list of directories in\n                this directory", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the list of directories in this directory\n        :rtype: ``osid.filing.DirectoryList``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.filing.DirectoryList", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.filing.FileSystemManagementSession", 
         "shortname": "FileSystemManagementSession", 
         "category": "sessions", 
         "doc": {
            "headline": "This session defines methods for operating on files and directories.", 
            "body": "    This session is an expanded version of the ``DirectoryAdminSession``\n    that defines methods requiring path names for navigating a\n    federation of directories as opposed to working within a single\n    directory node.\n\n    The directory associated with this session is the current working\n    directory and any relative path names provided are with respect to\n    this directory. Absolute pathnames may be supplied outside this\n    directory."
         }, 
         "inherit_fullnames": [
            "osid.OsidSession"
         ], 
         "inherit_shortnames": [
            "OsidSession"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidSession"
            }
         ], 
         "method_names": [
            "get_directory_id", 
            "get_directory", 
            "can_manage_filing", 
            "overwrite", 
            "create_missing_paths", 
            "move_file", 
            "move_directory", 
            "copy_file", 
            "copy_directory", 
            "link_file", 
            "link_directory"
         ], 
         "methods": [
            {
               "name": "get_directory_id", 
               "doc": {
                  "headline": "Gets the ``Id`` of this directory.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.id.Id) - the ``Id`` of this directory", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the ``Id`` of this directory\n        :rtype: ``osid.id.Id``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.id.Id", 
               "errors": {}
            }, 
            {
               "name": "get_directory", 
               "doc": {
                  "headline": "Gets the directory associated with this session.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.filing.Directory) - the directory associated with\n                this session", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the directory associated with this session\n        :rtype: ``osid.filing.Directory``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.filing.Directory", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "can_manage_filing", 
               "doc": {
                  "headline": "Tests if this user can perform functions in this session.", 
                  "body": "        A return of true does not guarantee successful authorization. A\n        return of false indicates that it is known all methods in this\n        session will result in a ``PermissionDenied``. This is intended\n        as a hint to an application that may opt not to offer lookup\n        operations to unauthorized users."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``false`` if filing management methods are\n                not authorized, ``true`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``false`` if filing management methods are not authorized, ``true`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "overwrite", 
               "doc": {
                  "headline": "Overwrite files if a destination pathname exists.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    overwite (boolean): ``true`` if files can be\n                overwritten, ``false`` otherwise\n", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "        :param overwite: ``true`` if files can be overwritten, ``false`` otherwise\n        :type overwite: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "boolean", 
                     "var_name": "overwite", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "create_missing_paths", 
               "doc": {
                  "headline": "Create any missing directories for a destination path that does not exist.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    create (boolean): ``true`` if intermediate directories\n                should be created, ``false`` otherwise\n", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "        :param create: ``true`` if intermediate directories should be created, ``false`` otherwise\n        :type create: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "boolean", 
                     "var_name": "create", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "move_file", 
               "doc": {
                  "headline": "Moves a file to another path.", 
                  "body": "        The detination path may be a file or directory. If the\n        destination is a file and exists, the destination is only\n        replaced if ``overwrite()`` is ``true``. If the destination is a\n        directory and does not exist, the missing directories are only\n        created if ``create_missing_paths()`` is ``true``."
               }, 
               "arg_doc": "        arg:    src (osid.id.Id): the source ``Id`` of the file\n        arg:    dst (string): the destination name or path of the\n                directory or file\n", 
               "return_doc": "", 
               "error_doc": "        raise:  AlreadyExists - ``dst`` exists and ``overwrite()`` is\n                ``false``\n        raise:  InvalidArgument - ``src`` is not a file\n        raise:  NotFound - ``src`` is not found, or the path to ``dst``\n                is not found and ``create_missing_paths()`` is ``false``\n        raise:  NullArgument - ``src`` or ``dst`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param src: the source ``Id`` of the file\n        :type src: ``osid.id.Id``\n        :param dst: the destination name or path of the directory or file\n        :type dst: ``string``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``AlreadyExists`` -- ``dst`` exists and ``overwrite()`` is ``false``\n        :raise: ``InvalidArgument`` -- ``src`` is not a file\n        :raise: ``NotFound`` -- ``src`` is not found, or the path to ``dst`` is not found and ``create_missing_paths()`` is ``false``\n        :raise: ``NullArgument`` -- ``src`` or ``dst`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "src", 
                     "array": false
                  }, 
                  {
                     "arg_type": "string", 
                     "var_name": "dst", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "string"
               ], 
               "return_type": "", 
               "errors": {
                  "ALREADY_EXISTS": "User", 
                  "INVALID_ARGUMENT": "ConsumerContract", 
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "move_directory", 
               "doc": {
                  "headline": "Moves a directory to another path.", 
                  "body": "        The destination must be a directory and if exists, the source\n        directory is placed as a child to the given directory. If a path\n        component in the destination does not exist, the path is created\n        is ``create_missing_paths()`` is ``true``."
               }, 
               "arg_doc": "        arg:    src (osid.id.Id): the source ``Id`` of the directory\n        arg:    dst (string): the destination name or path of the\n                directory\n", 
               "return_doc": "", 
               "error_doc": "        raise:  InvalidArgument - ``src`` is not a directory\n        raise:  NotFound - ``src`` is not found, or the path to ``dst``\n                is not found and ``create_missing_paths()`` is ``false``\n        raise:  NullArgument - ``src`` or ``dst`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param src: the source ``Id`` of the directory\n        :type src: ``osid.id.Id``\n        :param dst: the destination name or path of the directory\n        :type dst: ``string``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``InvalidArgument`` -- ``src`` is not a directory\n        :raise: ``NotFound`` -- ``src`` is not found, or the path to ``dst`` is not found and ``create_missing_paths()`` is ``false``\n        :raise: ``NullArgument`` -- ``src`` or ``dst`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "src", 
                     "array": false
                  }, 
                  {
                     "arg_type": "string", 
                     "var_name": "dst", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "string"
               ], 
               "return_type": "", 
               "errors": {
                  "INVALID_ARGUMENT": "ConsumerContract", 
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "copy_file", 
               "doc": {
                  "headline": "Copies a file to another path.", 
                  "body": "        The detination path may be a file or directory. If the\n        destination is a file and exists, the destination is only\n        replaced if ``overwrite()`` is ``true``. If the destination is a\n        directory and does not exist, the missing directories are only\n        created if ``create_missing_paths()`` is ``true``."
               }, 
               "arg_doc": "        arg:    src (osid.id.Id): the source ``Id`` of the file\n        arg:    dst (string): the destination name or path of the\n                directory or file\n", 
               "return_doc": "        return: (osid.filing.File) - the new file", 
               "error_doc": "        raise:  AlreadyExists - ``dst`` exists and ``overwrite()`` is\n                ``false``\n        raise:  InvalidArgument - ``src`` is not a file\n        raise:  NotFound - ``src`` is not found, or the path to ``dst``\n                is not found and ``create_missing_paths()`` is ``false``\n        raise:  NullArgument - ``src`` or ``dst`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param src: the source ``Id`` of the file\n        :type src: ``osid.id.Id``\n        :param dst: the destination name or path of the directory or file\n        :type dst: ``string``\n", 
               "sphinx_return_doc": "        :return: the new file\n        :rtype: ``osid.filing.File``", 
               "sphinx_error_doc": "        :raise: ``AlreadyExists`` -- ``dst`` exists and ``overwrite()`` is ``false``\n        :raise: ``InvalidArgument`` -- ``src`` is not a file\n        :raise: ``NotFound`` -- ``src`` is not found, or the path to ``dst`` is not found and ``create_missing_paths()`` is ``false``\n        :raise: ``NullArgument`` -- ``src`` or ``dst`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "src", 
                     "array": false
                  }, 
                  {
                     "arg_type": "string", 
                     "var_name": "dst", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "string"
               ], 
               "return_type": "osid.filing.File", 
               "errors": {
                  "ALREADY_EXISTS": "User", 
                  "INVALID_ARGUMENT": "ConsumerContract", 
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "copy_directory", 
               "doc": {
                  "headline": "Copies a directory and all of its contents to another path.", 
                  "body": "        The destination must be a directory and if exists, the source\n        directory is placed as a child to the given directory. If a path\n        component in the destination does not exist, the path is created\n        is ``create_missing_paths()`` is ``true``."
               }, 
               "arg_doc": "        arg:    src (osid.id.Id): the source ``Id`` of the directory\n        arg:    dst (string): the destination name or path of the\n                directory\n", 
               "return_doc": "        return: (osid.filing.Directory) - the new file", 
               "error_doc": "        raise:  InvalidArgument - ``src`` is not a directory\n        raise:  NotFound - ``src`` is not found, or the path to ``dst``\n                is not found and ``create_missing_paths()`` is ``false``\n        raise:  NullArgument - ``src`` or ``dst`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param src: the source ``Id`` of the directory\n        :type src: ``osid.id.Id``\n        :param dst: the destination name or path of the directory\n        :type dst: ``string``\n", 
               "sphinx_return_doc": "        :return: the new file\n        :rtype: ``osid.filing.Directory``", 
               "sphinx_error_doc": "        :raise: ``InvalidArgument`` -- ``src`` is not a directory\n        :raise: ``NotFound`` -- ``src`` is not found, or the path to ``dst`` is not found and ``create_missing_paths()`` is ``false``\n        :raise: ``NullArgument`` -- ``src`` or ``dst`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "src", 
                     "array": false
                  }, 
                  {
                     "arg_type": "string", 
                     "var_name": "dst", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "string"
               ], 
               "return_type": "osid.filing.Directory", 
               "errors": {
                  "INVALID_ARGUMENT": "ConsumerContract", 
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "link_file", 
               "doc": {
                  "headline": "Creates a link from one file to another.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    file_id (osid.id.Id): the ``Id`` of a file\n        arg:    link (string): the link path\n", 
               "return_doc": "        return: (osid.filing.File) - the link", 
               "error_doc": "        raise:  AlreadyExists - ``link already`` exists\n        raise:  NotFound - ``file_id`` is not found, or the path to\n                ``link`` is not found and ``create_missing_paths()`` is\n                ``false``\n        raise:  NullArgument - ``file_id`` or ``link`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param file_id: the ``Id`` of a file\n        :type file_id: ``osid.id.Id``\n        :param link: the link path\n        :type link: ``string``\n", 
               "sphinx_return_doc": "        :return: the link\n        :rtype: ``osid.filing.File``", 
               "sphinx_error_doc": "        :raise: ``AlreadyExists`` -- ``link already`` exists\n        :raise: ``NotFound`` -- ``file_id`` is not found, or the path to ``link`` is not found and ``create_missing_paths()`` is ``false``\n        :raise: ``NullArgument`` -- ``file_id`` or ``link`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "file_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "string", 
                     "var_name": "link", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "string"
               ], 
               "return_type": "osid.filing.File", 
               "errors": {
                  "ALREADY_EXISTS": "User", 
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "link_directory", 
               "doc": {
                  "headline": "Creates a link from one directory to another.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    directory_id (osid.id.Id): the ``Id`` of a directory\n        arg:    link (string): the destination path\n", 
               "return_doc": "        return: (osid.filing.Directory) - the link", 
               "error_doc": "        raise:  AlreadyExists - ``link already`` exists\n        raise:  NotFound - ``directory_id`` is not found, or the path to\n                ``link`` is not found and ``create_missing_paths()`` is\n                ``false``\n        raise:  NullArgument - ``directory_id`` or ``link`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param directory_id: the ``Id`` of a directory\n        :type directory_id: ``osid.id.Id``\n        :param link: the destination path\n        :type link: ``string``\n", 
               "sphinx_return_doc": "        :return: the link\n        :rtype: ``osid.filing.Directory``", 
               "sphinx_error_doc": "        :raise: ``AlreadyExists`` -- ``link already`` exists\n        :raise: ``NotFound`` -- ``directory_id`` is not found, or the path to ``link`` is not found and ``create_missing_paths()`` is ``false``\n        :raise: ``NullArgument`` -- ``directory_id`` or ``link`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "directory_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "string", 
                     "var_name": "link", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "string"
               ], 
               "return_type": "osid.filing.Directory", 
               "errors": {
                  "ALREADY_EXISTS": "User", 
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.filing.FileContentSession", 
         "shortname": "FileContentSession", 
         "category": "sessions", 
         "doc": {
            "headline": "This session defines methods forreading and writing files.", 
            "body": "    The directory associated with this session is the current working\n    directory and any relative path names provided are with respect to\n    this directory."
         }, 
         "inherit_fullnames": [
            "osid.OsidSession"
         ], 
         "inherit_shortnames": [
            "OsidSession"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidSession"
            }
         ], 
         "method_names": [
            "get_directory_id", 
            "get_directory", 
            "can_read_files", 
            "get_input_stream", 
            "get_blocking_input_stream", 
            "can_write_files", 
            "get_output_stream", 
            "get_output_stream_for_append", 
            "touch"
         ], 
         "methods": [
            {
               "name": "get_directory_id", 
               "doc": {
                  "headline": "Gets the ``Id`` of this directory.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.id.Id) - the ``Id`` of this directory", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the ``Id`` of this directory\n        :rtype: ``osid.id.Id``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.id.Id", 
               "errors": {}
            }, 
            {
               "name": "get_directory", 
               "doc": {
                  "headline": "Gets the directory associated with this session.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.filing.Directory) - the directory associated with\n                this session", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the directory associated with this session\n        :rtype: ``osid.filing.Directory``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.filing.Directory", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "can_read_files", 
               "doc": {
                  "headline": "Tests if this user can access files in this directory.", 
                  "body": "        A return of true does not guarantee successful authorization. A\n        return of false indicates that it is known accessing this file\n        will result in a ``PermissionDenied``. This is intended as a\n        hint to an application that may not wish to offer read\n        operations to unauthorized users."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``false`` if file access is not authorized,\n                ``true`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``false`` if file access is not authorized, ``true`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "get_input_stream", 
               "doc": {
                  "headline": "Gets the input stream for reading a file.", 
                  "body": "        The input stream reads until the end of the file."
               }, 
               "arg_doc": "        arg:    name (string): the relative or absolute path name\n", 
               "return_doc": "        return: (osid.transport.DataInputStream) - the input stream for\n                reading this file", 
               "error_doc": "        raise:  NotFound - ``name`` is not found\n        raise:  NullArgument - ``name`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param name: the relative or absolute path name\n        :type name: ``string``\n", 
               "sphinx_return_doc": "        :return: the input stream for reading this file\n        :rtype: ``osid.transport.DataInputStream``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``name`` is not found\n        :raise: ``NullArgument`` -- ``name`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "string", 
                     "var_name": "name", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "string"
               ], 
               "return_type": "osid.transport.DataInputStream", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_blocking_input_stream", 
               "doc": {
                  "headline": "Gets the input stream for reading this file.", 
                  "body": "        The returned input stream, once it reaches the end of the file,\n        blocks for new content that may be later appended to the file."
               }, 
               "arg_doc": "        arg:    name (string): the relative or absolute path name\n", 
               "return_doc": "        return: (osid.transport.DataInputStream) - the input stream for\n                reading this file", 
               "error_doc": "        raise:  NotFound - ``name`` is not found\n        raise:  NullArgument - ``name`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param name: the relative or absolute path name\n        :type name: ``string``\n", 
               "sphinx_return_doc": "        :return: the input stream for reading this file\n        :rtype: ``osid.transport.DataInputStream``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``name`` is not found\n        :raise: ``NullArgument`` -- ``name`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "string", 
                     "var_name": "name", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "string"
               ], 
               "return_type": "osid.transport.DataInputStream", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "can_write_files", 
               "doc": {
                  "headline": "Tests if this user can update this file.", 
                  "body": "        A return of true does not guarantee successful authorization. A\n        return of false indicates that it is known writing to this this\n        file will result in a ``PermissionDenied``. This is intended as\n        a hint to an application that may not wish to offer write\n        operations to unauthorized users."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``false`` if file writing is not authorized,\n                ``true`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``false`` if file writing is not authorized, ``true`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "get_output_stream", 
               "doc": {
                  "headline": "Gets an output stream for writing to this file, replacing any existing contents.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    name (string): the relative or absolute path name\n", 
               "return_doc": "        return: (osid.transport.DataOutputStream) - the output stream\n                for writing to this file", 
               "error_doc": "        raise:  NotFound - ``name`` is not found\n        raise:  NullArgument - ``name`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param name: the relative or absolute path name\n        :type name: ``string``\n", 
               "sphinx_return_doc": "        :return: the output stream for writing to this file\n        :rtype: ``osid.transport.DataOutputStream``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``name`` is not found\n        :raise: ``NullArgument`` -- ``name`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "string", 
                     "var_name": "name", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "string"
               ], 
               "return_type": "osid.transport.DataOutputStream", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_output_stream_for_append", 
               "doc": {
                  "headline": "Gets an output stream for appending to this file.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    name (string): the relative or absolute path name\n", 
               "return_doc": "        return: (osid.transport.DataOutputStream) - the output stream\n                for appending to this file", 
               "error_doc": "        raise:  NotFound - ``name`` is not found\n        raise:  NullArgument - ``name`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param name: the relative or absolute path name\n        :type name: ``string``\n", 
               "sphinx_return_doc": "        :return: the output stream for appending to this file\n        :rtype: ``osid.transport.DataOutputStream``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``name`` is not found\n        :raise: ``NullArgument`` -- ``name`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "string", 
                     "var_name": "name", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "string"
               ], 
               "return_type": "osid.transport.DataOutputStream", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "touch", 
               "doc": {
                  "headline": "Updates the modified time of a file to be the current time.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    name (string): the relative or absolute path name\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NotFound - ``name`` is not found\n        raise:  NullArgument - ``name`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param name: the relative or absolute path name\n        :type name: ``string``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``name`` is not found\n        :raise: ``NullArgument`` -- ``name`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "string", 
                     "var_name": "name", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "string"
               ], 
               "return_type": "", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.filing.FileLookupSession", 
         "shortname": "FileLookupSession", 
         "category": "sessions", 
         "doc": {
            "headline": "This session defines methods for looking up on files in the current directory.", 
            "body": ""
         }, 
         "inherit_fullnames": [
            "osid.OsidSession"
         ], 
         "inherit_shortnames": [
            "OsidSession"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidSession"
            }
         ], 
         "method_names": [
            "get_directory_id", 
            "get_directory", 
            "can_lookup_files", 
            "use_comparative_file_view", 
            "use_plenary_file_view", 
            "use_federated_directory_view", 
            "use_isolated_directory_view", 
            "get_file", 
            "get_files_by_ids", 
            "get_files_by_genus_type", 
            "get_files_by_parent_genus_type", 
            "get_files_by_record_type", 
            "get_files"
         ], 
         "methods": [
            {
               "name": "get_directory_id", 
               "doc": {
                  "headline": "Gets the ``Id`` of this directory.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.id.Id) - the ``Id`` of this directory", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the ``Id`` of this directory\n        :rtype: ``osid.id.Id``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.id.Id", 
               "errors": {}
            }, 
            {
               "name": "get_directory", 
               "doc": {
                  "headline": "Gets the directory associated with this session.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.filing.Directory) - the directory associated with\n                this session", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the directory associated with this session\n        :rtype: ``osid.filing.Directory``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.filing.Directory", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "can_lookup_files", 
               "doc": {
                  "headline": "Tests if this user can perform entry lookups.", 
                  "body": "        A return of true does not guarantee successful authorization. A\n        return of false indicates that it is known all methods in this\n        session will result in a ``PermissionDenied``. This is intended\n        as a hint to an application that may opt not to offer lookup\n        operations."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``false`` if lookup methods are not\n                authorized, ``true`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``false`` if lookup methods are not authorized, ``true`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "use_comparative_file_view", 
               "doc": {
                  "headline": "The returns from the lookup methods may omit or translate elements based on this session, such as authorization, and not result in an error.", 
                  "body": "        This view is used when greater interoperability is desired at\n        the expense of precision."
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "use_plenary_file_view", 
               "doc": {
                  "headline": "A complete view of the file returns is desired.", 
                  "body": "        Methods will return what is requested or result in an error.\n        This view is used when greater precision is desired at the\n        expense of interoperability."
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "use_federated_directory_view", 
               "doc": {
                  "headline": "Federates the view for methods in this session.", 
                  "body": "        A federated view will include entries in directories which are\n        children of this directory."
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "use_isolated_directory_view", 
               "doc": {
                  "headline": "Isolates the view for methods in this session.", 
                  "body": "        An isolated view restricts lookups to this directory only."
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "get_file", 
               "doc": {
                  "headline": "Gets a specified file or alias to the file.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    file_id (osid.id.Id): the ``Id`` to the file\n", 
               "return_doc": "        return: (osid.filing.File) - the file", 
               "error_doc": "        raise:  NotFound - ``file_id`` is not found\n        raise:  NullArgument - ``file_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param file_id: the ``Id`` to the file\n        :type file_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: the file\n        :rtype: ``osid.filing.File``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``file_id`` is not found\n        :raise: ``NullArgument`` -- ``file_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "file_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "osid.filing.File", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_files_by_ids", 
               "doc": {
                  "headline": "Gets a ``FileList`` corresponding to the given ``IdList``.", 
                  "body": "        In plenary mode, the returned list contains all of the files\n        specified in the ``Id`` list, in the order of the list,\n        including duplicates, or an error results if an ``Id`` in the\n        supplied list is not found or inaccessible. Otherwise,\n        inaccessible ``Fies`` may be omitted from the list and may\n        present the elements in any order including returning a unique\n        set."
               }, 
               "arg_doc": "        arg:    file_ids (osid.id.IdList): the list of ``Ids`` to\n                retrieve\n", 
               "return_doc": "        return: (osid.filing.FileList) - the returned ``File`` list", 
               "error_doc": "        raise:  NotFound - an ``Id`` was not found\n        raise:  NullArgument - ``file_ids`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param file_ids: the list of ``Ids`` to retrieve\n        :type file_ids: ``osid.id.IdList``\n", 
               "sphinx_return_doc": "        :return: the returned ``File`` list\n        :rtype: ``osid.filing.FileList``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- an ``Id`` was not found\n        :raise: ``NullArgument`` -- ``file_ids`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.IdList", 
                     "var_name": "file_ids", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.IdList"
               ], 
               "return_type": "osid.filing.FileList", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_files_by_genus_type", 
               "doc": {
                  "headline": "Gets a ``FileList`` corresponding to the given file genus ``Type`` which does not include files of genus types derived from the specified ``Type``.", 
                  "body": "        In plenary mode, the returned list contains all known files or\n        an error results. Otherwise, the returned list may contain only\n        those files that are accessible through this session."
               }, 
               "arg_doc": "        arg:    file_genus_type (osid.type.Type): a file genus type\n", 
               "return_doc": "        return: (osid.filing.FileList) - the returned ``File list``", 
               "error_doc": "        raise:  NullArgument - ``file_genus_type`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param file_genus_type: a file genus type\n        :type file_genus_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "        :return: the returned ``File list``\n        :rtype: ``osid.filing.FileList``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``file_genus_type`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "file_genus_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "osid.filing.FileList", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_files_by_parent_genus_type", 
               "doc": {
                  "headline": "Gets a ``FileList`` corresponding to the given file genus ``Type`` and include any additional files with genus types derived from the specified ``Type``.", 
                  "body": "        In plenary mode, the returned list contains all known files or\n        an error results. Otherwise, the returned list may contain only\n        those files that are accessible through this session."
               }, 
               "arg_doc": "        arg:    file_genus_type (osid.type.Type): a file genus type\n", 
               "return_doc": "        return: (osid.filing.FileList) - the returned ``File`` list", 
               "error_doc": "        raise:  NullArgument - ``file_genus_type`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param file_genus_type: a file genus type\n        :type file_genus_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "        :return: the returned ``File`` list\n        :rtype: ``osid.filing.FileList``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``file_genus_type`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "file_genus_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "osid.filing.FileList", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_files_by_record_type", 
               "doc": {
                  "headline": "Gets a ``FileList`` corresponding to the given file record ``Type``.", 
                  "body": "        The set of files implementing the given record type is\n        returned.In plenary mode, the returned list contains all known\n        files or an error results. Otherwise, the returned list may\n        contain only those files that are accessible through this\n        session."
               }, 
               "arg_doc": "        arg:    file_record_type (osid.type.Type): a file record type\n", 
               "return_doc": "        return: (osid.filing.FileList) - the returned ``File`` list", 
               "error_doc": "        raise:  NullArgument - ``file_record_type`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param file_record_type: a file record type\n        :type file_record_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "        :return: the returned ``File`` list\n        :rtype: ``osid.filing.FileList``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``file_record_type`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "file_record_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "osid.filing.FileList", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_files", 
               "doc": {
                  "headline": "Gets the list of files and aliases to files in this directory.", 
                  "body": "        In a federated view, this method returns all files in descendant\n        directories. In plenary mode, the returned list contains all\n        known files or an error results. Otherwise, the returned list\n        may contain only those files that are accessible through this\n        session."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.filing.FileList) - the list of files in this\n                directory", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the list of files in this directory\n        :rtype: ``osid.filing.FileList``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.filing.FileList", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.filing.FileQuerySession", 
         "shortname": "FileQuerySession", 
         "category": "sessions", 
         "doc": {
            "headline": "This session provides methods for searching among files and directories objects.", 
            "body": "    The search query is constructed using a ``FileQuery``.\n\n    This session defines views that offer differing behaviors when\n    retrieving multiple objects.\n    \n      * federated directory view: searches include entries in\n        directories of which this directory is a ancestor\n      * isolated directory view: searches are restricted this directory\n        only\n"
         }, 
         "inherit_fullnames": [
            "osid.OsidSession"
         ], 
         "inherit_shortnames": [
            "OsidSession"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidSession"
            }
         ], 
         "method_names": [
            "get_directory_id", 
            "get_directory", 
            "can_search_files", 
            "use_federated_directory_view", 
            "use_isolated_directory_view", 
            "get_file_query", 
            "get_files_by_query"
         ], 
         "methods": [
            {
               "name": "get_directory_id", 
               "doc": {
                  "headline": "Gets the ``Id`` of this directory.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.id.Id) - the ``Id`` of this directory", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the ``Id`` of this directory\n        :rtype: ``osid.id.Id``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.id.Id", 
               "errors": {}
            }, 
            {
               "name": "get_directory", 
               "doc": {
                  "headline": "Gets the directory associated with this session.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.filing.Directory) - the directory associated with\n                this session", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the directory associated with this session\n        :rtype: ``osid.filing.Directory``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.filing.Directory", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "can_search_files", 
               "doc": {
                  "headline": "Tests if this user can perform ``File`` searches.", 
                  "body": "        A return of true does not guarantee successful authorization. A\n        return of false indicates that it is known all methods in this\n        session will result in a ``PermissionDenied``. This is intended\n        as a hint to an application that may opt not to offer search\n        operations to unauthorized users."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``false`` if lookup methods are not\n                authorized, ``true`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``false`` if lookup methods are not authorized, ``true`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "use_federated_directory_view", 
               "doc": {
                  "headline": "Federates the view for methods in this session.", 
                  "body": "        A federated view will include entries in directories which are\n        children of this directory."
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "use_isolated_directory_view", 
               "doc": {
                  "headline": "Isolates the view for methods in this session.", 
                  "body": "        An isolated view restricts lookups to this directory only."
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "get_file_query", 
               "doc": {
                  "headline": "Gets a file query.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.filing.FileQuery) - the file query", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the file query\n        :rtype: ``osid.filing.FileQuery``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.filing.FileQuery", 
               "errors": {}
            }, 
            {
               "name": "get_files_by_query", 
               "doc": {
                  "headline": "Gets a list of ``Files`` matching the given file query.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    file_query (osid.filing.FileQuery): the file query\n", 
               "return_doc": "        return: (osid.filing.FileList) - the returned ``FileList``", 
               "error_doc": "        raise:  NullArgument - ``file_query`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        raise:  Unsupported - ``file_query`` is not of this service", 
               "sphinx_param_doc": "        :param file_query: the file query\n        :type file_query: ``osid.filing.FileQuery``\n", 
               "sphinx_return_doc": "        :return: the returned ``FileList``\n        :rtype: ``osid.filing.FileList``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``file_query`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure\n        :raise: ``Unsupported`` -- ``file_query`` is not of this service", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.filing.FileQuery", 
                     "var_name": "file_query", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.filing.FileQuery"
               ], 
               "return_type": "osid.filing.FileList", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.filing.FileSearchSession", 
         "shortname": "FileSearchSession", 
         "category": "sessions", 
         "doc": {
            "headline": "This session provides methods for searching among files and directories objects.", 
            "body": "    The search query is constructed using a ``FileQuery``.\n\n    ``get_files_by_query()`` is the basic search method and returns a\n    list of ``Files``. A more advanced search may be performed with\n    ``getFilesBySearch()``. It accepts a ``FileSearch`` in addition to\n    the query for the purpose of specifying additional options affecting\n    the entire search, such as ordering. ``get_files_by_search()``\n    returns an ``FileSearchResults`` that can be used to access the\n    resulting ``FileList`` or be used to perform a search within the\n    result set through ``FileSearch``.\n    \n    This session defines views that offer differing behaviors when\n    retrieving multiple objects.\n    \n      * federated directory view: searches include entries in\n        directories of which this directory is a ancestor\n      * isolated directory view: searches are restricted this directory\n        only\n"
         }, 
         "inherit_fullnames": [
            "osid.filing.FileQuerySession"
         ], 
         "inherit_shortnames": [
            "FileQuerySession"
         ], 
         "inherit_pkg_names": [
            "filing"
         ], 
         "inheritance": [
            {
               "pkg_name": "filing", 
               "name": "FileQuerySession"
            }
         ], 
         "method_names": [
            "get_file_search", 
            "get_file_search_order", 
            "get_files_by_search", 
            "get_file_query_from_inspector"
         ], 
         "methods": [
            {
               "name": "get_file_search", 
               "doc": {
                  "headline": "Gets a file search.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.filing.FileSearch) - the file search", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the file search\n        :rtype: ``osid.filing.FileSearch``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.filing.FileSearch", 
               "errors": {}
            }, 
            {
               "name": "get_file_search_order", 
               "doc": {
                  "headline": "Gets a file search order.", 
                  "body": "        The ``FileSearchOrder`` is supplied to a ``FileSearch`` to\n        specify the ordering of results."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.filing.FileSearchOrder) - the file search order.", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the file search order.\n        :rtype: ``osid.filing.FileSearchOrder``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.filing.FileSearchOrder", 
               "errors": {}
            }, 
            {
               "name": "get_files_by_search", 
               "doc": {
                  "headline": "Gets the search results matching the given search query using the given search.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    file_query (osid.filing.FileQuery): the file query\n        arg:    file_search (osid.filing.FileSearch): the file search\n", 
               "return_doc": "        return: (osid.filing.FileSearchResults) - the file search\n                results", 
               "error_doc": "        raise:  NullArgument - ``file_query`` or ``file_search`` is\n                ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        raise:  Unsupported - ``file_query`` or ``file_search`` is not\n                of this service", 
               "sphinx_param_doc": "        :param file_query: the file query\n        :type file_query: ``osid.filing.FileQuery``\n        :param file_search: the file search\n        :type file_search: ``osid.filing.FileSearch``\n", 
               "sphinx_return_doc": "        :return: the file search results\n        :rtype: ``osid.filing.FileSearchResults``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``file_query`` or ``file_search`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure\n        :raise: ``Unsupported`` -- ``file_query`` or ``file_search`` is not of this service", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.filing.FileQuery", 
                     "var_name": "file_query", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.filing.FileSearch", 
                     "var_name": "file_search", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.filing.FileQuery", 
                  "osid.filing.FileSearch"
               ], 
               "return_type": "osid.filing.FileSearchResults", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_file_query_from_inspector", 
               "doc": {
                  "headline": "Gets a file query from an inspector.", 
                  "body": "        The inspector is available from a ``FileSearchResults``."
               }, 
               "arg_doc": "        arg:    file_query_inspector (osid.filing.FileQueryInspector): a\n                query inspector\n", 
               "return_doc": "        return: (osid.filing.FileQuery) - the file query", 
               "error_doc": "        raise:  NullArgument - ``file_query_inspector`` is ``null``\n        raise:  Unsupported - ``file_query_inspector`` is not of this\n                service", 
               "sphinx_param_doc": "        :param file_query_inspector: a query inspector\n        :type file_query_inspector: ``osid.filing.FileQueryInspector``\n", 
               "sphinx_return_doc": "        :return: the file query\n        :rtype: ``osid.filing.FileQuery``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``file_query_inspector`` is ``null``\n        :raise: ``Unsupported`` -- ``file_query_inspector`` is not of this service", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.filing.FileQueryInspector", 
                     "var_name": "file_query_inspector", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.filing.FileQueryInspector"
               ], 
               "return_type": "osid.filing.FileQuery", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.filing.FileNotificationSession", 
         "shortname": "FileNotificationSession", 
         "category": "sessions", 
         "doc": {
            "headline": "This session defines methods to receive notifications on adds/changes to ``Files``.", 
            "body": "    This session is intended for consumers needing to synchronize their\n    state with this service without the use of polling. Notifications\n    are cancelled when this session is closed.\n\n    Two view are defined in this session:\n    \n    federated view: includes notifications of files located in\n    subdirectories in this directory\n    \n    isolated view: includes notifcations of files in this directory only"
         }, 
         "inherit_fullnames": [
            "osid.OsidSession"
         ], 
         "inherit_shortnames": [
            "OsidSession"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidSession"
            }
         ], 
         "method_names": [
            "get_directory_id", 
            "get_directory", 
            "can_register_for_file_notifications", 
            "use_federated_directory_view", 
            "use_isolated_directory_view", 
            "register_for_new_files", 
            "register_for_changed_files", 
            "register_for_changed_file", 
            "register_for_deleted_files", 
            "register_for_deleted_file"
         ], 
         "methods": [
            {
               "name": "get_directory_id", 
               "doc": {
                  "headline": "Gets the ``Id`` of this directory.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.id.Id) - the ``Id`` of this directory", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the ``Id`` of this directory\n        :rtype: ``osid.id.Id``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.id.Id", 
               "errors": {}
            }, 
            {
               "name": "get_directory", 
               "doc": {
                  "headline": "Gets the ``Directory`` associated with this session.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.filing.Directory) - the ``Directory`` associated\n                with this session", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the ``Directory`` associated with this session\n        :rtype: ``osid.filing.Directory``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.filing.Directory", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "can_register_for_file_notifications", 
               "doc": {
                  "headline": "Tests if this user can register for ``File`` notifications.", 
                  "body": "        A return of true does not guarantee successful authorization. A\n        return of false indicates that it is known all methods in this\n        session will result in a ``PermissionDenied``. This is intended\n        as a hint to an application that may opt not to offer\n        notification operations."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``false`` if notification methods are not\n                authorized, ``true`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``false`` if notification methods are not authorized, ``true`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "use_federated_directory_view", 
               "doc": {
                  "headline": "Federates the view for methods in this session.", 
                  "body": "        A federated view will include files in directories which are\n        children of this directory."
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "use_isolated_directory_view", 
               "doc": {
                  "headline": "Isolates the view for methods in this session.", 
                  "body": "        An isolated view restricts notifications to this diretory only."
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "register_for_new_files", 
               "doc": {
                  "headline": "Register for notifications of new files.", 
                  "body": "        ``FileReceiver.newFile()`` is invoked when a new ``File`` is\n        created."
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "register_for_changed_files", 
               "doc": {
                  "headline": "Registers for notification of updated files.", 
                  "body": "        ``FileReceiver.changedFile()`` is invoked when a file is\n        changed."
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "register_for_changed_file", 
               "doc": {
                  "headline": "Registers for notification of an updated file.", 
                  "body": "        ``FileReceiver.changedFile()`` is invoked when the specified\n        file is changed."
               }, 
               "arg_doc": "        arg:    file_id (osid.id.Id): the ``Id`` of the file\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``file_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param file_id: the ``Id`` of the file\n        :type file_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``file_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "file_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "register_for_deleted_files", 
               "doc": {
                  "headline": "Registers for notification of deleted files.", 
                  "body": "        ``FileReceiver.deletedFile()`` is invoked when a file is\n        deleted."
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "register_for_deleted_file", 
               "doc": {
                  "headline": "Registers for notification of a deleted file.", 
                  "body": "        ``FileReceiver.changedFile()`` is invoked when the specified\n        file is deleted."
               }, 
               "arg_doc": "        arg:    file_id (osid.id.Id): the ``Id`` of the file\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``file_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param file_id: the ``Id`` of the file\n        :type file_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``file_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "file_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.filing.FileSmartDirectorySession", 
         "shortname": "FileSmartDirectorySession", 
         "category": "sessions", 
         "doc": {
            "headline": "This session manages queries and sequencing to create \"smart\" dynamic catalogs.", 
            "body": "    A ``FileQuery`` can be retrieved from this session and mapped to\n    this ``Directory`` to create a virtual collection of files. The\n    files may be sequenced using the ``FileSearchOrder`` from this\n    session.\n\n    This ``Directory`` has a default query that matches any file and a\n    default search order that specifies no sequencing. The queries may\n    be examined using a ``FileQueryInspector``. The query may be\n    modified by converting the inspector back to a ``FileQuery``."
         }, 
         "inherit_fullnames": [
            "osid.OsidSession"
         ], 
         "inherit_shortnames": [
            "OsidSession"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidSession"
            }
         ], 
         "method_names": [
            "get_directory_id", 
            "get_directory", 
            "can_manage_smart_directories", 
            "get_file_query", 
            "get_file_search_order", 
            "apply_file_query", 
            "inspect_file_query", 
            "apply_file_sequencing", 
            "get_file_query_from_inspector"
         ], 
         "methods": [
            {
               "name": "get_directory_id", 
               "doc": {
                  "headline": "Gets the absolute path of this directory.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.id.Id) - the ``Id`` of this directory", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the ``Id`` of this directory\n        :rtype: ``osid.id.Id``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.id.Id", 
               "errors": {}
            }, 
            {
               "name": "get_directory", 
               "doc": {
                  "headline": "Gets the ``Directory`` associated with this session.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.filing.Directory) - the ``Directory`` associated\n                with this session", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the ``Directory`` associated with this session\n        :rtype: ``osid.filing.Directory``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.filing.Directory", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "can_manage_smart_directories", 
               "doc": {
                  "headline": "Tests if this user can manage smart directories.", 
                  "body": "        A return of true does not guarantee successful authorization. A\n        return of false indicates that it is known methods in this\n        session will result in a ``PermissionDenied``. This is intended\n        as a hint to an application that may opt not to offer operations\n        to unauthorized users."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``false`` if smart directory management is\n                not authorized, ``true`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``false`` if smart directory management is not authorized, ``true`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "get_file_query", 
               "doc": {
                  "headline": "Gets a file query.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.filing.FileQuery) - the file query", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the file query\n        :rtype: ``osid.filing.FileQuery``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.filing.FileQuery", 
               "errors": {}
            }, 
            {
               "name": "get_file_search_order", 
               "doc": {
                  "headline": "Gets a file search order.", 
                  "body": "        The ``FileSearchOrder`` is supplied to a ``FileSearch`` to\n        specify the ordering of results."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.filing.FileSearchOrder) - the file search order", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the file search order\n        :rtype: ``osid.filing.FileSearchOrder``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.filing.FileSearchOrder", 
               "errors": {}
            }, 
            {
               "name": "apply_file_query", 
               "doc": {
                  "headline": "Applies a file query to this directory.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    file_query (osid.filing.FileQuery): the file query\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``file_query`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure occurred\n        raise:  Unsupported - ``file_query`` not of this service", 
               "sphinx_param_doc": "        :param file_query: the file query\n        :type file_query: ``osid.filing.FileQuery``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``file_query`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure occurred\n        :raise: ``Unsupported`` -- ``file_query`` not of this service", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.filing.FileQuery", 
                     "var_name": "file_query", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.filing.FileQuery"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }, 
            {
               "name": "inspect_file_query", 
               "doc": {
                  "headline": "Gets a file query inspector for this directory.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.filing.FileQueryInspector) - the file query\n                inspector", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure occurred", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the file query inspector\n        :rtype: ``osid.filing.FileQueryInspector``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure occurred", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.filing.FileQueryInspector", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "apply_file_sequencing", 
               "doc": {
                  "headline": "Applies a file search order to this directory.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    file_search_order (osid.filing.FileSearchOrder): the\n                file search order\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``file_search_order`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure occurred\n        raise:  Unsupported - ``file_search_order`` not of this service", 
               "sphinx_param_doc": "        :param file_search_order: the file search order\n        :type file_search_order: ``osid.filing.FileSearchOrder``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``file_search_order`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure occurred\n        :raise: ``Unsupported`` -- ``file_search_order`` not of this service", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.filing.FileSearchOrder", 
                     "var_name": "file_search_order", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.filing.FileSearchOrder"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_file_query_from_inspector", 
               "doc": {
                  "headline": "Gets a file query from an inspector.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    file_query_inspector (osid.filing.FileQueryInspector): a\n                file query inspector\n", 
               "return_doc": "        return: (osid.filing.FileQuery) - the file query", 
               "error_doc": "        raise:  NullArgument - ``file_query_inspector`` is ``null``\n        raise:  Unsupported - ``file_query_inspector`` is not of this\n                service", 
               "sphinx_param_doc": "        :param file_query_inspector: a file query inspector\n        :type file_query_inspector: ``osid.filing.FileQueryInspector``\n", 
               "sphinx_return_doc": "        :return: the file query\n        :rtype: ``osid.filing.FileQuery``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``file_query_inspector`` is ``null``\n        :raise: ``Unsupported`` -- ``file_query_inspector`` is not of this service", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.filing.FileQueryInspector", 
                     "var_name": "file_query_inspector", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.filing.FileQueryInspector"
               ], 
               "return_type": "osid.filing.FileQuery", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.filing.DirectoryLookupSession", 
         "shortname": "DirectoryLookupSession", 
         "category": "sessions", 
         "doc": {
            "headline": "This session defines methods for looking up directories in the current directory.", 
            "body": ""
         }, 
         "inherit_fullnames": [
            "osid.OsidSession"
         ], 
         "inherit_shortnames": [
            "OsidSession"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidSession"
            }
         ], 
         "method_names": [
            "get_directory_id", 
            "get_directory", 
            "can_lookup_directories", 
            "use_comparative_directory_view", 
            "use_plenary_directory_view", 
            "use_federated_directory_view", 
            "use_isolated_directory_view", 
            "get_directory", 
            "get_directories_by_ids", 
            "get_directories_by_genus_type", 
            "get_directories_by_parent_genus_type", 
            "get_directories_by_record_type", 
            "get_directories_by_provider", 
            "get_directories"
         ], 
         "methods": [
            {
               "name": "get_directory_id", 
               "doc": {
                  "headline": "Gets the ``Id`` of this directory.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.id.Id) - the ``Id`` of this directory", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the ``Id`` of this directory\n        :rtype: ``osid.id.Id``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.id.Id", 
               "errors": {}
            }, 
            {
               "name": "get_directory", 
               "doc": {
                  "headline": "Gets the directory associated with this session.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.filing.Directory) - the directory associated with\n                this session", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the directory associated with this session\n        :rtype: ``osid.filing.Directory``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.filing.Directory", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "can_lookup_directories", 
               "doc": {
                  "headline": "Tests if this user can perform entry lookups.", 
                  "body": "        A return of true does not guarantee successful authorization. A\n        return of false indicates that it is known all methods in this\n        session will result in a ``PermissionDenied``. This is intended\n        as a hint to an application that may opt not to offer lookup\n        operations."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``false`` if lookup methods are not\n                authorized, ``true`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``false`` if lookup methods are not authorized, ``true`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "use_comparative_directory_view", 
               "doc": {
                  "headline": "The returns from the lookup methods may omit or translate elements based on this session, such as authorization, and not result in an error.", 
                  "body": "        This view is used when greater interoperability is desired at\n        the expense of precision."
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "use_plenary_directory_view", 
               "doc": {
                  "headline": "A complete view of the directory returns is desired.", 
                  "body": "        Methods will return what is requested or result in an error.\n        This view is used when greater precision is desired at the\n        expense of interoperability."
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "use_federated_directory_view", 
               "doc": {
                  "headline": "Federates the view for methods in this session.", 
                  "body": "        A federated view will include entries in directories which are\n        children of this directory."
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "use_isolated_directory_view", 
               "doc": {
                  "headline": "Isolates the view for methods in this session.", 
                  "body": "        An isolated view restricts lookups to this directory only."
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "get_directory", 
               "doc": {
                  "headline": "Gets a specified directory.", 
                  "body": "        In plenary mode, the exact Id is found or a NOT_FOUND results.\n        Otherwise, the returned ``Directory`` may have a different\n        ``Id`` than requested such as with a link."
               }, 
               "arg_doc": "        arg:    directory_id (osid.id.Id): the ``Id`` to the directory\n", 
               "return_doc": "        return: (osid.filing.Directory) - the directory", 
               "error_doc": "        raise:  NotFound - ``directory_id`` is not found\n        raise:  NullArgument - ``directory_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param directory_id: the ``Id`` to the directory\n        :type directory_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: the directory\n        :rtype: ``osid.filing.Directory``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``directory_id`` is not found\n        :raise: ``NullArgument`` -- ``directory_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "directory_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "osid.filing.Directory", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_directories_by_ids", 
               "doc": {
                  "headline": "Gets a ``DirectoryList`` corresponding to the given ``IdList``.", 
                  "body": "        In plenary mode, the returned list contains all of the\n        directories specified in the ``Id`` list, in the order of the\n        list, including duplicates, or an error results if an ``Id`` in\n        the supplied list is not found or inaccessible. Otherwise,\n        inaccessible ``Directories`` may be omitted from the list and\n        may present the elements in any order including returning a\n        unique set."
               }, 
               "arg_doc": "        arg:    directory_ids (osid.id.IdList): the list of ``Ids`` to\n                retrieve\n", 
               "return_doc": "        return: (osid.filing.DirectoryList) - the returned ``Directory``\n                list", 
               "error_doc": "        raise:  NotFound - an ``Id`` was not found\n        raise:  NullArgument - ``directory_ids`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param directory_ids: the list of ``Ids`` to retrieve\n        :type directory_ids: ``osid.id.IdList``\n", 
               "sphinx_return_doc": "        :return: the returned ``Directory`` list\n        :rtype: ``osid.filing.DirectoryList``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- an ``Id`` was not found\n        :raise: ``NullArgument`` -- ``directory_ids`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.IdList", 
                     "var_name": "directory_ids", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.IdList"
               ], 
               "return_type": "osid.filing.DirectoryList", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_directories_by_genus_type", 
               "doc": {
                  "headline": "Gets a ``DirectoryList`` corresponding to the given directory genus ``Type`` which does not include directories of genus types derived from the specified ``Type``.", 
                  "body": "        In plenary mode, the returned list contains all known\n        directories or an error results. Otherwise, the returned list\n        may contain only those directories that are accessible through\n        this session."
               }, 
               "arg_doc": "        arg:    dircetory_genus_type (osid.type.Type): a directory genus\n                type\n", 
               "return_doc": "        return: (osid.filing.DirectoryList) - the returned ``Directory\n                list``", 
               "error_doc": "        raise:  NullArgument - ``directory_genus_type`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param dircetory_genus_type: a directory genus type\n        :type dircetory_genus_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "        :return: the returned ``Directory list``\n        :rtype: ``osid.filing.DirectoryList``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``directory_genus_type`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "dircetory_genus_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "osid.filing.DirectoryList", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_directories_by_parent_genus_type", 
               "doc": {
                  "headline": "Gets a ``DirectoryList`` corresponding to the given directory genus ``Type`` and include any additional directories with genus types derived from the specified ``Type``.", 
                  "body": "        In plenary mode, the returned list contains all known\n        directories or an error results. Otherwise, the returned list\n        may contain only those directories that are accessible through\n        this session."
               }, 
               "arg_doc": "        arg:    directory_genus_type (osid.type.Type): a directory genus\n                type\n", 
               "return_doc": "        return: (osid.filing.DirectoryList) - the returned ``Directory``\n                list", 
               "error_doc": "        raise:  NullArgument - ``directory_genus_type`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param directory_genus_type: a directory genus type\n        :type directory_genus_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "        :return: the returned ``Directory`` list\n        :rtype: ``osid.filing.DirectoryList``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``directory_genus_type`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "directory_genus_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "osid.filing.DirectoryList", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_directories_by_record_type", 
               "doc": {
                  "headline": "Gets a ``DirectoryList`` corresponding to the given directory record ``Type``.", 
                  "body": "        The set of directories implementing the given record type is\n        returned.In plenary mode, the returned list contains all known\n        directories or an error results. Otherwise, the returned list\n        may contain only those directories that are accessible through\n        this session."
               }, 
               "arg_doc": "        arg:    directory_record_type (osid.type.Type): a directory\n                record type\n", 
               "return_doc": "        return: (osid.filing.DirectoryList) - the returned ``Directory``\n                list", 
               "error_doc": "        raise:  NullArgument - ``directory_record_type`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param directory_record_type: a directory record type\n        :type directory_record_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "        :return: the returned ``Directory`` list\n        :rtype: ``osid.filing.DirectoryList``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``directory_record_type`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "directory_record_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "osid.filing.DirectoryList", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_directories_by_provider", 
               "doc": {
                  "headline": "Gets a ``DirectoryList`` for the given provider.", 
                  "body": "        In plenary mode, the returned list contains all known\n        directories or an error results. Otherwise, the returned list\n        may contain only those directories that are accessible through\n        this session."
               }, 
               "arg_doc": "        arg:    resource_id (osid.id.Id): a resource Id\n", 
               "return_doc": "        return: (osid.filing.DirectoryList) - the returned ``Directory``\n                list", 
               "error_doc": "        raise:  NullArgument - ``resource_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param resource_id: a resource Id\n        :type resource_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: the returned ``Directory`` list\n        :rtype: ``osid.filing.DirectoryList``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``resource_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "resource_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "osid.filing.DirectoryList", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_directories", 
               "doc": {
                  "headline": "Gets the list of directories inthis directory.", 
                  "body": "        In a federated view, this method returns all directories in\n        descendant directories. In plenary mode, the returned list\n        contains all known directories or an error results. Otherwise,\n        the returned list may contain only those directories that are\n        accessible through this session."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.filing.DirectoryList) - the list of directories in\n                this directory", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the list of directories in this directory\n        :rtype: ``osid.filing.DirectoryList``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.filing.DirectoryList", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.filing.DirectoryQuerySession", 
         "shortname": "DirectoryQuerySession", 
         "category": "sessions", 
         "doc": {
            "headline": "This session provides methods for searching among ``Directory`` objects.", 
            "body": "    The search query is constructed using the ``DirectoryQuery``.\n\n    This session defines views that offer differing behaviors for\n    searching.\n    \n      * federated directory view: searches include directories in\n        directories of which this directory is an ancestor\n      * isolated directory view: searches are restricted to diectories\n        in this directory only\n"
         }, 
         "inherit_fullnames": [
            "osid.OsidSession"
         ], 
         "inherit_shortnames": [
            "OsidSession"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidSession"
            }
         ], 
         "method_names": [
            "get_directory_id", 
            "get_directory", 
            "can_search_directories", 
            "use_federated_directory_view", 
            "use_isolated_directory_view", 
            "get_directory_query", 
            "get_directories_by_query"
         ], 
         "methods": [
            {
               "name": "get_directory_id", 
               "doc": {
                  "headline": "Gets the ``Id`` of this directory.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.id.Id) - the ``Id`` of this directory", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the ``Id`` of this directory\n        :rtype: ``osid.id.Id``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.id.Id", 
               "errors": {}
            }, 
            {
               "name": "get_directory", 
               "doc": {
                  "headline": "Gets the directory associated with this session.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.filing.Directory) - the directory associated with\n                this session", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the directory associated with this session\n        :rtype: ``osid.filing.Directory``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.filing.Directory", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "can_search_directories", 
               "doc": {
                  "headline": "Tests if this user can perform ``Directory`` searches.", 
                  "body": "        A return of true does not guarantee successful authorization. A\n        return of false indicates that it is known all methods in this\n        session will result in a ``PermissionDenied``. This is intended\n        as a hint to an application that may opt not to offer search\n        operations to unauthorized users."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``false`` if search methods are not\n                authorized, ``true`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``false`` if search methods are not authorized, ``true`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "use_federated_directory_view", 
               "doc": {
                  "headline": "Federates the view for methods in this session.", 
                  "body": "        A federated view will include entries in directories which are\n        children of this directory."
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "use_isolated_directory_view", 
               "doc": {
                  "headline": "Isolates the view for methods in this session.", 
                  "body": "        An isolated view restricts lookups to this directory only."
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "get_directory_query", 
               "doc": {
                  "headline": "Gets a directory query.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.filing.DirectoryQuery) - the directory query", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the directory query\n        :rtype: ``osid.filing.DirectoryQuery``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.filing.DirectoryQuery", 
               "errors": {}
            }, 
            {
               "name": "get_directories_by_query", 
               "doc": {
                  "headline": "Gets a list of ``Directory`` objects matching the given directory query.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    directory_query (osid.filing.DirectoryQuery): the\n                directory query\n", 
               "return_doc": "        return: (osid.filing.DirectoryList) - the returned\n                ``DirectoryList``", 
               "error_doc": "        raise:  NullArgument - ``directory_query`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        raise:  Unsupported - ``directory_query`` is not of this service", 
               "sphinx_param_doc": "        :param directory_query: the directory query\n        :type directory_query: ``osid.filing.DirectoryQuery``\n", 
               "sphinx_return_doc": "        :return: the returned ``DirectoryList``\n        :rtype: ``osid.filing.DirectoryList``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``directory_query`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure\n        :raise: ``Unsupported`` -- ``directory_query`` is not of this service", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.filing.DirectoryQuery", 
                     "var_name": "directory_query", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.filing.DirectoryQuery"
               ], 
               "return_type": "osid.filing.DirectoryList", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.filing.DirectorySearchSession", 
         "shortname": "DirectorySearchSession", 
         "category": "sessions", 
         "doc": {
            "headline": "This session provides methods for searching among ``Directory`` objects.", 
            "body": "    The search query is constructed using the ``DirectoryQuery``.\n\n    This session defines views that offer differing behaviors for\n    searching.\n    \n      * federated directory view: searches include directories in\n        directories of which this directory is an ancestor\n      * isolated directory view: searches are restricted to diectories\n        in this directory only\n\n    \n    ``get_directories_by_query()`` is the basic search method and\n    returns a list of ``Directories``. A more advanced search may be\n    performed with ``getDirectoriesBySearch()``. It accepts a\n    ``DirectorySearch`` in addition to the query for the purpose of\n    specifying additional options affecting the entire search, such as\n    ordering. ``get_directories_by_search()`` returns an\n    ``DirectorySearchResults`` that can be used to access the resulting\n    ``DirectoryList`` or be used to perform a search within the result\n    set through ``DirectorySearch``."
         }, 
         "inherit_fullnames": [
            "osid.filing.DirectoryQuerySession"
         ], 
         "inherit_shortnames": [
            "DirectoryQuerySession"
         ], 
         "inherit_pkg_names": [
            "filing"
         ], 
         "inheritance": [
            {
               "pkg_name": "filing", 
               "name": "DirectoryQuerySession"
            }
         ], 
         "method_names": [
            "get_directory_search", 
            "get_directory_search_order", 
            "get_directories_by_search", 
            "get_directory_query_from_inspector"
         ], 
         "methods": [
            {
               "name": "get_directory_search", 
               "doc": {
                  "headline": "Gets a diectory search.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.filing.DirectorySearch) - the directory search", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the directory search\n        :rtype: ``osid.filing.DirectorySearch``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.filing.DirectorySearch", 
               "errors": {}
            }, 
            {
               "name": "get_directory_search_order", 
               "doc": {
                  "headline": "Gets a directory search order.", 
                  "body": "        The ``DirectorySearchOrder`` is supplied to a\n        ``DirectorySearch`` to specify the ordering of results."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.filing.DirectorySearchOrder) - the directory\n                search order", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the directory search order\n        :rtype: ``osid.filing.DirectorySearchOrder``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.filing.DirectorySearchOrder", 
               "errors": {}
            }, 
            {
               "name": "get_directories_by_search", 
               "doc": {
                  "headline": "Gets the search results matching the given search.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    directory_query (osid.filing.DirectoryQuery): the\n                directory query\n        arg:    directory_search (osid.filing.DirectorySearch): the\n                directory search\n", 
               "return_doc": "        return: (osid.filing.DirectorySearchResults) - the directory\n                search results", 
               "error_doc": "        raise:  NullArgument - ``directory_query`` or\n                ``directory_search`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        raise:  Unsupported - ``directory_query`` or\n                ``directory_search`` is not of this service", 
               "sphinx_param_doc": "        :param directory_query: the directory query\n        :type directory_query: ``osid.filing.DirectoryQuery``\n        :param directory_search: the directory search\n        :type directory_search: ``osid.filing.DirectorySearch``\n", 
               "sphinx_return_doc": "        :return: the directory search results\n        :rtype: ``osid.filing.DirectorySearchResults``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``directory_query`` or ``directory_search`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure\n        :raise: ``Unsupported`` -- ``directory_query`` or ``directory_search`` is not of this service", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.filing.DirectoryQuery", 
                     "var_name": "directory_query", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.filing.DirectorySearch", 
                     "var_name": "directory_search", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.filing.DirectoryQuery", 
                  "osid.filing.DirectorySearch"
               ], 
               "return_type": "osid.filing.DirectorySearchResults", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_directory_query_from_inspector", 
               "doc": {
                  "headline": "Gets a directory query from an inspector.", 
                  "body": "        The inspector is available from an ``DirectorySearchResults``."
               }, 
               "arg_doc": "        arg:    directory_query_inspector\n                (osid.filing.DirectoryQueryInspector): a query inspector\n", 
               "return_doc": "        return: (osid.filing.DirectoryQuery) - the directory query", 
               "error_doc": "        raise:  NullArgument - ``directory_query_inspector`` is ``null``\n        raise:  Unsupported - ``directory_query_inspector`` is not of\n                this service", 
               "sphinx_param_doc": "        :param directory_query_inspector: a query inspector\n        :type directory_query_inspector: ``osid.filing.DirectoryQueryInspector``\n", 
               "sphinx_return_doc": "        :return: the directory query\n        :rtype: ``osid.filing.DirectoryQuery``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``directory_query_inspector`` is ``null``\n        :raise: ``Unsupported`` -- ``directory_query_inspector`` is not of this service", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.filing.DirectoryQueryInspector", 
                     "var_name": "directory_query_inspector", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.filing.DirectoryQueryInspector"
               ], 
               "return_type": "osid.filing.DirectoryQuery", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.filing.DirectoryAdminSession", 
         "shortname": "DirectoryAdminSession", 
         "category": "sessions", 
         "doc": {
            "headline": "This session creates and removes files and directories under the directory associated with this session.", 
            "body": ""
         }, 
         "inherit_fullnames": [
            "osid.OsidSession"
         ], 
         "inherit_shortnames": [
            "OsidSession"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidSession"
            }
         ], 
         "method_names": [
            "get_directory_id", 
            "get_directory", 
            "can_modify_directory", 
            "overwrite", 
            "can_create_file_with_record_types", 
            "get_file_form_for_create", 
            "create_file", 
            "get_file_form_for_update", 
            "update_file", 
            "delete_file", 
            "can_create_directory_with_record_types", 
            "get_directory_form_for_create", 
            "create_directory", 
            "get_directory_form_for_update", 
            "update_directory", 
            "delete_directory", 
            "clear_directory"
         ], 
         "methods": [
            {
               "name": "get_directory_id", 
               "doc": {
                  "headline": "Gets the ``Id`` of this directory.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.id.Id) - the ``Id`` of this directory", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the ``Id`` of this directory\n        :rtype: ``osid.id.Id``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.id.Id", 
               "errors": {}
            }, 
            {
               "name": "get_directory", 
               "doc": {
                  "headline": "Gets the directory associated with this session.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.filing.Directory) - the directory associated with\n                this session", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the directory associated with this session\n        :rtype: ``osid.filing.Directory``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.filing.Directory", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "can_modify_directory", 
               "doc": {
                  "headline": "Tests if this user can create or remove entries in this directory.", 
                  "body": "        A return of true does not guarantee successful authorization. A\n        return of false indicates that it is known modifying this\n        directory will result in a ``PermissionDenied``. This is\n        intended as a hint to an application that may opt not to offer\n        create operations to an unauthorized user."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``false`` if modifying this directory is not\n                authorized, ``true`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``false`` if modifying this directory is not authorized, ``true`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "overwrite", 
               "doc": {
                  "headline": "Overwrite files if a destination pathname exists and is a file.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "can_create_file_with_record_types", 
               "doc": {
                  "headline": "Tests if this user can create a single ``File`` using the desired record types.", 
                  "body": "        While ``FilingManager.getFileRecordTypes()`` can be used to\n        examine which records are supported, this method tests which\n        record(s) are required for creating a specific ``File``.\n        Providing an empty array tests if a ``File`` can be created with\n        no records."
               }, 
               "arg_doc": "        arg:    file_record_types (osid.type.Type[]): array of file\n                record types\n", 
               "return_doc": "        return: (boolean) - ``true`` if ``File`` creation using the\n                specified record ``Types`` is supported, ``false``\n                otherwise", 
               "error_doc": "        raise:  NullArgument - ``file_record_types`` is ``null``", 
               "sphinx_param_doc": "        :param file_record_types: array of file record types\n        :type file_record_types: ``osid.type.Type[]``\n", 
               "sphinx_return_doc": "        :return: ``true`` if ``File`` creation using the specified record ``Types`` is supported, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``file_record_types`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type[]", 
                     "var_name": "file_record_types", 
                     "array": true
                  }
               ], 
               "arg_types": [
                  "osid.type.Type[]"
               ], 
               "return_type": "boolean", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "get_file_form_for_create", 
               "doc": {
                  "headline": "Gets the file form for creating new files.", 
                  "body": "        A new form should be requested for each create transaction."
               }, 
               "arg_doc": "        arg:    name (string): name of a file\n        arg:    file_record_types (osid.type.Type[]): array of file\n                record types\n", 
               "return_doc": "        return: (osid.filing.FileForm) - the file form", 
               "error_doc": "        raise:  AlreadyExists - ``name`` already exists as a file in\n                this direrctory and ``overwrite()`` is ``false``\n        raise:  InvalidArgument - ``name`` is invalid\n        raise:  NullArgument - ``name`` or ``file_record_types`` is\n                ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        raise:  Unsupported - unable to get form for requested record\n                types", 
               "sphinx_param_doc": "        :param name: name of a file\n        :type name: ``string``\n        :param file_record_types: array of file record types\n        :type file_record_types: ``osid.type.Type[]``\n", 
               "sphinx_return_doc": "        :return: the file form\n        :rtype: ``osid.filing.FileForm``", 
               "sphinx_error_doc": "        :raise: ``AlreadyExists`` -- ``name`` already exists as a file in this direrctory and ``overwrite()`` is ``false``\n        :raise: ``InvalidArgument`` -- ``name`` is invalid\n        :raise: ``NullArgument`` -- ``name`` or ``file_record_types`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure\n        :raise: ``Unsupported`` -- unable to get form for requested record types", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "string", 
                     "var_name": "name", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.type.Type[]", 
                     "var_name": "file_record_types", 
                     "array": true
                  }
               ], 
               "arg_types": [
                  "string", 
                  "osid.type.Type[]"
               ], 
               "return_type": "osid.filing.FileForm", 
               "errors": {
                  "ALREADY_EXISTS": "User", 
                  "INVALID_ARGUMENT": "ConsumerContract", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }, 
            {
               "name": "create_file", 
               "doc": {
                  "headline": "Creates a new file in this directory.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    file_form (osid.filing.FileForm): the file form\n", 
               "return_doc": "        return: (osid.filing.File) - the new file", 
               "error_doc": "        raise:  IllegalState - ``file_form`` already used in a create\n                transaction\n        raise:  InvalidArgument - one or more of the form elements is\n                invalid\n        raise:  NullArgument - ``file_form`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        raise:  Unsupported - ``file_form`` did not originate from\n                ``get_file_form_for_create()``", 
               "sphinx_param_doc": "        :param file_form: the file form\n        :type file_form: ``osid.filing.FileForm``\n", 
               "sphinx_return_doc": "        :return: the new file\n        :rtype: ``osid.filing.File``", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- ``file_form`` already used in a create transaction\n        :raise: ``InvalidArgument`` -- one or more of the form elements is invalid\n        :raise: ``NullArgument`` -- ``file_form`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure\n        :raise: ``Unsupported`` -- ``file_form`` did not originate from ``get_file_form_for_create()``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.filing.FileForm", 
                     "var_name": "file_form", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.filing.FileForm"
               ], 
               "return_type": "osid.filing.File", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract", 
                  "INVALID_ARGUMENT": "ConsumerContract", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_file_form_for_update", 
               "doc": {
                  "headline": "Gets the file form for updating an existing files.", 
                  "body": "        A new file form should be requested for each update transaction."
               }, 
               "arg_doc": "        arg:    file_id (osid.id.Id): ``Id`` of the file to update\n", 
               "return_doc": "        return: (osid.filing.FileForm) - the file form", 
               "error_doc": "        raise:  NotFound - ``file_id`` is not found\n        raise:  NullArgument - ``file_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param file_id: ``Id`` of the file to update\n        :type file_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: the file form\n        :rtype: ``osid.filing.FileForm``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``file_id`` is not found\n        :raise: ``NullArgument`` -- ``file_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "file_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "osid.filing.FileForm", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "update_file", 
               "doc": {
                  "headline": "Updates an existing file.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    file_form (osid.filing.FileForm): the form containing\n                the elements to be updated\n", 
               "return_doc": "", 
               "error_doc": "        raise:  IllegalState - ``file_form`` already used in an update\n                transaction\n        raise:  InvalidArgument - the form contains an invalid value\n        raise:  NullArgument - ``file_form`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        raise:  Unsupported - ``file_form`` did not originate from\n                ``get_file_form_for_update()``", 
               "sphinx_param_doc": "        :param file_form: the form containing the elements to be updated\n        :type file_form: ``osid.filing.FileForm``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- ``file_form`` already used in an update transaction\n        :raise: ``InvalidArgument`` -- the form contains an invalid value\n        :raise: ``NullArgument`` -- ``file_form`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure\n        :raise: ``Unsupported`` -- ``file_form`` did not originate from ``get_file_form_for_update()``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.filing.FileForm", 
                     "var_name": "file_form", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.filing.FileForm"
               ], 
               "return_type": "", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract", 
                  "INVALID_ARGUMENT": "ConsumerContract", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }, 
            {
               "name": "delete_file", 
               "doc": {
                  "headline": "Deletes a file.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    file_id (osid.id.Id): the ``Id`` of the file to delete\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NotFound - ``file_id`` is not found\n        raise:  NullArgument - ``file_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param file_id: the ``Id`` of the file to delete\n        :type file_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``file_id`` is not found\n        :raise: ``NullArgument`` -- ``file_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "file_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "can_create_directory_with_record_types", 
               "doc": {
                  "headline": "Tests if this user can create a single ``Directory`` using the desired record types.", 
                  "body": "        While ``FilingManager.getDiectoryRecordTypes()`` can be used to\n        examine which records are supported, this method tests which\n        record(s) are required for creating a specific ``Directory``.\n        Providing an empty array tests if a ``Directory`` can be created\n        with no records."
               }, 
               "arg_doc": "        arg:    directory_record_types (osid.type.Type[]): array of\n                directory record types\n", 
               "return_doc": "        return: (boolean) - ``true`` if ``Directory`` creation using the\n                specified record ``Types`` is supported, ``false``\n                otherwise", 
               "error_doc": "        raise:  NullArgument - ``directory_record_types`` is ``null``", 
               "sphinx_param_doc": "        :param directory_record_types: array of directory record types\n        :type directory_record_types: ``osid.type.Type[]``\n", 
               "sphinx_return_doc": "        :return: ``true`` if ``Directory`` creation using the specified record ``Types`` is supported, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``directory_record_types`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type[]", 
                     "var_name": "directory_record_types", 
                     "array": true
                  }
               ], 
               "arg_types": [
                  "osid.type.Type[]"
               ], 
               "return_type": "boolean", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "get_directory_form_for_create", 
               "doc": {
                  "headline": "Gets the file form for creating new directories.", 
                  "body": "        A new form should be requested for each create transaction. This\n        method is used for creating new ``Directories`` where only the\n        ``Directory`` ``Type`` is known."
               }, 
               "arg_doc": "        arg:    name (string): the name of a subdirectory in this\n                directory\n        arg:    directory_record_types (osid.type.Type[]): array of\n                directory record types\n", 
               "return_doc": "        return: (osid.filing.DirectoryForm) - the directory form", 
               "error_doc": "        raise:  AlreadyExists - directory already exists and\n                ``overwrite()`` is false\n        raise:  InvalidArgument - ``name`` is invalid\n        raise:  NullArgument - ``name`` or ``directory_record_types`` is\n                ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        raise:  Unsupported - unable to get form for requested record\n                types", 
               "sphinx_param_doc": "        :param name: the name of a subdirectory in this directory\n        :type name: ``string``\n        :param directory_record_types: array of directory record types\n        :type directory_record_types: ``osid.type.Type[]``\n", 
               "sphinx_return_doc": "        :return: the directory form\n        :rtype: ``osid.filing.DirectoryForm``", 
               "sphinx_error_doc": "        :raise: ``AlreadyExists`` -- directory already exists and ``overwrite()`` is false\n        :raise: ``InvalidArgument`` -- ``name`` is invalid\n        :raise: ``NullArgument`` -- ``name`` or ``directory_record_types`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure\n        :raise: ``Unsupported`` -- unable to get form for requested record types", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "string", 
                     "var_name": "name", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.type.Type[]", 
                     "var_name": "directory_record_types", 
                     "array": true
                  }
               ], 
               "arg_types": [
                  "string", 
                  "osid.type.Type[]"
               ], 
               "return_type": "osid.filing.DirectoryForm", 
               "errors": {
                  "ALREADY_EXISTS": "User", 
                  "INVALID_ARGUMENT": "ConsumerContract", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }, 
            {
               "name": "create_directory", 
               "doc": {
                  "headline": "Creates a new directory.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    directory_form (osid.filing.DirectoryForm): the\n                directory form\n", 
               "return_doc": "        return: (osid.filing.Directory) - the new directory", 
               "error_doc": "        raise:  IllegalState - ``directory_form`` already used in a\n                create transaction\n        raise:  InvalidArgument - one or more of the form elements is\n                invalid\n        raise:  NullArgument - ``directory_form`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        raise:  Unsupported - ``directory_form`` did not originate from\n                ``get_directory_form_for_create()``", 
               "sphinx_param_doc": "        :param directory_form: the directory form\n        :type directory_form: ``osid.filing.DirectoryForm``\n", 
               "sphinx_return_doc": "        :return: the new directory\n        :rtype: ``osid.filing.Directory``", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- ``directory_form`` already used in a create transaction\n        :raise: ``InvalidArgument`` -- one or more of the form elements is invalid\n        :raise: ``NullArgument`` -- ``directory_form`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure\n        :raise: ``Unsupported`` -- ``directory_form`` did not originate from ``get_directory_form_for_create()``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.filing.DirectoryForm", 
                     "var_name": "directory_form", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.filing.DirectoryForm"
               ], 
               "return_type": "osid.filing.Directory", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract", 
                  "INVALID_ARGUMENT": "ConsumerContract", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_directory_form_for_update", 
               "doc": {
                  "headline": "Gets the directory form for updating an existing files.", 
                  "body": "        A new directory form should be requested for each update\n        transaction. This method is used when the ``Directory`` to be\n        updated is known and is desired to access any metadata specific\n        to the ``Directory`` being updated."
               }, 
               "arg_doc": "        arg:    directory_id (osid.id.Id): ``Id`` of the directory to\n                update\n", 
               "return_doc": "        return: (osid.filing.DirectoryForm) - the directory form", 
               "error_doc": "        raise:  NotFound - ``directory_id`` is not found\n        raise:  NullArgument - ``directory_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param directory_id: ``Id`` of the directory to update\n        :type directory_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: the directory form\n        :rtype: ``osid.filing.DirectoryForm``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``directory_id`` is not found\n        :raise: ``NullArgument`` -- ``directory_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "directory_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "osid.filing.DirectoryForm", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "update_directory", 
               "doc": {
                  "headline": "Updates an existing directory.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    directory_form (osid.filing.DirectoryForm): the form\n                containing the elements to be updated\n", 
               "return_doc": "", 
               "error_doc": "        raise:  IllegalState - ``directory_form`` already used in an\n                update transaction\n        raise:  InvalidArgument - the form contains an invalid value\n        raise:  NullArgument - ``directory_form`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        raise:  Unsupported - ``directory_form`` did not originate from\n                ``get_directory_form_for_update()``", 
               "sphinx_param_doc": "        :param directory_form: the form containing the elements to be updated\n        :type directory_form: ``osid.filing.DirectoryForm``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- ``directory_form`` already used in an update transaction\n        :raise: ``InvalidArgument`` -- the form contains an invalid value\n        :raise: ``NullArgument`` -- ``directory_form`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure\n        :raise: ``Unsupported`` -- ``directory_form`` did not originate from ``get_directory_form_for_update()``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.filing.DirectoryForm", 
                     "var_name": "directory_form", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.filing.DirectoryForm"
               ], 
               "return_type": "", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract", 
                  "INVALID_ARGUMENT": "ConsumerContract", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }, 
            {
               "name": "delete_directory", 
               "doc": {
                  "headline": "Deletes a directory in this directory.", 
                  "body": "        The directory to remove must be empty."
               }, 
               "arg_doc": "        arg:    directory_id (osid.id.Id): the ``Id`` of the directory\n                to delete\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NotFound - ``directory_id`` is not found\n        raise:  NullArgument - ``directory_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param directory_id: the ``Id`` of the directory to delete\n        :type directory_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``directory_id`` is not found\n        :raise: ``NullArgument`` -- ``directory_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "directory_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "clear_directory", 
               "doc": {
                  "headline": "Deletes all files and subdirectories within the given directory.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    directory_id (osid.id.Id): the ``Id`` of the directory\n                to delete\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NotFound - ``directory_id`` is not found\n        raise:  NullArgument - ``directory_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param directory_id: the ``Id`` of the directory to delete\n        :type directory_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``directory_id`` is not found\n        :raise: ``NullArgument`` -- ``directory_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "directory_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.filing.DirectoryNotificationSession", 
         "shortname": "DirectoryNotificationSession", 
         "category": "sessions", 
         "doc": {
            "headline": "This session defines methods to receive notifications on adds/changes to ``Directories``.", 
            "body": "    This session is intended for consumers needing to synchronize their\n    state with this service without the use of polling. Notifications\n    are cancelled when this session is closed.\n\n    Two view are defined in this session:\n    \n    federated view: includes notifications of directories located in\n    descendants of this directory\n    \n    isolated view: includes notifcations of directories in this\n    directory only"
         }, 
         "inherit_fullnames": [
            "osid.OsidSession"
         ], 
         "inherit_shortnames": [
            "OsidSession"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidSession"
            }
         ], 
         "method_names": [
            "get_directory_id", 
            "get_directory", 
            "can_register_for_directory_notifications", 
            "use_federated_directory_view", 
            "use_isolated_directory_view", 
            "register_for_new_directories", 
            "register_for_changed_directories", 
            "register_for_changed_directory", 
            "register_for_deleted_directories", 
            "register_for_deleted_directory"
         ], 
         "methods": [
            {
               "name": "get_directory_id", 
               "doc": {
                  "headline": "Gets the ``Id`` of this directory.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.id.Id) - the ``Id`` of this directory", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the ``Id`` of this directory\n        :rtype: ``osid.id.Id``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.id.Id", 
               "errors": {}
            }, 
            {
               "name": "get_directory", 
               "doc": {
                  "headline": "Gets the ``Directory`` associated with this session.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.filing.Directory) - the ``Directory`` associated\n                with this session", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the ``Directory`` associated with this session\n        :rtype: ``osid.filing.Directory``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.filing.Directory", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "can_register_for_directory_notifications", 
               "doc": {
                  "headline": "Tests if this user can register for ``Directory`` notifications.", 
                  "body": "        A return of true does not guarantee successful authorization. A\n        return of false indicates that it is known all methods in this\n        session will result in a ``PermissionDenied``. This is intended\n        as a hint to an application that may opt not to offer\n        notification operations."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``false`` if notification methods are not\n                authorized, ``true`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``false`` if notification methods are not authorized, ``true`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "use_federated_directory_view", 
               "doc": {
                  "headline": "Federates the view for methods in this session.", 
                  "body": "        A federated view will include directories in directories which\n        are children of this directory."
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "use_isolated_directory_view", 
               "doc": {
                  "headline": "Isolates the view for methods in this session.", 
                  "body": "        An isolated view restricts notifications to this diretory only."
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "register_for_new_directories", 
               "doc": {
                  "headline": "Register for notifications of new directories.", 
                  "body": "        ``DirectoryReceiver.newDirectory()`` is invoked when a new\n        ``Directory`` is created."
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "register_for_changed_directories", 
               "doc": {
                  "headline": "Registers for notification of updated directories.", 
                  "body": "        ``DirectoryReceiver.changedDirectory()`` is invoked when a file\n        is changed."
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "register_for_changed_directory", 
               "doc": {
                  "headline": "Registers for notification of an updated file.", 
                  "body": "        ``DirectoryReceiver.changedDirectory()`` is invoked when the\n        specified directory is changed."
               }, 
               "arg_doc": "        arg:    directory_id (osid.id.Id): the ``Id`` of the directory\n                to monitor\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``directory_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param directory_id: the ``Id`` of the directory to monitor\n        :type directory_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``directory_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "directory_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "register_for_deleted_directories", 
               "doc": {
                  "headline": "Registers for notification of deleted directories.", 
                  "body": "        ``DirectoryReceiver.deletedDirectory()`` is invoked when a\n        directory is deleted."
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "register_for_deleted_directory", 
               "doc": {
                  "headline": "Registers for notification of a deleted directory.", 
                  "body": "        ``DirectoryReceiver.changedDirectory()`` is invoked when the\n        specified directory is deleted."
               }, 
               "arg_doc": "        arg:    directory_id (osid.id.Id): the ``Id`` of the directory\n                to monitor\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``directory_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param directory_id: the ``Id`` of the directory to monitor\n        :type directory_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``directory_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "directory_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.filing.DirectoryEntry", 
         "shortname": "DirectoryEntry", 
         "category": "objects", 
         "doc": {
            "headline": "``DirectoryEntry`` defines methods in common to both ``File`` and ``Directory``.", 
            "body": "    The concatenated path and name are assumed to be unique."
         }, 
         "inherit_fullnames": [
            "osid.OsidObject"
         ], 
         "inherit_shortnames": [
            "OsidObject"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidObject"
            }
         ], 
         "method_names": [
            "get_name", 
            "is_alias", 
            "get_path", 
            "get_real_path", 
            "get_owner_id", 
            "get_owner", 
            "get_created_time", 
            "get_last_modified_time", 
            "get_last_access_time"
         ], 
         "methods": [
            {
               "name": "get_name", 
               "doc": {
                  "headline": "Gets the name of this entry.", 
                  "body": "        The name does not include the path. If this entry represents an\n        alias, the name of the alias is returned."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (string) - the entry name", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the entry name\n        :rtype: ``string``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "string", 
               "errors": {}
            }, 
            {
               "name": "is_alias", 
               "doc": {
                  "headline": "Tests if this entry is an alias.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if this is an alias, ``false``\n                otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if this is an alias, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "get_path", 
               "doc": {
                  "headline": "Gets the full path of this entry.", 
                  "body": "        The path includes the name. Path components are separated by a\n        /. If this entry represents an alias, the path to the alias is\n        returned."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (string) - the path", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the path\n        :rtype: ``string``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "string", 
               "errors": {}
            }, 
            {
               "name": "get_real_path", 
               "doc": {
                  "headline": "Gets the real path of this entry.", 
                  "body": "        The path includes the name. Path components are separated by a\n        /. If this entry represents an alias, the full path to the\n        target file or directory is returned."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (string) - the path", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the path\n        :rtype: ``string``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "string", 
               "errors": {}
            }, 
            {
               "name": "get_owner_id", 
               "doc": {
                  "headline": "Gets the ``Id`` of the ``Agent`` that owns this entry.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.id.Id) - the ``Agent Id``", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the ``Agent Id``\n        :rtype: ``osid.id.Id``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.id.Id", 
               "errors": {}
            }, 
            {
               "name": "get_owner", 
               "doc": {
                  "headline": "Gets the ``Agent`` that owns this entry.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.authentication.Agent) - the ``Agent``", 
               "error_doc": "        raise:  OperationFailed - authentication service not available", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the ``Agent``\n        :rtype: ``osid.authentication.Agent``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- authentication service not available", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.authentication.Agent", 
               "errors": {
                  "OPERATION_FAILED": "Operational"
               }
            }, 
            {
               "name": "get_created_time", 
               "doc": {
                  "headline": "Gets the created time of this entry.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.DateTime) - the created time", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the created time\n        :rtype: ``osid.calendaring.DateTime``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.DateTime", 
               "errors": {}
            }, 
            {
               "name": "get_last_modified_time", 
               "doc": {
                  "headline": "Gets the last modified time of this entry.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.DateTime) - the last modified time", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the last modified time\n        :rtype: ``osid.calendaring.DateTime``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.DateTime", 
               "errors": {}
            }, 
            {
               "name": "get_last_access_time", 
               "doc": {
                  "headline": "Gets the last access time of this entry.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.DateTime) - the last access time", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the last access time\n        :rtype: ``osid.calendaring.DateTime``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.DateTime", 
               "errors": {}
            }
         ]
      }, 
      {
         "fullname": "osid.filing.DirectoryEntryQuery", 
         "shortname": "DirectoryEntryQuery", 
         "category": "queries", 
         "doc": {
            "headline": "``DirectoryEntryQuery`` defines methods in common to both ``FileQuery`` and ``DirectoryQuery``.", 
            "body": ""
         }, 
         "inherit_fullnames": [
            "osid.OsidObjectQuery"
         ], 
         "inherit_shortnames": [
            "OsidObjectQuery"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidObjectQuery"
            }
         ], 
         "method_names": [
            "match_name", 
            "clear_name_terms", 
            "match_path", 
            "clear_path_terms", 
            "supports_directory_query", 
            "get_directory_query", 
            "clear_directory_terms", 
            "match_aliases", 
            "match_any_aliases", 
            "clear_aliases_terms", 
            "match_owner_id", 
            "clear_owner_id_terms", 
            "supports_owner_query", 
            "get_owner_query", 
            "clear_owner_terms", 
            "match_created_time", 
            "clear_created_time_terms", 
            "match_modified_time", 
            "clear_modified_time_terms", 
            "match_last_access_time", 
            "clear_last_access_time_terms"
         ], 
         "methods": [
            {
               "name": "match_name", 
               "doc": {
                  "headline": "Matches entry names.", 
                  "body": "        Supplying multiple strings behaves like a boolean ``AND`` among\n        the elements each which must correspond to the\n        ``stringMatchType``. An ``OR`` can be performed with multiple\n        queries."
               }, 
               "arg_doc": "        arg:    name (string): name to match\n        arg:    string_match_type (osid.type.Type): the string match\n                type\n        arg:    match (boolean): ``true`` for a positive match,\n                ``false`` for a negative match\n", 
               "return_doc": "", 
               "error_doc": "        raise:  InvalidArgument - ``name`` not of ``string_match_type``\n        raise:  NullArgument - ``name`` or ``string_match_type`` is\n                ``null``\n        raise:  Unsupported -\n                ``supports_string_match_type(string_match_type)`` is\n                ``false``", 
               "sphinx_param_doc": "        :param name: name to match\n        :type name: ``string``\n        :param string_match_type: the string match type\n        :type string_match_type: ``osid.type.Type``\n        :param match: ``true`` for a positive match, ``false`` for a negative match\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``InvalidArgument`` -- ``name`` not of ``string_match_type``\n        :raise: ``NullArgument`` -- ``name`` or ``string_match_type`` is ``null``\n        :raise: ``Unsupported`` -- ``supports_string_match_type(string_match_type)`` is ``false``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "string", 
                     "var_name": "name", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "string_match_type", 
                     "array": false
                  }, 
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "string", 
                  "osid.type.Type", 
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {
                  "INVALID_ARGUMENT": "ConsumerContract", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }, 
            {
               "name": "clear_name_terms", 
               "doc": {
                  "headline": "Clears the name terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "match_path", 
               "doc": {
                  "headline": "Matches an absolute pathname of a directory entry.", 
                  "body": "        Supplying multiple strings behaves like a boolean ``AND`` among\n        the elements each which must correspond to the\n        ``stringMatchType``. An ``OR`` can be performed with multiple\n        queries."
               }, 
               "arg_doc": "        arg:    path (string): path to match\n        arg:    string_match_type (osid.type.Type): the string match\n                type\n        arg:    match (boolean): ``true`` for a positive match,\n                ``false`` for a negative match\n", 
               "return_doc": "", 
               "error_doc": "        raise:  InvalidArgument - ``name`` not of ``string_match_type``\n        raise:  NullArgument - ``path`` or ``string_match_type`` is\n                ``null``\n        raise:  Unsupported -\n                ``supports_string_match_type(string_match_type)`` is\n                ``false``", 
               "sphinx_param_doc": "        :param path: path to match\n        :type path: ``string``\n        :param string_match_type: the string match type\n        :type string_match_type: ``osid.type.Type``\n        :param match: ``true`` for a positive match, ``false`` for a negative match\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``InvalidArgument`` -- ``name`` not of ``string_match_type``\n        :raise: ``NullArgument`` -- ``path`` or ``string_match_type`` is ``null``\n        :raise: ``Unsupported`` -- ``supports_string_match_type(string_match_type)`` is ``false``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "string", 
                     "var_name": "path", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "string_match_type", 
                     "array": false
                  }, 
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "string", 
                  "osid.type.Type", 
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {
                  "INVALID_ARGUMENT": "ConsumerContract", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }, 
            {
               "name": "clear_path_terms", 
               "doc": {
                  "headline": "Clears the path terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "supports_directory_query", 
               "doc": {
                  "headline": "Tests if a ``DirectoryQuery`` is available.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if a directory query is available,\n                ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if a directory query is available, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "get_directory_query", 
               "doc": {
                  "headline": "Gets the query for a directory to match the parent directory.", 
                  "body": "        There is only one ``DirectoryQuery`` per\n        ``DifrectoryEntryQuery``. Multiple retrievals return the same\n        object."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.filing.DirectoryQuery) - the directory query", 
               "error_doc": "        raise:  Unimplemented - ``supports_directory_query()`` is\n                ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the directory query\n        :rtype: ``osid.filing.DirectoryQuery``", 
               "sphinx_error_doc": "        :raise: ``Unimplemented`` -- ``supports_directory_query()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_directory_query()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.filing.DirectoryQuery", 
               "errors": {
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "clear_directory_terms", 
               "doc": {
                  "headline": "Clears the directory terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "match_aliases", 
               "doc": {
                  "headline": "Matches aliases only.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    match (boolean): ``true`` to match aliases, ``false`` to\n                match target files\n", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "        :param match: ``true`` to match aliases, ``false`` to match target files\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "match_any_aliases", 
               "doc": {
                  "headline": "Matches a file that has any aliases.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    match (boolean): ``true`` to match any alias, ``false``\n                to match objects with no aliases\n", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "        :param match: ``true`` to match any alias, ``false`` to match objects with no aliases\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "clear_aliases_terms", 
               "doc": {
                  "headline": "Clears the aliases terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "match_owner_id", 
               "doc": {
                  "headline": "Matches files whose entries are owned by the given agent id.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    agent_id (osid.id.Id): the agent ``Id``\n        arg:    match (boolean): ``true`` for a positive match,\n                ``false`` for a negative match\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``agent_id`` is ``null``", 
               "sphinx_param_doc": "        :param agent_id: the agent ``Id``\n        :type agent_id: ``osid.id.Id``\n        :param match: ``true`` for a positive match, ``false`` for a negative match\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``agent_id`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "agent_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "clear_owner_id_terms", 
               "doc": {
                  "headline": "Clears the owner ``Id`` terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "supports_owner_query", 
               "doc": {
                  "headline": "Tests if an ``AgentQuery`` is available for querying agents.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if an agent query is available,\n                ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if an agent query is available, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "get_owner_query", 
               "doc": {
                  "headline": "Gets the query for an agent.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.authentication.AgentQuery) - the agent query", 
               "error_doc": "        raise:  Unimplemented - ``supports_agent_query()`` is ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the agent query\n        :rtype: ``osid.authentication.AgentQuery``", 
               "sphinx_error_doc": "        :raise: ``Unimplemented`` -- ``supports_agent_query()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_agent_query()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.authentication.AgentQuery", 
               "errors": {
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "clear_owner_terms", 
               "doc": {
                  "headline": "Clears the owner terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "match_created_time", 
               "doc": {
                  "headline": "Match directory entries that are created between the specified time period inclusive.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    start (osid.calendaring.DateTime): start time of the\n                query\n        arg:    end (osid.calendaring.DateTime): end time of the query\n        arg:    match (boolean): ``true`` for a positive match,\n                ``false`` for a negative match\n", 
               "return_doc": "", 
               "error_doc": "        raise:  InvalidArgument - ``end`` is les than ``start``\n        raise:  NullArgument - ``start`` or ``end`` is ``null``", 
               "sphinx_param_doc": "        :param start: start time of the query\n        :type start: ``osid.calendaring.DateTime``\n        :param end: end time of the query\n        :type end: ``osid.calendaring.DateTime``\n        :param match: ``true`` for a positive match, ``false`` for a negative match\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``InvalidArgument`` -- ``end`` is les than ``start``\n        :raise: ``NullArgument`` -- ``start`` or ``end`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.calendaring.DateTime", 
                     "var_name": "start", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.calendaring.DateTime", 
                     "var_name": "end", 
                     "array": false
                  }, 
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.calendaring.DateTime", 
                  "osid.calendaring.DateTime", 
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {
                  "INVALID_ARGUMENT": "ConsumerContract", 
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "clear_created_time_terms", 
               "doc": {
                  "headline": "Clears the created time terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "match_modified_time", 
               "doc": {
                  "headline": "Match directory entries that are modified between the specified time period inclusive.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    start (osid.calendaring.DateTime): start time of the\n                query\n        arg:    end (osid.calendaring.DateTime): end time of the query\n        arg:    match (boolean): ``true`` for a positive match,\n                ``false`` for a negative match\n", 
               "return_doc": "", 
               "error_doc": "        raise:  InvalidArgument - ``end`` is les than ``start``\n        raise:  NullArgument - ``start`` or ``end`` is ``null``", 
               "sphinx_param_doc": "        :param start: start time of the query\n        :type start: ``osid.calendaring.DateTime``\n        :param end: end time of the query\n        :type end: ``osid.calendaring.DateTime``\n        :param match: ``true`` for a positive match, ``false`` for a negative match\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``InvalidArgument`` -- ``end`` is les than ``start``\n        :raise: ``NullArgument`` -- ``start`` or ``end`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.calendaring.DateTime", 
                     "var_name": "start", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.calendaring.DateTime", 
                     "var_name": "end", 
                     "array": false
                  }, 
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.calendaring.DateTime", 
                  "osid.calendaring.DateTime", 
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {
                  "INVALID_ARGUMENT": "ConsumerContract", 
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "clear_modified_time_terms", 
               "doc": {
                  "headline": "Clears the modified time terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "match_last_access_time", 
               "doc": {
                  "headline": "Match directory entries that were last accessed between the specified time period.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    start (osid.calendaring.DateTime): start time of the\n                query\n        arg:    end (osid.calendaring.DateTime): end time of the query\n        arg:    match (boolean): ``true`` for a positive match,\n                ``false`` for a negative match\n", 
               "return_doc": "", 
               "error_doc": "        raise:  InvalidArgument - ``end`` is les than ``start``\n        raise:  NullArgument - ``start`` or ``end`` is ``null``", 
               "sphinx_param_doc": "        :param start: start time of the query\n        :type start: ``osid.calendaring.DateTime``\n        :param end: end time of the query\n        :type end: ``osid.calendaring.DateTime``\n        :param match: ``true`` for a positive match, ``false`` for a negative match\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``InvalidArgument`` -- ``end`` is les than ``start``\n        :raise: ``NullArgument`` -- ``start`` or ``end`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.calendaring.DateTime", 
                     "var_name": "start", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.calendaring.DateTime", 
                     "var_name": "end", 
                     "array": false
                  }, 
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.calendaring.DateTime", 
                  "osid.calendaring.DateTime", 
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {
                  "INVALID_ARGUMENT": "ConsumerContract", 
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "clear_last_access_time_terms", 
               "doc": {
                  "headline": "Clears the last access time terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }
         ]
      }, 
      {
         "fullname": "osid.filing.DirectoryEntryQueryInspector", 
         "shortname": "DirectoryEntryQueryInspector", 
         "category": "query_inspectors", 
         "doc": {
            "headline": "``DirectoryEntryQueryInspector`` defines methods in common to both ``FileQueryInspector`` and ``DirectoryQueryInspector``.", 
            "body": ""
         }, 
         "inherit_fullnames": [
            "osid.OsidObjectQueryInspector"
         ], 
         "inherit_shortnames": [
            "OsidObjectQueryInspector"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidObjectQueryInspector"
            }
         ], 
         "method_names": [
            "get_name_terms", 
            "get_path_terms", 
            "get_directory_terms", 
            "get_aliases_terms", 
            "get_owner_id_terms", 
            "get_owner_terms", 
            "get_created_time_terms", 
            "get_modified_time_terms", 
            "get_last_access_time_terms"
         ], 
         "methods": [
            {
               "name": "get_name_terms", 
               "doc": {
                  "headline": "Gets the name query terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.search.terms.StringTerm) - the query terms", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the query terms\n        :rtype: ``osid.search.terms.StringTerm``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.search.terms.StringTerm", 
               "errors": {}
            }, 
            {
               "name": "get_path_terms", 
               "doc": {
                  "headline": "Gets the path query terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.search.terms.StringTerm) - the query terms", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the query terms\n        :rtype: ``osid.search.terms.StringTerm``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.search.terms.StringTerm", 
               "errors": {}
            }, 
            {
               "name": "get_directory_terms", 
               "doc": {
                  "headline": "Gets the directory query terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.filing.DirectoryQueryInspector) - the query terms", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the query terms\n        :rtype: ``osid.filing.DirectoryQueryInspector``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.filing.DirectoryQueryInspector", 
               "errors": {}
            }, 
            {
               "name": "get_aliases_terms", 
               "doc": {
                  "headline": "Gets the aliases query terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.search.terms.BooleanTerm) - the query terms", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the query terms\n        :rtype: ``osid.search.terms.BooleanTerm``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.search.terms.BooleanTerm", 
               "errors": {}
            }, 
            {
               "name": "get_owner_id_terms", 
               "doc": {
                  "headline": "Gets the owner ``Id`` query terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.search.terms.IdTerm) - the query terms", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the query terms\n        :rtype: ``osid.search.terms.IdTerm``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.search.terms.IdTerm", 
               "errors": {}
            }, 
            {
               "name": "get_owner_terms", 
               "doc": {
                  "headline": "Gets the owner query terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.authentication.AgentQueryInspector) - the query\n                terms", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the query terms\n        :rtype: ``osid.authentication.AgentQueryInspector``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.authentication.AgentQueryInspector", 
               "errors": {}
            }, 
            {
               "name": "get_created_time_terms", 
               "doc": {
                  "headline": "Gets the created time query terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.search.terms.DateTimeRangeTerm) - the query terms", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the query terms\n        :rtype: ``osid.search.terms.DateTimeRangeTerm``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.search.terms.DateTimeRangeTerm", 
               "errors": {}
            }, 
            {
               "name": "get_modified_time_terms", 
               "doc": {
                  "headline": "Gets the modified time query terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.search.terms.DateTimeRangeTerm) - the query terms", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the query terms\n        :rtype: ``osid.search.terms.DateTimeRangeTerm``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.search.terms.DateTimeRangeTerm", 
               "errors": {}
            }, 
            {
               "name": "get_last_access_time_terms", 
               "doc": {
                  "headline": "Gets the last access time query terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.search.terms.DateTimeRangeTerm) - the query terms", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the query terms\n        :rtype: ``osid.search.terms.DateTimeRangeTerm``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.search.terms.DateTimeRangeTerm", 
               "errors": {}
            }
         ]
      }, 
      {
         "fullname": "osid.filing.DirectoryEntryForm", 
         "shortname": "DirectoryEntryForm", 
         "category": "objects", 
         "doc": {
            "headline": "``DirectoryEntryForm`` defines methods in common to both ``FileForm`` and ``DirectoryForm``.", 
            "body": ""
         }, 
         "inherit_fullnames": [
            "osid.OsidObjectForm"
         ], 
         "inherit_shortnames": [
            "OsidObjectForm"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidObjectForm"
            }
         ], 
         "method_names": [
            "get_owner_metadata", 
            "set_owner", 
            "clear_owner"
         ], 
         "methods": [
            {
               "name": "get_owner_metadata", 
               "doc": {
                  "headline": "Gets the metadata for the owner.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.Metadata) - metadata for the owner", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: metadata for the owner\n        :rtype: ``osid.Metadata``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.Metadata", 
               "errors": {}
            }, 
            {
               "name": "set_owner", 
               "doc": {
                  "headline": "Sets the owner.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    agent_id (osid.id.Id): the new owner\n", 
               "return_doc": "", 
               "error_doc": "        raise:  InvalidArgument - ``agent_id`` is invalid\n        raise:  NoAccess - ``Metadata.isReadOnly()`` is ``true``\n        raise:  NullArgument - ``agent_id`` is ``null``", 
               "sphinx_param_doc": "        :param agent_id: the new owner\n        :type agent_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``InvalidArgument`` -- ``agent_id`` is invalid\n        :raise: ``NoAccess`` -- ``Metadata.isReadOnly()`` is ``true``\n        :raise: ``NullArgument`` -- ``agent_id`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "agent_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {
                  "INVALID_ARGUMENT": "ConsumerContract", 
                  "NO_ACCESS": "ConsumerContract", 
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "clear_owner", 
               "doc": {
                  "headline": "Clears the owner.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "        raise:  NoAccess - ``Metadata.isRequired()`` or\n                ``Metadata.isReadOnly()`` is ``true``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NoAccess`` -- ``Metadata.isRequired()`` or ``Metadata.isReadOnly()`` is ``true``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {
                  "NO_ACCESS": "ConsumerContract"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.filing.DirectoryEntrySearchOrder", 
         "shortname": "DirectoryEntrySearchOrder", 
         "category": "search_orders", 
         "doc": {
            "headline": "An interface for specifying the order of search results.", 
            "body": ""
         }, 
         "inherit_fullnames": [
            "osid.OsidObjectSearchOrder"
         ], 
         "inherit_shortnames": [
            "OsidObjectSearchOrder"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidObjectSearchOrder"
            }
         ], 
         "method_names": [
            "order_by_name", 
            "order_by_path", 
            "order_by_owner", 
            "supports_owner_search_order", 
            "get_owner_search_order", 
            "order_by_created_time", 
            "order_by_modified_time", 
            "order_by_last_access_time"
         ], 
         "methods": [
            {
               "name": "order_by_name", 
               "doc": {
                  "headline": "Specifies a preference for ordering the result set by the entry name.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    style (osid.SearchOrderStyle): search order style\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``style`` is ``null``", 
               "sphinx_param_doc": "        :param style: search order style\n        :type style: ``osid.SearchOrderStyle``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``style`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.SearchOrderStyle", 
                     "var_name": "style", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.SearchOrderStyle"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "order_by_path", 
               "doc": {
                  "headline": "Specifies a preference for ordering the result set by the entry path.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    style (osid.SearchOrderStyle): search order style\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``style`` is ``null``", 
               "sphinx_param_doc": "        :param style: search order style\n        :type style: ``osid.SearchOrderStyle``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``style`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.SearchOrderStyle", 
                     "var_name": "style", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.SearchOrderStyle"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "order_by_owner", 
               "doc": {
                  "headline": "Specifies a preference for ordering the result set by the entry owner.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    style (osid.SearchOrderStyle): search order style\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``style`` is ``null``", 
               "sphinx_param_doc": "        :param style: search order style\n        :type style: ``osid.SearchOrderStyle``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``style`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.SearchOrderStyle", 
                     "var_name": "style", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.SearchOrderStyle"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "supports_owner_search_order", 
               "doc": {
                  "headline": "Tests if an agent search order is available.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if an agent search order interface\n                is available, ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if an agent search order interface is available, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "get_owner_search_order", 
               "doc": {
                  "headline": "Gets an agent search order interface.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.authentication.AgentSearchOrder) - an agent search\n                order interface", 
               "error_doc": "        raise:  Unimplemented - ``supports_owner_search_order()`` is\n                ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: an agent search order interface\n        :rtype: ``osid.authentication.AgentSearchOrder``", 
               "sphinx_error_doc": "        :raise: ``Unimplemented`` -- ``supports_owner_search_order()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_owner_search_order()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.authentication.AgentSearchOrder", 
               "errors": {
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "order_by_created_time", 
               "doc": {
                  "headline": "Specifies a preference for ordering the result set by the entry creation time.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    style (osid.SearchOrderStyle): search order style\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``style`` is ``null``", 
               "sphinx_param_doc": "        :param style: search order style\n        :type style: ``osid.SearchOrderStyle``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``style`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.SearchOrderStyle", 
                     "var_name": "style", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.SearchOrderStyle"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "order_by_modified_time", 
               "doc": {
                  "headline": "Specifies a preference for ordering the result set by the entry modification time.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    style (osid.SearchOrderStyle): search order style\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``style`` is ``null``", 
               "sphinx_param_doc": "        :param style: search order style\n        :type style: ``osid.SearchOrderStyle``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``style`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.SearchOrderStyle", 
                     "var_name": "style", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.SearchOrderStyle"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "order_by_last_access_time", 
               "doc": {
                  "headline": "Specifies a preference for ordering the result set by the entry last access time.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    style (osid.SearchOrderStyle): search order style\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``style`` is ``null``", 
               "sphinx_param_doc": "        :param style: search order style\n        :type style: ``osid.SearchOrderStyle``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``style`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.SearchOrderStyle", 
                     "var_name": "style", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.SearchOrderStyle"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.filing.File", 
         "shortname": "File", 
         "category": "objects", 
         "doc": {
            "headline": "``File`` represents a file in a file system.", 
            "body": ""
         }, 
         "inherit_fullnames": [
            "osid.filing.DirectoryEntry"
         ], 
         "inherit_shortnames": [
            "DirectoryEntry"
         ], 
         "inherit_pkg_names": [
            "filing"
         ], 
         "inheritance": [
            {
               "pkg_name": "filing", 
               "name": "DirectoryEntry"
            }
         ], 
         "method_names": [
            "has_size", 
            "get_size", 
            "get_file_record"
         ], 
         "methods": [
            {
               "name": "has_size", 
               "doc": {
                  "headline": "Tests if this file has a known size.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if this file has a size, ``false``\n                otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if this file has a size, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "get_size", 
               "doc": {
                  "headline": "Gets the size of this file in bytes if ``has_size()`` is ``true``.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (cardinal) - the size of this file", 
               "error_doc": "        raise:  IllegalState - ``has_size()`` is ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the size of this file\n        :rtype: ``cardinal``", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- ``has_size()`` is ``false``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "cardinal", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract"
               }
            }, 
            {
               "name": "get_file_record", 
               "doc": {
                  "headline": "Gets the file record corresponding to the given ``File`` record ``Type``.", 
                  "body": "        This method is used to retrieve an object implementing the\n        requested record. The ``file_record_type`` may be the ``Type``\n        returned in ``get_record_types()`` or any of its parents in a\n        ``Type`` hierarchy where ``has_record_type(file_record_type)``\n        is ``true`` ."
               }, 
               "arg_doc": "        arg:    file_record_type (osid.type.Type): the file record type\n", 
               "return_doc": "        return: (osid.filing.records.FileRecord) - the file record", 
               "error_doc": "        raise:  NullArgument - ``file_record_type`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unsupported - ``has_record_type(file_record_type)`` is\n                ``false``", 
               "sphinx_param_doc": "        :param file_record_type: the file record type\n        :type file_record_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "        :return: the file record\n        :rtype: ``osid.filing.records.FileRecord``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``file_record_type`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unsupported`` -- ``has_record_type(file_record_type)`` is ``false``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "file_record_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "osid.filing.records.FileRecord", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.filing.records.FileRecord", 
         "shortname": "FileRecord", 
         "category": "records", 
         "doc": {
            "headline": "A record for a ``File``.", 
            "body": "    The methods specified by the record type are available through the\n    underlying object."
         }, 
         "inherit_fullnames": [
            "osid.OsidRecord"
         ], 
         "inherit_shortnames": [
            "OsidRecord"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidRecord"
            }
         ], 
         "method_names": [], 
         "methods": []
      }, 
      {
         "fullname": "osid.filing.FileQuery", 
         "shortname": "FileQuery", 
         "category": "queries", 
         "doc": {
            "headline": "This is the query for searching files.", 
            "body": "    Each method specifies an ``AND`` term while multiple invocations of\n    the same method produces a nested ``OR``."
         }, 
         "inherit_fullnames": [
            "osid.filing.DirectoryEntryQuery"
         ], 
         "inherit_shortnames": [
            "DirectoryEntryQuery"
         ], 
         "inherit_pkg_names": [
            "filing"
         ], 
         "inheritance": [
            {
               "pkg_name": "filing", 
               "name": "DirectoryEntryQuery"
            }
         ], 
         "method_names": [
            "match_size", 
            "match_any_size", 
            "clear_size_terms", 
            "match_data_string", 
            "clear_data_string_terms", 
            "match_data", 
            "match_any_data", 
            "clear_data_terms", 
            "get_file_query_record"
         ], 
         "methods": [
            {
               "name": "match_size", 
               "doc": {
                  "headline": "Matches files whose size is within and including the given range.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    from (cardinal): low file size\n        arg:    to (cardinal): high file size\n        arg:    match (boolean): ``true`` for a positive match,\n                ``false`` for a negative match\n", 
               "return_doc": "", 
               "error_doc": "        raise:  InvalidArgument - ``to`` is les than ``from``", 
               "sphinx_param_doc": "        :param from: low file size\n        :type from: ``cardinal``\n        :param to: high file size\n        :type to: ``cardinal``\n        :param match: ``true`` for a positive match, ``false`` for a negative match\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``InvalidArgument`` -- ``to`` is les than ``from``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "cardinal", 
                     "var_name": "from_", 
                     "array": false
                  }, 
                  {
                     "arg_type": "cardinal", 
                     "var_name": "to", 
                     "array": false
                  }, 
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "cardinal", 
                  "cardinal", 
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {
                  "INVALID_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "match_any_size", 
               "doc": {
                  "headline": "Matches a file that has any known size.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    match (boolean): ``true`` to match any size, ``false``\n                to match files with no known size\n", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "        :param match: ``true`` to match any size, ``false`` to match files with no known size\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "clear_size_terms", 
               "doc": {
                  "headline": "Clears all file size terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "match_data_string", 
               "doc": {
                  "headline": "Adds data strings to this query to match files whose content contains these strings.", 
                  "body": "        Supplying multiple strings behaves like a boolean AND among the\n        elements each which must correspond to the ``stringMatchType``.\n        An OR can be performed with multiple queries."
               }, 
               "arg_doc": "        arg:    data (string): string to match\n        arg:    string_match_type (osid.type.Type): the string match\n                type\n        arg:    match (boolean): ``true`` for a positive match,\n                ``false`` for a negative match\n", 
               "return_doc": "", 
               "error_doc": "        raise:  InvalidArgument - ``data`` not of ``string_match_type``\n        raise:  NullArgument - ``data`` or ``string_match_type`` is\n                ``null``\n        raise:  Unsupported -\n                ``supports_string_match_type(string_match_type)`` is\n                ``false``", 
               "sphinx_param_doc": "        :param data: string to match\n        :type data: ``string``\n        :param string_match_type: the string match type\n        :type string_match_type: ``osid.type.Type``\n        :param match: ``true`` for a positive match, ``false`` for a negative match\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``InvalidArgument`` -- ``data`` not of ``string_match_type``\n        :raise: ``NullArgument`` -- ``data`` or ``string_match_type`` is ``null``\n        :raise: ``Unsupported`` -- ``supports_string_match_type(string_match_type)`` is ``false``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "string", 
                     "var_name": "data", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "string_match_type", 
                     "array": false
                  }, 
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "string", 
                  "osid.type.Type", 
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {
                  "INVALID_ARGUMENT": "ConsumerContract", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }, 
            {
               "name": "clear_data_string_terms", 
               "doc": {
                  "headline": "Clears all file data string terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "match_data", 
               "doc": {
                  "headline": "Matches files who data contains the given bytes.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    data (byte[]): data to match\n        arg:    match (boolean): ``true`` for a positive match,\n                ``false`` for a negative match\n        arg:    partial (boolean): ``true`` for a partial match,\n                ``false`` for a complete match\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``data`` is ``null``", 
               "sphinx_param_doc": "        :param data: data to match\n        :type data: ``byte[]``\n        :param match: ``true`` for a positive match, ``false`` for a negative match\n        :type match: ``boolean``\n        :param partial: ``true`` for a partial match, ``false`` for a complete match\n        :type partial: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``data`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "byte[]", 
                     "var_name": "data", 
                     "array": true
                  }, 
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }, 
                  {
                     "arg_type": "boolean", 
                     "var_name": "partial", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "byte[]", 
                  "boolean", 
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "match_any_data", 
               "doc": {
                  "headline": "Matches a file that has any data.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    match (boolean): ``true`` to match any data, ``false``\n                to match files with no data\n", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "        :param match: ``true`` to match any data, ``false`` to match files with no data\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "clear_data_terms", 
               "doc": {
                  "headline": "Clears all file data terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "get_file_query_record", 
               "doc": {
                  "headline": "Gets the file query record corresponding to the given ``File`` record ``Type``.", 
                  "body": "        Multiple record retrievals produce a nested boolean ``OR`` term."
               }, 
               "arg_doc": "        arg:    file_record_type (osid.type.Type): a file record type\n", 
               "return_doc": "        return: (osid.filing.records.FileQueryRecord) - the file query\n                record", 
               "error_doc": "        raise:  NullArgument - ``file_record_type`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unsupported - ``has_record_type(file_record_type)`` is\n                ``false``", 
               "sphinx_param_doc": "        :param file_record_type: a file record type\n        :type file_record_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "        :return: the file query record\n        :rtype: ``osid.filing.records.FileQueryRecord``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``file_record_type`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unsupported`` -- ``has_record_type(file_record_type)`` is ``false``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "file_record_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "osid.filing.records.FileQueryRecord", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.filing.records.FileQueryRecord", 
         "shortname": "FileQueryRecord", 
         "category": "records", 
         "doc": {
            "headline": "A record for a ``FileQuery``.", 
            "body": "    The methods specified by the record type are available through the\n    underlying object."
         }, 
         "inherit_fullnames": [
            "osid.OsidRecord"
         ], 
         "inherit_shortnames": [
            "OsidRecord"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidRecord"
            }
         ], 
         "method_names": [], 
         "methods": []
      }, 
      {
         "fullname": "osid.filing.FileQueryInspector", 
         "shortname": "FileQueryInspector", 
         "category": "query_inspectors", 
         "doc": {
            "headline": "This is the query inspector for examining file queries.", 
            "body": ""
         }, 
         "inherit_fullnames": [
            "osid.filing.DirectoryEntryQueryInspector"
         ], 
         "inherit_shortnames": [
            "DirectoryEntryQueryInspector"
         ], 
         "inherit_pkg_names": [
            "filing"
         ], 
         "inheritance": [
            {
               "pkg_name": "filing", 
               "name": "DirectoryEntryQueryInspector"
            }
         ], 
         "method_names": [
            "get_size_terms", 
            "get_data_string_terms", 
            "get_data_terms", 
            "get_file_query_inspector_record"
         ], 
         "methods": [
            {
               "name": "get_size_terms", 
               "doc": {
                  "headline": "Gets the size query terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.search.terms.CardinalRangeTerm) - the query terms", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the query terms\n        :rtype: ``osid.search.terms.CardinalRangeTerm``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.search.terms.CardinalRangeTerm", 
               "errors": {}
            }, 
            {
               "name": "get_data_string_terms", 
               "doc": {
                  "headline": "Gets the data string query terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.search.terms.StringTerm) - the query terms", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the query terms\n        :rtype: ``osid.search.terms.StringTerm``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.search.terms.StringTerm", 
               "errors": {}
            }, 
            {
               "name": "get_data_terms", 
               "doc": {
                  "headline": "Gets the data query terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.search.terms.BytesTerm) - the query terms", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the query terms\n        :rtype: ``osid.search.terms.BytesTerm``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.search.terms.BytesTerm", 
               "errors": {}
            }, 
            {
               "name": "get_file_query_inspector_record", 
               "doc": {
                  "headline": "Gets the file query inspector record corresponding to the given ``File`` record ``Type``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    file_record_type (osid.type.Type): a file record type\n", 
               "return_doc": "        return: (osid.filing.records.FileQueryInspectorRecord) - the\n                file query inspector record", 
               "error_doc": "        raise:  NullArgument - ``file_record_type`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unsupported - ``has_record_type(file_record_type)`` is\n                ``false``", 
               "sphinx_param_doc": "        :param file_record_type: a file record type\n        :type file_record_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "        :return: the file query inspector record\n        :rtype: ``osid.filing.records.FileQueryInspectorRecord``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``file_record_type`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unsupported`` -- ``has_record_type(file_record_type)`` is ``false``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "file_record_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "osid.filing.records.FileQueryInspectorRecord", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.filing.records.FileQueryInspectorRecord", 
         "shortname": "FileQueryInspectorRecord", 
         "category": "records", 
         "doc": {
            "headline": "A record for a ``FileQueryInspector``.", 
            "body": "    The methods specified by the record type are available through the\n    underlying object."
         }, 
         "inherit_fullnames": [
            "osid.OsidRecord"
         ], 
         "inherit_shortnames": [
            "OsidRecord"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidRecord"
            }
         ], 
         "method_names": [], 
         "methods": []
      }, 
      {
         "fullname": "osid.filing.FileForm", 
         "shortname": "FileForm", 
         "category": "objects", 
         "doc": {
            "headline": "This is the form for creating and updating ``Files``.", 
            "body": "    Like all ``OsidForm`` objects, various data elements may be set here\n    for use in the create and update methods in the\n    ``FileAdminSession``. For each data element that may be set,\n    metadata may be examined to provide display hints or data\n    constraints."
         }, 
         "inherit_fullnames": [
            "osid.filing.DirectoryEntryForm"
         ], 
         "inherit_shortnames": [
            "DirectoryEntryForm"
         ], 
         "inherit_pkg_names": [
            "filing"
         ], 
         "inheritance": [
            {
               "pkg_name": "filing", 
               "name": "DirectoryEntryForm"
            }
         ], 
         "method_names": [
            "get_file_form_record"
         ], 
         "methods": [
            {
               "name": "get_file_form_record", 
               "doc": {
                  "headline": "Gets the ``FileFormRecord`` corresponding to the given file record ``Type``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    file_record_type (osid.type.Type): the file record type\n", 
               "return_doc": "        return: (osid.filing.records.FileFormRecord) - the file form\n                record", 
               "error_doc": "        raise:  NullArgument - ``file_record_type`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unsupported - ``has_record_type(file_record_type)`` is\n                ``false``", 
               "sphinx_param_doc": "        :param file_record_type: the file record type\n        :type file_record_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "        :return: the file form record\n        :rtype: ``osid.filing.records.FileFormRecord``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``file_record_type`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unsupported`` -- ``has_record_type(file_record_type)`` is ``false``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "file_record_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "osid.filing.records.FileFormRecord", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.filing.records.FileFormRecord", 
         "shortname": "FileFormRecord", 
         "category": "records", 
         "doc": {
            "headline": "A record for a ``FileForm``.", 
            "body": "    The methods specified by the record type are available through the\n    underlying object."
         }, 
         "inherit_fullnames": [
            "osid.OsidRecord"
         ], 
         "inherit_shortnames": [
            "OsidRecord"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidRecord"
            }
         ], 
         "method_names": [], 
         "methods": []
      }, 
      {
         "fullname": "osid.filing.FileSearchOrder", 
         "shortname": "FileSearchOrder", 
         "category": "search_orders", 
         "doc": {
            "headline": "An interface for specifying the ordering of search results.", 
            "body": ""
         }, 
         "inherit_fullnames": [
            "osid.filing.DirectoryEntrySearchOrder"
         ], 
         "inherit_shortnames": [
            "DirectoryEntrySearchOrder"
         ], 
         "inherit_pkg_names": [
            "filing"
         ], 
         "inheritance": [
            {
               "pkg_name": "filing", 
               "name": "DirectoryEntrySearchOrder"
            }
         ], 
         "method_names": [
            "order_by_size", 
            "get_file_search_order_record"
         ], 
         "methods": [
            {
               "name": "order_by_size", 
               "doc": {
                  "headline": "Specifies a preference for ordering the results by file size.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    style (osid.SearchOrderStyle): search order style\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``style`` is ``null``", 
               "sphinx_param_doc": "        :param style: search order style\n        :type style: ``osid.SearchOrderStyle``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``style`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.SearchOrderStyle", 
                     "var_name": "style", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.SearchOrderStyle"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "get_file_search_order_record", 
               "doc": {
                  "headline": "Gets the file search order record corresponding to the given file record Type.", 
                  "body": "        Multiple retrievals return the same underlying object."
               }, 
               "arg_doc": "        arg:    file_record_type (osid.type.Type): a file record type\n", 
               "return_doc": "        return: (osid.filing.records.FileSearchOrderRecord) - the file\n                search order record", 
               "error_doc": "        raise:  NullArgument - ``file_record_type`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unsupported - ``has_record_type(file_record_type)`` is\n                ``false``", 
               "sphinx_param_doc": "        :param file_record_type: a file record type\n        :type file_record_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "        :return: the file search order record\n        :rtype: ``osid.filing.records.FileSearchOrderRecord``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``file_record_type`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unsupported`` -- ``has_record_type(file_record_type)`` is ``false``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "file_record_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "osid.filing.records.FileSearchOrderRecord", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.filing.records.FileSearchOrderRecord", 
         "shortname": "FileSearchOrderRecord", 
         "category": "records", 
         "doc": {
            "headline": "A record for a ``FileSearchOrder``.", 
            "body": "    The methods specified by the record type are available through the\n    underlying object."
         }, 
         "inherit_fullnames": [
            "osid.OsidRecord"
         ], 
         "inherit_shortnames": [
            "OsidRecord"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidRecord"
            }
         ], 
         "method_names": [], 
         "methods": []
      }, 
      {
         "fullname": "osid.filing.FileSearch", 
         "shortname": "FileSearch", 
         "category": "searches", 
         "doc": {
            "headline": "The search interface for governing file searches.", 
            "body": ""
         }, 
         "inherit_fullnames": [
            "osid.OsidSearch"
         ], 
         "inherit_shortnames": [
            "OsidSearch"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidSearch"
            }
         ], 
         "method_names": [
            "search_among_files", 
            "order_file_results", 
            "get_file_search_record"
         ], 
         "methods": [
            {
               "name": "search_among_files", 
               "doc": {
                  "headline": "Execute this search among the given list of files.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    file_ids (osid.id.IdList): list of file ``Ids``\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``file_ids`` is ``null``", 
               "sphinx_param_doc": "        :param file_ids: list of file ``Ids``\n        :type file_ids: ``osid.id.IdList``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``file_ids`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.IdList", 
                     "var_name": "file_ids", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.IdList"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "order_file_results", 
               "doc": {
                  "headline": "Specify an ordering to the search results.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    file_search_order (osid.filing.FileSearchOrder): file\n                search order\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``file_search_order`` is ``null``\n        raise:  Unsupported - ``file_search_order`` is not of this\n                service", 
               "sphinx_param_doc": "        :param file_search_order: file search order\n        :type file_search_order: ``osid.filing.FileSearchOrder``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``file_search_order`` is ``null``\n        :raise: ``Unsupported`` -- ``file_search_order`` is not of this service", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.filing.FileSearchOrder", 
                     "var_name": "file_search_order", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.filing.FileSearchOrder"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_file_search_record", 
               "doc": {
                  "headline": "Gets the file search record corresponding to the given file search record ``Type``.", 
                  "body": "        This method is used to retrieve an object implementing the\n        requested record."
               }, 
               "arg_doc": "        arg:    file_search_record_type (osid.type.Type): a file search\n                record type\n", 
               "return_doc": "        return: (osid.filing.records.FileSearchRecord) - the file search\n                record", 
               "error_doc": "        raise:  NullArgument - ``file_search_record_type`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unsupported -\n                ``has_record_type(file_search_record_type)`` is\n                ``false``", 
               "sphinx_param_doc": "        :param file_search_record_type: a file search record type\n        :type file_search_record_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "        :return: the file search record\n        :rtype: ``osid.filing.records.FileSearchRecord``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``file_search_record_type`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unsupported`` -- ``has_record_type(file_search_record_type)`` is ``false``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "file_search_record_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "osid.filing.records.FileSearchRecord", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.filing.records.FileSearchRecord", 
         "shortname": "FileSearchRecord", 
         "category": "records", 
         "doc": {
            "headline": "A record for a ``FileSearch``.", 
            "body": "    The methods specified by the record type are available through the\n    underlying object."
         }, 
         "inherit_fullnames": [
            "osid.OsidRecord"
         ], 
         "inherit_shortnames": [
            "OsidRecord"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidRecord"
            }
         ], 
         "method_names": [], 
         "methods": []
      }, 
      {
         "fullname": "osid.filing.FileSearchResults", 
         "shortname": "FileSearchResults", 
         "category": "searches", 
         "doc": {
            "headline": "This interface provides a means to capture results of a search.", 
            "body": ""
         }, 
         "inherit_fullnames": [
            "osid.OsidSearchResults"
         ], 
         "inherit_shortnames": [
            "OsidSearchResults"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidSearchResults"
            }
         ], 
         "method_names": [
            "get_files", 
            "get_file_query_inspector", 
            "get_file_search_results_record"
         ], 
         "methods": [
            {
               "name": "get_files", 
               "doc": {
                  "headline": "Gets the file list resulting from a search.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.filing.FileList) - the directory list", 
               "error_doc": "        raise:  IllegalState - list already retrieved", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the directory list\n        :rtype: ``osid.filing.FileList``", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- list already retrieved", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.filing.FileList", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract"
               }
            }, 
            {
               "name": "get_file_query_inspector", 
               "doc": {
                  "headline": "Gets the inspector for the query to examine the terms used in the search.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.filing.FileQueryInspector) - the query inspector", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the query inspector\n        :rtype: ``osid.filing.FileQueryInspector``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.filing.FileQueryInspector", 
               "errors": {}
            }, 
            {
               "name": "get_file_search_results_record", 
               "doc": {
                  "headline": "Gets the file search results record corresponding to the given file search record ``Type``.", 
                  "body": "        This method is used to retrieve an object implementing the\n        requested record."
               }, 
               "arg_doc": "        arg:    file_search_record_type (osid.type.Type): a file search\n                record type\n", 
               "return_doc": "        return: (osid.filing.records.FileSearchResultsRecord) - the file\n                search results record", 
               "error_doc": "        raise:  NullArgument - ``file_search_record_type`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unsupported -\n                ``has_record_type(file_search_record_type)`` is\n                ``false``", 
               "sphinx_param_doc": "        :param file_search_record_type: a file search record type\n        :type file_search_record_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "        :return: the file search results record\n        :rtype: ``osid.filing.records.FileSearchResultsRecord``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``file_search_record_type`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unsupported`` -- ``has_record_type(file_search_record_type)`` is ``false``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "file_search_record_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "osid.filing.records.FileSearchResultsRecord", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.filing.records.FileSearchResultsRecord", 
         "shortname": "FileSearchResultsRecord", 
         "category": "records", 
         "doc": {
            "headline": "A record for a ``FileSearchResults``.", 
            "body": "    The methods specified by the record type are available through the\n    underlying object."
         }, 
         "inherit_fullnames": [
            "osid.OsidRecord"
         ], 
         "inherit_shortnames": [
            "OsidRecord"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidRecord"
            }
         ], 
         "method_names": [], 
         "methods": []
      }, 
      {
         "fullname": "osid.filing.FileReceiver", 
         "shortname": "FileReceiver", 
         "category": "receivers", 
         "doc": {
            "headline": "The file receiver is the consumer supplied interface for receiving notifications pertaining to new, updated or deleted files.", 
            "body": ""
         }, 
         "inherit_fullnames": [
            "osid.OsidReceiver"
         ], 
         "inherit_shortnames": [
            "OsidReceiver"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidReceiver"
            }
         ], 
         "method_names": [
            "new_file", 
            "changed_file", 
            "deleted_file"
         ], 
         "methods": [
            {
               "name": "new_file", 
               "doc": {
                  "headline": "The callback for notifications of new files.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    file_path (string): absolute pathname to the new file\n", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "        :param file_path: absolute pathname to the new file\n        :type file_path: ``string``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "string", 
                     "var_name": "file_path", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "string"
               ], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "changed_file", 
               "doc": {
                  "headline": "The callback for notification of updated files.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    file_path (string): absolute pathname to the changed\n                file\n", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "        :param file_path: absolute pathname to the changed file\n        :type file_path: ``string``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "string", 
                     "var_name": "file_path", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "string"
               ], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "deleted_file", 
               "doc": {
                  "headline": "the callback for notification of deleted files.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    file_path (string): absolute pathname to the deleted\n                file\n", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "        :param file_path: absolute pathname to the deleted file\n        :type file_path: ``string``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "string", 
                     "var_name": "file_path", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "string"
               ], 
               "return_type": "", 
               "errors": {}
            }
         ]
      }, 
      {
         "fullname": "osid.filing.FileList", 
         "shortname": "FileList", 
         "category": "objects", 
         "doc": {
            "headline": "Like all ``OsidLists,``  ``FileList`` provides a means for accessing ``File`` elements sequentially either one at a time or many at a time.", 
            "body": "    Examples: while (fl.hasNext()) { File file = fl.getNextFile(); }\n\n    or\n      while (fl.hasNext()) {\n           File[] files = fl.getNextFiles(fl.available());\n      }\n    \n"
         }, 
         "inherit_fullnames": [
            "osid.OsidList"
         ], 
         "inherit_shortnames": [
            "OsidList"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidList"
            }
         ], 
         "method_names": [
            "get_next_file", 
            "get_next_files"
         ], 
         "methods": [
            {
               "name": "get_next_file", 
               "doc": {
                  "headline": "Gets the next ``File`` in this list.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.filing.File) - the next ``File`` in this list. The\n                ``has_next()`` method should be used to test that a next\n                ``File`` is available before calling this method.", 
               "error_doc": "        raise:  IllegalState - no more elements available in this list\n        raise:  OperationFailed - unable to complete request", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the next ``File`` in this list. The ``has_next()`` method should be used to test that a next ``File`` is available before calling this method.\n        :rtype: ``osid.filing.File``", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- no more elements available in this list\n        :raise: ``OperationFailed`` -- unable to complete request", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.filing.File", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational"
               }
            }, 
            {
               "name": "get_next_files", 
               "doc": {
                  "headline": "Gets the next set of ``File`` elements in this list which must be less than or equal to the number returned from ``available()``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    n (cardinal): the number of ``File`` elements requested\n                which should be less than or equal to ``available()``\n", 
               "return_doc": "        return: (osid.filing.File) - an array of ``File`` elements.The\n                length of the array is less than or equal to the number\n                specified.", 
               "error_doc": "        raise:  IllegalState - no more elements available in this list\n        raise:  OperationFailed - unable to complete request", 
               "sphinx_param_doc": "        :param n: the number of ``File`` elements requested which should be less than or equal to ``available()``\n        :type n: ``cardinal``\n", 
               "sphinx_return_doc": "        :return: an array of ``File`` elements.The length of the array is less than or equal to the number specified.\n        :rtype: ``osid.filing.File``", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- no more elements available in this list\n        :raise: ``OperationFailed`` -- unable to complete request", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "cardinal", 
                     "var_name": "n", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "cardinal"
               ], 
               "return_type": "osid.filing.File", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.filing.Directory", 
         "shortname": "Directory", 
         "category": "objects", 
         "doc": {
            "headline": "``Directory`` represents a directory in a file system that may contain other files and directories.", 
            "body": ""
         }, 
         "inherit_fullnames": [
            "osid.OsidCatalog", 
            "osid.filing.DirectoryEntry"
         ], 
         "inherit_shortnames": [
            "OsidCatalog", 
            "DirectoryEntry"
         ], 
         "inherit_pkg_names": [
            "osid", 
            "filing"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidCatalog"
            }, 
            {
               "pkg_name": "filing", 
               "name": "DirectoryEntry"
            }
         ], 
         "method_names": [
            "get_directory_record"
         ], 
         "methods": [
            {
               "name": "get_directory_record", 
               "doc": {
                  "headline": "Gets the directory record corresponding to the given ``Directory`` record ``Type``.", 
                  "body": "        This method is used to retrieve an object implementing the\n        requested record. The ``directory_record_type`` may be the\n        ``Type`` returned in ``get_record_types()`` or any of its\n        parents in a ``Type`` hierarchy where\n        ``has_record_type(directory_record_type)`` is ``true`` ."
               }, 
               "arg_doc": "        arg:    directory_record_type (osid.type.Type): the directory\n                record type\n", 
               "return_doc": "        return: (osid.filing.records.DirectoryRecord) - the directory\n                record", 
               "error_doc": "        raise:  NullArgument - ``directory_record_type`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unsupported - ``has_record_type(directory_record_type)``\n                is ``false``", 
               "sphinx_param_doc": "        :param directory_record_type: the directory record type\n        :type directory_record_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "        :return: the directory record\n        :rtype: ``osid.filing.records.DirectoryRecord``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``directory_record_type`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unsupported`` -- ``has_record_type(directory_record_type)`` is ``false``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "directory_record_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "osid.filing.records.DirectoryRecord", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.filing.records.DirectoryRecord", 
         "shortname": "DirectoryRecord", 
         "category": "records", 
         "doc": {
            "headline": "A record for a ``Directory``.", 
            "body": "    The methods specified by the record type are available through the\n    underlying object."
         }, 
         "inherit_fullnames": [
            "osid.OsidRecord"
         ], 
         "inherit_shortnames": [
            "OsidRecord"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidRecord"
            }
         ], 
         "method_names": [], 
         "methods": []
      }, 
      {
         "fullname": "osid.filing.DirectoryQuery", 
         "shortname": "DirectoryQuery", 
         "category": "queries", 
         "doc": {
            "headline": "This is the query for searching directories.", 
            "body": "    Each method match request produces an ``AND`` term while multiple\n    invocations of a method produces a nested ``OR``.\n\n    An example to find directories whose name is \"Library\".\n      DirectoryQuery query = session.getDirectoryQuery();\n      query.matchName(\"Library\", wordStringMatchType, true);\n      \n      DirectoryList list = session.getDirectoriesByQuery(query);\n    \n"
         }, 
         "inherit_fullnames": [
            "osid.OsidCatalogQuery", 
            "osid.filing.DirectoryEntryQuery"
         ], 
         "inherit_shortnames": [
            "OsidCatalogQuery", 
            "DirectoryEntryQuery"
         ], 
         "inherit_pkg_names": [
            "osid", 
            "filing"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidCatalogQuery"
            }, 
            {
               "pkg_name": "filing", 
               "name": "DirectoryEntryQuery"
            }
         ], 
         "method_names": [
            "match_file_name", 
            "clear_file_name_terms", 
            "supports_file_query", 
            "get_file_query", 
            "match_any_file", 
            "clear_file_terms", 
            "get_directory_query_record"
         ], 
         "methods": [
            {
               "name": "match_file_name", 
               "doc": {
                  "headline": "Matches directories that contain the specified file name.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    name (string): a file name\n        arg:    string_match_type (osid.type.Type): the string match\n                type\n        arg:    match (boolean): ``true`` for a positive match,\n                ``false`` for a negative match\n", 
               "return_doc": "", 
               "error_doc": "        raise:  InvalidArgument - ``name`` not of ``string_match_type``\n        raise:  NullArgument - ``name`` or ``string_match_type`` is\n                ``null``\n        raise:  Unsupported -\n                ``supports_string_match_type(string_match_type)`` is\n                ``false``", 
               "sphinx_param_doc": "        :param name: a file name\n        :type name: ``string``\n        :param string_match_type: the string match type\n        :type string_match_type: ``osid.type.Type``\n        :param match: ``true`` for a positive match, ``false`` for a negative match\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``InvalidArgument`` -- ``name`` not of ``string_match_type``\n        :raise: ``NullArgument`` -- ``name`` or ``string_match_type`` is ``null``\n        :raise: ``Unsupported`` -- ``supports_string_match_type(string_match_type)`` is ``false``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "string", 
                     "var_name": "name", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "string_match_type", 
                     "array": false
                  }, 
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "string", 
                  "osid.type.Type", 
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {
                  "INVALID_ARGUMENT": "ConsumerContract", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }, 
            {
               "name": "clear_file_name_terms", 
               "doc": {
                  "headline": "Clears all file name terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "supports_file_query", 
               "doc": {
                  "headline": "Tests if a ``FileQuery`` is available.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if a file query is available,\n                ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if a file query is available, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "get_file_query", 
               "doc": {
                  "headline": "Gets the query for a file contained within the directory.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    match (boolean): ``true`` for a positive match,\n                ``false`` for a negative match\n", 
               "return_doc": "        return: (osid.filing.FileQuery) - the directory query", 
               "error_doc": "        raise:  Unimplemented - ``supports_file_query()`` is ``false``", 
               "sphinx_param_doc": "        :param match: ``true`` for a positive match, ``false`` for a negative match\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "        :return: the directory query\n        :rtype: ``osid.filing.FileQuery``", 
               "sphinx_error_doc": "        :raise: ``Unimplemented`` -- ``supports_file_query()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_file_query()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "boolean"
               ], 
               "return_type": "osid.filing.FileQuery", 
               "errors": {
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "match_any_file", 
               "doc": {
                  "headline": "Matches directories with any file.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    match (boolean): ``true`` to match directories with any\n                file,, ``false`` to match directories with no file.\n", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "        :param match: ``true`` to match directories with any file,, ``false`` to match directories with no file.\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "clear_file_terms", 
               "doc": {
                  "headline": "Clears all file terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "get_directory_query_record", 
               "doc": {
                  "headline": "Gets the directory query record corresponding to the given ``Directory`` record ``Type``.", 
                  "body": "        Multiple record retrievals produce a nested boolean ``OR`` term."
               }, 
               "arg_doc": "        arg:    directory_record_type (osid.type.Type): a directory\n                record type\n", 
               "return_doc": "        return: (osid.filing.records.DirectoryQueryRecord) - the\n                directory query record", 
               "error_doc": "        raise:  NullArgument - ``directory_record_type`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unsupported - ``has_record_type(directory_record_type)``\n                is ``false``", 
               "sphinx_param_doc": "        :param directory_record_type: a directory record type\n        :type directory_record_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "        :return: the directory query record\n        :rtype: ``osid.filing.records.DirectoryQueryRecord``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``directory_record_type`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unsupported`` -- ``has_record_type(directory_record_type)`` is ``false``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "directory_record_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "osid.filing.records.DirectoryQueryRecord", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.filing.records.DirectoryQueryRecord", 
         "shortname": "DirectoryQueryRecord", 
         "category": "records", 
         "doc": {
            "headline": "A record for a ``DirectoryQuery``.", 
            "body": "    The methods specified by the record type are available through the\n    underlying object."
         }, 
         "inherit_fullnames": [
            "osid.OsidRecord"
         ], 
         "inherit_shortnames": [
            "OsidRecord"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidRecord"
            }
         ], 
         "method_names": [], 
         "methods": []
      }, 
      {
         "fullname": "osid.filing.DirectoryQueryInspector", 
         "shortname": "DirectoryQueryInspector", 
         "category": "query_inspectors", 
         "doc": {
            "headline": "This is the query inspector for examining directory queries.", 
            "body": ""
         }, 
         "inherit_fullnames": [
            "osid.OsidCatalogQueryInspector", 
            "osid.filing.DirectoryEntryQueryInspector"
         ], 
         "inherit_shortnames": [
            "OsidCatalogQueryInspector", 
            "DirectoryEntryQueryInspector"
         ], 
         "inherit_pkg_names": [
            "osid", 
            "filing"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidCatalogQueryInspector"
            }, 
            {
               "pkg_name": "filing", 
               "name": "DirectoryEntryQueryInspector"
            }
         ], 
         "method_names": [
            "get_file_name_terms", 
            "get_file_terms", 
            "get_directory_query_inspector_record"
         ], 
         "methods": [
            {
               "name": "get_file_name_terms", 
               "doc": {
                  "headline": "Gets the file name query terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.search.terms.StringTerm) - the query terms", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the query terms\n        :rtype: ``osid.search.terms.StringTerm``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.search.terms.StringTerm", 
               "errors": {}
            }, 
            {
               "name": "get_file_terms", 
               "doc": {
                  "headline": "Gets the file query terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.filing.FileQueryInspector) - the query terms", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the query terms\n        :rtype: ``osid.filing.FileQueryInspector``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.filing.FileQueryInspector", 
               "errors": {}
            }, 
            {
               "name": "get_directory_query_inspector_record", 
               "doc": {
                  "headline": "Gets the directory query inspector record corresponding to the given ``Directory`` record ``Type``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    directory_record_type (osid.type.Type): a directory\n                record type\n", 
               "return_doc": "        return: (osid.filing.records.DirectoryQueryInspectorRecord) -\n                the directory query inspector record", 
               "error_doc": "        raise:  NullArgument - ``directory_record_type`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unsupported - ``has_record_type(directory_record_type)``\n                is ``false``", 
               "sphinx_param_doc": "        :param directory_record_type: a directory record type\n        :type directory_record_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "        :return: the directory query inspector record\n        :rtype: ``osid.filing.records.DirectoryQueryInspectorRecord``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``directory_record_type`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unsupported`` -- ``has_record_type(directory_record_type)`` is ``false``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "directory_record_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "osid.filing.records.DirectoryQueryInspectorRecord", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.filing.records.DirectoryQueryInspectorRecord", 
         "shortname": "DirectoryQueryInspectorRecord", 
         "category": "records", 
         "doc": {
            "headline": "A record for a ``DirectoryQueryInspector``.", 
            "body": "    The methods specified by the record type are available through the\n    underlying object."
         }, 
         "inherit_fullnames": [
            "osid.OsidRecord"
         ], 
         "inherit_shortnames": [
            "OsidRecord"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidRecord"
            }
         ], 
         "method_names": [], 
         "methods": []
      }, 
      {
         "fullname": "osid.filing.DirectoryForm", 
         "shortname": "DirectoryForm", 
         "category": "objects", 
         "doc": {
            "headline": "This is the form for creating and updating ``Directory`` objects.", 
            "body": "    Like all ``OsidForm`` objects, various data elements may be set here\n    for use in the create and update methods in the\n    ``DirectoryAdminSession``. For each data element that may be set,\n    metadata may be examined to provide display hints or data\n    constraints."
         }, 
         "inherit_fullnames": [
            "osid.OsidCatalogForm", 
            "osid.filing.DirectoryEntryForm"
         ], 
         "inherit_shortnames": [
            "OsidCatalogForm", 
            "DirectoryEntryForm"
         ], 
         "inherit_pkg_names": [
            "osid", 
            "filing"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidCatalogForm"
            }, 
            {
               "pkg_name": "filing", 
               "name": "DirectoryEntryForm"
            }
         ], 
         "method_names": [
            "get_directory_form_record"
         ], 
         "methods": [
            {
               "name": "get_directory_form_record", 
               "doc": {
                  "headline": "Gets the ``DirectoryFormRecord`` corresponding to the given directory record ``Type``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    directory_record_type (osid.type.Type): the directory\n                record type\n", 
               "return_doc": "        return: (osid.filing.records.DirectoryFormRecord) - the\n                directory form record", 
               "error_doc": "        raise:  NullArgument - ``directory_record_type`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unsupported - ``has_record_type(directory_record_type)``\n                is ``false``", 
               "sphinx_param_doc": "        :param directory_record_type: the directory record type\n        :type directory_record_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "        :return: the directory form record\n        :rtype: ``osid.filing.records.DirectoryFormRecord``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``directory_record_type`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unsupported`` -- ``has_record_type(directory_record_type)`` is ``false``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "directory_record_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "osid.filing.records.DirectoryFormRecord", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.filing.records.DirectoryFormRecord", 
         "shortname": "DirectoryFormRecord", 
         "category": "records", 
         "doc": {
            "headline": "A record for a ``DirectoryForm``.", 
            "body": "    The methods specified by the record type are available through the\n    underlying object."
         }, 
         "inherit_fullnames": [
            "osid.OsidRecord"
         ], 
         "inherit_shortnames": [
            "OsidRecord"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidRecord"
            }
         ], 
         "method_names": [], 
         "methods": []
      }, 
      {
         "fullname": "osid.filing.DirectorySearchOrder", 
         "shortname": "DirectorySearchOrder", 
         "category": "search_orders", 
         "doc": {
            "headline": "An interface for specifying the ordering of search results.", 
            "body": ""
         }, 
         "inherit_fullnames": [
            "osid.OsidCatalogSearchOrder", 
            "osid.filing.DirectoryEntrySearchOrder"
         ], 
         "inherit_shortnames": [
            "OsidCatalogSearchOrder", 
            "DirectoryEntrySearchOrder"
         ], 
         "inherit_pkg_names": [
            "osid", 
            "filing"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidCatalogSearchOrder"
            }, 
            {
               "pkg_name": "filing", 
               "name": "DirectoryEntrySearchOrder"
            }
         ], 
         "method_names": [
            "get_directory_search_order_record"
         ], 
         "methods": [
            {
               "name": "get_directory_search_order_record", 
               "doc": {
                  "headline": "Gets the directory search order record corresponding to the given directory record Type.", 
                  "body": "        Multiple retrievals return the same underlying object."
               }, 
               "arg_doc": "        arg:    directory_record_type (osid.type.Type): a directory\n                record type\n", 
               "return_doc": "        return: (osid.filing.records.DirectorySearchOrderRecord) - the\n                directory search order record", 
               "error_doc": "        raise:  NullArgument - ``directory_record_type`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unsupported - ``has_record_type(directory_record_type)``\n                is ``false``", 
               "sphinx_param_doc": "        :param directory_record_type: a directory record type\n        :type directory_record_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "        :return: the directory search order record\n        :rtype: ``osid.filing.records.DirectorySearchOrderRecord``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``directory_record_type`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unsupported`` -- ``has_record_type(directory_record_type)`` is ``false``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "directory_record_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "osid.filing.records.DirectorySearchOrderRecord", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.filing.records.DirectorySearchOrderRecord", 
         "shortname": "DirectorySearchOrderRecord", 
         "category": "records", 
         "doc": {
            "headline": "A record for a ``DirectorySearchOrder``.", 
            "body": "    The methods specified by the record type are available through the\n    underlying object."
         }, 
         "inherit_fullnames": [
            "osid.OsidRecord"
         ], 
         "inherit_shortnames": [
            "OsidRecord"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidRecord"
            }
         ], 
         "method_names": [], 
         "methods": []
      }, 
      {
         "fullname": "osid.filing.DirectorySearch", 
         "shortname": "DirectorySearch", 
         "category": "searches", 
         "doc": {
            "headline": "The search interface for gioverning directory searches.", 
            "body": ""
         }, 
         "inherit_fullnames": [
            "osid.OsidSearch"
         ], 
         "inherit_shortnames": [
            "OsidSearch"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidSearch"
            }
         ], 
         "method_names": [
            "search_among_directories", 
            "order_directory_results", 
            "get_directory_search_record"
         ], 
         "methods": [
            {
               "name": "search_among_directories", 
               "doc": {
                  "headline": "Execute this search among the given list of diectories.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    directory_ids (osid.id.IdList): list of directory\n                ``Ids``\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``directory_ids`` is ``null``", 
               "sphinx_param_doc": "        :param directory_ids: list of directory ``Ids``\n        :type directory_ids: ``osid.id.IdList``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``directory_ids`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.IdList", 
                     "var_name": "directory_ids", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.IdList"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "order_directory_results", 
               "doc": {
                  "headline": "Specify an ordering to the search results.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    directory_search_order\n                (osid.filing.DirectorySearchOrder): directory search\n                order\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``directory_search_order`` is ``null``\n        raise:  Unsupported - ``directory_search_order`` is not of this\n                service", 
               "sphinx_param_doc": "        :param directory_search_order: directory search order\n        :type directory_search_order: ``osid.filing.DirectorySearchOrder``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``directory_search_order`` is ``null``\n        :raise: ``Unsupported`` -- ``directory_search_order`` is not of this service", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.filing.DirectorySearchOrder", 
                     "var_name": "directory_search_order", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.filing.DirectorySearchOrder"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_directory_search_record", 
               "doc": {
                  "headline": "Gets the directory search record corresponding to the given directory search record ``Type``.", 
                  "body": "        This method is used to retrieve an object implementing the\n        requested record."
               }, 
               "arg_doc": "        arg:    directory_search_record_type (osid.type.Type): a\n                directory search record type\n", 
               "return_doc": "        return: (osid.filing.records.DirectorySearchRecord) - the\n                directory search record", 
               "error_doc": "        raise:  NullArgument - ``directory_search_record_type`` is\n                ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unsupported -\n                ``has_record_type(directory_search_record_type)`` is\n                ``false``", 
               "sphinx_param_doc": "        :param directory_search_record_type: a directory search record type\n        :type directory_search_record_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "        :return: the directory search record\n        :rtype: ``osid.filing.records.DirectorySearchRecord``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``directory_search_record_type`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unsupported`` -- ``has_record_type(directory_search_record_type)`` is ``false``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "directory_search_record_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "osid.filing.records.DirectorySearchRecord", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.filing.records.DirectorySearchRecord", 
         "shortname": "DirectorySearchRecord", 
         "category": "records", 
         "doc": {
            "headline": "A record for a ``DirectorySearch``.", 
            "body": "    The methods specified by the record type are available through the\n    underlying object."
         }, 
         "inherit_fullnames": [
            "osid.OsidRecord"
         ], 
         "inherit_shortnames": [
            "OsidRecord"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidRecord"
            }
         ], 
         "method_names": [], 
         "methods": []
      }, 
      {
         "fullname": "osid.filing.DirectorySearchResults", 
         "shortname": "DirectorySearchResults", 
         "category": "searches", 
         "doc": {
            "headline": "This interface provides a means to capture results of a search.", 
            "body": "    This example gets a result set from a keyword match.\n\n    An example to find directories whose path contains \"System\" from a\n    resulting search of directories whose name is \"Library\", sorted by\n    the path name.\n      DirectoryQuery query = session.getDirectoryQuery();\n      query.addNameMatch(\"Library\", wordStringMatchType, true);\n      DirectorySearch search = session.getDirectorySearch();\n      DirectorySearchResults results = session.getDirectoriesBySearch(query, search);\n      \n      query = session.getDirectoryQuery();\n      query.addNameMatch(\"System\", wordStringMatchType, true);\n      search = session.getDirectorySearch();\n      search.searchWithinDirectoryResults(results);\n      DirectorySearchOrder order = session.getDirectorySearchOrder();\n      order.orderByPath();\n      search.orderDirectoryResults(order);\n      \n      results = session.getDirectoriesBySearch(query, search);\n      DirectoryList directories = results.getDirectories();\n    \n"
         }, 
         "inherit_fullnames": [
            "osid.OsidSearchResults"
         ], 
         "inherit_shortnames": [
            "OsidSearchResults"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidSearchResults"
            }
         ], 
         "method_names": [
            "get_directories", 
            "get_directory_query_inspector", 
            "get_directory_search_results_record"
         ], 
         "methods": [
            {
               "name": "get_directories", 
               "doc": {
                  "headline": "Gets the directory list resulting from a search.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.filing.DirectoryList) - the directory list", 
               "error_doc": "        raise:  IllegalState - list already retrieved", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the directory list\n        :rtype: ``osid.filing.DirectoryList``", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- list already retrieved", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.filing.DirectoryList", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract"
               }
            }, 
            {
               "name": "get_directory_query_inspector", 
               "doc": {
                  "headline": "Gets the inspector for the query to examine the terms used in the search.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.filing.DirectoryQueryInspector) - the query\n                inspector", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the query inspector\n        :rtype: ``osid.filing.DirectoryQueryInspector``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.filing.DirectoryQueryInspector", 
               "errors": {}
            }, 
            {
               "name": "get_directory_search_results_record", 
               "doc": {
                  "headline": "Gets the directory search results record corresponding to the given directory search record ``Type``.", 
                  "body": "        This method is used to retrieve an object implementing the\n        requested record."
               }, 
               "arg_doc": "        arg:    directory_search_record_type (osid.type.Type): a\n                directory search record type\n", 
               "return_doc": "        return: (osid.filing.records.DirectorySearchResultsRecord) - the\n                directory search results record", 
               "error_doc": "        raise:  NullArgument - ``directory_search_record_type`` is\n                ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unsupported -\n                ``has_record_type(directory_search_record_type)`` is\n                ``false``", 
               "sphinx_param_doc": "        :param directory_search_record_type: a directory search record type\n        :type directory_search_record_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "        :return: the directory search results record\n        :rtype: ``osid.filing.records.DirectorySearchResultsRecord``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``directory_search_record_type`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unsupported`` -- ``has_record_type(directory_search_record_type)`` is ``false``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "directory_search_record_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "osid.filing.records.DirectorySearchResultsRecord", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.filing.records.DirectorySearchResultsRecord", 
         "shortname": "DirectorySearchResultsRecord", 
         "category": "records", 
         "doc": {
            "headline": "A record for a ``DirectorySearchResults``.", 
            "body": "    The methods specified by the record type are available through the\n    underlying object."
         }, 
         "inherit_fullnames": [
            "osid.OsidRecord"
         ], 
         "inherit_shortnames": [
            "OsidRecord"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidRecord"
            }
         ], 
         "method_names": [], 
         "methods": []
      }, 
      {
         "fullname": "osid.filing.DirectoryReceiver", 
         "shortname": "DirectoryReceiver", 
         "category": "receivers", 
         "doc": {
            "headline": "The directory receiver is the consumer supplied interface for receiving notifications pertaining to new, updated or deleted directories.", 
            "body": ""
         }, 
         "inherit_fullnames": [
            "osid.OsidReceiver"
         ], 
         "inherit_shortnames": [
            "OsidReceiver"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidReceiver"
            }
         ], 
         "method_names": [
            "new_directory", 
            "changed_directory", 
            "deleted_directory"
         ], 
         "methods": [
            {
               "name": "new_directory", 
               "doc": {
                  "headline": "The callback for notifications of new directories.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    directory_path (string): absolute pathname to the new\n                directory\n", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "        :param directory_path: absolute pathname to the new directory\n        :type directory_path: ``string``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "string", 
                     "var_name": "directory_path", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "string"
               ], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "changed_directory", 
               "doc": {
                  "headline": "The callback for notification of updated directories.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    directory_path (string): absolute pathname to the\n                changed directory\n", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "        :param directory_path: absolute pathname to the changed directory\n        :type directory_path: ``string``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "string", 
                     "var_name": "directory_path", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "string"
               ], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "deleted_directory", 
               "doc": {
                  "headline": "the callback for notification of deleted directories.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    directory_path (string): absolute pathname to the\n                deleted directory\n", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "        :param directory_path: absolute pathname to the deleted directory\n        :type directory_path: ``string``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "string", 
                     "var_name": "directory_path", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "string"
               ], 
               "return_type": "", 
               "errors": {}
            }
         ]
      }, 
      {
         "fullname": "osid.filing.DirectoryList", 
         "shortname": "DirectoryList", 
         "category": "objects", 
         "doc": {
            "headline": "Like all ``OsidLists,``  ``DirectoryList`` provides a means for accessing ``Directory`` elements sequentially either one at a time or many at a time.", 
            "body": "    Examples: while (dl.hasNext()) { Directory directory =\n    dl.getNextDirectory(); }\n\n    or\n      while (dl.hasNext()) {\n           Directory[] directories = dl.getNextDirectories(dl.available());\n      }\n    \n"
         }, 
         "inherit_fullnames": [
            "osid.OsidList"
         ], 
         "inherit_shortnames": [
            "OsidList"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidList"
            }
         ], 
         "method_names": [
            "get_next_directory", 
            "get_next_directories"
         ], 
         "methods": [
            {
               "name": "get_next_directory", 
               "doc": {
                  "headline": "Gets the next ``Directory`` in this list.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.filing.Directory) - the next ``Directory`` in this\n                list. The ``has_next()`` method should be used to test\n                that a next ``Dircectory`` is available before calling\n                this method.", 
               "error_doc": "        raise:  IllegalState - no more elements available in this list\n        raise:  OperationFailed - unable to complete request", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the next ``Directory`` in this list. The ``has_next()`` method should be used to test that a next ``Dircectory`` is available before calling this method.\n        :rtype: ``osid.filing.Directory``", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- no more elements available in this list\n        :raise: ``OperationFailed`` -- unable to complete request", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.filing.Directory", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational"
               }
            }, 
            {
               "name": "get_next_directories", 
               "doc": {
                  "headline": "Gets the next set of ``Directory`` elements in this list which must be less than or equal to the number returned from ``available()``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    n (cardinal): the number of ``Directory`` elements\n                requested which should be less than or equal to\n                ``available()``\n", 
               "return_doc": "        return: (osid.filing.Directory) - an array of ``Directory``\n                elements.The length of the array is less than or equal\n                to the number specified.", 
               "error_doc": "        raise:  IllegalState - no more elements available in this list\n        raise:  OperationFailed - unable to complete request", 
               "sphinx_param_doc": "        :param n: the number of ``Directory`` elements requested which should be less than or equal to ``available()``\n        :type n: ``cardinal``\n", 
               "sphinx_return_doc": "        :return: an array of ``Directory`` elements.The length of the array is less than or equal to the number specified.\n        :rtype: ``osid.filing.Directory``", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- no more elements available in this list\n        :raise: ``OperationFailed`` -- unable to complete request", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "cardinal", 
                     "var_name": "n", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "cardinal"
               ], 
               "return_type": "osid.filing.Directory", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational"
               }
            }
         ]
      }
   ], 
   "full_name": "osid.filing"
}
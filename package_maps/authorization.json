{
   "name": "authorization", 
   "version": "3.0.0", 
   "title": "Authorization Open Service Interface Definitions", 
   "copyright": "Copyright (c) 2002-2004, 2007-2008 Massachusetts Institute of\nTechnology.\n\nCopyright (c) 2009-2010 Ingenescus. All Rights Reserved.", 
   "license": "This Work is being provided by the copyright holder(s) subject to the\nfollowing license. By obtaining, using and/or copying this Work, you\nagree that you have read, understand, and will comply with the following\nterms and conditions.\n\nPermission to use, copy and distribute unmodified versions of this Work,\nfor any purpose, without fee or royalty is hereby granted, provided that\nyou include the above copyright notices and the terms of this license on\nALL copies of the Work or portions thereof.\n\nYou may modify or create Derivatives of this Work only for your internal\npurposes. You shall not distribute or transfer any such Derivative of\nthis Work to any location or to any third party. For the purposes of\nthis license, \"Derivative\" shall mean any derivative of the Work as\ndefined in the United States Copyright Act of 1976, such as a\ntranslation or modification.\n\nThis Work and the information contained herein is provided on an \"AS IS\"\nbasis WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT\nNOT LIMITED TO WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR\nPURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\nHOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN\nAN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\nCONNECTION WITH THE WORK OR THE USE OR OTHER DEALINGS IN THE WORK.\n\nThe export of software employing encryption technology may require a\nspecific license from the United States Government. It is the\nresponsibility of any person or organization contemplating export to\nobtain such a license before exporting this Work.", 
   "summary": "The Authorization OSID manages and queries authorizations.\n\nAuthorizations\n\nAn ``Authorization`` is an ``OsidRelationship`` that defines who can do\nwhat to what. The grammar of an authorization incluides the subject or\nthe actor (who), the action or verb (do what), and the object or context\n(to what). All three of these components must exist in an authorization\nfor it to have any explicit meaning. An ``Authorization`` is a mapping\namong these three components.\n\n  * ``Agent:`` the actor (eg: tom@coppeto.org)\n  * ``Function:`` the action (eg: create purchase order)\n  * ``Qualifier:`` the object or context within a Function (eg: on\n    account 1967)\n\n\nThis tuple in essence defines a role. \"Instructor\" is not a role and is\nnot suitable for making an authorization decision. \"Instructs Physics\n101\", both the function and qualifier, defines the complete role (within\nthe context of a particular college) that can be used for an\nauthorization decision.\n\nThe basic service of the Authorization OSID is to provide a means for\nasking whether a given ``Agent`` is authorized to perform a ``Function``\nwith a ``Qualifier,`` in other words, if such a mapping exists. The\nAgent will generally be obtained from an Authentication service and the\n``Function`` and ``Qualifier`` generally known to the consuming\napplication (a server process needing to protect some resource).\n\nExample\n  Authentication auth = authNValidationSession.authenticate(creds);\n  \n  AuthorizationSession session = authZManager.getAuthorizationSession();\n  boolean authorized = session.isAuthorized(auth.getAgentId(), functionId, qualifierId);\n\n\n\nThe rest of the Authorization OSID is concerned with managing\nauthorizations.\n\nExplicit/Implicit Authorizations\n\nAuthorizations can be explcit or implcit. Explicit authorizations are\nmanaged while implcit authorizations are derived from ``Resources,``\n``Function`` and ``Qualifier`` hierrachies. Examples of implcit\nauthorizations:\n\n  * The Authorization OSID can accept a ``Resource`` in lieu of an\n    ``Agent`` as the actor so a Person, Group or Organization may be\n    used to specify an authorization. In this case, the explicit\n    authorization is the one containing the ``Resource`` and an implicit\n    authorization exists for each ``Agent.``\n  * ``Qualifiers`` only exist as Hierarchy Nodes since the Authorization\n    OSID does not manage the objects used as qualifiers but may manage\n    directly, or have access to, a Hierarchy service to obtain the\n    identity and relationship among these objects. An explicit\n    authorization for a given ``Qualifier`` creates an implcit\n    authorization for every child of that ``Qualifier.``\n\n\nThe Authorization OSID manages ``Functions`` directly through its owned\ndefined sessions and exposes actors via the Resource OSID.\n``Qualifiers`` are only exposed through the Hierarchy service as the\nAuthorization service doesn't have anything to say about the objects\nrepresented by the ``Qualifiers``.\n\nVault Cataloging\n\n``Authorizations, Functions`` and ``Qualifiers`` may be organized into\none or many ``Vaults``. This serves to categorize authorizatiion data\nfor the purpose of browsing or auditing. ``Vaults`` are hierarchical\nwhere each node includes all the authorization data of its children. A\nsingle root node will make available all known authorizations and is a\nreasonable choice for a default ``Vault`` for a non-federated aware\nconsumer. A federated authorization scheme is one in which ``Vaults``\nare available for selection.\n\nNotifications\n\nCertain consumers may wish to be notified of changes within the service.\nAuthorization supports notifications via\n``AuthorizatioNotificationSession,``  ``FunctionNotificationSession``\nand ``VaultNotificationSession``.\n  if (manager.supportsAuthorizationNotification()) {\n      AuthorizationNotificationSession ans = manager.getAuthorizationNotificationSession(receiver);           \n      ans.registerForDeletedAuthorizations();\n  }\n  \n  AuthorizationReceiver receiver {\n      newAuthorization(Authorization a) {print(\"authorization created\");}\n      deletedAuthorization(Authorization a) {print(\"authorization removed\");}\n  }\n\n\n\nSub Packages\n\nThe Authorization OSID includes an Authorization Rules OSID for managing\nthe effectiveness of ``Authorizations``.", 
   "interfaces": [
      {
         "fullname": "osid.authorization.AuthorizationProfile", 
         "shortname": "AuthorizationProfile", 
         "category": "managers", 
         "doc": {
            "headline": "The ``AuthorizationProfile`` describes the interoperability among authorization services.", 
            "body": ""
         }, 
         "inherit_fullnames": [
            "osid.OsidProfile"
         ], 
         "inherit_shortnames": [
            "OsidProfile"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidProfile"
            }
         ], 
         "method_names": [
            "supports_visible_federation", 
            "supports_authorization", 
            "supports_authorization_lookup", 
            "supports_authorization_query", 
            "supports_authorization_search", 
            "supports_authorization_admin", 
            "supports_authorization_notification", 
            "supports_authorization_vault", 
            "supports_authorization_vault_assignment", 
            "supports_authorization_smart_vault", 
            "supports_function_lookup", 
            "supports_function_query", 
            "supports_function_search", 
            "supports_function_admin", 
            "supports_function_notification", 
            "supports_function_vault", 
            "supports_function_vault_assignment", 
            "supports_function_smart_vault", 
            "supports_qualifier_lookup", 
            "supports_qualifier_query", 
            "supports_qualifier_search", 
            "supports_qualifier_admin", 
            "supports_qualifier_notification", 
            "supports_qualifier_hierarchy", 
            "supports_qualifier_hierarchy_design", 
            "supports_qualifier_vault", 
            "supports_qualifier_vault_assignment", 
            "supports_qualifier_smart_vault", 
            "supports_vault_lookup", 
            "supports_vault_query", 
            "supports_vault_search", 
            "supports_vault_admin", 
            "supports_vault_notification", 
            "supports_vault_hierarchy", 
            "supports_vault_hierarchy_design", 
            "supports_authorizatin_batch", 
            "supports_authorizatin_rules", 
            "get_authorization_record_types", 
            "supports_authorization_record_type", 
            "get_authorization_search_record_types", 
            "supports_authorization_search_record_type", 
            "get_function_record_types", 
            "supports_function_record_type", 
            "get_function_search_record_types", 
            "supports_function_search_record_type", 
            "get_qualifier_record_types", 
            "supports_qualifier_record_type", 
            "get_qualifier_search_record_types", 
            "supports_qualifier_search_record_type", 
            "get_vault_record_types", 
            "supports_vault_record_type", 
            "get_vault_search_record_types", 
            "supports_vault_search_record_type", 
            "get_authorization_condition_record_types", 
            "supports_authorization_condition_record_type"
         ], 
         "methods": [
            {
               "name": "supports_visible_federation", 
               "doc": {
                  "headline": "Tests if federation is visible.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if visible federation is supported\n                ``,``  ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if visible federation is supported ``,``  ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "supports_authorization", 
               "doc": {
                  "headline": "Tests for the availability of an authorization service which is the basic service for checking authorizations.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if authorization is supported,\n                ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if authorization is supported, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "supports_authorization_lookup", 
               "doc": {
                  "headline": "Tests if an authorization lookup service is supported.", 
                  "body": "        An authorization lookup service defines methods to access\n        authorizations."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - true if authorization lookup is supported,\n                false otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: true if authorization lookup is supported, false otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "supports_authorization_query", 
               "doc": {
                  "headline": "Tests if an authorization query service is supported.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if authorization query is\n                supported, ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if authorization query is supported, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "supports_authorization_search", 
               "doc": {
                  "headline": "Tests if an authorization search service is supported.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if authorization search is\n                supported, ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if authorization search is supported, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "supports_authorization_admin", 
               "doc": {
                  "headline": "Tests if an authorization administrative service is supported.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if authorization admin is\n                supported, ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if authorization admin is supported, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "supports_authorization_notification", 
               "doc": {
                  "headline": "Tests if authorization notification is supported.", 
                  "body": "        Messages may be sent when authorizations are created, modified,\n        or deleted."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if authorization notification is\n                supported, ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if authorization notification is supported, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "supports_authorization_vault", 
               "doc": {
                  "headline": "Tests if an authorization to vault lookup session is available.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if authorization vault lookup\n                session is supported, ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if authorization vault lookup session is supported, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "supports_authorization_vault_assignment", 
               "doc": {
                  "headline": "Tests if an authorization to vault assignment session is available.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if authorization vault assignment\n                is supported, ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if authorization vault assignment is supported, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "supports_authorization_smart_vault", 
               "doc": {
                  "headline": "Tests if an authorization smart vaulting session is available.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if authorization smart vaulting is\n                supported, ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if authorization smart vaulting is supported, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "supports_function_lookup", 
               "doc": {
                  "headline": "Tests if a function lookup service is supported.", 
                  "body": "        A function lookup service defines methods to access\n        authorization functions."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if function lookup is supported,\n                ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if function lookup is supported, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "supports_function_query", 
               "doc": {
                  "headline": "Tests if a function query service is supported.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if function query is supported,\n                ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if function query is supported, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "supports_function_search", 
               "doc": {
                  "headline": "Tests if a function search service is supported.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if function search is supported,\n                ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if function search is supported, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "supports_function_admin", 
               "doc": {
                  "headline": "Tests if a function administrative service is supported.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if function admin is supported,\n                ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if function admin is supported, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "supports_function_notification", 
               "doc": {
                  "headline": "Tests if function notification is supported.", 
                  "body": "        Messages may be sent when functions are created, modified, or\n        deleted."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if function notification is\n                supported ``,``  ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if function notification is supported ``,``  ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "supports_function_vault", 
               "doc": {
                  "headline": "Tests if a function to vault lookup session is available.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if function vault lookup session is\n                supported, ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if function vault lookup session is supported, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "supports_function_vault_assignment", 
               "doc": {
                  "headline": "Tests if a function to vault assignment session is available.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if function vault assignment is\n                supported, ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if function vault assignment is supported, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "supports_function_smart_vault", 
               "doc": {
                  "headline": "Tests if a function smart vaulting session is available.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if function smart vaulting is\n                supported, ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if function smart vaulting is supported, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "supports_qualifier_lookup", 
               "doc": {
                  "headline": "Tests if a qualifier lookup service is supported.", 
                  "body": "        A function lookup service defines methods to access\n        authorization qualifiers."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if qualifier lookup is supported,\n                ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if qualifier lookup is supported, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "supports_qualifier_query", 
               "doc": {
                  "headline": "Tests if a qualifier query service is supported.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if qualifier query is supported,\n                ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if qualifier query is supported, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "supports_qualifier_search", 
               "doc": {
                  "headline": "Tests if a qualifier search service is supported.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if qualifier search is supported,\n                ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if qualifier search is supported, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "supports_qualifier_admin", 
               "doc": {
                  "headline": "Tests if a qualifier administrative service is supported.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if qualifier admin is supported,\n                ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if qualifier admin is supported, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "supports_qualifier_notification", 
               "doc": {
                  "headline": "Tests if qualifier notification is supported.", 
                  "body": "        Messages may be sent when qualifiers are created, modified, or\n        deleted."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if qualifier notification is\n                supported ``,``  ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if qualifier notification is supported ``,``  ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "supports_qualifier_hierarchy", 
               "doc": {
                  "headline": "Tests if a qualifier hierarchy traversal is supported.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if a qualifier hierarchy traversal\n                is supported, ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if a qualifier hierarchy traversal is supported, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "supports_qualifier_hierarchy_design", 
               "doc": {
                  "headline": "Tests if qualifier hierarchy design is supported.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if a qualifier hierarchy design is\n                supported, ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if a qualifier hierarchy design is supported, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "supports_qualifier_vault", 
               "doc": {
                  "headline": "Tests if a qualifier to vault lookup session is available.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if qualifier vault lookup session\n                is supported, ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if qualifier vault lookup session is supported, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "supports_qualifier_vault_assignment", 
               "doc": {
                  "headline": "Tests if a qualifier to vault assignment session is available.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if qualifier vault assignment is\n                supported, ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if qualifier vault assignment is supported, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "supports_qualifier_smart_vault", 
               "doc": {
                  "headline": "Tests if a qualifier smart vaulting session is available.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if qualifier smart vault session is\n                supported, ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if qualifier smart vault session is supported, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "supports_vault_lookup", 
               "doc": {
                  "headline": "Tests if a vault lookup service is supported.", 
                  "body": "        A vault lookup service defines methods to access authorization\n        vaults."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if function lookup is supported,\n                ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if function lookup is supported, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "supports_vault_query", 
               "doc": {
                  "headline": "Tests if a vault query service is supported.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if vault query is supported,\n                ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if vault query is supported, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "supports_vault_search", 
               "doc": {
                  "headline": "Tests if a vault search service is supported.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if vault search is supported,\n                ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if vault search is supported, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "supports_vault_admin", 
               "doc": {
                  "headline": "Tests if a vault administrative service is supported.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if vault admin is supported,\n                ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if vault admin is supported, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "supports_vault_notification", 
               "doc": {
                  "headline": "Tests if vault notification is supported.", 
                  "body": "        Messages may be sent when vaults are created, modified, or\n        deleted."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if vault notification is supported\n                ``,``  ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if vault notification is supported ``,``  ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "supports_vault_hierarchy", 
               "doc": {
                  "headline": "Tests if a vault hierarchy traversal is supported.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if a vault hierarchy traversal is\n                supported, ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if a vault hierarchy traversal is supported, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "supports_vault_hierarchy_design", 
               "doc": {
                  "headline": "Tests if vault hierarchy design is supported.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if a function hierarchy design is\n                supported, ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if a function hierarchy design is supported, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "supports_authorizatin_batch", 
               "doc": {
                  "headline": "Tests if an authorization batch service is supported.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if an authorization batch service\n                design is supported, ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if an authorization batch service design is supported, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "supports_authorizatin_rules", 
               "doc": {
                  "headline": "Tests if an authorization rules service is supported.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if an authorization rules service\n                design is supported, ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if an authorization rules service design is supported, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "get_authorization_record_types", 
               "doc": {
                  "headline": "Gets the supported ``Authorization`` record types.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.type.TypeList) - a list containing the supported\n                authorization record types", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: a list containing the supported authorization record types\n        :rtype: ``osid.type.TypeList``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.type.TypeList", 
               "errors": {}
            }, 
            {
               "name": "supports_authorization_record_type", 
               "doc": {
                  "headline": "Tests if the given authorization record type is supported.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    authorization_record_type (osid.type.Type): a ``Type``\n                indicating an authorization record type\n", 
               "return_doc": "        return: (boolean) - ``true`` if the given record Type is\n                supported, ``false`` otherwise", 
               "error_doc": "        raise:  NullArgument - ``authorization_record_type`` is ``null``", 
               "sphinx_param_doc": "        :param authorization_record_type: a ``Type`` indicating an authorization record type\n        :type authorization_record_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "        :return: ``true`` if the given record Type is supported, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``authorization_record_type`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "authorization_record_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "boolean", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "get_authorization_search_record_types", 
               "doc": {
                  "headline": "Gets the supported ``Authorization`` search record types.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.type.TypeList) - a list containing the supported\n                authorization search record types", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: a list containing the supported authorization search record types\n        :rtype: ``osid.type.TypeList``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.type.TypeList", 
               "errors": {}
            }, 
            {
               "name": "supports_authorization_search_record_type", 
               "doc": {
                  "headline": "Tests if the given authorization search record type is supported.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    authorization_search_record_type (osid.type.Type): a\n                ``Type`` indicating an authorization search record type\n", 
               "return_doc": "        return: (boolean) - ``true`` if the given search record Type is\n                supported, ``false`` otherwise", 
               "error_doc": "        raise:  NullArgument - ``authorization_search_record_type`` is\n                ``null``", 
               "sphinx_param_doc": "        :param authorization_search_record_type: a ``Type`` indicating an authorization search record type\n        :type authorization_search_record_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "        :return: ``true`` if the given search record Type is supported, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``authorization_search_record_type`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "authorization_search_record_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "boolean", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "get_function_record_types", 
               "doc": {
                  "headline": "Gets the supported ``Function`` record types.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.type.TypeList) - a list containing the supported\n                ``Function`` record types", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: a list containing the supported ``Function`` record types\n        :rtype: ``osid.type.TypeList``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.type.TypeList", 
               "errors": {}
            }, 
            {
               "name": "supports_function_record_type", 
               "doc": {
                  "headline": "Tests if the given ``Function`` record type is supported.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    function_record_type (osid.type.Type): a ``Type``\n                indicating a ``Function`` record type\n", 
               "return_doc": "        return: (boolean) - ``true`` if the given Type is supported,\n                ``false`` otherwise", 
               "error_doc": "        raise:  NullArgument - ``function_record_type`` is ``null``", 
               "sphinx_param_doc": "        :param function_record_type: a ``Type`` indicating a ``Function`` record type\n        :type function_record_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "        :return: ``true`` if the given Type is supported, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``function_record_type`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "function_record_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "boolean", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "get_function_search_record_types", 
               "doc": {
                  "headline": "Gets the supported ``Function`` search record types.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.type.TypeList) - a list containing the supported\n                ``Function`` search record types", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: a list containing the supported ``Function`` search record types\n        :rtype: ``osid.type.TypeList``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.type.TypeList", 
               "errors": {}
            }, 
            {
               "name": "supports_function_search_record_type", 
               "doc": {
                  "headline": "Tests if the given ``Function`` search record type is supported.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    function_search_record_type (osid.type.Type): a ``Type``\n                indicating a ``Function`` search record type\n", 
               "return_doc": "        return: (boolean) - ``true`` if the given Type is supported,\n                ``false`` otherwise", 
               "error_doc": "        raise:  NullArgument - ``function_search_record_type`` is\n                ``null``", 
               "sphinx_param_doc": "        :param function_search_record_type: a ``Type`` indicating a ``Function`` search record type\n        :type function_search_record_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "        :return: ``true`` if the given Type is supported, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``function_search_record_type`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "function_search_record_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "boolean", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "get_qualifier_record_types", 
               "doc": {
                  "headline": "Gets the supported ``Qualifier`` record types.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.type.TypeList) - a list containing the supported\n                ``Qualifier`` record types", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: a list containing the supported ``Qualifier`` record types\n        :rtype: ``osid.type.TypeList``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.type.TypeList", 
               "errors": {}
            }, 
            {
               "name": "supports_qualifier_record_type", 
               "doc": {
                  "headline": "Tests if the given ``Qualifier`` record type is supported.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    qualifier_record_type (osid.type.Type): a ``Type``\n                indicating a ``Qualifier`` record type\n", 
               "return_doc": "        return: (boolean) - ``true`` if the given Type is supported,\n                ``false`` otherwise", 
               "error_doc": "        raise:  NullArgument - ``qualifier_record_type`` is ``null``", 
               "sphinx_param_doc": "        :param qualifier_record_type: a ``Type`` indicating a ``Qualifier`` record type\n        :type qualifier_record_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "        :return: ``true`` if the given Type is supported, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``qualifier_record_type`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "qualifier_record_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "boolean", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "get_qualifier_search_record_types", 
               "doc": {
                  "headline": "Gets the supported ``Qualifier`` search record types.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.type.TypeList) - a list containing the supported\n                ``Qualifier`` search record types", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: a list containing the supported ``Qualifier`` search record types\n        :rtype: ``osid.type.TypeList``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.type.TypeList", 
               "errors": {}
            }, 
            {
               "name": "supports_qualifier_search_record_type", 
               "doc": {
                  "headline": "Tests if the given ``Qualifier`` search record type is supported.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    qualifier_search_record_type (osid.type.Type): a\n                ``Type`` indicating a ``Qualifier`` search record type\n", 
               "return_doc": "        return: (boolean) - ``true`` if the given Type is supported,\n                ``false`` otherwise", 
               "error_doc": "        raise:  NullArgument - ``qualifier_search_record_type`` is\n                ``null``", 
               "sphinx_param_doc": "        :param qualifier_search_record_type: a ``Type`` indicating a ``Qualifier`` search record type\n        :type qualifier_search_record_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "        :return: ``true`` if the given Type is supported, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``qualifier_search_record_type`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "qualifier_search_record_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "boolean", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "get_vault_record_types", 
               "doc": {
                  "headline": "Gets the supported ``Vault`` record types.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.type.TypeList) - a list containing the supported\n                ``Vault`` record types", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: a list containing the supported ``Vault`` record types\n        :rtype: ``osid.type.TypeList``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.type.TypeList", 
               "errors": {}
            }, 
            {
               "name": "supports_vault_record_type", 
               "doc": {
                  "headline": "Tests if the given ``Vault`` record type is supported.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    vault_record_type (osid.type.Type): a ``Type``\n                indicating a ``Vault`` type\n", 
               "return_doc": "        return: (boolean) - ``true`` if the given vault record ``Type``\n                is supported, ``false`` otherwise", 
               "error_doc": "        raise:  NullArgument - ``vault_record_type`` is ``null``", 
               "sphinx_param_doc": "        :param vault_record_type: a ``Type`` indicating a ``Vault`` type\n        :type vault_record_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "        :return: ``true`` if the given vault record ``Type`` is supported, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``vault_record_type`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "vault_record_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "boolean", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "get_vault_search_record_types", 
               "doc": {
                  "headline": "Gets the supported vault search record types.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.type.TypeList) - a list containing the supported\n                ``Vault`` search record types", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: a list containing the supported ``Vault`` search record types\n        :rtype: ``osid.type.TypeList``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.type.TypeList", 
               "errors": {}
            }, 
            {
               "name": "supports_vault_search_record_type", 
               "doc": {
                  "headline": "Tests if the given vault search record type is supported.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    vault_search_record_type (osid.type.Type): a ``Type``\n                indicating a ``Vault`` search record type\n", 
               "return_doc": "        return: (boolean) - ``true`` if the given search record ``Type``\n                is supported, ``false`` otherwise", 
               "error_doc": "        raise:  NullArgument - ``vault_search_record_type`` is ``null``", 
               "sphinx_param_doc": "        :param vault_search_record_type: a ``Type`` indicating a ``Vault`` search record type\n        :type vault_search_record_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "        :return: ``true`` if the given search record ``Type`` is supported, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``vault_search_record_type`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "vault_search_record_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "boolean", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "get_authorization_condition_record_types", 
               "doc": {
                  "headline": "Gets the supported ``AuthorizationCondition`` record types.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.type.TypeList) - a list containing the supported\n                ``AuthorizationCondition`` record types", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: a list containing the supported ``AuthorizationCondition`` record types\n        :rtype: ``osid.type.TypeList``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.type.TypeList", 
               "errors": {}
            }, 
            {
               "name": "supports_authorization_condition_record_type", 
               "doc": {
                  "headline": "Tests if the given ``AuthorizationCondition`` record type is supported.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    authorization_condition_record_type (osid.type.Type): a\n                ``Type`` indicating an ``AuthorizationCondition`` record\n                type\n", 
               "return_doc": "        return: (boolean) - ``true`` if the given authorization\n                condition record ``Type`` is supported, ``false``\n                otherwise", 
               "error_doc": "        raise:  NullArgument - ``authorization_condition_record_type``\n                is ``null``", 
               "sphinx_param_doc": "        :param authorization_condition_record_type: a ``Type`` indicating an ``AuthorizationCondition`` record type\n        :type authorization_condition_record_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "        :return: ``true`` if the given authorization condition record ``Type`` is supported, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``authorization_condition_record_type`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "authorization_condition_record_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "boolean", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.authorization.AuthorizationManager", 
         "shortname": "AuthorizationManager", 
         "category": "managers", 
         "doc": {
            "headline": "The authorization manager provides access to authorization sessions and provides interoperability tests for various aspects of this service.", 
            "body": "    The sessions included in this manager are:\n\n      * ``AuthorizationSession:`` a session to performs authorization\n        checks\n      * ``AuthorizationLookupSession:`` a session to look up\n        ``Authorizations``\n      * ``AuthorizationQuerySession:`` a session to query\n        ``Authorizations``\n      * ``AuthorizationSearchSession:`` a session to search\n        ``Authorizations``\n      * ``AuthorizationAdminSession:`` a session to create, modify and\n        delete ``Authorizations``\n      * ``AuthorizationNotificationSession: a`` session to receive\n        messages pertaining to ``Authorization`` changes\n      * ``AuthorizationVaultSession:`` a session to look up\n        authorization to vault mappings\n      * ``AuthorizationVaultAssignmentSession:`` a session to manage\n        authorization to vault mappings\n      * ``AuthorizationSmartVaultSession:`` a session to manage smart\n        authorization vaults\n    \n      * ``FunctionLookupSession:`` a session to look up ``Functions``\n      * ``FunctionQuerySession:`` a session to query ``Functions``\n      * ``FunctionSearchSession:`` a session to search ``Functions``\n      * ``FunctionAdminSession:`` a session to create, modify and delete\n        ``Functions``\n      * ``FunctionNotificationSession: a`` session to receive messages\n        pertaining to ``Function`` changes\n      * ``FunctionVaultSession:`` a session for looking up function and\n        vault mappings\n      * ``FunctionVaultAssignmentSession:`` a session for managing\n        function and vault mappings\n      * ``FunctionSmartVaultSession:`` a session to manage dynamic\n        function vaults\n    \n      * ``QualifierLookupSession:`` a session to look up ``Qualifiers``\n      * ``QualifierQuerySession:`` a session to query ``Qualifiers``\n      * ``QualifierSearchSession:`` a session to search ``Qualifiers``\n      * ``QualifierAdminSession:`` a session to create, modify and\n        delete ``Qualifiers``\n      * ``QualifierNotificationSession: a`` session to receive messages\n        pertaining to ``Qualifier`` changes\n      * ``QualifierHierarchySession:`` a session for traversing\n        qualifier hierarchies\n      * ``QualifierHierarchyDesignSession:`` a session for managing\n        qualifier hierarchies\n      * ``QualifierVaultSession:`` a session for looking up qualifier\n        and vault mappings\n      * ``QualifierVaultAssignmentSession:`` a session for managing\n        qualifier and vault mappings\n      * ``QualifierSmartVaultSession:`` a session to manage dynamic\n        qualifier vaults\n    \n      * ``VaultLookupSession:`` a session to lookup vaults\n      * ``VaultQuerySession:`` a session to query Vaults\n      * ``VaultSearchSession`` : a session to search vaults\n      * ``VaultAdminSession`` : a session to create, modify and delete\n        vaults\n      * ``VaultNotificationSession`` : a session to receive messages\n        pertaining to ``Vault`` changes\n      * ``VaultHierarchySession`` : a session to traverse the ``Vault``\n        hierarchy\n      * ``VaultHierarchyDesignSession`` : a session to manage the\n        ``Vault`` hierarchy\n"
         }, 
         "inherit_fullnames": [
            "osid.OsidManager", 
            "osid.authorization.AuthorizationProfile"
         ], 
         "inherit_shortnames": [
            "OsidManager", 
            "AuthorizationProfile"
         ], 
         "inherit_pkg_names": [
            "osid", 
            "authorization"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidManager"
            }, 
            {
               "pkg_name": "authorization", 
               "name": "AuthorizationProfile"
            }
         ], 
         "method_names": [
            "get_authorization_session", 
            "get_authorization_session_for_vault", 
            "get_authorization_lookup_session", 
            "get_authorization_lookup_session_for_vault", 
            "get_authorization_query_session", 
            "get_authorization_query_session_for_vault", 
            "get_authorization_search_session", 
            "get_authorization_search_session_for_vault", 
            "get_authorization_admin_session", 
            "get_authorization_admin_session_for_vault", 
            "get_authorization_notification_session", 
            "get_authorization_notification_session_for_vault", 
            "get_authorization_vault_session", 
            "get_authorization_vault_assignment_session", 
            "get_authorization_smart_vault_session", 
            "get_function_lookup_session", 
            "get_function_lookup_session_for_vault", 
            "get_function_query_session", 
            "get_function_query_session_for_vault", 
            "get_function_search_session", 
            "get_function_search_session_for_vault", 
            "get_function_admin_session", 
            "get_function_admin_session_for_vault", 
            "get_function_notification_session", 
            "get_function_notification_session_for_vault", 
            "get_function_vault_session", 
            "get_function_vault_assignment_session", 
            "get_function_smart_vault_session", 
            "get_qualifier_lookup_session", 
            "get_qualifier_lookup_session_for_vault", 
            "get_qualifier_query_session", 
            "get_qualifier_query_session_for_vault", 
            "get_qualifier_search_session", 
            "get_qualifier_search_session_for_vault", 
            "get_qualifier_admin_session", 
            "get_qualifier_admin_session_for_vault", 
            "get_qualifier_notification_session", 
            "get_qualifier_notification_session_for_vault", 
            "get_qualifier_hierarchy_session", 
            "get_qualifier_hierarchy_design_session", 
            "get_qualifier_vault_session", 
            "get_qualifier_vault_assignment_session", 
            "get_qualifier_smart_vault_session", 
            "get_vault_lookup_session", 
            "get_vault_query_session", 
            "get_vault_search_session", 
            "get_vault_admin_session", 
            "get_vault_notification_session", 
            "get_vault_hierarchy_session", 
            "get_vault_hierarchy_design_session", 
            "get_authorization_batch_manager", 
            "get_authorization_rules_manager"
         ], 
         "methods": [
            {
               "name": "get_authorization_session", 
               "doc": {
                  "headline": "Gets an ``AuthorizationSession`` which is responsible for performing authorization checks.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.authorization.AuthorizationSession) - an\n                authorization session for this service", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_authorization()`` is\n                ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: an authorization session for this service\n        :rtype: ``osid.authorization.AuthorizationSession``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_authorization()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_authorization()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.authorization.AuthorizationSession", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_authorization_session_for_vault", 
               "doc": {
                  "headline": "Gets an ``AuthorizationSession`` which is responsible for performing authorization checks for the given vault.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    vault_id (osid.id.Id): the ``Id`` of the vault\n", 
               "return_doc": "        return: (osid.authorization.AuthorizationSession) - ``an\n                _authorization_session``", 
               "error_doc": "        raise:  NotFound - ``vault_id``\n        raise:  NullArgument - ``vault_id`` is ``null``\n        raise:  OperationFailed - ``unable to complete request``\n        raise:  Unimplemented - ``supports_authorization()`` or\n                ``supports_visible_federation()`` is ``false``", 
               "sphinx_param_doc": "        :param vault_id: the ``Id`` of the vault\n        :type vault_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: ``an _authorization_session``\n        :rtype: ``osid.authorization.AuthorizationSession``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``vault_id``\n        :raise: ``NullArgument`` -- ``vault_id`` is ``null``\n        :raise: ``OperationFailed`` -- ``unable to complete request``\n        :raise: ``Unimplemented`` -- ``supports_authorization()`` or ``supports_visible_federation()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_authorization()`` and ``supports_visible_federation()`` are ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "vault_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "osid.authorization.AuthorizationSession", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_authorization_lookup_session", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` associated with the authorization lookup service.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.authorization.AuthorizationLookupSession) - an\n                ``AuthorizationLookupSession``", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_authorization_lookup()`` is\n                ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: an ``AuthorizationLookupSession``\n        :rtype: ``osid.authorization.AuthorizationLookupSession``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_authorization_lookup()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_authorization_lookup()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.authorization.AuthorizationLookupSession", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_authorization_lookup_session_for_vault", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` associated with the authorization lookup service for the given vault.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    vault_id (osid.id.Id): the ``Id`` of the vault\n", 
               "return_doc": "        return: (osid.authorization.AuthorizationLookupSession) - ``an\n                _authorization_lookup_session``", 
               "error_doc": "        raise:  NotFound - ``vault_id`` not found\n        raise:  NullArgument - ``vault_id`` is ``null``\n        raise:  OperationFailed - ``unable to complete request``\n        raise:  Unimplemented - ``supports_authorization_lookup()`` or\n                ``supports_visible_federation()`` is ``false``", 
               "sphinx_param_doc": "        :param vault_id: the ``Id`` of the vault\n        :type vault_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: ``an _authorization_lookup_session``\n        :rtype: ``osid.authorization.AuthorizationLookupSession``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``vault_id`` not found\n        :raise: ``NullArgument`` -- ``vault_id`` is ``null``\n        :raise: ``OperationFailed`` -- ``unable to complete request``\n        :raise: ``Unimplemented`` -- ``supports_authorization_lookup()`` or ``supports_visible_federation()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_authorization_lookup()`` and ``supports_visible_federation()`` are ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "vault_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "osid.authorization.AuthorizationLookupSession", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_authorization_query_session", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` associated with the authorization query service.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.authorization.AuthorizationQuerySession) - an\n                ``AuthorizationQuerySession``", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_authorization_query()`` is\n                ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: an ``AuthorizationQuerySession``\n        :rtype: ``osid.authorization.AuthorizationQuerySession``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_authorization_query()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_authorization_query()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.authorization.AuthorizationQuerySession", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_authorization_query_session_for_vault", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` associated with the authorization query service for the given vault.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    vault_id (osid.id.Id): the ``Id`` of the vault\n", 
               "return_doc": "        return: (osid.authorization.AuthorizationQuerySession) - ``an\n                _authorization_query_session``", 
               "error_doc": "        raise:  NotFound - ``vault_id`` not found\n        raise:  NullArgument - ``vault_id`` is ``null``\n        raise:  OperationFailed - ``unable to complete request``\n        raise:  Unimplemented - ``supports_authorization_query()`` or\n                ``supports_visible_federation()`` is ``false``", 
               "sphinx_param_doc": "        :param vault_id: the ``Id`` of the vault\n        :type vault_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: ``an _authorization_query_session``\n        :rtype: ``osid.authorization.AuthorizationQuerySession``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``vault_id`` not found\n        :raise: ``NullArgument`` -- ``vault_id`` is ``null``\n        :raise: ``OperationFailed`` -- ``unable to complete request``\n        :raise: ``Unimplemented`` -- ``supports_authorization_query()`` or ``supports_visible_federation()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_authorization_query()`` and ``supports_visible_federation()`` are ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "vault_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "osid.authorization.AuthorizationQuerySession", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_authorization_search_session", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` associated with the authorization search service.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.authorization.AuthorizationSearchSession) - an\n                ``AuthorizationSearchSession``", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_authorization_search()`` is\n                ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: an ``AuthorizationSearchSession``\n        :rtype: ``osid.authorization.AuthorizationSearchSession``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_authorization_search()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_authorization_search()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.authorization.AuthorizationSearchSession", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_authorization_search_session_for_vault", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` associated with the authorization search service for the given vault.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    vault_id (osid.id.Id): the ``Id`` of the vault\n", 
               "return_doc": "        return: (osid.authorization.AuthorizationSearchSession) - ``an\n                _authorization_search_session``", 
               "error_doc": "        raise:  NotFound - ``vault_id`` not found\n        raise:  NullArgument - ``vault_id`` is ``null``\n        raise:  OperationFailed - ``unable to complete request``\n        raise:  Unimplemented - ``supports_authorization_search()`` or\n                ``supports_visible_federation()`` is ``false``", 
               "sphinx_param_doc": "        :param vault_id: the ``Id`` of the vault\n        :type vault_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: ``an _authorization_search_session``\n        :rtype: ``osid.authorization.AuthorizationSearchSession``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``vault_id`` not found\n        :raise: ``NullArgument`` -- ``vault_id`` is ``null``\n        :raise: ``OperationFailed`` -- ``unable to complete request``\n        :raise: ``Unimplemented`` -- ``supports_authorization_search()`` or ``supports_visible_federation()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_authorization_search()`` and ``supports_visible_federation()`` are ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "vault_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "osid.authorization.AuthorizationSearchSession", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_authorization_admin_session", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` associated with the authorization administration service.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.authorization.AuthorizationAdminSession) - an\n                ``AuthorizationAdminSession``", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_authorization_admin()`` is\n                ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: an ``AuthorizationAdminSession``\n        :rtype: ``osid.authorization.AuthorizationAdminSession``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_authorization_admin()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_authorization_admin()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.authorization.AuthorizationAdminSession", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_authorization_admin_session_for_vault", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` associated with the authorization admin service for the given vault.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    vault_id (osid.id.Id): the ``Id`` of the vault\n", 
               "return_doc": "        return: (osid.authorization.AuthorizationAdminSession) - ``an\n                _authorization_admin_session``", 
               "error_doc": "        raise:  NotFound - ``vault_id`` not found\n        raise:  NullArgument - ``vault_id`` is ``null``\n        raise:  OperationFailed - ``unable to complete request``\n        raise:  Unimplemented - ``supports_authorization_admin()`` or\n                ``supports_visible_federation()`` is ``false``", 
               "sphinx_param_doc": "        :param vault_id: the ``Id`` of the vault\n        :type vault_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: ``an _authorization_admin_session``\n        :rtype: ``osid.authorization.AuthorizationAdminSession``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``vault_id`` not found\n        :raise: ``NullArgument`` -- ``vault_id`` is ``null``\n        :raise: ``OperationFailed`` -- ``unable to complete request``\n        :raise: ``Unimplemented`` -- ``supports_authorization_admin()`` or ``supports_visible_federation()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_authorization_admin()`` and ``supports_visible_federation()`` are ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "vault_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "osid.authorization.AuthorizationAdminSession", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_authorization_notification_session", 
               "doc": {
                  "headline": "Gets the notification session for notifications pertaining to authorization changes.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    authorization_receiver\n                (osid.authorization.AuthorizationReceiver): the\n                authorization receiver\n", 
               "return_doc": "        return: (osid.authorization.AuthorizationNotificationSession) -\n                an ``AuthorizationNotificationSession``", 
               "error_doc": "        raise:  NullArgument - ``authorization_receiver`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented -\n                ``supports_authorization_notification()`` is ``false``", 
               "sphinx_param_doc": "        :param authorization_receiver: the authorization receiver\n        :type authorization_receiver: ``osid.authorization.AuthorizationReceiver``\n", 
               "sphinx_return_doc": "        :return: an ``AuthorizationNotificationSession``\n        :rtype: ``osid.authorization.AuthorizationNotificationSession``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``authorization_receiver`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_authorization_notification()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_authorization_notification()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.authorization.AuthorizationReceiver", 
                     "var_name": "authorization_receiver", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.authorization.AuthorizationReceiver"
               ], 
               "return_type": "osid.authorization.AuthorizationNotificationSession", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_authorization_notification_session_for_vault", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` associated with the authorization notification service for the given vault.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    authorization_receiver\n                (osid.authorization.AuthorizationReceiver): the\n                authorization receiver\n        arg:    vault_id (osid.id.Id): the ``Id`` of the vault\n", 
               "return_doc": "        return: (osid.authorization.AuthorizationNotificationSession) -\n                ``an _authorization_notification_session``", 
               "error_doc": "        raise:  NotFound - ``vault_id`` not found\n        raise:  NullArgument - ``authorization_receiver`` or\n                ``vault_id`` is ``null``\n        raise:  OperationFailed - ``unable to complete request``\n        raise:  Unimplemented -\n                ``supports_authorization_notification()`` or\n                ``supports_visible_federation()`` is ``false``", 
               "sphinx_param_doc": "        :param authorization_receiver: the authorization receiver\n        :type authorization_receiver: ``osid.authorization.AuthorizationReceiver``\n        :param vault_id: the ``Id`` of the vault\n        :type vault_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: ``an _authorization_notification_session``\n        :rtype: ``osid.authorization.AuthorizationNotificationSession``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``vault_id`` not found\n        :raise: ``NullArgument`` -- ``authorization_receiver`` or ``vault_id`` is ``null``\n        :raise: ``OperationFailed`` -- ``unable to complete request``\n        :raise: ``Unimplemented`` -- ``supports_authorization_notification()`` or ``supports_visible_federation()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_authorization_notification()`` and ``supports_visible_federation()`` are ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.authorization.AuthorizationReceiver", 
                     "var_name": "authorization_receiver", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "vault_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.authorization.AuthorizationReceiver", 
                  "osid.id.Id"
               ], 
               "return_type": "osid.authorization.AuthorizationNotificationSession", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_authorization_vault_session", 
               "doc": {
                  "headline": "Gets the session for retrieving authorization to vault mappings.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.authorization.AuthorizationVaultSession) - an\n                ``AuthorizationVaultSession``", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_authorization_vault()`` is\n                ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: an ``AuthorizationVaultSession``\n        :rtype: ``osid.authorization.AuthorizationVaultSession``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_authorization_vault()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_authorization_vault()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.authorization.AuthorizationVaultSession", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_authorization_vault_assignment_session", 
               "doc": {
                  "headline": "Gets the session for assigning authorizations to vault mappings.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.authorization.AuthorizationVaultAssignmentSession)\n                - a ``AuthorizationVaultAssignmentSession``", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented -\n                ``supports_authorization_vault_assignment()`` is\n                ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: a ``AuthorizationVaultAssignmentSession``\n        :rtype: ``osid.authorization.AuthorizationVaultAssignmentSession``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_authorization_vault_assignment()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_authorization_vault_assignment()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.authorization.AuthorizationVaultAssignmentSession", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_authorization_smart_vault_session", 
               "doc": {
                  "headline": "Gets the session for managing dynamic authorization vaults.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    vault_id (osid.id.Id): the ``Id`` of the vault\n", 
               "return_doc": "        return: (osid.authorization.AuthorizationSmartVaultSession) - a\n                ``AuthorizationSmartVaultSession``", 
               "error_doc": "        raise:  NotFound - ``vault_id`` not found\n        raise:  NullArgument - ``vault_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_authorization_smart_vault()``\n                is ``false``", 
               "sphinx_param_doc": "        :param vault_id: the ``Id`` of the vault\n        :type vault_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: a ``AuthorizationSmartVaultSession``\n        :rtype: ``osid.authorization.AuthorizationSmartVaultSession``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``vault_id`` not found\n        :raise: ``NullArgument`` -- ``vault_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_authorization_smart_vault()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_authorization_smart_vault()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "vault_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "osid.authorization.AuthorizationSmartVaultSession", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_function_lookup_session", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` associated with the function lookup service.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.authorization.FunctionLookupSession) - a\n                ``FunctionLookupSession``", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_function_lookup()`` is\n                ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: a ``FunctionLookupSession``\n        :rtype: ``osid.authorization.FunctionLookupSession``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_function_lookup()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_function_lookup()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.authorization.FunctionLookupSession", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_function_lookup_session_for_vault", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` associated with the function lookup service for the given vault.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    vault_id (osid.id.Id): the ``Id`` of the vault\n", 
               "return_doc": "        return: (osid.authorization.FunctionLookupSession) - ``a\n                FunctionLookupSession``", 
               "error_doc": "        raise:  NotFound - ``vault_id`` not found\n        raise:  NullArgument - ``vault_id`` is ``null``\n        raise:  OperationFailed - ``unable to complete request``\n        raise:  Unimplemented - ``supports_function_lookup()`` or\n                ``supports_visible_federation()`` is ``false``", 
               "sphinx_param_doc": "        :param vault_id: the ``Id`` of the vault\n        :type vault_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: ``a FunctionLookupSession``\n        :rtype: ``osid.authorization.FunctionLookupSession``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``vault_id`` not found\n        :raise: ``NullArgument`` -- ``vault_id`` is ``null``\n        :raise: ``OperationFailed`` -- ``unable to complete request``\n        :raise: ``Unimplemented`` -- ``supports_function_lookup()`` or ``supports_visible_federation()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_function_lookup()`` and ``supports_visible_federation()`` are ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "vault_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "osid.authorization.FunctionLookupSession", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_function_query_session", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` associated with the function query service.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.authorization.FunctionQuerySession) - a\n                ``FunctionQuerySession``", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_function_query()`` is\n                ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: a ``FunctionQuerySession``\n        :rtype: ``osid.authorization.FunctionQuerySession``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_function_query()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_function_query()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.authorization.FunctionQuerySession", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_function_query_session_for_vault", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` associated with the function query service for the given vault.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    vault_id (osid.id.Id): the ``Id`` of the vault\n", 
               "return_doc": "        return: (osid.authorization.FunctionQuerySession) - a\n                ``FunctionQuerySession``", 
               "error_doc": "        raise:  NotFound - ``vault_id`` not found\n        raise:  NullArgument - ``vault_id`` is ``null``\n        raise:  OperationFailed - ``unable to complete request``\n        raise:  Unimplemented - ``supports_function_query()`` or\n                ``supports_visible_federation()`` is ``false``", 
               "sphinx_param_doc": "        :param vault_id: the ``Id`` of the vault\n        :type vault_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: a ``FunctionQuerySession``\n        :rtype: ``osid.authorization.FunctionQuerySession``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``vault_id`` not found\n        :raise: ``NullArgument`` -- ``vault_id`` is ``null``\n        :raise: ``OperationFailed`` -- ``unable to complete request``\n        :raise: ``Unimplemented`` -- ``supports_function_query()`` or ``supports_visible_federation()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_function_query()`` and ``supports_visible_federation()`` are ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "vault_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "osid.authorization.FunctionQuerySession", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_function_search_session", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` associated with the function search service.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.authorization.FunctionSearchSession) - a\n                ``FunctionSearchSession``", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_function_search()`` is\n                ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: a ``FunctionSearchSession``\n        :rtype: ``osid.authorization.FunctionSearchSession``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_function_search()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_function_search()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.authorization.FunctionSearchSession", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_function_search_session_for_vault", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` associated with the function search service for the given vault.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    vault_id (osid.id.Id): the ``Id`` of the vault\n", 
               "return_doc": "        return: (osid.authorization.FunctionSearchSession) - a\n                ``FunctionSearchSession``", 
               "error_doc": "        raise:  NotFound - ``vault_id`` not found\n        raise:  NullArgument - ``vault_id`` is ``null``\n        raise:  OperationFailed - ``unable to complete request``\n        raise:  Unimplemented - ``supports_function_search()`` or\n                ``supports_visible_federation()`` is ``false``", 
               "sphinx_param_doc": "        :param vault_id: the ``Id`` of the vault\n        :type vault_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: a ``FunctionSearchSession``\n        :rtype: ``osid.authorization.FunctionSearchSession``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``vault_id`` not found\n        :raise: ``NullArgument`` -- ``vault_id`` is ``null``\n        :raise: ``OperationFailed`` -- ``unable to complete request``\n        :raise: ``Unimplemented`` -- ``supports_function_search()`` or ``supports_visible_federation()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_function_search()`` and ``supports_visible_federation()`` are ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "vault_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "osid.authorization.FunctionSearchSession", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_function_admin_session", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` associated with the function administration service.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.authorization.FunctionAdminSession) - a\n                ``FunctionAdminSession``", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_function_admin()`` is\n                ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: a ``FunctionAdminSession``\n        :rtype: ``osid.authorization.FunctionAdminSession``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_function_admin()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_function_admin()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.authorization.FunctionAdminSession", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_function_admin_session_for_vault", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` associated with the function admin service for the given vault.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    vault_id (osid.id.Id): the ``Id`` of the vault\n", 
               "return_doc": "        return: (osid.authorization.FunctionAdminSession) - ``a\n                FunctionAdminSession``", 
               "error_doc": "        raise:  NotFound - ``vault_id`` not found\n        raise:  NullArgument - ``vault_id`` is ``null``\n        raise:  OperationFailed - ``unable to complete request``\n        raise:  Unimplemented - ``supports_function_admin()`` or\n                ``supports_visible_federation()`` is ``false``", 
               "sphinx_param_doc": "        :param vault_id: the ``Id`` of the vault\n        :type vault_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: ``a FunctionAdminSession``\n        :rtype: ``osid.authorization.FunctionAdminSession``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``vault_id`` not found\n        :raise: ``NullArgument`` -- ``vault_id`` is ``null``\n        :raise: ``OperationFailed`` -- ``unable to complete request``\n        :raise: ``Unimplemented`` -- ``supports_function_admin()`` or ``supports_visible_federation()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_function_admin()`` and ``supports_visible_federation()`` are ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "vault_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "osid.authorization.FunctionAdminSession", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_function_notification_session", 
               "doc": {
                  "headline": "Gets the notification session for notifications pertaining to function changes.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    function_receiver (osid.authorization.FunctionReceiver):\n                the function receiver\n", 
               "return_doc": "        return: (osid.authorization.FunctionNotificationSession) - a\n                ``FunctionNotificationSession``", 
               "error_doc": "        raise:  NullArgument - ``function_receiver`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_function_notification()`` is\n                ``false``", 
               "sphinx_param_doc": "        :param function_receiver: the function receiver\n        :type function_receiver: ``osid.authorization.FunctionReceiver``\n", 
               "sphinx_return_doc": "        :return: a ``FunctionNotificationSession``\n        :rtype: ``osid.authorization.FunctionNotificationSession``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``function_receiver`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_function_notification()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_function_notification()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.authorization.FunctionReceiver", 
                     "var_name": "function_receiver", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.authorization.FunctionReceiver"
               ], 
               "return_type": "osid.authorization.FunctionNotificationSession", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_function_notification_session_for_vault", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` associated with the function notification service for the given vault.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    function_receiver (osid.authorization.FunctionReceiver):\n                the function receiver\n        arg:    vault_id (osid.id.Id): the ``Id`` of the vault\n", 
               "return_doc": "        return: (osid.authorization.FunctionNotificationSession) - ``a\n                FunctionNotificationSession``", 
               "error_doc": "        raise:  NotFound - ``vault_id`` not found\n        raise:  NullArgument - ``function_receiver`` or ``vault_id`` is\n                ``null``\n        raise:  OperationFailed - ``unable to complete request``\n        raise:  Unimplemented - ``supports_function_notification()`` or\n                ``supports_visible_federation()`` is ``false``", 
               "sphinx_param_doc": "        :param function_receiver: the function receiver\n        :type function_receiver: ``osid.authorization.FunctionReceiver``\n        :param vault_id: the ``Id`` of the vault\n        :type vault_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: ``a FunctionNotificationSession``\n        :rtype: ``osid.authorization.FunctionNotificationSession``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``vault_id`` not found\n        :raise: ``NullArgument`` -- ``function_receiver`` or ``vault_id`` is ``null``\n        :raise: ``OperationFailed`` -- ``unable to complete request``\n        :raise: ``Unimplemented`` -- ``supports_function_notification()`` or ``supports_visible_federation()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_function_notification()`` and ``supports_visible_federation()`` are ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.authorization.FunctionReceiver", 
                     "var_name": "function_receiver", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "vault_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.authorization.FunctionReceiver", 
                  "osid.id.Id"
               ], 
               "return_type": "osid.authorization.FunctionNotificationSession", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_function_vault_session", 
               "doc": {
                  "headline": "Gets the session for retrieving function to vault mappings.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.authorization.FunctionVaultSession) - a\n                ``FunctionVaultSession``", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_function_vault()`` is\n                ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: a ``FunctionVaultSession``\n        :rtype: ``osid.authorization.FunctionVaultSession``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_function_vault()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_function_vault()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.authorization.FunctionVaultSession", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_function_vault_assignment_session", 
               "doc": {
                  "headline": "Gets the session for assigning function to vault mappings.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.authorization.FunctionVaultAssignmentSession) - a\n                ``FunctionVaultAssignmentSession``", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_function_vault_assignment()``\n                is ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: a ``FunctionVaultAssignmentSession``\n        :rtype: ``osid.authorization.FunctionVaultAssignmentSession``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_function_vault_assignment()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_function_vault_assignment()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.authorization.FunctionVaultAssignmentSession", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_function_smart_vault_session", 
               "doc": {
                  "headline": "Gets the session associated with the function smart vault for the given vault.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    vault_id (osid.id.Id): the ``Id`` of the vault\n", 
               "return_doc": "        return: (osid.authorization.FunctionSmartVaultSession) - a\n                ``FunctionSmartVaultSession``", 
               "error_doc": "        raise:  NotFound - ``vault_id`` not found\n        raise:  NullArgument - ``vault_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_function_smart_vault()`` is\n                ``false``", 
               "sphinx_param_doc": "        :param vault_id: the ``Id`` of the vault\n        :type vault_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: a ``FunctionSmartVaultSession``\n        :rtype: ``osid.authorization.FunctionSmartVaultSession``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``vault_id`` not found\n        :raise: ``NullArgument`` -- ``vault_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_function_smart_vault()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_function_smart_vault()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "vault_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "osid.authorization.FunctionSmartVaultSession", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_qualifier_lookup_session", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` associated with the qualifier lookup service.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.authorization.QualifierLookupSession) - a\n                ``QualifierLookupSession``", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_qualifier_lookup()`` is\n                ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: a ``QualifierLookupSession``\n        :rtype: ``osid.authorization.QualifierLookupSession``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_qualifier_lookup()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_qualifier_lookup()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.authorization.QualifierLookupSession", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_qualifier_lookup_session_for_vault", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` associated with the qualifier lookup service for the given vault.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    vault_id (osid.id.Id): the ``Id`` of the vault\n", 
               "return_doc": "        return: (osid.authorization.QualifierLookupSession) - a\n                ``QualifierLookupSession``", 
               "error_doc": "        raise:  NotFound - ``vault_id`` not found\n        raise:  NullArgument - ``vault_id`` is ``null``\n        raise:  OperationFailed - ``unable to complete request``\n        raise:  Unimplemented - ``supports_qualifier_lookup()`` or\n                ``supports_visible_federation()`` is ``false``", 
               "sphinx_param_doc": "        :param vault_id: the ``Id`` of the vault\n        :type vault_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: a ``QualifierLookupSession``\n        :rtype: ``osid.authorization.QualifierLookupSession``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``vault_id`` not found\n        :raise: ``NullArgument`` -- ``vault_id`` is ``null``\n        :raise: ``OperationFailed`` -- ``unable to complete request``\n        :raise: ``Unimplemented`` -- ``supports_qualifier_lookup()`` or ``supports_visible_federation()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_qualifier_lookup()`` and ``supports_visible_federation()`` are ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "vault_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "osid.authorization.QualifierLookupSession", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_qualifier_query_session", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` associated with the qualifier query service.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.authorization.QualifierQuerySession) - a\n                ``QualifierQuerySession``", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_qualifier_query()`` is\n                ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: a ``QualifierQuerySession``\n        :rtype: ``osid.authorization.QualifierQuerySession``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_qualifier_query()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_qualifier_query()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.authorization.QualifierQuerySession", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_qualifier_query_session_for_vault", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` associated with the qualifier query service for the given vault.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    vault_id (osid.id.Id): the ``Id`` of the vault\n", 
               "return_doc": "        return: (osid.authorization.QualifierQuerySession) - a\n                ``QualifierQuerySession``", 
               "error_doc": "        raise:  NotFound - ``vault_id`` not found\n        raise:  NullArgument - ``vault_id`` is ``null``\n        raise:  OperationFailed - ``unable to complete request``\n        raise:  Unimplemented - ``supports_qualifier_query()`` or\n                ``supports_visible_federation()`` is ``false``", 
               "sphinx_param_doc": "        :param vault_id: the ``Id`` of the vault\n        :type vault_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: a ``QualifierQuerySession``\n        :rtype: ``osid.authorization.QualifierQuerySession``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``vault_id`` not found\n        :raise: ``NullArgument`` -- ``vault_id`` is ``null``\n        :raise: ``OperationFailed`` -- ``unable to complete request``\n        :raise: ``Unimplemented`` -- ``supports_qualifier_query()`` or ``supports_visible_federation()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_qualifier_query()`` and ``supports_visible_federation()`` are ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "vault_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "osid.authorization.QualifierQuerySession", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_qualifier_search_session", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` associated with the qualifier search service.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.authorization.QualifierSearchSession) - a\n                ``QualifierSearchSession``", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_qualifier_search()`` is\n                ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: a ``QualifierSearchSession``\n        :rtype: ``osid.authorization.QualifierSearchSession``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_qualifier_search()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_qualifier_search()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.authorization.QualifierSearchSession", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_qualifier_search_session_for_vault", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` associated with the qualifier search service for the given vault.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    vault_id (osid.id.Id): the ``Id`` of the vault\n", 
               "return_doc": "        return: (osid.authorization.QualifierSearchSession) - a\n                ``QualifierSearchSession``", 
               "error_doc": "        raise:  NotFound - ``vault_id`` not found\n        raise:  NullArgument - ``vault_id`` is ``null``\n        raise:  OperationFailed - ``unable to complete request``\n        raise:  Unimplemented - ``supports_qualifier_search()`` or\n                ``supports_visible_federation()`` is ``false``", 
               "sphinx_param_doc": "        :param vault_id: the ``Id`` of the vault\n        :type vault_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: a ``QualifierSearchSession``\n        :rtype: ``osid.authorization.QualifierSearchSession``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``vault_id`` not found\n        :raise: ``NullArgument`` -- ``vault_id`` is ``null``\n        :raise: ``OperationFailed`` -- ``unable to complete request``\n        :raise: ``Unimplemented`` -- ``supports_qualifier_search()`` or ``supports_visible_federation()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_qualifier_search()`` and ``supports_visible_federation()`` are ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "vault_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "osid.authorization.QualifierSearchSession", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_qualifier_admin_session", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` associated with the qualifier administration service.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.authorization.QualifierAdminSession) - a\n                ``QualifierAdminSession``", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_qualifier_admin()`` is\n                ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: a ``QualifierAdminSession``\n        :rtype: ``osid.authorization.QualifierAdminSession``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_qualifier_admin()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_qualifier_admin()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.authorization.QualifierAdminSession", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_qualifier_admin_session_for_vault", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` associated with the qualifier admin service for the given vault.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    vault_id (osid.id.Id): the ``Id`` of the vault\n", 
               "return_doc": "        return: (osid.authorization.QualifierAdminSession) - a\n                ``QualifierAdminSession``", 
               "error_doc": "        raise:  NotFound - ``vault_id`` not found\n        raise:  NullArgument - ``vault_id`` is ``null``\n        raise:  OperationFailed - ``unable to complete request``\n        raise:  Unimplemented - ``supports_qualifier_admin()`` or\n                ``supports_visible_federation()`` is ``false``", 
               "sphinx_param_doc": "        :param vault_id: the ``Id`` of the vault\n        :type vault_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: a ``QualifierAdminSession``\n        :rtype: ``osid.authorization.QualifierAdminSession``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``vault_id`` not found\n        :raise: ``NullArgument`` -- ``vault_id`` is ``null``\n        :raise: ``OperationFailed`` -- ``unable to complete request``\n        :raise: ``Unimplemented`` -- ``supports_qualifier_admin()`` or ``supports_visible_federation()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_qualifier_admin()`` and ``supports_visible_federation()`` are ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "vault_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "osid.authorization.QualifierAdminSession", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_qualifier_notification_session", 
               "doc": {
                  "headline": "Gets the notification session for notifications pertaining to qualifier changes.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    qualifier_receiver\n                (osid.authorization.QualifierReceiver): the qualifier\n                receiver\n", 
               "return_doc": "        return: (osid.authorization.QualifierNotificationSession) - a\n                ``QualifierNotificationSession``", 
               "error_doc": "        raise:  NullArgument - ``qualifier_receiver`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_qualifier_notification()`` is\n                ``false``", 
               "sphinx_param_doc": "        :param qualifier_receiver: the qualifier receiver\n        :type qualifier_receiver: ``osid.authorization.QualifierReceiver``\n", 
               "sphinx_return_doc": "        :return: a ``QualifierNotificationSession``\n        :rtype: ``osid.authorization.QualifierNotificationSession``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``qualifier_receiver`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_qualifier_notification()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_qualifier_notification()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.authorization.QualifierReceiver", 
                     "var_name": "qualifier_receiver", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.authorization.QualifierReceiver"
               ], 
               "return_type": "osid.authorization.QualifierNotificationSession", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_qualifier_notification_session_for_vault", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` associated with the qualifier notification service for the given vault.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    qualifier_receiver\n                (osid.authorization.QualifierReceiver): the qualifier\n                receiver\n        arg:    vault_id (osid.id.Id): the ``Id`` of the vault\n", 
               "return_doc": "        return: (osid.authorization.QualifierNotificationSession) - a\n                ``QualifierNotificationSession``", 
               "error_doc": "        raise:  NotFound - ``vault_id`` not found\n        raise:  NullArgument - ``qualifier_receiver`` or ``vault_id`` is\n                ``null``\n        raise:  OperationFailed - ``unable to complete request``\n        raise:  Unimplemented - ``supports_qualifier_notification()`` or\n                ``supports_visible_federation()`` is ``false``", 
               "sphinx_param_doc": "        :param qualifier_receiver: the qualifier receiver\n        :type qualifier_receiver: ``osid.authorization.QualifierReceiver``\n        :param vault_id: the ``Id`` of the vault\n        :type vault_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: a ``QualifierNotificationSession``\n        :rtype: ``osid.authorization.QualifierNotificationSession``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``vault_id`` not found\n        :raise: ``NullArgument`` -- ``qualifier_receiver`` or ``vault_id`` is ``null``\n        :raise: ``OperationFailed`` -- ``unable to complete request``\n        :raise: ``Unimplemented`` -- ``supports_qualifier_notification()`` or ``supports_visible_federation()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_qualifier_notification()`` and ``supports_visible_federation()`` are ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.authorization.QualifierReceiver", 
                     "var_name": "qualifier_receiver", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "vault_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.authorization.QualifierReceiver", 
                  "osid.id.Id"
               ], 
               "return_type": "osid.authorization.QualifierNotificationSession", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_qualifier_hierarchy_session", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` associated with the qualifier hierarchy traversal service.", 
                  "body": "        The authorization service uses distinct hierarchies that can be\n        managed through a Hierarchy OSID."
               }, 
               "arg_doc": "        arg:    qualifier_hierarchy_id (osid.id.Id): the ``Id`` of a\n                qualifier hierarchy\n", 
               "return_doc": "        return: (osid.authorization.QualifierHierarchySession) - a\n                ``QualifierHierarchySession``", 
               "error_doc": "        raise:  NotFound - ``qualifier_hierarchy_id`` not found\n        raise:  NullArgument - ``qualifier_hierarchy_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_qualifier_hierarchy()`` is\n                ``false``", 
               "sphinx_param_doc": "        :param qualifier_hierarchy_id: the ``Id`` of a qualifier hierarchy\n        :type qualifier_hierarchy_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: a ``QualifierHierarchySession``\n        :rtype: ``osid.authorization.QualifierHierarchySession``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``qualifier_hierarchy_id`` not found\n        :raise: ``NullArgument`` -- ``qualifier_hierarchy_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_qualifier_hierarchy()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_qualifier_hierarchy()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "qualifier_hierarchy_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "osid.authorization.QualifierHierarchySession", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_qualifier_hierarchy_design_session", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` associated with the qualifier hierarchy design service.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    qualifier_hierarchy_id (osid.id.Id): the ``Id`` of a\n                qualifier hierarchy\n", 
               "return_doc": "        return: (osid.authorization.QualifierHierarchyDesignSession) - a\n                ``QualifierHierarchyDesignSession``", 
               "error_doc": "        raise:  NotFound - ``qualifier_hierarchy_id`` not found\n        raise:  NullArgument - ``qualifier_hierarchy_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented -\n                ``supports_qualifier_hierarchy_design()`` is ``false``", 
               "sphinx_param_doc": "        :param qualifier_hierarchy_id: the ``Id`` of a qualifier hierarchy\n        :type qualifier_hierarchy_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: a ``QualifierHierarchyDesignSession``\n        :rtype: ``osid.authorization.QualifierHierarchyDesignSession``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``qualifier_hierarchy_id`` not found\n        :raise: ``NullArgument`` -- ``qualifier_hierarchy_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_qualifier_hierarchy_design()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_qualifier_hierarchy_design()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "qualifier_hierarchy_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "osid.authorization.QualifierHierarchyDesignSession", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_qualifier_vault_session", 
               "doc": {
                  "headline": "Gets the session for retrieving qualifier to vault mappings.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.authorization.QualifierVaultSession) - a\n                ``QualifierVaultSession``", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_qualifier_vault()`` is\n                ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: a ``QualifierVaultSession``\n        :rtype: ``osid.authorization.QualifierVaultSession``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_qualifier_vault()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_qualifier_vault()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.authorization.QualifierVaultSession", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_qualifier_vault_assignment_session", 
               "doc": {
                  "headline": "Gets the session for assigning qualifier to vault mappings.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.authorization.QualifierVaultSession) - a\n                ``QualifierVaultAssignmentSession``", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented -\n                ``supports_qualifier_vault_assignment()`` is ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: a ``QualifierVaultAssignmentSession``\n        :rtype: ``osid.authorization.QualifierVaultSession``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_qualifier_vault_assignment()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_qualifier_vault_assignment()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.authorization.QualifierVaultSession", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_qualifier_smart_vault_session", 
               "doc": {
                  "headline": "Gets the session associated with the qualifier smart vault for the given vault.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    vault_id (osid.id.Id): the ``Id`` of the vault\n", 
               "return_doc": "        return: (osid.authorization.QualifierSmartVaultSession) - a\n                ``QualifierSmartVaultSession``", 
               "error_doc": "        raise:  NotFound - ``vault_id`` not found\n        raise:  NullArgument - ``vault_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_qualifier_smart_vault()`` is\n                ``false``", 
               "sphinx_param_doc": "        :param vault_id: the ``Id`` of the vault\n        :type vault_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: a ``QualifierSmartVaultSession``\n        :rtype: ``osid.authorization.QualifierSmartVaultSession``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``vault_id`` not found\n        :raise: ``NullArgument`` -- ``vault_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_qualifier_smart_vault()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_qualifier_smart_vault()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "vault_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "osid.authorization.QualifierSmartVaultSession", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_vault_lookup_session", 
               "doc": {
                  "headline": "Gets the OsidSession associated with the vault lookup service.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.authorization.VaultLookupSession) - a\n                ``VaultLookupSession``", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_vault_lookup() is false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: a ``VaultLookupSession``\n        :rtype: ``osid.authorization.VaultLookupSession``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_vault_lookup() is false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_vault_lookup()`` is true.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.authorization.VaultLookupSession", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_vault_query_session", 
               "doc": {
                  "headline": "Gets the OsidSession associated with the vault query service.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.authorization.VaultQuerySession) - a\n                ``VaultQuerySession``", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_vault_query() is false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: a ``VaultQuerySession``\n        :rtype: ``osid.authorization.VaultQuerySession``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_vault_query() is false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_vault_query()`` is true.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.authorization.VaultQuerySession", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_vault_search_session", 
               "doc": {
                  "headline": "Gets the OsidSession associated with the vault search service.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.authorization.VaultSearchSession) - a\n                ``VaultSearchSession``", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_vault_search() is false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: a ``VaultSearchSession``\n        :rtype: ``osid.authorization.VaultSearchSession``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_vault_search() is false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_vault_search()`` is true.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.authorization.VaultSearchSession", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_vault_admin_session", 
               "doc": {
                  "headline": "Gets the OsidSession associated with the vault administration service.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.authorization.VaultAdminSession) - a\n                ``VaultAdminSession``", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_vault_admin() is false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: a ``VaultAdminSession``\n        :rtype: ``osid.authorization.VaultAdminSession``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_vault_admin() is false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_vault_admin()`` is true.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.authorization.VaultAdminSession", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_vault_notification_session", 
               "doc": {
                  "headline": "Gets the notification session for notifications pertaining to vault service changes.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    vaultreceiver (osid.authorization.VaultReceiver): the\n                vault receiver\n", 
               "return_doc": "        return: (osid.authorization.VaultNotificationSession) - a\n                ``VaultNotificationSession``", 
               "error_doc": "        raise:  NullArgument - ``vault_receiver`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_vault_notification() is\n                false``", 
               "sphinx_param_doc": "        :param vaultreceiver: the vault receiver\n        :type vaultreceiver: ``osid.authorization.VaultReceiver``\n", 
               "sphinx_return_doc": "        :return: a ``VaultNotificationSession``\n        :rtype: ``osid.authorization.VaultNotificationSession``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``vault_receiver`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_vault_notification() is false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_vault_notification()`` is true.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.authorization.VaultReceiver", 
                     "var_name": "vaultreceiver", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.authorization.VaultReceiver"
               ], 
               "return_type": "osid.authorization.VaultNotificationSession", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_vault_hierarchy_session", 
               "doc": {
                  "headline": "Gets the session traversing vault hierarchies.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.authorization.VaultHierarchySession) - a\n                ``VaultHierarchySession``", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_vault_hierarchy() is false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: a ``VaultHierarchySession``\n        :rtype: ``osid.authorization.VaultHierarchySession``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_vault_hierarchy() is false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_vault_hierarchy()`` is true.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.authorization.VaultHierarchySession", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_vault_hierarchy_design_session", 
               "doc": {
                  "headline": "Gets the session designing vault hierarchies.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.authorization.VaultHierarchyDesignSession) - a\n                ``VaultHierarchyDesignSession``", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_vault_hierarchy_design() is\n                false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: a ``VaultHierarchyDesignSession``\n        :rtype: ``osid.authorization.VaultHierarchyDesignSession``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_vault_hierarchy_design() is false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_vault_hierarchy_design()`` is true.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.authorization.VaultHierarchyDesignSession", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_authorization_batch_manager", 
               "doc": {
                  "headline": "Gets an ``AuthorizationBatchManager``.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.authorization.batch.AuthorizationBatchManager) -\n                an ``AuthorizationBatchManager``", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_authorization_batch() is\n                false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: an ``AuthorizationBatchManager``\n        :rtype: ``osid.authorization.batch.AuthorizationBatchManager``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_authorization_batch() is false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_authorization_batch()`` is true.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.authorization.batch.AuthorizationBatchManager", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_authorization_rules_manager", 
               "doc": {
                  "headline": "Gets an ``AuthorizationRulesManager``.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.authorization.rules.AuthorizationRulesManager) -\n                an ``AuthorizationRulesManager``", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_authorization_rules() is\n                false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: an ``AuthorizationRulesManager``\n        :rtype: ``osid.authorization.rules.AuthorizationRulesManager``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_authorization_rules() is false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_authorization_rules()`` is true.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.authorization.rules.AuthorizationRulesManager", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.authorization.AuthorizationProxyManager", 
         "shortname": "AuthorizationProxyManager", 
         "category": "managers", 
         "doc": {
            "headline": "The authorization manager provides access to authorization sessions and provides interoperability tests for various aspects of this service.", 
            "body": "    Methods in this manager support the passing of a ``Proxy`` object.\n    The sessions included in this manager are:\n\n      * ``AuthorizationSession:`` a session to performs authorization\n        checks\n      * ``AuthorizationLookupSession:`` a session to look up\n        ``Authorizations``\n      * ``AuthorizationSearchSession:`` a session to search\n        ``Authorizations``\n      * ``AuthorizationAdminSession:`` a session to create, modify and\n        delete ``Authorizations``\n      * ``AuthorizationNotificationSession: a`` session to receive\n        messages pertaining to ``Authorization`` changes\n      * ``AuthorizationVaultSession:`` a session to look up\n        authorization to vault mappings\n      * ``AuthorizationVaultAssignmentSession:`` a session to manage\n        authorization to vault mappings\n      * ``AuthorizationSmartVaultSession:`` a session to manage smart\n        authorization vault\n    \n      * ``FunctionLookupSession:`` a session to look up ``Functions``\n      * ``FunctionQuerySession:`` a session to query ``Functions``\n      * ``FunctionSearchSession:`` a session to search ``Functions``\n      * ``FunctionAdminSession:`` a session to create, modify and delete\n        ``Functions``\n      * ``FunctionNotificationSession: a`` session to receive messages\n        pertaining to ``Function`` changes\n      * ``FunctionVaultSession:`` a session for looking up function and\n        vault mappings\n      * ``FunctionVaultAssignmentSession:`` a session for managing\n        function and vault mappings\n      * ``FunctionSmartVaultSession:`` a session to manage dynamic\n        function vaults\n    \n      * ``QualifierLookupSession:`` a session to look up ``Qualifiers``\n      * ``QualifierQuerySession:`` a session to query ``Qualifiers``\n      * ``QualifierSearchSession:`` a session to search ``Qualifiers``\n      * ``QualifierAdminSession:`` a session to create, modify and\n        delete ``Qualifiers``\n      * ``QualifierNotificationSession: a`` session to receive messages\n        pertaining to ``Qualifier`` changes\n      * ``QualifierHierarchySession:`` a session for traversing\n        qualifier hierarchies\n      * ``QualifierHierarchyDesignSession:`` a session for managing\n        qualifier hierarchies\n      * ``QualifierVaultSession:`` a session for looking up qualifier\n        and vault mappings\n      * ``QualifierVaultAssignmentSession:`` a session for managing\n        qualifier and vault mappings\n      * ``QualifierSmartVaultSession:`` a session to manage dynamic\n        qualifier vaults\n    \n      * ``VaultLookupSession:`` a session to lookup vaults\n      * ``VaultQuerySession:`` a session to query Vaults\n      * ``VaultSearchSession`` : a session to search vaults\n      * ``VaultAdminSession`` : a session to create, modify and delete\n        vaults\n      * ``VaultNotificationSession`` : a session to receive messages\n        pertaining to ``Vault`` changes\n      * ``VaultHierarchySession`` : a session to traverse the ``Vault``\n        hierarchy\n      * ``VaultHierarchyDesignSession`` : a session to manage the\n        ``Vault`` hierarchy\n"
         }, 
         "inherit_fullnames": [
            "osid.OsidProxyManager", 
            "osid.authorization.AuthorizationProfile"
         ], 
         "inherit_shortnames": [
            "OsidProxyManager", 
            "AuthorizationProfile"
         ], 
         "inherit_pkg_names": [
            "osid", 
            "authorization"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidProxyManager"
            }, 
            {
               "pkg_name": "authorization", 
               "name": "AuthorizationProfile"
            }
         ], 
         "method_names": [
            "get_authorization_session", 
            "get_authorization_session_for_vault", 
            "get_authorization_lookup_session", 
            "get_authorization_lookup_session_for_vault", 
            "get_authorization_query_session", 
            "get_authorization_query_session_for_vault", 
            "get_authorization_search_session", 
            "get_authorization_search_session_for_vault", 
            "get_authorization_admin_session", 
            "get_authorization_admin_session_for_vault", 
            "get_authorization_notification_session", 
            "get_authorization_notification_session_for_vault", 
            "get_authorization_vault_session", 
            "get_authorization_vault_assignment_session", 
            "get_authorization_smart_vault_session", 
            "get_function_lookup_session", 
            "get_function_lookup_session_for_vault", 
            "get_function_query_session", 
            "get_function_query_session_for_vault", 
            "get_function_search_session", 
            "get_function_search_session_for_vault", 
            "get_function_admin_session", 
            "get_function_admin_session_for_vault", 
            "get_function_notification_session", 
            "get_function_notification_session_for_vault", 
            "get_function_vault_session", 
            "get_function_vault_assignment_session", 
            "get_function_smart_vault_session", 
            "get_qualifier_lookup_session", 
            "get_qualifier_lookup_session_for_vault", 
            "get_qualifier_query_session", 
            "get_qualifier_query_session_for_vault", 
            "get_qualifier_search_session", 
            "get_qualifier_search_session_for_vault", 
            "get_qualifier_admin_session", 
            "get_qualifier_admin_session_for_vault", 
            "get_qualifier_notification_session", 
            "get_qualifier_notification_session_for_vault", 
            "get_qualifier_hierarchy_session", 
            "get_qualifier_hierarchy_design_session", 
            "get_qualifier_vault_session", 
            "get_qualifier_vault_assignment_session", 
            "get_qualifier_smart_vault_session", 
            "get_vault_lookup_session", 
            "get_vault_query_session", 
            "get_vault_search_session", 
            "get_vault_admin_session", 
            "get_vault_notification_session", 
            "get_vault_hierarchy_session", 
            "get_vault_hierarchy_design_session", 
            "get_authorization_batch_proxy_manager", 
            "get_authorization_rules_proxy_manager"
         ], 
         "methods": [
            {
               "name": "get_authorization_session", 
               "doc": {
                  "headline": "Gets an ``AuthorizationSession`` which is responsible for performing authorization checks.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    proxy (osid.proxy.Proxy): a proxy\n", 
               "return_doc": "        return: (osid.authorization.AuthorizationSession) - an\n                authorization session for this service", 
               "error_doc": "        raise:  NullArgument - ``proxy`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_authorization()`` is\n                ``false``", 
               "sphinx_param_doc": "        :param proxy: a proxy\n        :type proxy: ``osid.proxy.Proxy``\n", 
               "sphinx_return_doc": "        :return: an authorization session for this service\n        :rtype: ``osid.authorization.AuthorizationSession``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``proxy`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_authorization()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_authorization()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.proxy.Proxy", 
                     "var_name": "proxy", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.proxy.Proxy"
               ], 
               "return_type": "osid.authorization.AuthorizationSession", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_authorization_session_for_vault", 
               "doc": {
                  "headline": "Gets an ``AuthorizationSession`` which is responsible for performing authorization checks for the given vault.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    vault_id (osid.id.Id): the ``Id`` of the vault\n        arg:    proxy (osid.proxy.Proxy): a proxy\n", 
               "return_doc": "        return: (osid.authorization.AuthorizationSession) - ``an\n                _authorization_session``", 
               "error_doc": "        raise:  NotFound - ``vault_id`` not found\n        raise:  NullArgument - ``vault_id`` or ``proxy`` is ``null``\n        raise:  OperationFailed - ``unable to complete request``\n        raise:  Unimplemented - ``supports_authorization()`` or\n                ``supports_visible_federation()`` is ``false``", 
               "sphinx_param_doc": "        :param vault_id: the ``Id`` of the vault\n        :type vault_id: ``osid.id.Id``\n        :param proxy: a proxy\n        :type proxy: ``osid.proxy.Proxy``\n", 
               "sphinx_return_doc": "        :return: ``an _authorization_session``\n        :rtype: ``osid.authorization.AuthorizationSession``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``vault_id`` not found\n        :raise: ``NullArgument`` -- ``vault_id`` or ``proxy`` is ``null``\n        :raise: ``OperationFailed`` -- ``unable to complete request``\n        :raise: ``Unimplemented`` -- ``supports_authorization()`` or ``supports_visible_federation()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_authorization()`` and ``supports_visible_federation()`` are ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "vault_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.proxy.Proxy", 
                     "var_name": "proxy", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "osid.proxy.Proxy"
               ], 
               "return_type": "osid.authorization.AuthorizationSession", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_authorization_lookup_session", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` associated with the authorization lookup service.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    proxy (osid.proxy.Proxy): a proxy\n", 
               "return_doc": "        return: (osid.authorization.AuthorizationLookupSession) - an\n                ``AuthorizationLookupSession``", 
               "error_doc": "        raise:  NullArgument - ``proxy`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_authorization_lookup()`` is\n                ``false``", 
               "sphinx_param_doc": "        :param proxy: a proxy\n        :type proxy: ``osid.proxy.Proxy``\n", 
               "sphinx_return_doc": "        :return: an ``AuthorizationLookupSession``\n        :rtype: ``osid.authorization.AuthorizationLookupSession``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``proxy`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_authorization_lookup()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_authorization_lookup()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.proxy.Proxy", 
                     "var_name": "proxy", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.proxy.Proxy"
               ], 
               "return_type": "osid.authorization.AuthorizationLookupSession", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_authorization_lookup_session_for_vault", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` associated with the authorization lookup service for the given vault.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    vault_id (osid.id.Id): the ``Id`` of the vault\n        arg:    proxy (osid.proxy.Proxy): a proxy\n", 
               "return_doc": "        return: (osid.authorization.AuthorizationLookupSession) - ``an\n                _authorization_lookup_session``", 
               "error_doc": "        raise:  NotFound - ``vault_id`` not found\n        raise:  NullArgument - ``vault_id`` or ``proxy`` is ``null``\n        raise:  OperationFailed - ``unable to complete request``\n        raise:  Unimplemented - ``supports_authorization_lookup()`` or\n                ``supports_visible_federation()`` is ``false``", 
               "sphinx_param_doc": "        :param vault_id: the ``Id`` of the vault\n        :type vault_id: ``osid.id.Id``\n        :param proxy: a proxy\n        :type proxy: ``osid.proxy.Proxy``\n", 
               "sphinx_return_doc": "        :return: ``an _authorization_lookup_session``\n        :rtype: ``osid.authorization.AuthorizationLookupSession``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``vault_id`` not found\n        :raise: ``NullArgument`` -- ``vault_id`` or ``proxy`` is ``null``\n        :raise: ``OperationFailed`` -- ``unable to complete request``\n        :raise: ``Unimplemented`` -- ``supports_authorization_lookup()`` or ``supports_visible_federation()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_authorization_lookup()`` and ``supports_visible_federation()`` are ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "vault_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.proxy.Proxy", 
                     "var_name": "proxy", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "osid.proxy.Proxy"
               ], 
               "return_type": "osid.authorization.AuthorizationLookupSession", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_authorization_query_session", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` associated with the authorization query service.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    proxy (osid.proxy.Proxy): a proxy\n", 
               "return_doc": "        return: (osid.authorization.AuthorizationQuerySession) - an\n                ``AuthorizationQuerySession``", 
               "error_doc": "        raise:  NullArgument - ``proxy`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_authorization_query()`` is\n                ``false``", 
               "sphinx_param_doc": "        :param proxy: a proxy\n        :type proxy: ``osid.proxy.Proxy``\n", 
               "sphinx_return_doc": "        :return: an ``AuthorizationQuerySession``\n        :rtype: ``osid.authorization.AuthorizationQuerySession``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``proxy`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_authorization_query()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_authorization_query()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.proxy.Proxy", 
                     "var_name": "proxy", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.proxy.Proxy"
               ], 
               "return_type": "osid.authorization.AuthorizationQuerySession", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_authorization_query_session_for_vault", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` associated with the authorization query service for the given vault.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    vault_id (osid.id.Id): the ``Id`` of the vault\n        arg:    proxy (osid.proxy.Proxy): a proxy\n", 
               "return_doc": "        return: (osid.authorization.AuthorizationQuerySession) - ``an\n                _authorization_query_session``", 
               "error_doc": "        raise:  NotFound - ``vault_id`` not found\n        raise:  NullArgument - ``vault_id`` or ``proxy`` is ``null``\n        raise:  OperationFailed - ``unable to complete request``\n        raise:  Unimplemented - ``supports_authorization_query()`` or\n                ``supports_visible_federation()`` is ``false``", 
               "sphinx_param_doc": "        :param vault_id: the ``Id`` of the vault\n        :type vault_id: ``osid.id.Id``\n        :param proxy: a proxy\n        :type proxy: ``osid.proxy.Proxy``\n", 
               "sphinx_return_doc": "        :return: ``an _authorization_query_session``\n        :rtype: ``osid.authorization.AuthorizationQuerySession``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``vault_id`` not found\n        :raise: ``NullArgument`` -- ``vault_id`` or ``proxy`` is ``null``\n        :raise: ``OperationFailed`` -- ``unable to complete request``\n        :raise: ``Unimplemented`` -- ``supports_authorization_query()`` or ``supports_visible_federation()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_authorization_query()`` and ``supports_visible_federation()`` are ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "vault_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.proxy.Proxy", 
                     "var_name": "proxy", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "osid.proxy.Proxy"
               ], 
               "return_type": "osid.authorization.AuthorizationQuerySession", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_authorization_search_session", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` associated with the authorization search service.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    proxy (osid.proxy.Proxy): a proxy\n", 
               "return_doc": "        return: (osid.authorization.AuthorizationSearchSession) - an\n                ``AuthorizationSearchSession``", 
               "error_doc": "        raise:  NullArgument - ``proxy`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_authorization_search()`` is\n                ``false``", 
               "sphinx_param_doc": "        :param proxy: a proxy\n        :type proxy: ``osid.proxy.Proxy``\n", 
               "sphinx_return_doc": "        :return: an ``AuthorizationSearchSession``\n        :rtype: ``osid.authorization.AuthorizationSearchSession``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``proxy`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_authorization_search()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_authorization_search()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.proxy.Proxy", 
                     "var_name": "proxy", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.proxy.Proxy"
               ], 
               "return_type": "osid.authorization.AuthorizationSearchSession", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_authorization_search_session_for_vault", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` associated with the authorization search service for the given vault.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    vault_id (osid.id.Id): the ``Id`` of the vault\n        arg:    proxy (osid.proxy.Proxy): a proxy\n", 
               "return_doc": "        return: (osid.authorization.AuthorizationSearchSession) - ``an\n                _authorization_search_session``", 
               "error_doc": "        raise:  NotFound - ``vault_id`` not found\n        raise:  NullArgument - ``vault_id`` or ``proxy`` is ``null``\n        raise:  OperationFailed - ``unable to complete request``\n        raise:  Unimplemented - ``supports_authorization_search()`` or\n                ``supports_visible_federation()`` is ``false``", 
               "sphinx_param_doc": "        :param vault_id: the ``Id`` of the vault\n        :type vault_id: ``osid.id.Id``\n        :param proxy: a proxy\n        :type proxy: ``osid.proxy.Proxy``\n", 
               "sphinx_return_doc": "        :return: ``an _authorization_search_session``\n        :rtype: ``osid.authorization.AuthorizationSearchSession``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``vault_id`` not found\n        :raise: ``NullArgument`` -- ``vault_id`` or ``proxy`` is ``null``\n        :raise: ``OperationFailed`` -- ``unable to complete request``\n        :raise: ``Unimplemented`` -- ``supports_authorization_search()`` or ``supports_visible_federation()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_authorization_search()`` and ``supports_visible_federation()`` are ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "vault_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.proxy.Proxy", 
                     "var_name": "proxy", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "osid.proxy.Proxy"
               ], 
               "return_type": "osid.authorization.AuthorizationSearchSession", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_authorization_admin_session", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` associated with the authorization administration service.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    proxy (osid.proxy.Proxy): a proxy\n", 
               "return_doc": "        return: (osid.authorization.AuthorizationAdminSession) - an\n                ``AuthorizationAdminSession``", 
               "error_doc": "        raise:  NullArgument - ``proxy`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_authorization_admin()`` is\n                ``false``", 
               "sphinx_param_doc": "        :param proxy: a proxy\n        :type proxy: ``osid.proxy.Proxy``\n", 
               "sphinx_return_doc": "        :return: an ``AuthorizationAdminSession``\n        :rtype: ``osid.authorization.AuthorizationAdminSession``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``proxy`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_authorization_admin()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_authorization_admin()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.proxy.Proxy", 
                     "var_name": "proxy", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.proxy.Proxy"
               ], 
               "return_type": "osid.authorization.AuthorizationAdminSession", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_authorization_admin_session_for_vault", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` associated with the authorization admin service for the given vault.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    vault_id (osid.id.Id): the ``Id`` of the vault\n        arg:    proxy (osid.proxy.Proxy): a proxy\n", 
               "return_doc": "        return: (osid.authorization.AuthorizationAdminSession) - ``an\n                _authorization_admin_session``", 
               "error_doc": "        raise:  NotFound - ``vault_id`` not found\n        raise:  NullArgument - ``vault_id`` or ``proxy`` is ``null``\n        raise:  OperationFailed - ``unable to complete request``\n        raise:  Unimplemented - ``supports_authorization_admin()`` or\n                ``supports_visible_federation()`` is ``false``", 
               "sphinx_param_doc": "        :param vault_id: the ``Id`` of the vault\n        :type vault_id: ``osid.id.Id``\n        :param proxy: a proxy\n        :type proxy: ``osid.proxy.Proxy``\n", 
               "sphinx_return_doc": "        :return: ``an _authorization_admin_session``\n        :rtype: ``osid.authorization.AuthorizationAdminSession``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``vault_id`` not found\n        :raise: ``NullArgument`` -- ``vault_id`` or ``proxy`` is ``null``\n        :raise: ``OperationFailed`` -- ``unable to complete request``\n        :raise: ``Unimplemented`` -- ``supports_authorization_admin()`` or ``supports_visible_federation()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_authorization_admin()`` and ``supports_visible_federation()`` are ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "vault_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.proxy.Proxy", 
                     "var_name": "proxy", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "osid.proxy.Proxy"
               ], 
               "return_type": "osid.authorization.AuthorizationAdminSession", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_authorization_notification_session", 
               "doc": {
                  "headline": "Gets the notification session for notifications pertaining to authorization changes.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    authorization_receiver\n                (osid.authorization.AuthorizationReceiver): the\n                authorization receiver\n        arg:    proxy (osid.proxy.Proxy): a proxy\n", 
               "return_doc": "        return: (osid.authorization.AuthorizationNotificationSession) -\n                an ``AuthorizationNotificationSession``", 
               "error_doc": "        raise:  NullArgument - ``authorization_receiver`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented -\n                ``supports_authorization_notification()`` is ``false``", 
               "sphinx_param_doc": "        :param authorization_receiver: the authorization receiver\n        :type authorization_receiver: ``osid.authorization.AuthorizationReceiver``\n        :param proxy: a proxy\n        :type proxy: ``osid.proxy.Proxy``\n", 
               "sphinx_return_doc": "        :return: an ``AuthorizationNotificationSession``\n        :rtype: ``osid.authorization.AuthorizationNotificationSession``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``authorization_receiver`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_authorization_notification()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_authorization_notification()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.authorization.AuthorizationReceiver", 
                     "var_name": "authorization_receiver", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.proxy.Proxy", 
                     "var_name": "proxy", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.authorization.AuthorizationReceiver", 
                  "osid.proxy.Proxy"
               ], 
               "return_type": "osid.authorization.AuthorizationNotificationSession", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_authorization_notification_session_for_vault", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` associated with the authorization notification service for the given vault.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    authorization_receiver\n                (osid.authorization.AuthorizationReceiver): the\n                authorization receiver\n        arg:    vault_id (osid.id.Id): the ``Id`` of the vault\n        arg:    proxy (osid.proxy.Proxy): a proxy\n", 
               "return_doc": "        return: (osid.authorization.AuthorizationNotificationSession) -\n                ``an _authorization_notification_session``", 
               "error_doc": "        raise:  NotFound - ``vault_id`` not found\n        raise:  NullArgument - ``authorization_receiver`` or\n                ``vault_id`` or ``proxy`` is ``null``\n        raise:  OperationFailed - ``unable to complete request``\n        raise:  Unimplemented -\n                ``supports_authorization_notification()`` or\n                ``supports_visible_federation()`` is ``false``", 
               "sphinx_param_doc": "        :param authorization_receiver: the authorization receiver\n        :type authorization_receiver: ``osid.authorization.AuthorizationReceiver``\n        :param vault_id: the ``Id`` of the vault\n        :type vault_id: ``osid.id.Id``\n        :param proxy: a proxy\n        :type proxy: ``osid.proxy.Proxy``\n", 
               "sphinx_return_doc": "        :return: ``an _authorization_notification_session``\n        :rtype: ``osid.authorization.AuthorizationNotificationSession``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``vault_id`` not found\n        :raise: ``NullArgument`` -- ``authorization_receiver`` or ``vault_id`` or ``proxy`` is ``null``\n        :raise: ``OperationFailed`` -- ``unable to complete request``\n        :raise: ``Unimplemented`` -- ``supports_authorization_notification()`` or ``supports_visible_federation()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_authorization_notification()`` and ``supports_visible_federation()`` are ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.authorization.AuthorizationReceiver", 
                     "var_name": "authorization_receiver", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "vault_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.proxy.Proxy", 
                     "var_name": "proxy", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.authorization.AuthorizationReceiver", 
                  "osid.id.Id", 
                  "osid.proxy.Proxy"
               ], 
               "return_type": "osid.authorization.AuthorizationNotificationSession", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_authorization_vault_session", 
               "doc": {
                  "headline": "Gets the session for retrieving authorization to vault mappings.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    proxy (osid.proxy.Proxy): a proxy\n", 
               "return_doc": "        return: (osid.authorization.AuthorizationVaultSession) - an\n                ``AuthorizationVaultSession``", 
               "error_doc": "        raise:  NullArgument - ``proxy`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_authorization_vault()`` is\n                ``false``", 
               "sphinx_param_doc": "        :param proxy: a proxy\n        :type proxy: ``osid.proxy.Proxy``\n", 
               "sphinx_return_doc": "        :return: an ``AuthorizationVaultSession``\n        :rtype: ``osid.authorization.AuthorizationVaultSession``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``proxy`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_authorization_vault()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_authorization_vault()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.proxy.Proxy", 
                     "var_name": "proxy", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.proxy.Proxy"
               ], 
               "return_type": "osid.authorization.AuthorizationVaultSession", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_authorization_vault_assignment_session", 
               "doc": {
                  "headline": "Gets the session for assigning authorization to vault mappings.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    proxy (osid.proxy.Proxy): a proxy\n", 
               "return_doc": "        return: (osid.authorization.AuthorizationVaultAssignmentSession)\n                - a ``AuthorizationVaultAssignmentSession``", 
               "error_doc": "        raise:  NullArgument - ``proxy`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented -\n                ``supports_authorization_vault_assignment()`` is\n                ``false``", 
               "sphinx_param_doc": "        :param proxy: a proxy\n        :type proxy: ``osid.proxy.Proxy``\n", 
               "sphinx_return_doc": "        :return: a ``AuthorizationVaultAssignmentSession``\n        :rtype: ``osid.authorization.AuthorizationVaultAssignmentSession``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``proxy`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_authorization_vault_assignment()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_authorization_vault_assignment()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.proxy.Proxy", 
                     "var_name": "proxy", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.proxy.Proxy"
               ], 
               "return_type": "osid.authorization.AuthorizationVaultAssignmentSession", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_authorization_smart_vault_session", 
               "doc": {
                  "headline": "Gets the session for managing dynamic authorization vault.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    vault_id (osid.id.Id): the ``Id`` of the vault\n        arg:    proxy (osid.proxy.Proxy): a proxy\n", 
               "return_doc": "        return: (osid.authorization.AuthorizationSmartVaultSession) - a\n                ``AuthorizationSmartVaultSession``", 
               "error_doc": "        raise:  NotFound - ``vault_id`` not found\n        raise:  NullArgument - ``vault_id`` or ``proxy`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_authorization_smart_vault()``\n                is ``false``", 
               "sphinx_param_doc": "        :param vault_id: the ``Id`` of the vault\n        :type vault_id: ``osid.id.Id``\n        :param proxy: a proxy\n        :type proxy: ``osid.proxy.Proxy``\n", 
               "sphinx_return_doc": "        :return: a ``AuthorizationSmartVaultSession``\n        :rtype: ``osid.authorization.AuthorizationSmartVaultSession``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``vault_id`` not found\n        :raise: ``NullArgument`` -- ``vault_id`` or ``proxy`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_authorization_smart_vault()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_authorization_smart_vault()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "vault_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.proxy.Proxy", 
                     "var_name": "proxy", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "osid.proxy.Proxy"
               ], 
               "return_type": "osid.authorization.AuthorizationSmartVaultSession", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_function_lookup_session", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` associated with the function lookup service.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    proxy (osid.proxy.Proxy): a proxy\n", 
               "return_doc": "        return: (osid.authorization.FunctionLookupSession) - a\n                ``FunctionLookupSession``", 
               "error_doc": "        raise:  NullArgument - ``proxy`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_function_lookup()`` is\n                ``false``", 
               "sphinx_param_doc": "        :param proxy: a proxy\n        :type proxy: ``osid.proxy.Proxy``\n", 
               "sphinx_return_doc": "        :return: a ``FunctionLookupSession``\n        :rtype: ``osid.authorization.FunctionLookupSession``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``proxy`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_function_lookup()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_function_lookup()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.proxy.Proxy", 
                     "var_name": "proxy", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.proxy.Proxy"
               ], 
               "return_type": "osid.authorization.FunctionLookupSession", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_function_lookup_session_for_vault", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` associated with the function lookup service for the given vault.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    vault_id (osid.id.Id): the ``Id`` of the vault\n        arg:    proxy (osid.proxy.Proxy): a proxy\n", 
               "return_doc": "        return: (osid.authorization.FunctionLookupSession) - ``a\n                FunctionLookupSession``", 
               "error_doc": "        raise:  NotFound - ``vault_id`` not found\n        raise:  NullArgument - ``vault_id`` or ``proxy`` is ``null``\n        raise:  OperationFailed - ``unable to complete request``\n        raise:  Unimplemented - ``supports_function_lookup()`` or\n                ``supports_visible_federation()`` is ``false``", 
               "sphinx_param_doc": "        :param vault_id: the ``Id`` of the vault\n        :type vault_id: ``osid.id.Id``\n        :param proxy: a proxy\n        :type proxy: ``osid.proxy.Proxy``\n", 
               "sphinx_return_doc": "        :return: ``a FunctionLookupSession``\n        :rtype: ``osid.authorization.FunctionLookupSession``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``vault_id`` not found\n        :raise: ``NullArgument`` -- ``vault_id`` or ``proxy`` is ``null``\n        :raise: ``OperationFailed`` -- ``unable to complete request``\n        :raise: ``Unimplemented`` -- ``supports_function_lookup()`` or ``supports_visible_federation()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_function_lookup()`` and ``supports_visible_federation()`` are ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "vault_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.proxy.Proxy", 
                     "var_name": "proxy", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "osid.proxy.Proxy"
               ], 
               "return_type": "osid.authorization.FunctionLookupSession", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_function_query_session", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` associated with the function query service.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    proxy (osid.proxy.Proxy): a proxy\n", 
               "return_doc": "        return: (osid.authorization.FunctionQuerySession) - a\n                ``FunctionQuerySession``", 
               "error_doc": "        raise:  NullArgument - ``proxy`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_function_query()`` is\n                ``false``", 
               "sphinx_param_doc": "        :param proxy: a proxy\n        :type proxy: ``osid.proxy.Proxy``\n", 
               "sphinx_return_doc": "        :return: a ``FunctionQuerySession``\n        :rtype: ``osid.authorization.FunctionQuerySession``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``proxy`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_function_query()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_function_query()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.proxy.Proxy", 
                     "var_name": "proxy", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.proxy.Proxy"
               ], 
               "return_type": "osid.authorization.FunctionQuerySession", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_function_query_session_for_vault", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` associated with the function query service for the given vault.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    vault_id (osid.id.Id): the ``Id`` of the vault\n        arg:    proxy (osid.proxy.Proxy): a proxy\n", 
               "return_doc": "        return: (osid.authorization.FunctionQuerySession) - a\n                ``FunctionQuerySession``", 
               "error_doc": "        raise:  NotFound - ``vault_id`` not found\n        raise:  NullArgument - ``vault_id`` or ``proxy`` is ``null``\n        raise:  OperationFailed - ``unable to complete request``\n        raise:  Unimplemented - ``supports_function_query()`` or\n                ``supports_visible_federation()`` is ``false``", 
               "sphinx_param_doc": "        :param vault_id: the ``Id`` of the vault\n        :type vault_id: ``osid.id.Id``\n        :param proxy: a proxy\n        :type proxy: ``osid.proxy.Proxy``\n", 
               "sphinx_return_doc": "        :return: a ``FunctionQuerySession``\n        :rtype: ``osid.authorization.FunctionQuerySession``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``vault_id`` not found\n        :raise: ``NullArgument`` -- ``vault_id`` or ``proxy`` is ``null``\n        :raise: ``OperationFailed`` -- ``unable to complete request``\n        :raise: ``Unimplemented`` -- ``supports_function_query()`` or ``supports_visible_federation()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_function_query()`` and ``supports_visible_federation()`` are ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "vault_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.proxy.Proxy", 
                     "var_name": "proxy", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "osid.proxy.Proxy"
               ], 
               "return_type": "osid.authorization.FunctionQuerySession", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_function_search_session", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` associated with the function search service.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    proxy (osid.proxy.Proxy): a proxy\n", 
               "return_doc": "        return: (osid.authorization.FunctionSearchSession) - a\n                ``FunctionSearchSession``", 
               "error_doc": "        raise:  NullArgument - ``proxy`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_function_search()`` is\n                ``false``", 
               "sphinx_param_doc": "        :param proxy: a proxy\n        :type proxy: ``osid.proxy.Proxy``\n", 
               "sphinx_return_doc": "        :return: a ``FunctionSearchSession``\n        :rtype: ``osid.authorization.FunctionSearchSession``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``proxy`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_function_search()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_function_search()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.proxy.Proxy", 
                     "var_name": "proxy", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.proxy.Proxy"
               ], 
               "return_type": "osid.authorization.FunctionSearchSession", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_function_search_session_for_vault", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` associated with the function search service for the given vault.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    vault_id (osid.id.Id): the ``Id`` of the vault\n        arg:    proxy (osid.proxy.Proxy): a proxy\n", 
               "return_doc": "        return: (osid.authorization.FunctionSearchSession) - a\n                ``FunctionSearchSession``", 
               "error_doc": "        raise:  NotFound - ``vault_id`` not found\n        raise:  NullArgument - ``vault_id`` or ``proxy`` is ``null``\n        raise:  OperationFailed - ``unable to complete request``\n        raise:  Unimplemented - ``supports_function_search()`` or\n                ``supports_visible_federation()`` is ``false``", 
               "sphinx_param_doc": "        :param vault_id: the ``Id`` of the vault\n        :type vault_id: ``osid.id.Id``\n        :param proxy: a proxy\n        :type proxy: ``osid.proxy.Proxy``\n", 
               "sphinx_return_doc": "        :return: a ``FunctionSearchSession``\n        :rtype: ``osid.authorization.FunctionSearchSession``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``vault_id`` not found\n        :raise: ``NullArgument`` -- ``vault_id`` or ``proxy`` is ``null``\n        :raise: ``OperationFailed`` -- ``unable to complete request``\n        :raise: ``Unimplemented`` -- ``supports_function_search()`` or ``supports_visible_federation()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_function_search()`` and ``supports_visible_federation()`` are ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "vault_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.proxy.Proxy", 
                     "var_name": "proxy", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "osid.proxy.Proxy"
               ], 
               "return_type": "osid.authorization.FunctionSearchSession", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_function_admin_session", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` associated with the function administration service.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    proxy (osid.proxy.Proxy): a proxy\n", 
               "return_doc": "        return: (osid.authorization.FunctionAdminSession) - a\n                ``FunctionAdminSession``", 
               "error_doc": "        raise:  NullArgument - ``proxy`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_function_admin()`` is\n                ``false``", 
               "sphinx_param_doc": "        :param proxy: a proxy\n        :type proxy: ``osid.proxy.Proxy``\n", 
               "sphinx_return_doc": "        :return: a ``FunctionAdminSession``\n        :rtype: ``osid.authorization.FunctionAdminSession``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``proxy`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_function_admin()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_function_admin()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.proxy.Proxy", 
                     "var_name": "proxy", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.proxy.Proxy"
               ], 
               "return_type": "osid.authorization.FunctionAdminSession", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_function_admin_session_for_vault", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` associated with the function admin service for the given vault.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    vault_id (osid.id.Id): the ``Id`` of the vault\n        arg:    proxy (osid.proxy.Proxy): a proxy\n", 
               "return_doc": "        return: (osid.authorization.FunctionAdminSession) - ``a\n                FunctionAdminSession``", 
               "error_doc": "        raise:  NotFound - ``vault_id`` not found\n        raise:  NullArgument - ``vault_id`` or ``proxy`` is ``null``\n        raise:  OperationFailed - ``unable to complete request``\n        raise:  Unimplemented - ``supports_function_admin()`` or\n                ``supports_visible_federation()`` is ``false``", 
               "sphinx_param_doc": "        :param vault_id: the ``Id`` of the vault\n        :type vault_id: ``osid.id.Id``\n        :param proxy: a proxy\n        :type proxy: ``osid.proxy.Proxy``\n", 
               "sphinx_return_doc": "        :return: ``a FunctionAdminSession``\n        :rtype: ``osid.authorization.FunctionAdminSession``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``vault_id`` not found\n        :raise: ``NullArgument`` -- ``vault_id`` or ``proxy`` is ``null``\n        :raise: ``OperationFailed`` -- ``unable to complete request``\n        :raise: ``Unimplemented`` -- ``supports_function_admin()`` or ``supports_visible_federation()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_function_admin()`` and ``supports_visible_federation()`` are ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "vault_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.proxy.Proxy", 
                     "var_name": "proxy", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "osid.proxy.Proxy"
               ], 
               "return_type": "osid.authorization.FunctionAdminSession", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_function_notification_session", 
               "doc": {
                  "headline": "Gets the notification session for notifications pertaining to function changes.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    function_receiver (osid.authorization.FunctionReceiver):\n                the function receiver\n        arg:    proxy (osid.proxy.Proxy): a proxy\n", 
               "return_doc": "        return: (osid.authorization.FunctionNotificationSession) - a\n                ``FunctionNotificationSession``", 
               "error_doc": "        raise:  NullArgument - ``function_receiver`` or ``proxy`` is\n                ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_function_notification()`` is\n                ``false``", 
               "sphinx_param_doc": "        :param function_receiver: the function receiver\n        :type function_receiver: ``osid.authorization.FunctionReceiver``\n        :param proxy: a proxy\n        :type proxy: ``osid.proxy.Proxy``\n", 
               "sphinx_return_doc": "        :return: a ``FunctionNotificationSession``\n        :rtype: ``osid.authorization.FunctionNotificationSession``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``function_receiver`` or ``proxy`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_function_notification()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_function_notification()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.authorization.FunctionReceiver", 
                     "var_name": "function_receiver", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.proxy.Proxy", 
                     "var_name": "proxy", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.authorization.FunctionReceiver", 
                  "osid.proxy.Proxy"
               ], 
               "return_type": "osid.authorization.FunctionNotificationSession", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_function_notification_session_for_vault", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` associated with the function notification service for the given vault.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    function_receiver (osid.authorization.FunctionReceiver):\n                the function receiver\n        arg:    vault_id (osid.id.Id): the ``Id`` of the vault\n        arg:    proxy (osid.proxy.Proxy): a proxy\n", 
               "return_doc": "        return: (osid.authorization.FunctionNotificationSession) - ``a\n                FunctionNotificationSession``", 
               "error_doc": "        raise:  NotFound - ``vault_id`` not found\n        raise:  NullArgument - ``function_receiver`` or ``vault_id`` or\n                ``proxy`` is ``null``\n        raise:  OperationFailed - ``unable to complete request``\n        raise:  Unimplemented - ``supports_function_notification()`` or\n                ``supports_visible_federation()`` is ``false``", 
               "sphinx_param_doc": "        :param function_receiver: the function receiver\n        :type function_receiver: ``osid.authorization.FunctionReceiver``\n        :param vault_id: the ``Id`` of the vault\n        :type vault_id: ``osid.id.Id``\n        :param proxy: a proxy\n        :type proxy: ``osid.proxy.Proxy``\n", 
               "sphinx_return_doc": "        :return: ``a FunctionNotificationSession``\n        :rtype: ``osid.authorization.FunctionNotificationSession``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``vault_id`` not found\n        :raise: ``NullArgument`` -- ``function_receiver`` or ``vault_id`` or ``proxy`` is ``null``\n        :raise: ``OperationFailed`` -- ``unable to complete request``\n        :raise: ``Unimplemented`` -- ``supports_function_notification()`` or ``supports_visible_federation()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_function_notification()`` and ``supports_visible_federation()`` are ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.authorization.FunctionReceiver", 
                     "var_name": "function_receiver", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "vault_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.proxy.Proxy", 
                     "var_name": "proxy", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.authorization.FunctionReceiver", 
                  "osid.id.Id", 
                  "osid.proxy.Proxy"
               ], 
               "return_type": "osid.authorization.FunctionNotificationSession", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_function_vault_session", 
               "doc": {
                  "headline": "Gets the session for retrieving function to vault mappings.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    proxy (osid.proxy.Proxy): a proxy\n", 
               "return_doc": "        return: (osid.authorization.FunctionVaultSession) - a\n                ``FunctionVaultSession``", 
               "error_doc": "        raise:  NullArgument - ``proxy`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_function_vault()`` is\n                ``false``", 
               "sphinx_param_doc": "        :param proxy: a proxy\n        :type proxy: ``osid.proxy.Proxy``\n", 
               "sphinx_return_doc": "        :return: a ``FunctionVaultSession``\n        :rtype: ``osid.authorization.FunctionVaultSession``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``proxy`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_function_vault()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_function_vault()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.proxy.Proxy", 
                     "var_name": "proxy", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.proxy.Proxy"
               ], 
               "return_type": "osid.authorization.FunctionVaultSession", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_function_vault_assignment_session", 
               "doc": {
                  "headline": "Gets the session for assigning function to vault mappings.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    proxy (osid.proxy.Proxy): a proxy\n", 
               "return_doc": "        return: (osid.authorization.FunctionVaultAssignmentSession) - a\n                ``FunctionVaultAssignmentSession``", 
               "error_doc": "        raise:  NullArgument - ``proxy`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_function_vault_assignment()``\n                is ``false``", 
               "sphinx_param_doc": "        :param proxy: a proxy\n        :type proxy: ``osid.proxy.Proxy``\n", 
               "sphinx_return_doc": "        :return: a ``FunctionVaultAssignmentSession``\n        :rtype: ``osid.authorization.FunctionVaultAssignmentSession``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``proxy`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_function_vault_assignment()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_function_vault_assignment()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.proxy.Proxy", 
                     "var_name": "proxy", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.proxy.Proxy"
               ], 
               "return_type": "osid.authorization.FunctionVaultAssignmentSession", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_function_smart_vault_session", 
               "doc": {
                  "headline": "Gets the session for managing dynamic function vaults for the given vault.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    vault_id (osid.id.Id): the ``Id`` of a vault\n        arg:    proxy (osid.proxy.Proxy): a proxy\n", 
               "return_doc": "        return: (osid.authorization.FunctionSmartVaultSession) -\n                ``vault_id`` not found", 
               "error_doc": "        raise:  NotFound - ``vault_id`` or ``proxy`` is ``null``\n        raise:  NullArgument - ``vault_id`` or ``proxy`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_function_smart_vault()`` is\n                ``false``", 
               "sphinx_param_doc": "        :param vault_id: the ``Id`` of a vault\n        :type vault_id: ``osid.id.Id``\n        :param proxy: a proxy\n        :type proxy: ``osid.proxy.Proxy``\n", 
               "sphinx_return_doc": "        :return: ``vault_id`` not found\n        :rtype: ``osid.authorization.FunctionSmartVaultSession``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``vault_id`` or ``proxy`` is ``null``\n        :raise: ``NullArgument`` -- ``vault_id`` or ``proxy`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_function_smart_vault()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_function_smart_vault()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "vault_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.proxy.Proxy", 
                     "var_name": "proxy", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "osid.proxy.Proxy"
               ], 
               "return_type": "osid.authorization.FunctionSmartVaultSession", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_qualifier_lookup_session", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` associated with the qualifier lookup service.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    proxy (osid.proxy.Proxy): a proxy\n", 
               "return_doc": "        return: (osid.authorization.QualifierLookupSession) - a\n                ``QualifierLookupSession``", 
               "error_doc": "        raise:  NullArgument - ``proxy`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_qualifier_lookup()`` is\n                ``false``", 
               "sphinx_param_doc": "        :param proxy: a proxy\n        :type proxy: ``osid.proxy.Proxy``\n", 
               "sphinx_return_doc": "        :return: a ``QualifierLookupSession``\n        :rtype: ``osid.authorization.QualifierLookupSession``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``proxy`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_qualifier_lookup()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_qualifier_lookup()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.proxy.Proxy", 
                     "var_name": "proxy", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.proxy.Proxy"
               ], 
               "return_type": "osid.authorization.QualifierLookupSession", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_qualifier_lookup_session_for_vault", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` associated with the qualifier lookup service for the given vault.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    vault_id (osid.id.Id): the ``Id`` of the vault\n        arg:    proxy (osid.proxy.Proxy): a proxy\n", 
               "return_doc": "        return: (osid.authorization.QualifierLookupSession) - a\n                ``QualifierLookupSession``", 
               "error_doc": "        raise:  NotFound - ``vault_id`` not found\n        raise:  NullArgument - ``vault_id`` or ``proxy`` is ``null``\n        raise:  OperationFailed - ``unable to complete request``\n        raise:  Unimplemented - ``supports_qualifier_lookup()`` or\n                ``supports_visible_federation()`` is ``false``", 
               "sphinx_param_doc": "        :param vault_id: the ``Id`` of the vault\n        :type vault_id: ``osid.id.Id``\n        :param proxy: a proxy\n        :type proxy: ``osid.proxy.Proxy``\n", 
               "sphinx_return_doc": "        :return: a ``QualifierLookupSession``\n        :rtype: ``osid.authorization.QualifierLookupSession``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``vault_id`` not found\n        :raise: ``NullArgument`` -- ``vault_id`` or ``proxy`` is ``null``\n        :raise: ``OperationFailed`` -- ``unable to complete request``\n        :raise: ``Unimplemented`` -- ``supports_qualifier_lookup()`` or ``supports_visible_federation()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_qualifier_lookup()`` and ``supports_visible_federation()`` are ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "vault_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.proxy.Proxy", 
                     "var_name": "proxy", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "osid.proxy.Proxy"
               ], 
               "return_type": "osid.authorization.QualifierLookupSession", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_qualifier_query_session", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` associated with the qualifier query service.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    proxy (osid.proxy.Proxy): a proxy\n", 
               "return_doc": "        return: (osid.authorization.QualifierQuerySession) - a\n                ``QualifierQuerySession``", 
               "error_doc": "        raise:  NullArgument - ``proxy`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_qualifier_query()`` is\n                ``false``", 
               "sphinx_param_doc": "        :param proxy: a proxy\n        :type proxy: ``osid.proxy.Proxy``\n", 
               "sphinx_return_doc": "        :return: a ``QualifierQuerySession``\n        :rtype: ``osid.authorization.QualifierQuerySession``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``proxy`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_qualifier_query()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_qualifier_search()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.proxy.Proxy", 
                     "var_name": "proxy", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.proxy.Proxy"
               ], 
               "return_type": "osid.authorization.QualifierQuerySession", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_qualifier_query_session_for_vault", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` associated with the qualifier query service for the given vault.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    vault_id (osid.id.Id): the ``Id`` of the vault\n        arg:    proxy (osid.proxy.Proxy): a proxy\n", 
               "return_doc": "        return: (osid.authorization.QualifierQuerySession) - a\n                ``QualifierQuerySession``", 
               "error_doc": "        raise:  NotFound - ``vault_id`` not found\n        raise:  NullArgument - ``vault_id`` or ``proxy`` is ``null``\n        raise:  OperationFailed - ``unable to complete request``\n        raise:  Unimplemented - ``supports_qualifier_query()`` or\n                ``supports_visible_federation()`` is ``false``", 
               "sphinx_param_doc": "        :param vault_id: the ``Id`` of the vault\n        :type vault_id: ``osid.id.Id``\n        :param proxy: a proxy\n        :type proxy: ``osid.proxy.Proxy``\n", 
               "sphinx_return_doc": "        :return: a ``QualifierQuerySession``\n        :rtype: ``osid.authorization.QualifierQuerySession``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``vault_id`` not found\n        :raise: ``NullArgument`` -- ``vault_id`` or ``proxy`` is ``null``\n        :raise: ``OperationFailed`` -- ``unable to complete request``\n        :raise: ``Unimplemented`` -- ``supports_qualifier_query()`` or ``supports_visible_federation()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_qualifier_query()`` and ``supports_visible_federation()`` are ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "vault_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.proxy.Proxy", 
                     "var_name": "proxy", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "osid.proxy.Proxy"
               ], 
               "return_type": "osid.authorization.QualifierQuerySession", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_qualifier_search_session", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` associated with the qualifier search service.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    proxy (osid.proxy.Proxy): a proxy\n", 
               "return_doc": "        return: (osid.authorization.QualifierSearchSession) - a\n                ``QualifierSearchSession``", 
               "error_doc": "        raise:  NullArgument - ``proxy`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_qualifier_search()`` is\n                ``false``", 
               "sphinx_param_doc": "        :param proxy: a proxy\n        :type proxy: ``osid.proxy.Proxy``\n", 
               "sphinx_return_doc": "        :return: a ``QualifierSearchSession``\n        :rtype: ``osid.authorization.QualifierSearchSession``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``proxy`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_qualifier_search()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_qualifier_search()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.proxy.Proxy", 
                     "var_name": "proxy", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.proxy.Proxy"
               ], 
               "return_type": "osid.authorization.QualifierSearchSession", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_qualifier_search_session_for_vault", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` associated with the qualifier search service for the given vault.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    vault_id (osid.id.Id): the ``Id`` of the vault\n        arg:    proxy (osid.proxy.Proxy): a proxy\n", 
               "return_doc": "        return: (osid.authorization.QualifierSearchSession) - a\n                ``QualifierSearchSession``", 
               "error_doc": "        raise:  NotFound - ``vault_id`` not found\n        raise:  NullArgument - ``vault_id`` or ``proxy`` is ``null``\n        raise:  OperationFailed - ``unable to complete request``\n        raise:  Unimplemented - ``supports_qualifier_search()`` or\n                ``supports_visible_federation()`` is ``false``", 
               "sphinx_param_doc": "        :param vault_id: the ``Id`` of the vault\n        :type vault_id: ``osid.id.Id``\n        :param proxy: a proxy\n        :type proxy: ``osid.proxy.Proxy``\n", 
               "sphinx_return_doc": "        :return: a ``QualifierSearchSession``\n        :rtype: ``osid.authorization.QualifierSearchSession``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``vault_id`` not found\n        :raise: ``NullArgument`` -- ``vault_id`` or ``proxy`` is ``null``\n        :raise: ``OperationFailed`` -- ``unable to complete request``\n        :raise: ``Unimplemented`` -- ``supports_qualifier_search()`` or ``supports_visible_federation()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_qualifier_search()`` and ``supports_visible_federation()`` are ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "vault_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.proxy.Proxy", 
                     "var_name": "proxy", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "osid.proxy.Proxy"
               ], 
               "return_type": "osid.authorization.QualifierSearchSession", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_qualifier_admin_session", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` associated with the qualifier administration service.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    proxy (osid.proxy.Proxy): a proxy\n", 
               "return_doc": "        return: (osid.authorization.QualifierAdminSession) - a\n                ``QualifierAdminSession``", 
               "error_doc": "        raise:  NullArgument - ``proxy`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_qualifier_admin()`` is\n                ``false``", 
               "sphinx_param_doc": "        :param proxy: a proxy\n        :type proxy: ``osid.proxy.Proxy``\n", 
               "sphinx_return_doc": "        :return: a ``QualifierAdminSession``\n        :rtype: ``osid.authorization.QualifierAdminSession``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``proxy`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_qualifier_admin()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_qualifier_admin()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.proxy.Proxy", 
                     "var_name": "proxy", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.proxy.Proxy"
               ], 
               "return_type": "osid.authorization.QualifierAdminSession", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_qualifier_admin_session_for_vault", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` associated with the qualifier admin service for the given vault.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    vault_id (osid.id.Id): the ``Id`` of the vault\n        arg:    proxy (osid.proxy.Proxy): a proxy\n", 
               "return_doc": "        return: (osid.authorization.QualifierAdminSession) - a\n                ``QualifierAdminSession``", 
               "error_doc": "        raise:  NotFound - ``vault_id`` not found\n        raise:  NullArgument - ``vault_id`` or ``proxy`` is ``null``\n        raise:  OperationFailed - ``unable to complete request``\n        raise:  Unimplemented - ``supports_qualifier_admin()`` or\n                ``supports_visible_federation()`` is ``false``", 
               "sphinx_param_doc": "        :param vault_id: the ``Id`` of the vault\n        :type vault_id: ``osid.id.Id``\n        :param proxy: a proxy\n        :type proxy: ``osid.proxy.Proxy``\n", 
               "sphinx_return_doc": "        :return: a ``QualifierAdminSession``\n        :rtype: ``osid.authorization.QualifierAdminSession``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``vault_id`` not found\n        :raise: ``NullArgument`` -- ``vault_id`` or ``proxy`` is ``null``\n        :raise: ``OperationFailed`` -- ``unable to complete request``\n        :raise: ``Unimplemented`` -- ``supports_qualifier_admin()`` or ``supports_visible_federation()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_qualifier_admin()`` and ``supports_visible_federation()`` are ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "vault_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.proxy.Proxy", 
                     "var_name": "proxy", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "osid.proxy.Proxy"
               ], 
               "return_type": "osid.authorization.QualifierAdminSession", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_qualifier_notification_session", 
               "doc": {
                  "headline": "Gets the notification session for notifications pertaining to qualifier changes.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    qualifier_receiver\n                (osid.authorization.QualifierReceiver): the qualifier\n                receiver\n        arg:    proxy (osid.proxy.Proxy): a proxy\n", 
               "return_doc": "        return: (osid.authorization.QualifierNotificationSession) - a\n                ``QualifierNotificationSession``", 
               "error_doc": "        raise:  NullArgument - ``qualifier_receiver`` or ``proxy`` is\n                ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_qualifier_notification()`` is\n                ``false``", 
               "sphinx_param_doc": "        :param qualifier_receiver: the qualifier receiver\n        :type qualifier_receiver: ``osid.authorization.QualifierReceiver``\n        :param proxy: a proxy\n        :type proxy: ``osid.proxy.Proxy``\n", 
               "sphinx_return_doc": "        :return: a ``QualifierNotificationSession``\n        :rtype: ``osid.authorization.QualifierNotificationSession``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``qualifier_receiver`` or ``proxy`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_qualifier_notification()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_qualifier_notification()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.authorization.QualifierReceiver", 
                     "var_name": "qualifier_receiver", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.proxy.Proxy", 
                     "var_name": "proxy", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.authorization.QualifierReceiver", 
                  "osid.proxy.Proxy"
               ], 
               "return_type": "osid.authorization.QualifierNotificationSession", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_qualifier_notification_session_for_vault", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` associated with the qualifier notification service for the given vault.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    qualifier_receiver\n                (osid.authorization.QualifierReceiver): the qualifier\n                receiver\n        arg:    vault_id (osid.id.Id): the ``Id`` of the vault\n        arg:    proxy (osid.proxy.Proxy): a proxy\n", 
               "return_doc": "        return: (osid.authorization.QualifierNotificationSession) - a\n                ``QualifierNotificationSession``", 
               "error_doc": "        raise:  NotFound - ``vault_id`` not found\n        raise:  NullArgument - ``qualifier_receiver`` or ``vault_id`` or\n                ``proxy`` is ``null``\n        raise:  OperationFailed - ``unable to complete request``\n        raise:  Unimplemented - ``supports_qualifier_notification()`` or\n                ``supports_visible_federation()`` is ``false``", 
               "sphinx_param_doc": "        :param qualifier_receiver: the qualifier receiver\n        :type qualifier_receiver: ``osid.authorization.QualifierReceiver``\n        :param vault_id: the ``Id`` of the vault\n        :type vault_id: ``osid.id.Id``\n        :param proxy: a proxy\n        :type proxy: ``osid.proxy.Proxy``\n", 
               "sphinx_return_doc": "        :return: a ``QualifierNotificationSession``\n        :rtype: ``osid.authorization.QualifierNotificationSession``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``vault_id`` not found\n        :raise: ``NullArgument`` -- ``qualifier_receiver`` or ``vault_id`` or ``proxy`` is ``null``\n        :raise: ``OperationFailed`` -- ``unable to complete request``\n        :raise: ``Unimplemented`` -- ``supports_qualifier_notification()`` or ``supports_visible_federation()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_qualifier_notification()`` and ``supports_visible_federation()`` are ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.authorization.QualifierReceiver", 
                     "var_name": "qualifier_receiver", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "vault_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.proxy.Proxy", 
                     "var_name": "proxy", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.authorization.QualifierReceiver", 
                  "osid.id.Id", 
                  "osid.proxy.Proxy"
               ], 
               "return_type": "osid.authorization.QualifierNotificationSession", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_qualifier_hierarchy_session", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` associated with the qualifier hierarchy traversal service.", 
                  "body": "        The authorization service uses distinct hierarchies that can be\n        managed through a Hierarchy OSID."
               }, 
               "arg_doc": "        arg:    qualifier_hierarchy_id (osid.id.Id): the ``Id`` of a\n                qualifier hierarchy\n        arg:    proxy (osid.proxy.Proxy): a proxy\n", 
               "return_doc": "        return: (osid.authorization.QualifierHierarchySession) - a\n                ``QualifierHierarchySession``", 
               "error_doc": "        raise:  NotFound - ``qualifier_hierarchy_id`` not found\n        raise:  NullArgument - ``qualifier_hierarchy_id`` or ``proxy``\n                is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_qualifier_hierarchy()`` is\n                ``false``", 
               "sphinx_param_doc": "        :param qualifier_hierarchy_id: the ``Id`` of a qualifier hierarchy\n        :type qualifier_hierarchy_id: ``osid.id.Id``\n        :param proxy: a proxy\n        :type proxy: ``osid.proxy.Proxy``\n", 
               "sphinx_return_doc": "        :return: a ``QualifierHierarchySession``\n        :rtype: ``osid.authorization.QualifierHierarchySession``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``qualifier_hierarchy_id`` not found\n        :raise: ``NullArgument`` -- ``qualifier_hierarchy_id`` or ``proxy`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_qualifier_hierarchy()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_qualifier_hierarchy()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "qualifier_hierarchy_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.proxy.Proxy", 
                     "var_name": "proxy", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "osid.proxy.Proxy"
               ], 
               "return_type": "osid.authorization.QualifierHierarchySession", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_qualifier_hierarchy_design_session", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` associated with the qualifier hierarchy design service.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    qualifier_hierarchy_id (osid.id.Id): the ``Id`` of a\n                qualifier hierarchy\n        arg:    proxy (osid.proxy.Proxy): a proxy\n", 
               "return_doc": "        return: (osid.authorization.QualifierHierarchyDesignSession) - a\n                ``QualifierHierarchyDesignSession``", 
               "error_doc": "        raise:  NotFound - ``qualifier_hierarchy_id`` not found\n        raise:  NullArgument - ``qualifier_hierarchy_id`` or ``proxy``\n                is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented -\n                ``supports_qualifier_hierarchy_design()`` is ``false``", 
               "sphinx_param_doc": "        :param qualifier_hierarchy_id: the ``Id`` of a qualifier hierarchy\n        :type qualifier_hierarchy_id: ``osid.id.Id``\n        :param proxy: a proxy\n        :type proxy: ``osid.proxy.Proxy``\n", 
               "sphinx_return_doc": "        :return: a ``QualifierHierarchyDesignSession``\n        :rtype: ``osid.authorization.QualifierHierarchyDesignSession``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``qualifier_hierarchy_id`` not found\n        :raise: ``NullArgument`` -- ``qualifier_hierarchy_id`` or ``proxy`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_qualifier_hierarchy_design()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_qualifier_hierarchy_design()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "qualifier_hierarchy_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.proxy.Proxy", 
                     "var_name": "proxy", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "osid.proxy.Proxy"
               ], 
               "return_type": "osid.authorization.QualifierHierarchyDesignSession", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_qualifier_vault_session", 
               "doc": {
                  "headline": "Gets the session for retrieving qualifier to vault mappings.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    proxy (osid.proxy.Proxy): a proxy\n", 
               "return_doc": "        return: (osid.authorization.QualifierVaultSession) - a\n                ``QualifierVaultSession``", 
               "error_doc": "        raise:  NullArgument - ``proxy`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_qualifier_vault()`` is\n                ``false``", 
               "sphinx_param_doc": "        :param proxy: a proxy\n        :type proxy: ``osid.proxy.Proxy``\n", 
               "sphinx_return_doc": "        :return: a ``QualifierVaultSession``\n        :rtype: ``osid.authorization.QualifierVaultSession``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``proxy`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_qualifier_vault()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_qualifier_vault()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.proxy.Proxy", 
                     "var_name": "proxy", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.proxy.Proxy"
               ], 
               "return_type": "osid.authorization.QualifierVaultSession", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_qualifier_vault_assignment_session", 
               "doc": {
                  "headline": "Gets the session for assigning qualifier to vault mappings.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    proxy (osid.proxy.Proxy): a proxy\n", 
               "return_doc": "        return: (osid.authorization.QualifierVaultSession) - a\n                ``QualifierVaultAssignmentSession``", 
               "error_doc": "        raise:  NullArgument - ``proxy`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented -\n                ``supports_qualifier_vault_assignment()`` is ``false``", 
               "sphinx_param_doc": "        :param proxy: a proxy\n        :type proxy: ``osid.proxy.Proxy``\n", 
               "sphinx_return_doc": "        :return: a ``QualifierVaultAssignmentSession``\n        :rtype: ``osid.authorization.QualifierVaultSession``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``proxy`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_qualifier_vault_assignment()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_qualifier_vault_assignment()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.proxy.Proxy", 
                     "var_name": "proxy", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.proxy.Proxy"
               ], 
               "return_type": "osid.authorization.QualifierVaultSession", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_qualifier_smart_vault_session", 
               "doc": {
                  "headline": "Gets the session for managing dynamic qualifier vaults for the given vault.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    vault_id (osid.id.Id): the ``Id`` of a vault\n        arg:    proxy (osid.proxy.Proxy): a proxy\n", 
               "return_doc": "        return: (osid.authorization.QualifierSmartVaultSession) -\n                ``vault_id`` not found", 
               "error_doc": "        raise:  NotFound - ``vault_id`` or ``proxy`` is ``null``\n        raise:  NullArgument - ``vault_id`` or ``proxy`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_qualifier_smart_vault()`` is\n                ``false``", 
               "sphinx_param_doc": "        :param vault_id: the ``Id`` of a vault\n        :type vault_id: ``osid.id.Id``\n        :param proxy: a proxy\n        :type proxy: ``osid.proxy.Proxy``\n", 
               "sphinx_return_doc": "        :return: ``vault_id`` not found\n        :rtype: ``osid.authorization.QualifierSmartVaultSession``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``vault_id`` or ``proxy`` is ``null``\n        :raise: ``NullArgument`` -- ``vault_id`` or ``proxy`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_qualifier_smart_vault()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_qualifier_smart_vault()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "vault_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.proxy.Proxy", 
                     "var_name": "proxy", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "osid.proxy.Proxy"
               ], 
               "return_type": "osid.authorization.QualifierSmartVaultSession", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_vault_lookup_session", 
               "doc": {
                  "headline": "Gets the OsidSession associated with the vault lookup service.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    proxy (osid.proxy.Proxy): a proxy\n", 
               "return_doc": "        return: (osid.authorization.VaultLookupSession) - a\n                ``VaultLookupSession``", 
               "error_doc": "        raise:  NullArgument - ``proxy`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_vault_lookup() is false``", 
               "sphinx_param_doc": "        :param proxy: a proxy\n        :type proxy: ``osid.proxy.Proxy``\n", 
               "sphinx_return_doc": "        :return: a ``VaultLookupSession``\n        :rtype: ``osid.authorization.VaultLookupSession``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``proxy`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_vault_lookup() is false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_vault_lookup()`` is true.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.proxy.Proxy", 
                     "var_name": "proxy", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.proxy.Proxy"
               ], 
               "return_type": "osid.authorization.VaultLookupSession", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_vault_query_session", 
               "doc": {
                  "headline": "Gets the OsidSession associated with the vault query service.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    proxy (osid.proxy.Proxy): a proxy\n", 
               "return_doc": "        return: (osid.authorization.VaultQuerySession) - a\n                ``VaultQuerySession``", 
               "error_doc": "        raise:  NullArgument - ``proxy`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_vault_query() is false``", 
               "sphinx_param_doc": "        :param proxy: a proxy\n        :type proxy: ``osid.proxy.Proxy``\n", 
               "sphinx_return_doc": "        :return: a ``VaultQuerySession``\n        :rtype: ``osid.authorization.VaultQuerySession``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``proxy`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_vault_query() is false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_vault_query()`` is true.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.proxy.Proxy", 
                     "var_name": "proxy", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.proxy.Proxy"
               ], 
               "return_type": "osid.authorization.VaultQuerySession", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_vault_search_session", 
               "doc": {
                  "headline": "Gets the OsidSession associated with the vault search service.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    proxy (osid.proxy.Proxy): a proxy\n", 
               "return_doc": "        return: (osid.authorization.VaultSearchSession) - a\n                ``VaultSearchSession``", 
               "error_doc": "        raise:  NullArgument - ``proxy`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_vault_search() is false``", 
               "sphinx_param_doc": "        :param proxy: a proxy\n        :type proxy: ``osid.proxy.Proxy``\n", 
               "sphinx_return_doc": "        :return: a ``VaultSearchSession``\n        :rtype: ``osid.authorization.VaultSearchSession``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``proxy`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_vault_search() is false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_vault_search()`` is true.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.proxy.Proxy", 
                     "var_name": "proxy", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.proxy.Proxy"
               ], 
               "return_type": "osid.authorization.VaultSearchSession", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_vault_admin_session", 
               "doc": {
                  "headline": "Gets the OsidSession associated with the vault administration service.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    proxy (osid.proxy.Proxy): a proxy\n", 
               "return_doc": "        return: (osid.authorization.VaultAdminSession) - a\n                ``VaultAdminSession``", 
               "error_doc": "        raise:  NullArgument - ``proxy`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_vault_admin() is false``", 
               "sphinx_param_doc": "        :param proxy: a proxy\n        :type proxy: ``osid.proxy.Proxy``\n", 
               "sphinx_return_doc": "        :return: a ``VaultAdminSession``\n        :rtype: ``osid.authorization.VaultAdminSession``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``proxy`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_vault_admin() is false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_vault_admin()`` is true.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.proxy.Proxy", 
                     "var_name": "proxy", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.proxy.Proxy"
               ], 
               "return_type": "osid.authorization.VaultAdminSession", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_vault_notification_session", 
               "doc": {
                  "headline": "Gets the notification session for notifications pertaining to vault service changes.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    vault_receiver (osid.authorization.VaultReceiver): the\n                vault receiver\n        arg:    proxy (osid.proxy.Proxy): a proxy\n", 
               "return_doc": "        return: (osid.authorization.VaultNotificationSession) - a\n                ``VaultNotificationSession``", 
               "error_doc": "        raise:  NullArgument - ``vault_receiver`` or ``proxy`` is\n                ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_vault_notification() is\n                false``", 
               "sphinx_param_doc": "        :param vault_receiver: the vault receiver\n        :type vault_receiver: ``osid.authorization.VaultReceiver``\n        :param proxy: a proxy\n        :type proxy: ``osid.proxy.Proxy``\n", 
               "sphinx_return_doc": "        :return: a ``VaultNotificationSession``\n        :rtype: ``osid.authorization.VaultNotificationSession``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``vault_receiver`` or ``proxy`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_vault_notification() is false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_vault_notification()`` is true.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.authorization.VaultReceiver", 
                     "var_name": "vault_receiver", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.proxy.Proxy", 
                     "var_name": "proxy", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.authorization.VaultReceiver", 
                  "osid.proxy.Proxy"
               ], 
               "return_type": "osid.authorization.VaultNotificationSession", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_vault_hierarchy_session", 
               "doc": {
                  "headline": "Gets the session traversing vault hierarchies.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    proxy (osid.proxy.Proxy): a proxy\n", 
               "return_doc": "        return: (osid.authorization.VaultHierarchySession) - a\n                ``VaultHierarchySession``", 
               "error_doc": "        raise:  NullArgument - ``proxy`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_vault_hierarchy() is false``", 
               "sphinx_param_doc": "        :param proxy: a proxy\n        :type proxy: ``osid.proxy.Proxy``\n", 
               "sphinx_return_doc": "        :return: a ``VaultHierarchySession``\n        :rtype: ``osid.authorization.VaultHierarchySession``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``proxy`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_vault_hierarchy() is false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_vault_hierarchy()`` is true.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.proxy.Proxy", 
                     "var_name": "proxy", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.proxy.Proxy"
               ], 
               "return_type": "osid.authorization.VaultHierarchySession", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_vault_hierarchy_design_session", 
               "doc": {
                  "headline": "Gets the session designing vault hierarchies.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    proxy (osid.proxy.Proxy): a proxy\n", 
               "return_doc": "        return: (osid.authorization.VaultHierarchyDesignSession) - a\n                ``VaultHierarchySession``", 
               "error_doc": "        raise:  NullArgument - ``proxy`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_vault_hierarchy_design() is\n                false``", 
               "sphinx_param_doc": "        :param proxy: a proxy\n        :type proxy: ``osid.proxy.Proxy``\n", 
               "sphinx_return_doc": "        :return: a ``VaultHierarchySession``\n        :rtype: ``osid.authorization.VaultHierarchyDesignSession``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``proxy`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_vault_hierarchy_design() is false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_vault_hierarchy_design()`` is true.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.proxy.Proxy", 
                     "var_name": "proxy", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.proxy.Proxy"
               ], 
               "return_type": "osid.authorization.VaultHierarchyDesignSession", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_authorization_batch_proxy_manager", 
               "doc": {
                  "headline": "Gets an ``AuthorizationBatchProxyManager``.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return:\n                (osid.authorization.batch.AuthorizationBatchProxyManager\n                ) - an ``AuthorizationBatchProxyManager``", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_authorization_batch() is\n                false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: an ``AuthorizationBatchProxyManager``\n        :rtype: ``osid.authorization.batch.AuthorizationBatchProxyManager``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_authorization_batch() is false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_authorization_batch()`` is true.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.authorization.batch.AuthorizationBatchProxyManager", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_authorization_rules_proxy_manager", 
               "doc": {
                  "headline": "Gets an ``AuthorizationRulesProxyManager``.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return:\n                (osid.authorization.rules.AuthorizationRulesProxyManager\n                ) - an ``AuthorizationRulesProxyManager``", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_authorization_rules() is\n                false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: an ``AuthorizationRulesProxyManager``\n        :rtype: ``osid.authorization.rules.AuthorizationRulesProxyManager``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_authorization_rules() is false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_authorization_rules()`` is true.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.authorization.rules.AuthorizationRulesProxyManager", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.authorization.AuthorizationSession", 
         "shortname": "AuthorizationSession", 
         "category": "sessions", 
         "doc": {
            "headline": "This is the basic session for verifying authorizations.", 
            "body": ""
         }, 
         "inherit_fullnames": [
            "osid.OsidSession"
         ], 
         "inherit_shortnames": [
            "OsidSession"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidSession"
            }
         ], 
         "method_names": [
            "get_vault_id", 
            "get_vault", 
            "can_access_authorizations", 
            "is_authorized", 
            "get_authorization_condition", 
            "is_authorized_on_condition"
         ], 
         "methods": [
            {
               "name": "get_vault_id", 
               "doc": {
                  "headline": "Gets the ``Vault``  ``Id`` associated with this session.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.id.Id) - the ``Vault Id`` associated with this\n                session", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the ``Vault Id`` associated with this session\n        :rtype: ``osid.id.Id``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.id.Id", 
               "errors": {}
            }, 
            {
               "name": "get_vault", 
               "doc": {
                  "headline": "Gets the ``Vault`` associated with this session.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.authorization.Vault) - the ``Vault`` associated\n                with this session", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the ``Vault`` associated with this session\n        :rtype: ``osid.authorization.Vault``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.authorization.Vault", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "can_access_authorizations", 
               "doc": {
                  "headline": "Tests if this user can perform authorization checks.", 
                  "body": "        A return of true does not guarantee successful authorization. A\n        return of false indicates that it is known all methods in this\n        session will result in a ``PermissionDenied``. This is intended\n        as a hint to an application that may opt not to offer lookup\n        operations to unauthorized users."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``false`` if authorization methods are not\n                authorized, ``true`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``false`` if authorization methods are not authorized, ``true`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "is_authorized", 
               "doc": {
                  "headline": "Determines if the given agent is authorized.", 
                  "body": "        An agent is authorized if an active authorization exists whose\n        ``Agent,`` ``Function`` and ``Qualifier`` matches the supplied\n        parameters. Authorizations may be defined using groupings or\n        hieratchical structures for both the ``Agent`` and the\n        ``Qualifier`` but are queried in the de-nornmalized form.\n\n        The ``Agent`` is generally determined through the use of an\n        Authentication OSID. The ``Function`` and ``Qualifier`` are\n        already known as they map to the desired authorization to\n        validate."
               }, 
               "arg_doc": "        arg:    agent_id (osid.id.Id): the ``Id`` of an ``Agent``\n        arg:    function_id (osid.id.Id): the ``Id`` of a ``Function``\n        arg:    qualifier_id (osid.id.Id): the ``Id`` of a ``Qualifier``\n", 
               "return_doc": "        return: (boolean) - ``true`` if the user is authorized,\n                ``false`` othersise", 
               "error_doc": "        raise:  NotFound - ``function_id`` is not found\n        raise:  NullArgument - ``agent_id`` , ``function_id`` or\n                ``qualifier_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure making request", 
               "sphinx_param_doc": "        :param agent_id: the ``Id`` of an ``Agent``\n        :type agent_id: ``osid.id.Id``\n        :param function_id: the ``Id`` of a ``Function``\n        :type function_id: ``osid.id.Id``\n        :param qualifier_id: the ``Id`` of a ``Qualifier``\n        :type qualifier_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: ``true`` if the user is authorized, ``false`` othersise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``function_id`` is not found\n        :raise: ``NullArgument`` -- ``agent_id`` , ``function_id`` or ``qualifier_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure making request", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "        *implementation notes*: Authorizations may be stored in a\n        normalized form with respect to various Resources and created\n        using specific nodes in a ``Function`` or ``Qualifer``\n        hierarchy. The provider needs to maintain a de-normalized\n        implicit authorization store or expand the applicable\n        hierarchies on the fly to honor this query.  Querying the\n        authorization service may in itself require a separate\n        authorization. A ``PermissionDenied`` is a result of this\n        authorization failure. If no explicit or implicit authorization\n        exists for the queried tuple, this method should return\n        ``false``.\n", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "agent_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "function_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "qualifier_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "osid.id.Id", 
                  "osid.id.Id"
               ], 
               "return_type": "boolean", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_authorization_condition", 
               "doc": {
                  "headline": "Gets the ``AuthorizationCondition`` for making conditional authorization checks.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    function_id (osid.id.Id): the ``Id`` of a ``Function``\n", 
               "return_doc": "        return: (osid.authorization.AuthorizationCondition) - an\n                authorization condition", 
               "error_doc": "        raise:  NotFound - ``function_id`` is not found\n        raise:  NullArgument - ``function_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure making request", 
               "sphinx_param_doc": "        :param function_id: the ``Id`` of a ``Function``\n        :type function_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: an authorization condition\n        :rtype: ``osid.authorization.AuthorizationCondition``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``function_id`` is not found\n        :raise: ``NullArgument`` -- ``function_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure making request", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "function_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "osid.authorization.AuthorizationCondition", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "is_authorized_on_condition", 
               "doc": {
                  "headline": "Determines if the given agent is authorized.", 
                  "body": "        An agent is authorized if an active authorization exists whose\n        ``Agent,`` ``Function`` and ``Qualifier`` matches the supplied\n        parameters. Authorizations may be defined using groupings or\n        hieratchical structures for both the ``Agent`` and the\n        ``Qualifier`` but are queried in the de-nornmalized form.\n\n        The ``Agent`` is generally determined through the use of an\n        Authentication OSID. The ``Function`` and ``Qualifier`` are\n        already known as they map to the desired authorization to\n        validate."
               }, 
               "arg_doc": "        arg:    agent_id (osid.id.Id): the ``Id`` of an ``Agent``\n        arg:    function_id (osid.id.Id): the ``Id`` of a ``Function``\n        arg:    qualifier_id (osid.id.Id): the ``Id`` of a ``Qualifier``\n        arg:    condition (osid.authorization.AuthorizationCondition):\n                an authorization condition\n", 
               "return_doc": "        return: (boolean) - ``true`` if the user is authorized,\n                ``false`` othersise", 
               "error_doc": "        raise:  NotFound - ``function_id`` is not found\n        raise:  NullArgument - ``agent_id`` , ``function_id,\n                qualifier_id`` , or ``condition`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure making request\n        raise:  Unsupported - ``condition`` is not of this service", 
               "sphinx_param_doc": "        :param agent_id: the ``Id`` of an ``Agent``\n        :type agent_id: ``osid.id.Id``\n        :param function_id: the ``Id`` of a ``Function``\n        :type function_id: ``osid.id.Id``\n        :param qualifier_id: the ``Id`` of a ``Qualifier``\n        :type qualifier_id: ``osid.id.Id``\n        :param condition: an authorization condition\n        :type condition: ``osid.authorization.AuthorizationCondition``\n", 
               "sphinx_return_doc": "        :return: ``true`` if the user is authorized, ``false`` othersise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``function_id`` is not found\n        :raise: ``NullArgument`` -- ``agent_id`` , ``function_id, qualifier_id`` , or ``condition`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure making request\n        :raise: ``Unsupported`` -- ``condition`` is not of this service", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "        *implementation notes*: Authorizations may be stored in a\n        normalized form with respect to various Resources and created\n        using specific nodes in a ``Function`` or ``Qualifer``\n        hierarchy. The provider needs to maintain a de-normalized\n        implicit authorization store or expand the applicable\n        hierarchies on the fly to honor this query.  Querying the\n        authorization service may in itself require a separate\n        authorization. A ``PermissionDenied`` is a result of this\n        authorization failure. If no explicit or implicit authorization\n        exists for the queried tuple, this method should return\n        ``false``.\n", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "agent_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "function_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "qualifier_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.authorization.AuthorizationCondition", 
                     "var_name": "condition", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "osid.id.Id", 
                  "osid.id.Id", 
                  "osid.authorization.AuthorizationCondition"
               ], 
               "return_type": "boolean", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.authorization.AuthorizationLookupSession", 
         "shortname": "AuthorizationLookupSession", 
         "category": "sessions", 
         "doc": {
            "headline": "This session defines methods to search and retrieve ``Authorization`` mappings.", 
            "body": ""
         }, 
         "inherit_fullnames": [
            "osid.OsidSession"
         ], 
         "inherit_shortnames": [
            "OsidSession"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidSession"
            }
         ], 
         "method_names": [
            "get_vault_id", 
            "get_vault", 
            "can_lookup_authorizations", 
            "use_comparative_authorization_view", 
            "use_plenary_authorization_view", 
            "use_federated_vault_view", 
            "use_isolated_vault_view", 
            "use_effective_authorization_view", 
            "use_any_effective_authorization_view", 
            "use_implicit_authorization_view", 
            "use_explicit_authorization_view", 
            "get_authorization", 
            "get_authorizations_by_ids", 
            "get_authorizations_by_genus_type", 
            "get_authorizations_by_parent_genus_type", 
            "get_authorizations_by_record_type", 
            "get_authorizations_on_date", 
            "get_authorizations_for_resource", 
            "get_authorizations_for_resource_on_date", 
            "get_authorizations_for_agent", 
            "get_authorizations_for_agent_on_date", 
            "get_authorizations_for_function", 
            "get_authorizations_for_function_on_date", 
            "get_authorizations_for_resource_and_function", 
            "get_authorizations_for_resource_and_function_on_date", 
            "get_authorizations_for_agent_and_function", 
            "get_authorizations_for_agent_and_function_on_date", 
            "get_authorizations_by_qualifier", 
            "get_explicit_authorization", 
            "get_authorizations"
         ], 
         "methods": [
            {
               "name": "get_vault_id", 
               "doc": {
                  "headline": "Gets the ``Vault``  ``Id`` associated with this session.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.id.Id) - the ``Vault Id`` associated with this\n                session", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the ``Vault Id`` associated with this session\n        :rtype: ``osid.id.Id``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.id.Id", 
               "errors": {}
            }, 
            {
               "name": "get_vault", 
               "doc": {
                  "headline": "Gets the ``Vault`` associated with this session.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.authorization.Vault) - the ``Vault`` associated\n                with this session", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the ``Vault`` associated with this session\n        :rtype: ``osid.authorization.Vault``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.authorization.Vault", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "can_lookup_authorizations", 
               "doc": {
                  "headline": "Tests if this user can perform authorization lookups.", 
                  "body": "        A return of true does not guarantee successful authorization. A\n        return of false indicates that it is known all methods in this\n        session will result in a ``PermissionDenied``. This is intended\n        as a hint to an application that may opt not to offer lookup\n        operations to unauthorized users."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``false`` if lookup methods are not\n                authorized, ``true`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``false`` if lookup methods are not authorized, ``true`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "use_comparative_authorization_view", 
               "doc": {
                  "headline": "The returns from the lookup methods may omit or translate elements based on this session, such as authorization, and not result in an error.", 
                  "body": "        This view is used when greater interoperability is desired at\n        the expense of precision."
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "use_plenary_authorization_view", 
               "doc": {
                  "headline": "A complete view of the ``Authorization`` returns is desired.", 
                  "body": "        Methods will return what is requested or result in an error.\n        This view is used when greater precision is desired at the\n        expense of interoperability."
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "use_federated_vault_view", 
               "doc": {
                  "headline": "Federates the view for methods in this session.", 
                  "body": "        A federated view will include authorizations in vaults which are\n        children of this vault in the vault hierarchy."
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "use_isolated_vault_view", 
               "doc": {
                  "headline": "Isolates the view for methods in this session.", 
                  "body": "        An isolated view restricts lookups to this vault only."
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "use_effective_authorization_view", 
               "doc": {
                  "headline": "Only authorizations whose effective dates are current are returned by methods in this session.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "use_any_effective_authorization_view", 
               "doc": {
                  "headline": "All authorizations of any effective dates are returned by all methods in this session.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "use_implicit_authorization_view", 
               "doc": {
                  "headline": "Sets the view for methods in this session to implicit authorizations.", 
                  "body": "        An implicit view will include authorizations derived from other\n        authorizations as a result of the ``Qualifier,`` ``Function`` or\n        ``Resource`` hierarchies. This method is the opposite of\n        ``explicitAuthorizationView()``."
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "use_explicit_authorization_view", 
               "doc": {
                  "headline": "Sets the view for methods in this session to explicit authorizations.", 
                  "body": "        An explicit view includes only those authorizations that were\n        explicitly defined and not implied. This method is the opposite\n        of ``implicitAuthorizationView()``."
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "get_authorization", 
               "doc": {
                  "headline": "Gets the ``Authorization`` specified by its ``Id``.", 
                  "body": "        In plenary mode, the exact ``Id`` is found or a ``NotFound``\n        results. Otherwise, the returned ``Authorization`` may have a\n        different ``Id`` than requested, such as the case where a\n        duplicate ``Id`` was assigned to an ``Authorization`` and\n        retained for compatibility."
               }, 
               "arg_doc": "        arg:    authorization_id (osid.id.Id): the ``Id`` of the\n                ``Authorization`` to retrieve\n", 
               "return_doc": "        return: (osid.authorization.Authorization) - the returned\n                ``Authorization``", 
               "error_doc": "        raise:  NotFound - no ``Authorization`` found with the given\n                ``Id``\n        raise:  NullArgument - ``authorization_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param authorization_id: the ``Id`` of the ``Authorization`` to retrieve\n        :type authorization_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: the returned ``Authorization``\n        :rtype: ``osid.authorization.Authorization``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- no ``Authorization`` found with the given ``Id``\n        :raise: ``NullArgument`` -- ``authorization_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "authorization_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "osid.authorization.Authorization", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_authorizations_by_ids", 
               "doc": {
                  "headline": "Gets an ``AuthorizationList`` corresponding to the given ``IdList``.", 
                  "body": "        In plenary mode, the returned list contains all of the\n        authorizations specified in the ``Id`` list, in the order of the\n        list, including duplicates, or an error results if an ``Id`` in\n        the supplied list is not found or inaccessible. Otherwise,\n        inaccessible ``Authorizations`` may be omitted from the list and\n        may present the elements in any order including returning a\n        unique set."
               }, 
               "arg_doc": "        arg:    authorization_ids (osid.id.IdList): the list of ``Ids``\n                to retrieve\n", 
               "return_doc": "        return: (osid.authorization.AuthorizationList) - the returned\n                ``Authorization list``", 
               "error_doc": "        raise:  NotFound - an ``Id was`` not found\n        raise:  NullArgument - ``authorization_ids`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param authorization_ids: the list of ``Ids`` to retrieve\n        :type authorization_ids: ``osid.id.IdList``\n", 
               "sphinx_return_doc": "        :return: the returned ``Authorization list``\n        :rtype: ``osid.authorization.AuthorizationList``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- an ``Id was`` not found\n        :raise: ``NullArgument`` -- ``authorization_ids`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.IdList", 
                     "var_name": "authorization_ids", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.IdList"
               ], 
               "return_type": "osid.authorization.AuthorizationList", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_authorizations_by_genus_type", 
               "doc": {
                  "headline": "Gets an ``AuthorizationList`` corresponding to the given authorization genus ``Type`` which does not include authorizations of genus types derived from the specified ``Type``.", 
                  "body": "        In plenary mode, the returned list contains all known\n        authorizations or an error results. Otherwise, the returned list\n        may contain only those authorizations that are accessible\n        through this session."
               }, 
               "arg_doc": "        arg:    authorization_genus_type (osid.type.Type): an\n                authorization genus type\n", 
               "return_doc": "        return: (osid.authorization.AuthorizationList) - the returned\n                ``Authorization`` list", 
               "error_doc": "        raise:  NullArgument - ``authorization_genus_type`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure occurred", 
               "sphinx_param_doc": "        :param authorization_genus_type: an authorization genus type\n        :type authorization_genus_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "        :return: the returned ``Authorization`` list\n        :rtype: ``osid.authorization.AuthorizationList``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``authorization_genus_type`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure occurred", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "authorization_genus_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "osid.authorization.AuthorizationList", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_authorizations_by_parent_genus_type", 
               "doc": {
                  "headline": "Gets an ``AuthorizationList`` corresponding to the given authorization genus ``Type`` and include authorizations of genus types derived from the specified ``Type``.", 
                  "body": "        In plenary mode, the returned list contains all known\n        authorizations or an error results. Otherwise, the returned list\n        may contain only those authorizations that are accessible\n        through this session."
               }, 
               "arg_doc": "        arg:    authorization_genus_type (osid.type.Type): an\n                authorization genus type\n", 
               "return_doc": "        return: (osid.authorization.AuthorizationList) - the returned\n                ``Authorization`` list", 
               "error_doc": "        raise:  NullArgument - ``authorization_genus_type`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure occurred", 
               "sphinx_param_doc": "        :param authorization_genus_type: an authorization genus type\n        :type authorization_genus_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "        :return: the returned ``Authorization`` list\n        :rtype: ``osid.authorization.AuthorizationList``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``authorization_genus_type`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure occurred", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "authorization_genus_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "osid.authorization.AuthorizationList", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_authorizations_by_record_type", 
               "doc": {
                  "headline": "Gets an ``AuthorizationList`` containing the given authorization record ``Type``.", 
                  "body": "        In plenary mode, the returned list contains all known\n        authorizations or an error results. Otherwise, the returned list\n        may contain only those authorizations that are accessible\n        through this session."
               }, 
               "arg_doc": "        arg:    authorization_record_type (osid.type.Type): an\n                authorization record type\n", 
               "return_doc": "        return: (osid.authorization.AuthorizationList) - the returned\n                ``Authorization`` list", 
               "error_doc": "        raise:  NullArgument - ``authorization_record_type`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure occurred", 
               "sphinx_param_doc": "        :param authorization_record_type: an authorization record type\n        :type authorization_record_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "        :return: the returned ``Authorization`` list\n        :rtype: ``osid.authorization.AuthorizationList``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``authorization_record_type`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure occurred", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "authorization_record_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "osid.authorization.AuthorizationList", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_authorizations_on_date", 
               "doc": {
                  "headline": "Gets an ``AuthorizationList`` effective during the entire given date range inclusive but not confined to the date range.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    from (osid.calendaring.DateTime): starting date\n        arg:    to (osid.calendaring.DateTime): ending date\n", 
               "return_doc": "        return: (osid.authorization.AuthorizationList) - the returned\n                ``Authorization`` list", 
               "error_doc": "        raise:  InvalidArgument - ``from`` is greater than ``to``\n        raise:  NullArgument - ``from`` or ``to`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure occurred", 
               "sphinx_param_doc": "        :param from: starting date\n        :type from: ``osid.calendaring.DateTime``\n        :param to: ending date\n        :type to: ``osid.calendaring.DateTime``\n", 
               "sphinx_return_doc": "        :return: the returned ``Authorization`` list\n        :rtype: ``osid.authorization.AuthorizationList``", 
               "sphinx_error_doc": "        :raise: ``InvalidArgument`` -- ``from`` is greater than ``to``\n        :raise: ``NullArgument`` -- ``from`` or ``to`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure occurred", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.calendaring.DateTime", 
                     "var_name": "from_", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.calendaring.DateTime", 
                     "var_name": "to", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.calendaring.DateTime", 
                  "osid.calendaring.DateTime"
               ], 
               "return_type": "osid.authorization.AuthorizationList", 
               "errors": {
                  "INVALID_ARGUMENT": "ConsumerContract", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_authorizations_for_resource", 
               "doc": {
                  "headline": "Gets a list of ``Authorizations`` associated with a given resource.", 
                  "body": "        Authorizations related to the given resource, including those\n        related through an ``Agent,`` are returned. In plenary mode, the\n        returned list contains all known authorizations or an error\n        results. Otherwise, the returned list may contain only those\n        authorizations that are accessible through this session."
               }, 
               "arg_doc": "        arg:    resource_id (osid.id.Id): a resource ``Id``\n", 
               "return_doc": "        return: (osid.authorization.AuthorizationList) - the returned\n                ``Authorization list``", 
               "error_doc": "        raise:  NullArgument - ``resource_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param resource_id: a resource ``Id``\n        :type resource_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: the returned ``Authorization list``\n        :rtype: ``osid.authorization.AuthorizationList``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``resource_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "resource_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "osid.authorization.AuthorizationList", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_authorizations_for_resource_on_date", 
               "doc": {
                  "headline": "Gets an ``AuthorizationList`` effective during the entire given date range inclusive but not confined to the date range.", 
                  "body": "        Authorizations related to the given resource, including those\n        related through an ``Agent,`` are returned.\n\n        In plenary mode, the returned list contains all known\n        authorizations or an error results. Otherwise, the returned list\n        may contain only those authorizations that are accessible\n        through this session.\n        \n        In effective mode, authorizations are returned that are\n        currently effective. In any effective mode, active\n        authorizations and those currently expired are returned."
               }, 
               "arg_doc": "        arg:    resource_id (osid.id.Id): a resource ``Id``\n        arg:    from (osid.calendaring.DateTime): starting date\n        arg:    to (osid.calendaring.DateTime): ending date\n", 
               "return_doc": "        return: (osid.authorization.AuthorizationList) - the returned\n                ``Authorization`` list", 
               "error_doc": "        raise:  InvalidArgument - ``from`` is greater than ``to``\n        raise:  NullArgument - ``resource_id, from`` or ``to`` is\n                ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure occurred", 
               "sphinx_param_doc": "        :param resource_id: a resource ``Id``\n        :type resource_id: ``osid.id.Id``\n        :param from: starting date\n        :type from: ``osid.calendaring.DateTime``\n        :param to: ending date\n        :type to: ``osid.calendaring.DateTime``\n", 
               "sphinx_return_doc": "        :return: the returned ``Authorization`` list\n        :rtype: ``osid.authorization.AuthorizationList``", 
               "sphinx_error_doc": "        :raise: ``InvalidArgument`` -- ``from`` is greater than ``to``\n        :raise: ``NullArgument`` -- ``resource_id, from`` or ``to`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure occurred", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "resource_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.calendaring.DateTime", 
                     "var_name": "from_", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.calendaring.DateTime", 
                     "var_name": "to", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "osid.calendaring.DateTime", 
                  "osid.calendaring.DateTime"
               ], 
               "return_type": "osid.authorization.AuthorizationList", 
               "errors": {
                  "INVALID_ARGUMENT": "ConsumerContract", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_authorizations_for_agent", 
               "doc": {
                  "headline": "Gets a list of ``Authorizations`` associated with a given agent.", 
                  "body": "        In plenary mode, the returned list contains all known\n        authorizations or an error results. Otherwise, the returned list\n        may contain only those authorizations that are accessible\n        through this session."
               }, 
               "arg_doc": "        arg:    agent_id (osid.id.Id): an agent ``Id``\n", 
               "return_doc": "        return: (osid.authorization.AuthorizationList) - the returned\n                ``Authorization list``", 
               "error_doc": "        raise:  NullArgument - ``agent_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param agent_id: an agent ``Id``\n        :type agent_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: the returned ``Authorization list``\n        :rtype: ``osid.authorization.AuthorizationList``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``agent_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "agent_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "osid.authorization.AuthorizationList", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_authorizations_for_agent_on_date", 
               "doc": {
                  "headline": "Gets an ``AuthorizationList`` for the given agent and effective during the entire given date range inclusive but not confined to the date range.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    agent_id (osid.id.Id): an agent ``Id``\n        arg:    from (osid.calendaring.DateTime): starting date\n        arg:    to (osid.calendaring.DateTime): ending date\n", 
               "return_doc": "        return: (osid.authorization.AuthorizationList) - the returned\n                ``Authorization`` list", 
               "error_doc": "        raise:  InvalidArgument - ``from`` is greater than ``to``\n        raise:  NullArgument - ``agent_id, from`` or ``to`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure occurred", 
               "sphinx_param_doc": "        :param agent_id: an agent ``Id``\n        :type agent_id: ``osid.id.Id``\n        :param from: starting date\n        :type from: ``osid.calendaring.DateTime``\n        :param to: ending date\n        :type to: ``osid.calendaring.DateTime``\n", 
               "sphinx_return_doc": "        :return: the returned ``Authorization`` list\n        :rtype: ``osid.authorization.AuthorizationList``", 
               "sphinx_error_doc": "        :raise: ``InvalidArgument`` -- ``from`` is greater than ``to``\n        :raise: ``NullArgument`` -- ``agent_id, from`` or ``to`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure occurred", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "agent_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.calendaring.DateTime", 
                     "var_name": "from_", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.calendaring.DateTime", 
                     "var_name": "to", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "osid.calendaring.DateTime", 
                  "osid.calendaring.DateTime"
               ], 
               "return_type": "osid.authorization.AuthorizationList", 
               "errors": {
                  "INVALID_ARGUMENT": "ConsumerContract", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_authorizations_for_function", 
               "doc": {
                  "headline": "Gets a list of ``Authorizations`` associated with a given function.", 
                  "body": "        In plenary mode, the returned list contains all known\n        authorizations or an error results. Otherwise, the returned list\n        may contain only those authorizations that are accessible\n        through this session."
               }, 
               "arg_doc": "        arg:    function_id (osid.id.Id): a function ``Id``\n", 
               "return_doc": "        return: (osid.authorization.AuthorizationList) - the returned\n                ``Authorization list``", 
               "error_doc": "        raise:  NullArgument - ``function_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param function_id: a function ``Id``\n        :type function_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: the returned ``Authorization list``\n        :rtype: ``osid.authorization.AuthorizationList``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``function_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "function_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "osid.authorization.AuthorizationList", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_authorizations_for_function_on_date", 
               "doc": {
                  "headline": "Gets an ``AuthorizationList`` for the given function and effective during the entire given date range inclusive but not confined to the date range.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    function_id (osid.id.Id): a function ``Id``\n        arg:    from (osid.calendaring.DateTime): starting date\n        arg:    to (osid.calendaring.DateTime): ending date\n", 
               "return_doc": "        return: (osid.authorization.AuthorizationList) - the returned\n                ``Authorization`` list", 
               "error_doc": "        raise:  InvalidArgument - ``from`` is greater than ``to``\n        raise:  NullArgument - ``function_id, from`` or ``to`` is\n                ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure occurred", 
               "sphinx_param_doc": "        :param function_id: a function ``Id``\n        :type function_id: ``osid.id.Id``\n        :param from: starting date\n        :type from: ``osid.calendaring.DateTime``\n        :param to: ending date\n        :type to: ``osid.calendaring.DateTime``\n", 
               "sphinx_return_doc": "        :return: the returned ``Authorization`` list\n        :rtype: ``osid.authorization.AuthorizationList``", 
               "sphinx_error_doc": "        :raise: ``InvalidArgument`` -- ``from`` is greater than ``to``\n        :raise: ``NullArgument`` -- ``function_id, from`` or ``to`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure occurred", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "function_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.calendaring.DateTime", 
                     "var_name": "from_", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.calendaring.DateTime", 
                     "var_name": "to", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "osid.calendaring.DateTime", 
                  "osid.calendaring.DateTime"
               ], 
               "return_type": "osid.authorization.AuthorizationList", 
               "errors": {
                  "INVALID_ARGUMENT": "ConsumerContract", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_authorizations_for_resource_and_function", 
               "doc": {
                  "headline": "Gets a list of ``Authorizations`` associated with a given resource.", 
                  "body": "        Authorizations related to the given resource, including those\n        related through an ``Agent,`` are returned. In plenary mode, the\n        returned list contains all known authorizations or an error\n        results. Otherwise, the returned list may contain only those\n        authorizations that are accessible through this session."
               }, 
               "arg_doc": "        arg:    resource_id (osid.id.Id): a resource ``Id``\n        arg:    function_id (osid.id.Id): a function ``Id``\n", 
               "return_doc": "        return: (osid.authorization.AuthorizationList) - the returned\n                ``Authorization list``", 
               "error_doc": "        raise:  NullArgument - ``resource_id`` or ``function_id`` is\n                ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param resource_id: a resource ``Id``\n        :type resource_id: ``osid.id.Id``\n        :param function_id: a function ``Id``\n        :type function_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: the returned ``Authorization list``\n        :rtype: ``osid.authorization.AuthorizationList``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``resource_id`` or ``function_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "resource_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "function_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "osid.id.Id"
               ], 
               "return_type": "osid.authorization.AuthorizationList", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_authorizations_for_resource_and_function_on_date", 
               "doc": {
                  "headline": "Gets an ``AuthorizationList`` effective during the entire given date range inclusive but not confined to the date range.", 
                  "body": "        Authorizations related to the given resource, including those\n        related through an ``Agent,`` are returned.\n\n        In plenary mode, the returned list contains all known\n        authorizations or an error results. Otherwise, the returned list\n        may contain only those authorizations that are accessible\n        through this session.\n        \n        In effective mode, authorizations are returned that are\n        currently effective. In any effective mode, active\n        authorizations and those currently expired are returned."
               }, 
               "arg_doc": "        arg:    resource_id (osid.id.Id): a resource ``Id``\n        arg:    function_id (osid.id.Id): a function ``Id``\n        arg:    from (osid.calendaring.DateTime): starting date\n        arg:    to (osid.calendaring.DateTime): ending date\n", 
               "return_doc": "        return: (osid.authorization.AuthorizationList) - the returned\n                ``Authorization`` list", 
               "error_doc": "        raise:  InvalidArgument - ``from`` is greater than ``to``\n        raise:  NullArgument - ``resource_id, function_id, from`` or\n                ``to`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure occurred", 
               "sphinx_param_doc": "        :param resource_id: a resource ``Id``\n        :type resource_id: ``osid.id.Id``\n        :param function_id: a function ``Id``\n        :type function_id: ``osid.id.Id``\n        :param from: starting date\n        :type from: ``osid.calendaring.DateTime``\n        :param to: ending date\n        :type to: ``osid.calendaring.DateTime``\n", 
               "sphinx_return_doc": "        :return: the returned ``Authorization`` list\n        :rtype: ``osid.authorization.AuthorizationList``", 
               "sphinx_error_doc": "        :raise: ``InvalidArgument`` -- ``from`` is greater than ``to``\n        :raise: ``NullArgument`` -- ``resource_id, function_id, from`` or ``to`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure occurred", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "resource_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "function_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.calendaring.DateTime", 
                     "var_name": "from_", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.calendaring.DateTime", 
                     "var_name": "to", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "osid.id.Id", 
                  "osid.calendaring.DateTime", 
                  "osid.calendaring.DateTime"
               ], 
               "return_type": "osid.authorization.AuthorizationList", 
               "errors": {
                  "INVALID_ARGUMENT": "ConsumerContract", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_authorizations_for_agent_and_function", 
               "doc": {
                  "headline": "Gets a list of ``Authorizations`` associated with a given agent.", 
                  "body": "        Authorizations related to the given resource, including those\n        related through an ``Agent,`` are returned. In plenary mode, the\n        returned list contains all known authorizations or an error\n        results. Otherwise, the returned list may contain only those\n        authorizations that are accessible through this session."
               }, 
               "arg_doc": "        arg:    agent_id (osid.id.Id): an agent ``Id``\n        arg:    function_id (osid.id.Id): a function ``Id``\n", 
               "return_doc": "        return: (osid.authorization.AuthorizationList) - the returned\n                ``Authorization list``", 
               "error_doc": "        raise:  NullArgument - ``agent_id`` or ``function_id`` is\n                ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param agent_id: an agent ``Id``\n        :type agent_id: ``osid.id.Id``\n        :param function_id: a function ``Id``\n        :type function_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: the returned ``Authorization list``\n        :rtype: ``osid.authorization.AuthorizationList``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``agent_id`` or ``function_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "agent_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "function_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "osid.id.Id"
               ], 
               "return_type": "osid.authorization.AuthorizationList", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_authorizations_for_agent_and_function_on_date", 
               "doc": {
                  "headline": "Gets an ``AuthorizationList`` for the given agent and effective during the entire given date range inclusive but not confined to the date range.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    agent_id (osid.id.Id): an agent ``Id``\n        arg:    function_id (osid.id.Id): a function ``Id``\n        arg:    from (osid.calendaring.DateTime): starting date\n        arg:    to (osid.calendaring.DateTime): ending date\n", 
               "return_doc": "        return: (osid.authorization.AuthorizationList) - the returned\n                ``Authorization`` list", 
               "error_doc": "        raise:  InvalidArgument - ``from`` is greater than ``to``\n        raise:  NullArgument - ``agent_id, function_id, from`` or ``to``\n                is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure occurred", 
               "sphinx_param_doc": "        :param agent_id: an agent ``Id``\n        :type agent_id: ``osid.id.Id``\n        :param function_id: a function ``Id``\n        :type function_id: ``osid.id.Id``\n        :param from: starting date\n        :type from: ``osid.calendaring.DateTime``\n        :param to: ending date\n        :type to: ``osid.calendaring.DateTime``\n", 
               "sphinx_return_doc": "        :return: the returned ``Authorization`` list\n        :rtype: ``osid.authorization.AuthorizationList``", 
               "sphinx_error_doc": "        :raise: ``InvalidArgument`` -- ``from`` is greater than ``to``\n        :raise: ``NullArgument`` -- ``agent_id, function_id, from`` or ``to`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure occurred", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "agent_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "function_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.calendaring.DateTime", 
                     "var_name": "from_", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.calendaring.DateTime", 
                     "var_name": "to", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "osid.id.Id", 
                  "osid.calendaring.DateTime", 
                  "osid.calendaring.DateTime"
               ], 
               "return_type": "osid.authorization.AuthorizationList", 
               "errors": {
                  "INVALID_ARGUMENT": "ConsumerContract", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_authorizations_by_qualifier", 
               "doc": {
                  "headline": "Gets a list of ``Authorizations`` associated with a given qualifier.", 
                  "body": "        In plenary mode, the returned list contains all known\n        authorizations or an error results. Otherwise, the returned list\n        may contain only those authorizations that are accessible\n        through this session."
               }, 
               "arg_doc": "        arg:    qualifier_id (osid.id.Id): a qualifier ``Id``\n", 
               "return_doc": "        return: (osid.authorization.AuthorizationList) - the returned\n                ``Authorization list``", 
               "error_doc": "        raise:  NullArgument - ``qualifier_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param qualifier_id: a qualifier ``Id``\n        :type qualifier_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: the returned ``Authorization list``\n        :rtype: ``osid.authorization.AuthorizationList``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``qualifier_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "qualifier_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "osid.authorization.AuthorizationList", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_explicit_authorization", 
               "doc": {
                  "headline": "Gets the explicit ``Authorization`` that generated the given implicit authorization.", 
                  "body": "        If the given ``Authorization`` is explicit, then the same\n        ``Authorization`` is returned."
               }, 
               "arg_doc": "        arg:    authorization_id (osid.id.Id): an authorization\n", 
               "return_doc": "        return: (osid.authorization.Authorization) - the explicit\n                ``Authorization``", 
               "error_doc": "        raise:  NotFound - ``authorization_id`` is not found\n        raise:  NullArgument - ``authorization_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param authorization_id: an authorization\n        :type authorization_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: the explicit ``Authorization``\n        :rtype: ``osid.authorization.Authorization``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``authorization_id`` is not found\n        :raise: ``NullArgument`` -- ``authorization_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "authorization_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "osid.authorization.Authorization", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_authorizations", 
               "doc": {
                  "headline": "Geta all ``Authorizations``.", 
                  "body": "        In plenary mode, the returned list contains all known\n        authorizations or an error results. Otherwise, the returned list\n        may contain only those authorizations that are accessible\n        through this session."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.authorization.AuthorizationList) - a list of\n                ``Authorizations``", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: a list of ``Authorizations``\n        :rtype: ``osid.authorization.AuthorizationList``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.authorization.AuthorizationList", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.authorization.AuthorizationQuerySession", 
         "shortname": "AuthorizationQuerySession", 
         "category": "sessions", 
         "doc": {
            "headline": "This session provides methods for searching ``Authorization`` objects.", 
            "body": "    The search query is constructed using the ``AuthorizationQuery``.\n\n    This session defines views that offer differing behaviors for\n    searching.\n    \n      * federated view: searches include authorizations in ``Vaults`` of\n        which this vault is a ancestor in the vault hierarchy\n      * isolated view: searches are restricted to authorizations in this\n        ``Vault``\n      * implicit authorization view: authorizations include implicit\n        authorizations\n      * explicit authorization view: only explicit authorizations are\n        returned\n"
         }, 
         "inherit_fullnames": [
            "osid.OsidSession"
         ], 
         "inherit_shortnames": [
            "OsidSession"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidSession"
            }
         ], 
         "method_names": [
            "get_vault_id", 
            "get_vault", 
            "can_search_authorizations", 
            "use_federated_vault_view", 
            "use_isolated_vault_view", 
            "use_implicit_authorization_view", 
            "use_explicit_authorization_view", 
            "get_authorization_query", 
            "get_authorizations_by_query"
         ], 
         "methods": [
            {
               "name": "get_vault_id", 
               "doc": {
                  "headline": "Gets the ``Vault``  ``Id`` associated with this session.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.id.Id) - the ``Vault Id`` associated with this\n                session", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the ``Vault Id`` associated with this session\n        :rtype: ``osid.id.Id``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.id.Id", 
               "errors": {}
            }, 
            {
               "name": "get_vault", 
               "doc": {
                  "headline": "Gets the ``Vault`` associated with this session.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.authorization.Vault) - the ``Vault`` associated\n                with this session", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the ``Vault`` associated with this session\n        :rtype: ``osid.authorization.Vault``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.authorization.Vault", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "can_search_authorizations", 
               "doc": {
                  "headline": "Tests if this user can perform authorization searches.", 
                  "body": "        A return of true does not guarantee successful authorization. A\n        return of false indicates that it is known all methods in this\n        session will result in a ``PermissionDenied``. This is intended\n        as a hint to an application that may opt not to offer search\n        operations to unauthorized users."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``false`` if search methods are not\n                authorized, ``true`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``false`` if search methods are not authorized, ``true`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "use_federated_vault_view", 
               "doc": {
                  "headline": "Federates the view for methods in this session.", 
                  "body": "        A federated view will include authorizations in vaults which are\n        children of this vault in the vault hierarchy."
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "use_isolated_vault_view", 
               "doc": {
                  "headline": "Isolates the view for methods in this session.", 
                  "body": "        An isolated view restricts searches to this vault only."
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "use_implicit_authorization_view", 
               "doc": {
                  "headline": "Sets the view for methods in this session to implicit authorizations.", 
                  "body": "        An implicit view will include authorizations derived from other\n        authorizations as a result of the ``Qualifier,`` ``Function`` or\n        ``Resource`` hierarchies. This method is the opposite of\n        ``explicit_aut``"
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "use_explicit_authorization_view", 
               "doc": {
                  "headline": "Sets the view for methods in this session to explicit authorizations.", 
                  "body": "        An explicit view includes only those authorizations that were\n        explicitly defined and not implied. This method is the opposite\n        of ``implicitAuthorizationView()``."
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "get_authorization_query", 
               "doc": {
                  "headline": "Gets an authorization query.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.authorization.AuthorizationQuery) - the\n                authorization query", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the authorization query\n        :rtype: ``osid.authorization.AuthorizationQuery``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.authorization.AuthorizationQuery", 
               "errors": {}
            }, 
            {
               "name": "get_authorizations_by_query", 
               "doc": {
                  "headline": "Gets a list of ``Authorizations`` matching the given query.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    authorization_query\n                (osid.authorization.AuthorizationQuery): the\n                authorization query\n", 
               "return_doc": "        return: (osid.authorization.AuthorizationList) - the returned\n                ``AuthorizationList``", 
               "error_doc": "        raise:  NullArgument - ``authorization_query`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        raise:  Unsupported - ``authorization_query`` is not of this\n                service", 
               "sphinx_param_doc": "        :param authorization_query: the authorization query\n        :type authorization_query: ``osid.authorization.AuthorizationQuery``\n", 
               "sphinx_return_doc": "        :return: the returned ``AuthorizationList``\n        :rtype: ``osid.authorization.AuthorizationList``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``authorization_query`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure\n        :raise: ``Unsupported`` -- ``authorization_query`` is not of this service", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.authorization.AuthorizationQuery", 
                     "var_name": "authorization_query", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.authorization.AuthorizationQuery"
               ], 
               "return_type": "osid.authorization.AuthorizationList", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.authorization.AuthorizationSearchSession", 
         "shortname": "AuthorizationSearchSession", 
         "category": "sessions", 
         "doc": {
            "headline": "This session provides methods for searching ``Authorization`` objects.", 
            "body": "    The search query is constructed using the ``AuthorizationQuery``.\n\n    ``get_authorizations_by_query()`` is the basic search method and\n    returns a list of ``Authorizations``. A more advanced search may be\n    performed with ``getAuthorizationsBySearch()``. It accepts an\n    ``AgentSearch`` in addition to the query for the purpose of\n    specifying additional options affecting the entire search, such as\n    ordering. ``get_authorizationss_by_search()`` returns an\n    ``AuthorizationSearchResults`` that can be used to access the\n    resulting ``AuthorizationList`` or be used to perform a search\n    within the result set through ``AuthorizationSearch``.\n    \n    This session defines views that offer differing behaviors for\n    searching.\n    \n      * federated view: searches include authorizations in ``Vaults`` of\n        which this vault is a ancestor in the vault hierarchy\n      * isolated view: searches are restricted to authorizations in this\n        ``Vault``\n      * implicit authorization view: authorizations include implicit\n        authorizations\n      * explicit authorization view: only explicit authorizations are\n        returned\n"
         }, 
         "inherit_fullnames": [
            "osid.authorization.AuthorizationQuerySession"
         ], 
         "inherit_shortnames": [
            "AuthorizationQuerySession"
         ], 
         "inherit_pkg_names": [
            "authorization"
         ], 
         "inheritance": [
            {
               "pkg_name": "authorization", 
               "name": "AuthorizationQuerySession"
            }
         ], 
         "method_names": [
            "get_authorization_search", 
            "get_authorization_search_order", 
            "get_authorizations_by_search", 
            "get_authorization_query_from_inspector"
         ], 
         "methods": [
            {
               "name": "get_authorization_search", 
               "doc": {
                  "headline": "Gets an authorization search.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.authorization.AuthorizationSearch) - the\n                authorization search", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the authorization search\n        :rtype: ``osid.authorization.AuthorizationSearch``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.authorization.AuthorizationSearch", 
               "errors": {}
            }, 
            {
               "name": "get_authorization_search_order", 
               "doc": {
                  "headline": "Gets an authorization search order.", 
                  "body": "        The ``AuthorizationSearchOrder`` is supplied to an\n        ``AuthorizationSearch`` to specify the ordering of results."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.authorization.AuthorizationSearchOrder) - the\n                authorization search order", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the authorization search order\n        :rtype: ``osid.authorization.AuthorizationSearchOrder``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.authorization.AuthorizationSearchOrder", 
               "errors": {}
            }, 
            {
               "name": "get_authorizations_by_search", 
               "doc": {
                  "headline": "Gets the search results matching the given search query using the given search.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    authorization_query\n                (osid.authorization.AuthorizationQuery): the\n                authorization query\n        arg:    authorization_search\n                (osid.authorization.AuthorizationSearch): the\n                authorization search\n", 
               "return_doc": "        return: (osid.authorization.AuthorizationSearchResults) - the\n                returned search results", 
               "error_doc": "        raise:  NullArgument - ``authorization_query`` or\n                ``authorization_search`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        raise:  Unsupported - ``authorization_search`` or\n                ``authorization_query`` is not of this service", 
               "sphinx_param_doc": "        :param authorization_query: the authorization query\n        :type authorization_query: ``osid.authorization.AuthorizationQuery``\n        :param authorization_search: the authorization search\n        :type authorization_search: ``osid.authorization.AuthorizationSearch``\n", 
               "sphinx_return_doc": "        :return: the returned search results\n        :rtype: ``osid.authorization.AuthorizationSearchResults``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``authorization_query`` or ``authorization_search`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure\n        :raise: ``Unsupported`` -- ``authorization_search`` or ``authorization_query`` is not of this service", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.authorization.AuthorizationQuery", 
                     "var_name": "authorization_query", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.authorization.AuthorizationSearch", 
                     "var_name": "authorization_search", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.authorization.AuthorizationQuery", 
                  "osid.authorization.AuthorizationSearch"
               ], 
               "return_type": "osid.authorization.AuthorizationSearchResults", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_authorization_query_from_inspector", 
               "doc": {
                  "headline": "Gets an authorization query from an inspector.", 
                  "body": "        The inspector is available from an\n        ``AuthorizationSearchResults``."
               }, 
               "arg_doc": "        arg:    authorization_query_inspector\n                (osid.authorization.AuthorizationQueryInspector): an\n                authorization query inspector\n", 
               "return_doc": "        return: (osid.authorization.AuthorizationQuery) - the\n                authorization query", 
               "error_doc": "        raise:  NullArgument - ``authorization_query_inspector`` is\n                ``null``\n        raise:  Unsupported - ``authorization_query_inspector`` is not\n                of this service", 
               "sphinx_param_doc": "        :param authorization_query_inspector: an authorization query inspector\n        :type authorization_query_inspector: ``osid.authorization.AuthorizationQueryInspector``\n", 
               "sphinx_return_doc": "        :return: the authorization query\n        :rtype: ``osid.authorization.AuthorizationQuery``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``authorization_query_inspector`` is ``null``\n        :raise: ``Unsupported`` -- ``authorization_query_inspector`` is not of this service", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.authorization.AuthorizationQueryInspector", 
                     "var_name": "authorization_query_inspector", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.authorization.AuthorizationQueryInspector"
               ], 
               "return_type": "osid.authorization.AuthorizationQuery", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.authorization.AuthorizationAdminSession", 
         "shortname": "AuthorizationAdminSession", 
         "category": "sessions", 
         "doc": {
            "headline": "This session creates, updates, and deletes ``Authorizations``.", 
            "body": "    The data for create and update is provided by the consumer via the\n    form object. ``OsidForms`` are requested for each create or update\n    and may not be reused.\n\n    Create and update operations differ in their usage. To create an\n    ``Authorization,`` an ``AuthorizationForm`` is requested using\n    ``get_authorization_form_for_create()`` specifying the desired\n    relationship peers and record ``Types`` or none if no record\n    ``Types`` are needed. The returned ``AuthorizationForm`` will\n    indicate that it is to be used with a create operation and can be\n    used to examine metdata or validate data prior to creation. Once the\n    ``AuthorizationForm`` is submiited to a create operation, it cannot\n    be reused with another create operation unless the first operation\n    was unsuccessful. Each ``AuthorizationForm`` corresponds to an\n    attempted transaction.\n    \n    For updates, ``AuthorizationForms`` are requested to the\n    ``Authorization``  ``Id`` that is to be updated using\n    ``getAuthorizationFormForUpdate()``. Similarly, the\n    ``AuthorizationForm`` has metadata about the data that can be\n    updated and it can perform validation before submitting the update.\n    The ``AuthorizationForm`` can only be used once for a successful\n    update and cannot be reused.\n    \n    The delete operations delete ``Authorizations``. To unmap an\n    ``Authorization`` from the current ``Vault,`` the\n    ``AuthorizationVaultAssignmentSession`` should be used. These delete\n    operations attempt to remove the ``Authorization`` itself thus\n    removing it from all known ``Vault`` catalogs.\n    \n    This session includes an ``Id`` aliasing mechanism to assign an\n    external ``Id`` to an internally assigned Id."
         }, 
         "inherit_fullnames": [
            "osid.OsidSession"
         ], 
         "inherit_shortnames": [
            "OsidSession"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidSession"
            }
         ], 
         "method_names": [
            "get_vault_id", 
            "get_vault", 
            "can_create_authorizations", 
            "can_create_authorization_with_record_types", 
            "get_authorization_form_for_create_for_agent", 
            "get_authorization_form_for_create_for_resource", 
            "get_authorization_form_for_create_for_resource_and_trust", 
            "create_authorization", 
            "can_update_authorizations", 
            "get_authorization_form_for_update", 
            "update_authorization", 
            "can_delete_authorizations", 
            "delete_authorization", 
            "can_manage_authorization_aliases", 
            "alias_authorization"
         ], 
         "methods": [
            {
               "name": "get_vault_id", 
               "doc": {
                  "headline": "Gets the ``Vault``  ``Id`` associated with this session.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.id.Id) - the ``Vault Id`` associated with this\n                session", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the ``Vault Id`` associated with this session\n        :rtype: ``osid.id.Id``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.id.Id", 
               "errors": {}
            }, 
            {
               "name": "get_vault", 
               "doc": {
                  "headline": "Gets the ``Vault`` associated with this session.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.authorization.Vault) - the ``Vault`` associated\n                with this session", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the ``Vault`` associated with this session\n        :rtype: ``osid.authorization.Vault``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.authorization.Vault", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "can_create_authorizations", 
               "doc": {
                  "headline": "Tests if this user can create ``Authorizations``.", 
                  "body": "        A return of true does not guarantee successful authorization. A\n        return of false indicates that it is known all methods in this\n        session will result in a ``PermissionDenied``. This is intended\n        as a hint to an application that may opt not to offer create\n        operations to unauthorized users."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``false`` if ``Authorization`` creation is\n                not authorized, ``true`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``false`` if ``Authorization`` creation is not authorized, ``true`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "can_create_authorization_with_record_types", 
               "doc": {
                  "headline": "Tests if this user can create a single ``Authorization`` using the desired record types.", 
                  "body": "        While ``AuthorizationManager.getAuthorizationRecordTypes()`` can\n        be used to examine which records are supported, this method\n        tests which record(s) are required for creating a specific\n        ``Authorization``. Providing an empty array tests if an\n        ``Authorization`` can be created with no records."
               }, 
               "arg_doc": "        arg:    authorization_record_types (osid.type.Type[]): array of\n                authorization record types\n", 
               "return_doc": "        return: (boolean) - ``true`` if ``Authorization`` creation using\n                the specified ``Types`` is supported, ``false``\n                otherwise", 
               "error_doc": "        raise:  NullArgument - ``authorization_record_types`` is\n                ``null``", 
               "sphinx_param_doc": "        :param authorization_record_types: array of authorization record types\n        :type authorization_record_types: ``osid.type.Type[]``\n", 
               "sphinx_return_doc": "        :return: ``true`` if ``Authorization`` creation using the specified ``Types`` is supported, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``authorization_record_types`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type[]", 
                     "var_name": "authorization_record_types", 
                     "array": true
                  }
               ], 
               "arg_types": [
                  "osid.type.Type[]"
               ], 
               "return_type": "boolean", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "get_authorization_form_for_create_for_agent", 
               "doc": {
                  "headline": "Gets the authorization form for creating new authorizations.", 
                  "body": "        A new form should be requested for each create transaction."
               }, 
               "arg_doc": "        arg:    agent_id (osid.id.Id): the agent ``Id``\n        arg:    function_id (osid.id.Id): the function ``Id``\n        arg:    qualifier_id (osid.id.Id): the qualifier ``Id``\n        arg:    authorization_record_types (osid.type.Type[]): array of\n                authorization record types\n", 
               "return_doc": "        return: (osid.authorization.AuthorizationForm) - the\n                authorization form", 
               "error_doc": "        raise:  NotFound - ``agent_id, function_id`` or ``qualifier_id``\n                is not found\n        raise:  NullArgument - ``agent_id, function_id, qualifier_id``\n                or ``authorization_record_types`` is ``null``\n        raise:  OperationFailed - ``unable to complete request``\n        raise:  PermissionDenied - authorization failure\n        raise:  Unsupported - unable to get form with requested record\n                types", 
               "sphinx_param_doc": "        :param agent_id: the agent ``Id``\n        :type agent_id: ``osid.id.Id``\n        :param function_id: the function ``Id``\n        :type function_id: ``osid.id.Id``\n        :param qualifier_id: the qualifier ``Id``\n        :type qualifier_id: ``osid.id.Id``\n        :param authorization_record_types: array of authorization record types\n        :type authorization_record_types: ``osid.type.Type[]``\n", 
               "sphinx_return_doc": "        :return: the authorization form\n        :rtype: ``osid.authorization.AuthorizationForm``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``agent_id, function_id`` or ``qualifier_id`` is not found\n        :raise: ``NullArgument`` -- ``agent_id, function_id, qualifier_id`` or ``authorization_record_types`` is ``null``\n        :raise: ``OperationFailed`` -- ``unable to complete request``\n        :raise: ``PermissionDenied`` -- authorization failure\n        :raise: ``Unsupported`` -- unable to get form with requested record types", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "agent_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "function_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "qualifier_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.type.Type[]", 
                     "var_name": "authorization_record_types", 
                     "array": true
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "osid.id.Id", 
                  "osid.id.Id", 
                  "osid.type.Type[]"
               ], 
               "return_type": "osid.authorization.AuthorizationForm", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_authorization_form_for_create_for_resource", 
               "doc": {
                  "headline": "Gets the authorization form for creating new authorizations.", 
                  "body": "        A new form should be requested for each create transaction."
               }, 
               "arg_doc": "        arg:    resource_id (osid.id.Id): the resource ``Id``\n        arg:    function_id (osid.id.Id): the function ``Id``\n        arg:    qualifier_id (osid.id.Id): the qualifier ``Id``\n        arg:    authorization_record_types (osid.type.Type[]): array of\n                authorization record types\n", 
               "return_doc": "        return: (osid.authorization.AuthorizationForm) - the\n                authorization form", 
               "error_doc": "        raise:  NotFound - ``resource_id, function_id`` or\n                ``qualifier_id`` is not found\n        raise:  NullArgument - ``resource_id, function_id,\n                qualifier_id,`` or ``authorization_record_types`` is\n                ``null``\n        raise:  OperationFailed - ``unable to complete request``\n        raise:  PermissionDenied - authorization failure\n        raise:  Unsupported - unable to get form with requested record\n                types", 
               "sphinx_param_doc": "        :param resource_id: the resource ``Id``\n        :type resource_id: ``osid.id.Id``\n        :param function_id: the function ``Id``\n        :type function_id: ``osid.id.Id``\n        :param qualifier_id: the qualifier ``Id``\n        :type qualifier_id: ``osid.id.Id``\n        :param authorization_record_types: array of authorization record types\n        :type authorization_record_types: ``osid.type.Type[]``\n", 
               "sphinx_return_doc": "        :return: the authorization form\n        :rtype: ``osid.authorization.AuthorizationForm``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``resource_id, function_id`` or ``qualifier_id`` is not found\n        :raise: ``NullArgument`` -- ``resource_id, function_id, qualifier_id,`` or ``authorization_record_types`` is ``null``\n        :raise: ``OperationFailed`` -- ``unable to complete request``\n        :raise: ``PermissionDenied`` -- authorization failure\n        :raise: ``Unsupported`` -- unable to get form with requested record types", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "resource_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "function_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "qualifier_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.type.Type[]", 
                     "var_name": "authorization_record_types", 
                     "array": true
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "osid.id.Id", 
                  "osid.id.Id", 
                  "osid.type.Type[]"
               ], 
               "return_type": "osid.authorization.AuthorizationForm", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_authorization_form_for_create_for_resource_and_trust", 
               "doc": {
                  "headline": "Gets the authorization form for creating new authorizations.", 
                  "body": "        A new form should be requested for each create transaction."
               }, 
               "arg_doc": "        arg:    resource_id (osid.id.Id): a resource ``Id``\n        arg:    trust_id (osid.id.Id): an ``Id`` for a circle of trust\n        arg:    function_id (osid.id.Id): a function ``Id``\n        arg:    qualifier_id (osid.id.Id): the qualifier ``Id``\n        arg:    authorization_record_types (osid.type.Type[]): array of\n                authorization record types\n", 
               "return_doc": "        return: (osid.authorization.AuthorizationForm) - the\n                authorization form", 
               "error_doc": "        raise:  NotFound - ``resource_id, trust_id, function_id`` , or\n                ``qualifierid`` is not found\n        raise:  NullArgument - ``resource_id, trust_id`` ,\n                ``resource_id, qualifier_id`` or\n                ``authorization_record_types`` is ``null``\n        raise:  OperationFailed - ``unable to complete request``\n        raise:  PermissionDenied - authorization failure\n        raise:  Unsupported - unable to get form with requested record\n                types", 
               "sphinx_param_doc": "        :param resource_id: a resource ``Id``\n        :type resource_id: ``osid.id.Id``\n        :param trust_id: an ``Id`` for a circle of trust\n        :type trust_id: ``osid.id.Id``\n        :param function_id: a function ``Id``\n        :type function_id: ``osid.id.Id``\n        :param qualifier_id: the qualifier ``Id``\n        :type qualifier_id: ``osid.id.Id``\n        :param authorization_record_types: array of authorization record types\n        :type authorization_record_types: ``osid.type.Type[]``\n", 
               "sphinx_return_doc": "        :return: the authorization form\n        :rtype: ``osid.authorization.AuthorizationForm``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``resource_id, trust_id, function_id`` , or ``qualifierid`` is not found\n        :raise: ``NullArgument`` -- ``resource_id, trust_id`` , ``resource_id, qualifier_id`` or ``authorization_record_types`` is ``null``\n        :raise: ``OperationFailed`` -- ``unable to complete request``\n        :raise: ``PermissionDenied`` -- authorization failure\n        :raise: ``Unsupported`` -- unable to get form with requested record types", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "resource_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "trust_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "function_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "qualifier_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.type.Type[]", 
                     "var_name": "authorization_record_types", 
                     "array": true
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "osid.id.Id", 
                  "osid.id.Id", 
                  "osid.id.Id", 
                  "osid.type.Type[]"
               ], 
               "return_type": "osid.authorization.AuthorizationForm", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }, 
            {
               "name": "create_authorization", 
               "doc": {
                  "headline": "Creates a new explicit ``Authorization``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    authorization_form\n                (osid.authorization.AuthorizationForm): the\n                authorization form\n", 
               "return_doc": "        return: (osid.authorization.Authorization) - ``t`` he new\n                ``Authorization``", 
               "error_doc": "        raise:  IllegalState - ``authorization_form`` already used in a\n                create transaction\n        raise:  InvalidArgument - one or more of the form elements is\n                invalid\n        raise:  NullArgument - ``authorization_form`` is ``null``\n        raise:  OperationFailed - ``unable to complete request``\n        raise:  PermissionDenied - authorization failure\n        raise:  Unsupported - ``authorization_form`` did not originate\n                from this service", 
               "sphinx_param_doc": "        :param authorization_form: the authorization form\n        :type authorization_form: ``osid.authorization.AuthorizationForm``\n", 
               "sphinx_return_doc": "        :return: ``t`` he new ``Authorization``\n        :rtype: ``osid.authorization.Authorization``", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- ``authorization_form`` already used in a create transaction\n        :raise: ``InvalidArgument`` -- one or more of the form elements is invalid\n        :raise: ``NullArgument`` -- ``authorization_form`` is ``null``\n        :raise: ``OperationFailed`` -- ``unable to complete request``\n        :raise: ``PermissionDenied`` -- authorization failure\n        :raise: ``Unsupported`` -- ``authorization_form`` did not originate from this service", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.authorization.AuthorizationForm", 
                     "var_name": "authorization_form", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.authorization.AuthorizationForm"
               ], 
               "return_type": "osid.authorization.Authorization", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract", 
                  "INVALID_ARGUMENT": "ConsumerContract", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }, 
            {
               "name": "can_update_authorizations", 
               "doc": {
                  "headline": "Tests if this user can update ``Authorizations``.", 
                  "body": "        A return of true does not guarantee successful authorization. A\n        return of false indicates that it is known updating an\n        ``Authorization`` will result in a ``PermissionDenied``. This is\n        intended as a hint to an application that may opt not to offer\n        update operations to an unauthorized user."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``false`` if authorization modification is\n                not authorized, ``true`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``false`` if authorization modification is not authorized, ``true`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "get_authorization_form_for_update", 
               "doc": {
                  "headline": "Gets the authorization form for updating an existing authorization.", 
                  "body": "        A new authorization form should be requested for each update\n        transaction."
               }, 
               "arg_doc": "        arg:    authorization_id (osid.id.Id): the ``Id`` of the\n                ``Authorization``\n", 
               "return_doc": "        return: (osid.authorization.AuthorizationForm) - the\n                authorization form", 
               "error_doc": "        raise:  NotFound - ``authorization_id`` is not found\n        raise:  NullArgument - ``authorization_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param authorization_id: the ``Id`` of the ``Authorization``\n        :type authorization_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: the authorization form\n        :rtype: ``osid.authorization.AuthorizationForm``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``authorization_id`` is not found\n        :raise: ``NullArgument`` -- ``authorization_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "authorization_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "osid.authorization.AuthorizationForm", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "update_authorization", 
               "doc": {
                  "headline": "Updates an existing authorization.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    authorization_form\n                (osid.authorization.AuthorizationForm): the\n                authorization ``Id``\n", 
               "return_doc": "", 
               "error_doc": "        raise:  IllegalState - ``authorization_form`` already used in an\n                update transaction\n        raise:  InvalidArgument - one or more of the form elements is\n                invalid\n        raise:  NullArgument - ``authorization_form`` is ``null``\n        raise:  OperationFailed - ``unable to complete request``\n        raise:  PermissionDenied - authorization failure\n        raise:  Unsupported - ``authorization_form`` did not originate\n                from ``get_authorization_form_for_update()``", 
               "sphinx_param_doc": "        :param authorization_form: the authorization ``Id``\n        :type authorization_form: ``osid.authorization.AuthorizationForm``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- ``authorization_form`` already used in an update transaction\n        :raise: ``InvalidArgument`` -- one or more of the form elements is invalid\n        :raise: ``NullArgument`` -- ``authorization_form`` is ``null``\n        :raise: ``OperationFailed`` -- ``unable to complete request``\n        :raise: ``PermissionDenied`` -- authorization failure\n        :raise: ``Unsupported`` -- ``authorization_form`` did not originate from ``get_authorization_form_for_update()``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.authorization.AuthorizationForm", 
                     "var_name": "authorization_form", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.authorization.AuthorizationForm"
               ], 
               "return_type": "", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract", 
                  "INVALID_ARGUMENT": "ConsumerContract", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }, 
            {
               "name": "can_delete_authorizations", 
               "doc": {
                  "headline": "Tests if this user can delete ``Authorizations``.", 
                  "body": "        A return of true does not guarantee successful authorization. A\n        return of false indicates that it is known deleting an\n        ``Authorization`` will result in a ``PermissionDenied``. This is\n        intended as a hint to an application that may opt not to offer\n        delete operations to an unauthorized user."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``false`` if ``Authorization`` deletion is\n                not authorized, ``true`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``false`` if ``Authorization`` deletion is not authorized, ``true`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "delete_authorization", 
               "doc": {
                  "headline": "Deletes the ``Authorization`` identified by the given ``Id``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    authorization_id (osid.id.Id): the ``Id`` of the\n                ``Authorization`` to delete\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NotFound - an ``Authorization`` was not found identified\n                by the given ``Id``\n        raise:  NullArgument - ``authorization_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param authorization_id: the ``Id`` of the ``Authorization`` to delete\n        :type authorization_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- an ``Authorization`` was not found identified by the given ``Id``\n        :raise: ``NullArgument`` -- ``authorization_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "authorization_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "can_manage_authorization_aliases", 
               "doc": {
                  "headline": "Tests if this user can manage ``Id`` aliases for ``Authorizations``.", 
                  "body": "        A return of true does not guarantee successful authorization. A\n        return of false indicates that it is known changing an alias\n        will result in a ``PermissionDenied``. This is intended as a\n        hint to an application that may opt not to offer alias\n        operations to an unauthorized user."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``false`` if ``Authorization`` aliasing is\n                not authorized, ``true`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``false`` if ``Authorization`` aliasing is not authorized, ``true`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "alias_authorization", 
               "doc": {
                  "headline": "Adds an ``Id`` to an ``Authorization`` for the purpose of creating compatibility.", 
                  "body": "        The primary ``Id`` of the ``Authorization`` is determined by the\n        provider. The new ``Id`` performs as an alias to the primary\n        ``Id``. If the alias is a pointer to another authorization. it\n        is reassigned to the given authorization ``Id``."
               }, 
               "arg_doc": "        arg:    authorization_id (osid.id.Id): the ``Id`` of an\n                ``Authorization``\n        arg:    alias_id (osid.id.Id): the alias ``Id``\n", 
               "return_doc": "", 
               "error_doc": "        raise:  AlreadyExists - ``alias_id`` is already assigned\n        raise:  NotFound - ``authorization_id`` not found\n        raise:  NullArgument - ``authorization_id`` or ``alias_id`` is\n                ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param authorization_id: the ``Id`` of an ``Authorization``\n        :type authorization_id: ``osid.id.Id``\n        :param alias_id: the alias ``Id``\n        :type alias_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``AlreadyExists`` -- ``alias_id`` is already assigned\n        :raise: ``NotFound`` -- ``authorization_id`` not found\n        :raise: ``NullArgument`` -- ``authorization_id`` or ``alias_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "authorization_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "alias_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {
                  "ALREADY_EXISTS": "User", 
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.authorization.AuthorizationNotificationSession", 
         "shortname": "AuthorizationNotificationSession", 
         "category": "sessions", 
         "doc": {
            "headline": "This session defines methods to receive asynchronous notifications on adds/changes to ``Authorizations``.", 
            "body": "    This session is intended for consumers needing to synchronize their\n    state with this service without the use of polling. Notifications\n    are cancelled when this session is closed.\n\n    The views defined in this session correspond to the views in the\n    ``AuthorizationLookupSession``."
         }, 
         "inherit_fullnames": [
            "osid.OsidSession"
         ], 
         "inherit_shortnames": [
            "OsidSession"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidSession"
            }
         ], 
         "method_names": [
            "get_vault_id", 
            "get_vault", 
            "can_register_for_authorization_notifications", 
            "use_federated_vault_view", 
            "use_isolated_vault_view", 
            "use_implicit_authorization_view", 
            "use_explicit_authorization_view", 
            "register_for_new_authorizations", 
            "register_for_new_authorizations_for_resource", 
            "register_for_new_authorizations_for_function", 
            "register_for_changed_authorizations", 
            "register_for_changed_authorizations_for_resource", 
            "register_for_changed_authorizations_for_function", 
            "register_for_changed_authorization", 
            "register_for_deleted_authorizations", 
            "register_for_deleted_authorizations_for_resource", 
            "register_for_deleted_authorizations_for_function", 
            "register_for_deleted_authorization"
         ], 
         "methods": [
            {
               "name": "get_vault_id", 
               "doc": {
                  "headline": "Gets the ``Vault``  ``Id`` associated with this session.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.id.Id) - the ``Vault Id`` associated with this\n                session", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the ``Vault Id`` associated with this session\n        :rtype: ``osid.id.Id``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.id.Id", 
               "errors": {}
            }, 
            {
               "name": "get_vault", 
               "doc": {
                  "headline": "Gets the ``Vault`` associated with this session.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.authorization.Vault) - the ``Vault`` associated\n                with this session", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the ``Vault`` associated with this session\n        :rtype: ``osid.authorization.Vault``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.authorization.Vault", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "can_register_for_authorization_notifications", 
               "doc": {
                  "headline": "Tests if this user can register for ``Authorization`` notifications.", 
                  "body": "        A return of true does not guarantee successful authorization. A\n        return of false indicates that it is known all methods in this\n        session will result in a ``PermissionDenied``. This is intended\n        as a hint to an application that may opt not to offer\n        notification operations."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``false`` if notification methods are not\n                authorized, ``true`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``false`` if notification methods are not authorized, ``true`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "use_federated_vault_view", 
               "doc": {
                  "headline": "Federates the view for methods in this session.", 
                  "body": "        A federated view will include authorizations in vaults which are\n        children of this vault in the vault hierarchy."
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "use_isolated_vault_view", 
               "doc": {
                  "headline": "Isolates the view for methods in this session.", 
                  "body": "        An isolated view restricts notifications for authorizations in\n        this vault only."
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "use_implicit_authorization_view", 
               "doc": {
                  "headline": "Sets the view for methods in this session to implicit authorizations.", 
                  "body": "        An implicit view will include authorizations derived from other\n        authorizations as a result of the ``Qualifier,`` ``Function`` or\n        ``Resource`` hierarchies. This method is the opposite of\n        ``explicitAuthorizationView()``."
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "use_explicit_authorization_view", 
               "doc": {
                  "headline": "Sets the view for methods in this session to explicit authorizations.", 
                  "body": "        An explicit view includes only those authorizations that were\n        explicitly defined and not implied. This method is the opposite\n        of ``implicitAuthorizationView()``."
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "register_for_new_authorizations", 
               "doc": {
                  "headline": "Register for notifications of new authorizations.", 
                  "body": "        ``AuthorizationReceiver.newAuthorization()`` is invoked when a\n        new ``Authorization`` appears in this vault."
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "register_for_new_authorizations_for_resource", 
               "doc": {
                  "headline": "Registers for notification of new authorizations for the given resource including any authorizations related to the resource through an agent.", 
                  "body": "        ``AuthorizationReceiver.newAuthorization()`` is invoked when an\n        authorization appears in this vault."
               }, 
               "arg_doc": "        arg:    resource_id (osid.id.Id): the ``Id`` of the ``Resource``\n                to monitor\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``resource_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param resource_id: the ``Id`` of the ``Resource`` to monitor\n        :type resource_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``resource_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "resource_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "register_for_new_authorizations_for_function", 
               "doc": {
                  "headline": "Register for notifications of new authorizations for the given function.", 
                  "body": "        ``AuthorizationReceiver.newAuthorization()`` is invoked when a\n        new ``Authorization`` appears in this vault."
               }, 
               "arg_doc": "        arg:    function_id (osid.id.Id): the ``Id`` of the ``Function``\n                to monitor\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``function_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param function_id: the ``Id`` of the ``Function`` to monitor\n        :type function_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``function_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "function_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "register_for_changed_authorizations", 
               "doc": {
                  "headline": "Registers for notification of updated authorizations.", 
                  "body": "        ``AuthorizationReceiver.changedAuthorization()`` is invoked when\n        an authorization in this vault is changed."
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "register_for_changed_authorizations_for_resource", 
               "doc": {
                  "headline": "Registers for notification of updated authorizations for the given resource including any authorizations related to the resource through an agent.", 
                  "body": "        ``AuthorizationReceiver.changedAuthorization()`` is invoked when\n        an authorization in this vault is changed."
               }, 
               "arg_doc": "        arg:    resource_id (osid.id.Id): the ``Id`` of the ``Resource``\n                to monitor\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``resource_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param resource_id: the ``Id`` of the ``Resource`` to monitor\n        :type resource_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``resource_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "resource_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "register_for_changed_authorizations_for_function", 
               "doc": {
                  "headline": "Registers for notification of updated authorizations for the given function.", 
                  "body": "        ``AuthorizationReceiver.changedAuthorization()`` is invoked when\n        an authorization in this vault is changed."
               }, 
               "arg_doc": "        arg:    function_id (osid.id.Id): the ``Id`` of the ``Function``\n                to monitor\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``function_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param function_id: the ``Id`` of the ``Function`` to monitor\n        :type function_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``function_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "function_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "register_for_changed_authorization", 
               "doc": {
                  "headline": "Registers for notification of an updated authorization.", 
                  "body": "        ``AuthorizationReceiver.changedAuthorization()`` is invoked when\n        the specified authorization in this vault is changed."
               }, 
               "arg_doc": "        arg:    authorization_id (osid.id.Id): the ``Id`` of the\n                ``Authorization`` to monitor\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``authorization_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param authorization_id: the ``Id`` of the ``Authorization`` to monitor\n        :type authorization_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``authorization_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "authorization_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "register_for_deleted_authorizations", 
               "doc": {
                  "headline": "Registers for notification of deleted authorizations.", 
                  "body": "        ``AuthorizationReceiver.deletedAuthorization()`` is invoked when\n        an authorization is removed from this vault."
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "register_for_deleted_authorizations_for_resource", 
               "doc": {
                  "headline": "Registers for notification of deleted authorizations for the given resource including any authorizations related to the resource through an agent.", 
                  "body": "        ``AuthorizationReceiver.deletedAuthorization()`` is invoked when\n        an authorization is removed from this vault."
               }, 
               "arg_doc": "        arg:    resource_id (osid.id.Id): the ``Id`` of the ``Resource``\n                to monitor\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``resource_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param resource_id: the ``Id`` of the ``Resource`` to monitor\n        :type resource_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``resource_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "resource_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "register_for_deleted_authorizations_for_function", 
               "doc": {
                  "headline": "Registers for notification of deleted authorizations for the given function.", 
                  "body": "        ``AuthorizationReceiver.deletedAuthorization()`` is invoked when\n        an authorization is removed from this vault."
               }, 
               "arg_doc": "        arg:    function_id (osid.id.Id): the ``Id`` of the ``Function``\n                to monitor\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``function_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param function_id: the ``Id`` of the ``Function`` to monitor\n        :type function_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``function_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "function_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "register_for_deleted_authorization", 
               "doc": {
                  "headline": "Registers for notification of a deleted authorization.", 
                  "body": "        ``AuthorizationReceiver.deletedAuthorization()`` is invoked when\n        the specified authorization is removed from this vault."
               }, 
               "arg_doc": "        arg:    authorization_id (osid.id.Id): the ``Id`` of the\n                ``Authorization`` to monitor\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``authorization_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param authorization_id: the ``Id`` of the ``Authorization`` to monitor\n        :type authorization_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``authorization_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "authorization_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.authorization.AuthorizationVaultSession", 
         "shortname": "AuthorizationVaultSession", 
         "category": "sessions", 
         "doc": {
            "headline": "This session provides methods to retrieve ``Authorization`` to ``Vault`` mappings.", 
            "body": "    An ``Authorization`` may appear in multiple ``Vaults``. Each\n    ``Vault`` may have its own authorizations governing who is allowed\n    to look at it.\n\n    This lookup session defines several views:\n    \n      * comparative view: elements may be silently omitted or re-ordered\n      * plenary view: provides a complete result set or is an error\n        condition\n"
         }, 
         "inherit_fullnames": [
            "osid.OsidSession"
         ], 
         "inherit_shortnames": [
            "OsidSession"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidSession"
            }
         ], 
         "method_names": [
            "use_comparative_vault_view", 
            "use_plenary_vault_view", 
            "can_lookup_authorization_vault_mappings", 
            "get_authorization_ids_by_vault", 
            "get_authorizations_by_vault", 
            "get_authorizations_ids_by_vault", 
            "get_authorizations_by_vault", 
            "get_vault_ids_by_authorization", 
            "get_vault_by_authorization"
         ], 
         "methods": [
            {
               "name": "use_comparative_vault_view", 
               "doc": {
                  "headline": "The returns from the lookup methods may omit or translate elements based on this session, such as authorization, and not result in an error.", 
                  "body": "        This view is used when greater interoperability is desired at\n        the expense of precision."
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "use_plenary_vault_view", 
               "doc": {
                  "headline": "A complete view of the ``Authorization`` and ``Vault`` returns is desired.", 
                  "body": "        Methods will return what is requested or result in an error.\n        This view is used when greater precision is desired at the\n        expense of interoperability."
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "can_lookup_authorization_vault_mappings", 
               "doc": {
                  "headline": "Tests if this user can perform lookups of authorization/vault mappings.", 
                  "body": "        A return of true does not guarantee successful authorization. A\n        return of false indicates that it is known lookup methods in\n        this session will result in a ``PermissionDenied``. This is\n        intended as a hint to an application that may opt not to offer\n        lookup operations to unauthorized users."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``false`` if looking up mappings is not\n                authorized, ``true`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``false`` if looking up mappings is not authorized, ``true`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "get_authorization_ids_by_vault", 
               "doc": {
                  "headline": "Gets the list of ``Authorization``  ``Ids`` associated with a ``Vault``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    vault_id (osid.id.Id): ``Id`` of a ``Vault``\n", 
               "return_doc": "        return: (osid.id.IdList) - list of related authorization ``Ids``", 
               "error_doc": "        raise:  NotFound - ``vault_id`` is not found\n        raise:  NullArgument - ``vault_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param vault_id: ``Id`` of a ``Vault``\n        :type vault_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: list of related authorization ``Ids``\n        :rtype: ``osid.id.IdList``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``vault_id`` is not found\n        :raise: ``NullArgument`` -- ``vault_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "vault_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "osid.id.IdList", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_authorizations_by_vault", 
               "doc": {
                  "headline": "Gets the list of ``Authorizations`` associated with a ``Vault``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    vault_id (osid.id.Id): ``Id`` of a ``Vault``\n", 
               "return_doc": "        return: (osid.authorization.AuthorizationList) - list of related\n                authorization", 
               "error_doc": "        raise:  NotFound - ``vault_id`` is not found\n        raise:  NullArgument - ``vault_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param vault_id: ``Id`` of a ``Vault``\n        :type vault_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: list of related authorization\n        :rtype: ``osid.authorization.AuthorizationList``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``vault_id`` is not found\n        :raise: ``NullArgument`` -- ``vault_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "vault_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "osid.authorization.AuthorizationList", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_authorizations_ids_by_vault", 
               "doc": {
                  "headline": "Gets the list of ``Authorization Ids`` corresponding to a list of ``Vault`` objects.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    vault_ids (osid.id.IdList): list of vault ``Ids``\n", 
               "return_doc": "        return: (osid.id.IdList) - list of authorization ``Ids``", 
               "error_doc": "        raise:  NullArgument - ``vault_ids`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param vault_ids: list of vault ``Ids``\n        :type vault_ids: ``osid.id.IdList``\n", 
               "sphinx_return_doc": "        :return: list of authorization ``Ids``\n        :rtype: ``osid.id.IdList``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``vault_ids`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.IdList", 
                     "var_name": "vault_ids", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.IdList"
               ], 
               "return_type": "osid.id.IdList", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_authorizations_by_vault", 
               "doc": {
                  "headline": "Gets the list of ``Authorizations`` corresponding to a list of ``Vault``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    vault_ids (osid.id.IdList): list of vault ``Ids``\n", 
               "return_doc": "        return: (osid.authorization.AuthorizationList) - list of\n                authorizations", 
               "error_doc": "        raise:  NullArgument - ``vault_ids`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param vault_ids: list of vault ``Ids``\n        :type vault_ids: ``osid.id.IdList``\n", 
               "sphinx_return_doc": "        :return: list of authorizations\n        :rtype: ``osid.authorization.AuthorizationList``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``vault_ids`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.IdList", 
                     "var_name": "vault_ids", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.IdList"
               ], 
               "return_type": "osid.authorization.AuthorizationList", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_vault_ids_by_authorization", 
               "doc": {
                  "headline": "Gets the list of ``Vault``  ``Ids`` mapped to an ``Authorization``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    authorization_id (osid.id.Id): ``Id`` of an\n                ``Authorization``\n", 
               "return_doc": "        return: (osid.id.IdList) - list of vault ``Ids``", 
               "error_doc": "        raise:  NotFound - ``authorization_id`` is not found\n        raise:  NullArgument - ``authorization_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param authorization_id: ``Id`` of an ``Authorization``\n        :type authorization_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: list of vault ``Ids``\n        :rtype: ``osid.id.IdList``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``authorization_id`` is not found\n        :raise: ``NullArgument`` -- ``authorization_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "authorization_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "osid.id.IdList", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_vault_by_authorization", 
               "doc": {
                  "headline": "Gets the list of ``Vault`` objects mapped to an ``Authorization``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    authorization_id (osid.id.Id): ``Id`` of an\n                ``Authorization``\n", 
               "return_doc": "        return: (osid.authorization.VaultList) - list of vault", 
               "error_doc": "        raise:  NotFound - ``authorization_id`` is not found\n        raise:  NullArgument - ``authorization_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param authorization_id: ``Id`` of an ``Authorization``\n        :type authorization_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: list of vault\n        :rtype: ``osid.authorization.VaultList``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``authorization_id`` is not found\n        :raise: ``NullArgument`` -- ``authorization_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "authorization_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "osid.authorization.VaultList", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.authorization.AuthorizationVaultAssignmentSession", 
         "shortname": "AuthorizationVaultAssignmentSession", 
         "category": "sessions", 
         "doc": {
            "headline": "This session provides methods to re-assign ``Authorizations`` to ``Vault``.", 
            "body": "    An ``Authorization`` may map to multiple ``Vault`` objects and\n    removing the last reference to a ``Authorization`` is the equivalent\n    of deleting it. Each ``Vault`` may have its own authorizations\n    governing who is allowed to operate on it.\n\n    Moving or adding a reference of a ``Authorization`` to another\n    ``Vault`` is not a copy operation (eg: does not change its ``Id`` )."
         }, 
         "inherit_fullnames": [
            "osid.OsidSession"
         ], 
         "inherit_shortnames": [
            "OsidSession"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidSession"
            }
         ], 
         "method_names": [
            "can_assign_authorizations", 
            "can_assign_authorizations_to_vault", 
            "get_assignable_vault_ids", 
            "get_assignable_vault_ids_for_authorization", 
            "assign_authorization_to_vault", 
            "unassign_authorization_from_vault"
         ], 
         "methods": [
            {
               "name": "can_assign_authorizations", 
               "doc": {
                  "headline": "Tests if this user can alter authorization/vault mappings.", 
                  "body": "        A return of true does not guarantee successful authorization. A\n        return of false indicates that it is known mapping methods in\n        this session will result in a ``PermissionDenied``. This is\n        intended as a hint to an application that may opt not to offer\n        assignment operations to unauthorized users."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``false`` if mapping is not authorized,\n                ``true`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``false`` if mapping is not authorized, ``true`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "can_assign_authorizations_to_vault", 
               "doc": {
                  "headline": "Tests if this user can alter authorization/vault mappings.", 
                  "body": "        A return of true does not guarantee successful authorization. A\n        return of false indicates that it is known mapping methods in\n        this session will result in a ``PermissionDenied``. This is\n        intended as a hint to an application that may opt not to offer\n        assignment operations to unauthorized users."
               }, 
               "arg_doc": "        arg:    vault_id (osid.id.Id): the ``Id`` of the ``Vault``\n", 
               "return_doc": "        return: (boolean) - ``false`` if mapping is not authorized,\n                ``true`` otherwise", 
               "error_doc": "        raise:  NullArgument - ``vault_id`` is ``null``", 
               "sphinx_param_doc": "        :param vault_id: the ``Id`` of the ``Vault``\n        :type vault_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: ``false`` if mapping is not authorized, ``true`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``vault_id`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "vault_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "boolean", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "get_assignable_vault_ids", 
               "doc": {
                  "headline": "Gets a list of vault including and under the given vault node in which any authorization can be assigned.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    vault_id (osid.id.Id): the ``Id`` of the ``Vault``\n", 
               "return_doc": "        return: (osid.id.IdList) - list of assignable vault ``Ids``", 
               "error_doc": "        raise:  NullArgument - ``vault_id`` is ``null``\n        raise:  OperationFailed - unable to complete request", 
               "sphinx_param_doc": "        :param vault_id: the ``Id`` of the ``Vault``\n        :type vault_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: list of assignable vault ``Ids``\n        :rtype: ``osid.id.IdList``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``vault_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "vault_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "osid.id.IdList", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational"
               }
            }, 
            {
               "name": "get_assignable_vault_ids_for_authorization", 
               "doc": {
                  "headline": "Gets a list of vault including and under the given vault node in which a specific authorization can be assigned.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    vault_id (osid.id.Id): the ``Id`` of the ``Vault``\n        arg:    authorization_id (osid.id.Id): the ``Id`` of the\n                ``Authorization``\n", 
               "return_doc": "        return: (osid.id.IdList) - list of assignable vault ``Ids``", 
               "error_doc": "        raise:  NullArgument - ``vault_id`` or ``authorization_id`` is\n                ``null``\n        raise:  OperationFailed - unable to complete request", 
               "sphinx_param_doc": "        :param vault_id: the ``Id`` of the ``Vault``\n        :type vault_id: ``osid.id.Id``\n        :param authorization_id: the ``Id`` of the ``Authorization``\n        :type authorization_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: list of assignable vault ``Ids``\n        :rtype: ``osid.id.IdList``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``vault_id`` or ``authorization_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "vault_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "authorization_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "osid.id.Id"
               ], 
               "return_type": "osid.id.IdList", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational"
               }
            }, 
            {
               "name": "assign_authorization_to_vault", 
               "doc": {
                  "headline": "Adds an existing ``Authorization`` to a ``Vault``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    authorization_id (osid.id.Id): the ``Id`` of the\n                ``Authorization``\n        arg:    vault_id (osid.id.Id): the ``Id`` of the ``Vault``\n", 
               "return_doc": "", 
               "error_doc": "        raise:  AlreadyExists - ``authorization_id`` is already assigned\n                to ``vault_id``\n        raise:  NotFound - ``authorization_id`` or ``vault_id`` not\n                found\n        raise:  NullArgument - ``authorization_id`` or ``vault_id`` is\n                ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param authorization_id: the ``Id`` of the ``Authorization``\n        :type authorization_id: ``osid.id.Id``\n        :param vault_id: the ``Id`` of the ``Vault``\n        :type vault_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``AlreadyExists`` -- ``authorization_id`` is already assigned to ``vault_id``\n        :raise: ``NotFound`` -- ``authorization_id`` or ``vault_id`` not found\n        :raise: ``NullArgument`` -- ``authorization_id`` or ``vault_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "authorization_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "vault_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {
                  "ALREADY_EXISTS": "User", 
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "unassign_authorization_from_vault", 
               "doc": {
                  "headline": "Removes an ``Authorization`` from a ``Vault``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    authorization_id (osid.id.Id): the ``Id`` of the\n                ``Authorization``\n        arg:    vault_id (osid.id.Id): the ``Id`` of the ``Vault``\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NotFound - ``authorization_id`` or ``vault_id`` not\n                found or ``authorization_id`` not assigned to\n                ``vault_id``\n        raise:  NullArgument - ``authorization_id`` or ``vault_id`` is\n                ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param authorization_id: the ``Id`` of the ``Authorization``\n        :type authorization_id: ``osid.id.Id``\n        :param vault_id: the ``Id`` of the ``Vault``\n        :type vault_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``authorization_id`` or ``vault_id`` not found or ``authorization_id`` not assigned to ``vault_id``\n        :raise: ``NullArgument`` -- ``authorization_id`` or ``vault_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "authorization_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "vault_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.authorization.AuthorizationSmartVaultSession", 
         "shortname": "AuthorizationSmartVaultSession", 
         "category": "sessions", 
         "doc": {
            "headline": "This session manages queries and sequencing to create \"smart\" dynamic catalogs.", 
            "body": "    A ``AuthorizationQuery`` can be retrieved from this session and\n    mapped to this ``Vault`` to create a virtual collection of\n    ``Authorizations``. The authorizations may be sequenced using the\n    ``AuthorizationSearchOrder`` from this session.\n\n    This ``Vault`` has a default query that matches any authorization\n    and a default search order that specifies no sequencing. The queries\n    may be examined using a ``AuthorizationQueryInspector``. The query\n    may be modified by converting the inspector back to a\n    ``AuthorizationQuery``."
         }, 
         "inherit_fullnames": [
            "osid.OsidSession"
         ], 
         "inherit_shortnames": [
            "OsidSession"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidSession"
            }
         ], 
         "method_names": [
            "get_vault_id", 
            "get_vault", 
            "can_manage_smart_vault", 
            "get_authorization_query", 
            "get_authorization_search_order", 
            "apply_authorization_query", 
            "inspect_authorization_query", 
            "apply_authorization_sequencing", 
            "get_authorization_query_from_inspector"
         ], 
         "methods": [
            {
               "name": "get_vault_id", 
               "doc": {
                  "headline": "Gets the ``Vault``  ``Id`` associated with this session.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.id.Id) - the ``Vault Id`` associated with this\n                session", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the ``Vault Id`` associated with this session\n        :rtype: ``osid.id.Id``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.id.Id", 
               "errors": {}
            }, 
            {
               "name": "get_vault", 
               "doc": {
                  "headline": "Gets the ``Vault`` associated with this session.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.authorization.Vault) - the ``Vault`` associated\n                with this session", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the ``Vault`` associated with this session\n        :rtype: ``osid.authorization.Vault``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.authorization.Vault", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "can_manage_smart_vault", 
               "doc": {
                  "headline": "Tests if this user can manage smart vault.", 
                  "body": "        A return of true does not guarantee successful authorization. A\n        return of false indicates that it is known methods in this\n        session will result in a ``PermissionDenied``. This is intended\n        as a hint to an application that may opt not to offer operations\n        to unauthorized users."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``false`` if smart vault management is not\n                authorized, ``true`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``false`` if smart vault management is not authorized, ``true`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "get_authorization_query", 
               "doc": {
                  "headline": "Gets a authorization query.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.authorization.AuthorizationQuery) - the\n                authorization query", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the authorization query\n        :rtype: ``osid.authorization.AuthorizationQuery``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.authorization.AuthorizationQuery", 
               "errors": {}
            }, 
            {
               "name": "get_authorization_search_order", 
               "doc": {
                  "headline": "Gets a authorization search order.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.authorization.AuthorizationSearchOrder) - the\n                authorization search order.", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the authorization search order.\n        :rtype: ``osid.authorization.AuthorizationSearchOrder``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.authorization.AuthorizationSearchOrder", 
               "errors": {}
            }, 
            {
               "name": "apply_authorization_query", 
               "doc": {
                  "headline": "Applies a authorization query to this vault.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    authorization_query\n                (osid.authorization.AuthorizationQuery): the\n                authorization query\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``authorization_query`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure occurred\n        raise:  Unsupported - ``authorization_query`` not of this\n                service", 
               "sphinx_param_doc": "        :param authorization_query: the authorization query\n        :type authorization_query: ``osid.authorization.AuthorizationQuery``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``authorization_query`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure occurred\n        :raise: ``Unsupported`` -- ``authorization_query`` not of this service", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.authorization.AuthorizationQuery", 
                     "var_name": "authorization_query", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.authorization.AuthorizationQuery"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }, 
            {
               "name": "inspect_authorization_query", 
               "doc": {
                  "headline": "Gets a authorization query inspector for this vault.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.authorization.AuthorizationQueryInspector) - the\n                authorization query inspector", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure occurred", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the authorization query inspector\n        :rtype: ``osid.authorization.AuthorizationQueryInspector``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure occurred", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.authorization.AuthorizationQueryInspector", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "apply_authorization_sequencing", 
               "doc": {
                  "headline": "Applies a authorization search order to this vault.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    authorization_search_order\n                (osid.authorization.AuthorizationSearchOrder): the\n                authorization search order\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``authorization_search_order`` is\n                ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure occurred\n        raise:  Unsupported - ``authorization_search_order`` not of this\n                service", 
               "sphinx_param_doc": "        :param authorization_search_order: the authorization search order\n        :type authorization_search_order: ``osid.authorization.AuthorizationSearchOrder``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``authorization_search_order`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure occurred\n        :raise: ``Unsupported`` -- ``authorization_search_order`` not of this service", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.authorization.AuthorizationSearchOrder", 
                     "var_name": "authorization_search_order", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.authorization.AuthorizationSearchOrder"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_authorization_query_from_inspector", 
               "doc": {
                  "headline": "Gets a authorization query from an inspector.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    authorization_query_inspector\n                (osid.authorization.AuthorizationQueryInspector): a\n                resorce relationship query inspector\n", 
               "return_doc": "        return: (osid.authorization.AuthorizationQuery) - the\n                authorization query", 
               "error_doc": "        raise:  NullArgument - ``authorization_query_inspector`` is\n                ``null``\n        raise:  Unsupported - ``authorization_query_inspector`` is not\n                of this service", 
               "sphinx_param_doc": "        :param authorization_query_inspector: a resorce relationship query inspector\n        :type authorization_query_inspector: ``osid.authorization.AuthorizationQueryInspector``\n", 
               "sphinx_return_doc": "        :return: the authorization query\n        :rtype: ``osid.authorization.AuthorizationQuery``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``authorization_query_inspector`` is ``null``\n        :raise: ``Unsupported`` -- ``authorization_query_inspector`` is not of this service", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.authorization.AuthorizationQueryInspector", 
                     "var_name": "authorization_query_inspector", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.authorization.AuthorizationQueryInspector"
               ], 
               "return_type": "osid.authorization.AuthorizationQuery", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.authorization.FunctionLookupSession", 
         "shortname": "FunctionLookupSession", 
         "category": "sessions", 
         "doc": {
            "headline": "This session provides methods for retrieving ``Function`` objects.", 
            "body": ""
         }, 
         "inherit_fullnames": [
            "osid.OsidSession"
         ], 
         "inherit_shortnames": [
            "OsidSession"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidSession"
            }
         ], 
         "method_names": [
            "get_vault_id", 
            "get_vault", 
            "can_lookup_functions", 
            "use_comparative_function_view", 
            "use_plenary_function_view", 
            "use_federated_vault_view", 
            "use_isolated_vault_view", 
            "use_active_function_view", 
            "use_any_status_function_view", 
            "get_function", 
            "get_functions_by_ids", 
            "get_functions_by_genus_type", 
            "get_functions_by_parent_genus_type", 
            "get_functions_by_record_type", 
            "get_functions"
         ], 
         "methods": [
            {
               "name": "get_vault_id", 
               "doc": {
                  "headline": "Gets the ``Vault``  ``Id`` associated with this session.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.id.Id) - the ``Vault Id`` associated with this\n                session", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the ``Vault Id`` associated with this session\n        :rtype: ``osid.id.Id``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.id.Id", 
               "errors": {}
            }, 
            {
               "name": "get_vault", 
               "doc": {
                  "headline": "Gets the ``Vault`` associated with this session.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.authorization.Vault) - the ``Vault`` associated\n                with this session", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the ``Vault`` associated with this session\n        :rtype: ``osid.authorization.Vault``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.authorization.Vault", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "can_lookup_functions", 
               "doc": {
                  "headline": "Tests if this user can perform ``Function`` lookups.", 
                  "body": "        A return of true does not guarantee successful authorization. A\n        return of false indicates that it is known all methods in this\n        session will result in a ``PermissionDenied``. This is intended\n        as a hint to an application that may opt not to offer lookup\n        operations."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``false`` if lookup methods are not\n                authorized, ``true`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``false`` if lookup methods are not authorized, ``true`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "use_comparative_function_view", 
               "doc": {
                  "headline": "The returns from the lookup methods may omit or translate elements based on this session, such as authorization, and not result in an error.", 
                  "body": "        This view is used when greater interoperability is desired at\n        the expense of precision."
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "use_plenary_function_view", 
               "doc": {
                  "headline": "A complete view of the ``Function`` returns is desired.", 
                  "body": "        Methods will return what is requested or result in an error.\n        This view is used when greater precision is desired at the\n        expense of interoperability."
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "use_federated_vault_view", 
               "doc": {
                  "headline": "Federates the view for methods in this session.", 
                  "body": "        A federated view will include functions in vaults which are\n        children of this vault in the vault hierarchy."
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "use_isolated_vault_view", 
               "doc": {
                  "headline": "Isolates the view for methods in this session.", 
                  "body": "        An isolated view restricts lookups to this vault only."
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "use_active_function_view", 
               "doc": {
                  "headline": "Only active functions are returned by methods in this session.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "use_any_status_function_view", 
               "doc": {
                  "headline": "Active and inactive functions are returned by methods in this session.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "get_function", 
               "doc": {
                  "headline": "Gets the ``Function`` specified by its ``Id``.", 
                  "body": "        In plenary mode, the exact ``Id`` is found or a ``NotFound``\n        results. Otherwise, the returned ``Function`` may have a\n        different ``Id`` than requested, such as the case where a\n        duplicate ``Id`` was assigned to a ``Function`` and retained for\n        compatibility."
               }, 
               "arg_doc": "        arg:    function_id (osid.id.Id): the ``Id`` of the ``Function``\n                to retrieve\n", 
               "return_doc": "        return: (osid.authorization.Function) - the returned\n                ``Function``", 
               "error_doc": "        raise:  NotFound - no ``Function`` found with the given ``Id``\n        raise:  NullArgument - ``function_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param function_id: the ``Id`` of the ``Function`` to retrieve\n        :type function_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: the returned ``Function``\n        :rtype: ``osid.authorization.Function``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- no ``Function`` found with the given ``Id``\n        :raise: ``NullArgument`` -- ``function_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "function_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "osid.authorization.Function", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_functions_by_ids", 
               "doc": {
                  "headline": "Gets a ``FunctionList`` corresponding to the given ``IdList``.", 
                  "body": "        In plenary mode, the returned list contains all of the functions\n        specified in the ``Id`` list, in the order of the list,\n        including duplicates, or an error results if an ``Id`` in the\n        supplied list is not found or inaccessible. Otherwise,\n        inaccessible ``Functions`` may be omitted from the list and may\n        present the elements in any order including returning a unique\n        set."
               }, 
               "arg_doc": "        arg:    function_ids (osid.id.IdList): the list of ``Ids`` to\n                retrieve\n", 
               "return_doc": "        return: (osid.authorization.FunctionList) - the returned\n                ``Function`` list", 
               "error_doc": "        raise:  NotFound - an ``Id was`` not found\n        raise:  NullArgument - ``function_ids`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param function_ids: the list of ``Ids`` to retrieve\n        :type function_ids: ``osid.id.IdList``\n", 
               "sphinx_return_doc": "        :return: the returned ``Function`` list\n        :rtype: ``osid.authorization.FunctionList``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- an ``Id was`` not found\n        :raise: ``NullArgument`` -- ``function_ids`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.IdList", 
                     "var_name": "function_ids", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.IdList"
               ], 
               "return_type": "osid.authorization.FunctionList", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_functions_by_genus_type", 
               "doc": {
                  "headline": "Gets a ``FunctionList`` corresponding to the given function genus ``Type`` which does not include functions of genus types derived from the specified ``Type``.", 
                  "body": "        In plenary mode, the returned list contains all known functions\n        or an error results. Otherwise, the returned list may contain\n        only those functions that are accessible through this session."
               }, 
               "arg_doc": "        arg:    function_genus_type (osid.type.Type): a function genus\n                type\n", 
               "return_doc": "        return: (osid.authorization.FunctionList) - the returned\n                ``Function`` list", 
               "error_doc": "        raise:  NullArgument - ``function_genus_type`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param function_genus_type: a function genus type\n        :type function_genus_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "        :return: the returned ``Function`` list\n        :rtype: ``osid.authorization.FunctionList``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``function_genus_type`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "function_genus_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "osid.authorization.FunctionList", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_functions_by_parent_genus_type", 
               "doc": {
                  "headline": "Gets a ``FunctionList`` corresponding to the given function genus ``Type`` and include any additional functions with genus types derived from the specified ``Type``.", 
                  "body": "        In plenary mode, the returned list contains all known functions\n        or an error results. Otherwise, the returned list may contain\n        only those functions that are accessible through this session."
               }, 
               "arg_doc": "        arg:    function_genus_type (osid.type.Type): a function genus\n                type\n", 
               "return_doc": "        return: (osid.authorization.FunctionList) - the returned\n                ``Function`` list", 
               "error_doc": "        raise:  NullArgument - ``function_genus_type`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param function_genus_type: a function genus type\n        :type function_genus_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "        :return: the returned ``Function`` list\n        :rtype: ``osid.authorization.FunctionList``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``function_genus_type`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "function_genus_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "osid.authorization.FunctionList", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_functions_by_record_type", 
               "doc": {
                  "headline": "Gets a ``FunctionList`` containing the given function record ``Type``.", 
                  "body": "        In plenary mode, the returned list contains all known functions\n        or an error results. Otherwise, the returned list may contain\n        only those functions that are accessible through this session."
               }, 
               "arg_doc": "        arg:    function_record_type (osid.type.Type): a function record\n                type\n", 
               "return_doc": "        return: (osid.authorization.FunctionList) - the returned\n                ``Function`` list", 
               "error_doc": "        raise:  NullArgument - ``function_record_type`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param function_record_type: a function record type\n        :type function_record_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "        :return: the returned ``Function`` list\n        :rtype: ``osid.authorization.FunctionList``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``function_record_type`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "function_record_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "osid.authorization.FunctionList", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_functions", 
               "doc": {
                  "headline": "Gets all ``Functions``.", 
                  "body": "        In plenary mode, the returned list contains all known functions\n        or an error results. Otherwise, the returned list may contain\n        only those functions that are accessible through this session."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.authorization.FunctionList) - a list of\n                ``Functions``", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: a list of ``Functions``\n        :rtype: ``osid.authorization.FunctionList``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.authorization.FunctionList", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.authorization.FunctionQuerySession", 
         "shortname": "FunctionQuerySession", 
         "category": "sessions", 
         "doc": {
            "headline": "This session provides methods for searching ``Function`` objects.", 
            "body": "    The search query is constructed using the ``FunctionQuery``. The\n    function record ``Type`` also specifies the query record for the\n    function query.\n\n    This session defines views that offer differing behaviors for\n    searching.\n    \n      * federated vault view: searches include functions in vaults of\n        which this vault is a ancestor in the vault hierarchy\n      * isolated vault view: searches are restricted to functions in\n        this vault\n\n    \n    Functions may have a query record indicated by their respective\n    record types. The query record is accessed via the\n    ``FunctionQuery``."
         }, 
         "inherit_fullnames": [
            "osid.OsidSession"
         ], 
         "inherit_shortnames": [
            "OsidSession"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidSession"
            }
         ], 
         "method_names": [
            "get_vault_id", 
            "get_vault", 
            "can_search_functions", 
            "use_federated_vault_view", 
            "use_isolated_vault_view", 
            "get_function_query", 
            "get_functions_by_query"
         ], 
         "methods": [
            {
               "name": "get_vault_id", 
               "doc": {
                  "headline": "Gets the ``Vault``  ``Id`` associated with this session.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.id.Id) - the ``Vault Id`` associated with this\n                session", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the ``Vault Id`` associated with this session\n        :rtype: ``osid.id.Id``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.id.Id", 
               "errors": {}
            }, 
            {
               "name": "get_vault", 
               "doc": {
                  "headline": "Gets the ``Vault`` associated with this session.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.authorization.Vault) - the ``Vault`` associated\n                with this session", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the ``Vault`` associated with this session\n        :rtype: ``osid.authorization.Vault``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.authorization.Vault", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "can_search_functions", 
               "doc": {
                  "headline": "Tests if this user can perform ``Function`` searches.", 
                  "body": "        A return of true does not guarantee successful authorization. A\n        return of false indicates that it is known all methods in this\n        session will result in a ``PermissionDenied``. This is intended\n        as a hint to an application that may opt not to offer search\n        operations to unauthorized users."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``false`` if search methods are not\n                authorized, ``true`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``false`` if search methods are not authorized, ``true`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "use_federated_vault_view", 
               "doc": {
                  "headline": "Federates the view for methods in this session.", 
                  "body": "        A federated view will include functions in vaults which are\n        children of this vault in the vault hierarchy."
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "use_isolated_vault_view", 
               "doc": {
                  "headline": "Isolates the view for methods in this session.", 
                  "body": "        An isolated view restricts searches to this vault only."
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "get_function_query", 
               "doc": {
                  "headline": "Gets a function query.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.authorization.FunctionQuery) - the function query", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the function query\n        :rtype: ``osid.authorization.FunctionQuery``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.authorization.FunctionQuery", 
               "errors": {}
            }, 
            {
               "name": "get_functions_by_query", 
               "doc": {
                  "headline": "Gets a list of ``Functions`` matching the given query.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    function_query (osid.authorization.FunctionQuery): the\n                function query\n", 
               "return_doc": "        return: (osid.authorization.FunctionList) - the returned\n                ``FunctionList``", 
               "error_doc": "        raise:  NullArgument - ``function_query`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        raise:  Unsupported - ``function_query`` is not of this service", 
               "sphinx_param_doc": "        :param function_query: the function query\n        :type function_query: ``osid.authorization.FunctionQuery``\n", 
               "sphinx_return_doc": "        :return: the returned ``FunctionList``\n        :rtype: ``osid.authorization.FunctionList``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``function_query`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure\n        :raise: ``Unsupported`` -- ``function_query`` is not of this service", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.authorization.FunctionQuery", 
                     "var_name": "function_query", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.authorization.FunctionQuery"
               ], 
               "return_type": "osid.authorization.FunctionList", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.authorization.FunctionSearchSession", 
         "shortname": "FunctionSearchSession", 
         "category": "sessions", 
         "doc": {
            "headline": "This session provides methods for searching ``Function`` objects.", 
            "body": "    The search query is constructed using the ``FunctionQuery``. The\n    function record ``Type`` also specifies the record for the function\n    query.\n\n    ``get_functions_by_query()`` is the basic search method and returns\n    a list of ``Functions``. A more advanced search may be performed\n    with ``getFunctionsBySearch()``. It accepts a ``FunctionSearch`` in\n    addition to the query for the purpose of specifying additional\n    options affecting the entire search, such as ordering.\n    ``get_functions_by_search()`` returns an ``FunctionSearchResults``\n    that can be used to access the resulting ``FunctionList`` or be used\n    to perform a search within the result set through\n    ``FunctionSearch``.\n    \n    This session defines views that offer differing behaviors for\n    searching.\n    \n      * federated vault view: searches include functions in vaults of\n        which this vault is a ancestor in the vault hierarchy\n      * isolated vault view: searches are restricted to functions in\n        this vault\n\n    \n    Functions may have a query record indicated by their respective\n    record types. The query record is accessed via the\n    ``FunctionQuery``."
         }, 
         "inherit_fullnames": [
            "osid.authorization.FunctionQuerySession"
         ], 
         "inherit_shortnames": [
            "FunctionQuerySession"
         ], 
         "inherit_pkg_names": [
            "authorization"
         ], 
         "inheritance": [
            {
               "pkg_name": "authorization", 
               "name": "FunctionQuerySession"
            }
         ], 
         "method_names": [
            "get_function_search", 
            "get_function_search_order", 
            "get_functions_by_search", 
            "get_function_query_from_inspector"
         ], 
         "methods": [
            {
               "name": "get_function_search", 
               "doc": {
                  "headline": "Gets a function search.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.authorization.FunctionSearch) - the function\n                search", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the function search\n        :rtype: ``osid.authorization.FunctionSearch``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.authorization.FunctionSearch", 
               "errors": {}
            }, 
            {
               "name": "get_function_search_order", 
               "doc": {
                  "headline": "Gets a function search order.", 
                  "body": "        The ``FunctionSearchOrder`` is supplied to a ``FunctionSearch``\n        to specify the ordering of results."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.authorization.FunctionSearchOrder) - the function\n                search order", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the function search order\n        :rtype: ``osid.authorization.FunctionSearchOrder``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.authorization.FunctionSearchOrder", 
               "errors": {}
            }, 
            {
               "name": "get_functions_by_search", 
               "doc": {
                  "headline": "Gets the search results matching the given search query using the given search.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    function_query (osid.authorization.FunctionQuery): the\n                function query\n        arg:    function_search (osid.authorization.FunctionSearch): the\n                function search\n", 
               "return_doc": "        return: (osid.authorization.FunctionSearchResults) - the\n                returned search results", 
               "error_doc": "        raise:  NullArgument - ``function_query`` or ``function_search``\n                is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        raise:  Unsupported - ``function_search`` or ``function_query``\n                is not of this service", 
               "sphinx_param_doc": "        :param function_query: the function query\n        :type function_query: ``osid.authorization.FunctionQuery``\n        :param function_search: the function search\n        :type function_search: ``osid.authorization.FunctionSearch``\n", 
               "sphinx_return_doc": "        :return: the returned search results\n        :rtype: ``osid.authorization.FunctionSearchResults``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``function_query`` or ``function_search`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure\n        :raise: ``Unsupported`` -- ``function_search`` or ``function_query`` is not of this service", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.authorization.FunctionQuery", 
                     "var_name": "function_query", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.authorization.FunctionSearch", 
                     "var_name": "function_search", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.authorization.FunctionQuery", 
                  "osid.authorization.FunctionSearch"
               ], 
               "return_type": "osid.authorization.FunctionSearchResults", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_function_query_from_inspector", 
               "doc": {
                  "headline": "Gets a function query from an inspector.", 
                  "body": "        The inspector is available from a ``FunctionSearchResults``."
               }, 
               "arg_doc": "        arg:    function_query_inspector\n                (osid.authorization.FunctionQueryInspector): a function\n                query inspector\n", 
               "return_doc": "        return: (osid.authorization.FunctionQuery) - the function query", 
               "error_doc": "        raise:  NullArgument - ``function_query_inspector`` is ``null``\n        raise:  Unsupported - ``function_query_inspector`` is not of\n                this service", 
               "sphinx_param_doc": "        :param function_query_inspector: a function query inspector\n        :type function_query_inspector: ``osid.authorization.FunctionQueryInspector``\n", 
               "sphinx_return_doc": "        :return: the function query\n        :rtype: ``osid.authorization.FunctionQuery``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``function_query_inspector`` is ``null``\n        :raise: ``Unsupported`` -- ``function_query_inspector`` is not of this service", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.authorization.FunctionQueryInspector", 
                     "var_name": "function_query_inspector", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.authorization.FunctionQueryInspector"
               ], 
               "return_type": "osid.authorization.FunctionQuery", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.authorization.FunctionAdminSession", 
         "shortname": "FunctionAdminSession", 
         "category": "sessions", 
         "doc": {
            "headline": "This session creates, updates, and deletes ``Functions``.", 
            "body": "    The data for create and update is provided by the consumer via the\n    form object. ``OsidForms`` are requested for each create or update\n    and may not be reused.\n\n    Create and update operations differ in their usage. To create a\n    ``Function,`` a ``FunctionForm`` is requested using\n    ``get_function_form_for_create()`` specifying the desired\n    relationship peers and record ``Types`` or none if no record\n    ``Types`` are needed. The returned ``FunctionForm`` will indicate\n    that it is to be used with a create operation and can be used to\n    examine metdata or validate data prior to creation. Once the\n    ``FunctionForm`` is submiited to a create operation, it cannot be\n    reused with another create operation unless the first operation was\n    unsuccessful. Each ``FunctionForm`` corresponds to an attempted\n    transaction.\n    \n    For updates, ``FunctionForms`` are requested to the ``Function``\n    ``Id`` that is to be updated using ``getFunctionFormForUpdate()``.\n    Similarly, the ``FunctionForm`` has metadata about the data that can\n    be updated and it can perform validation before submitting the\n    update. The ``FunctionForm`` can only be used once for a successful\n    update and cannot be reused.\n    \n    The delete operations delete ``Functions``. To unmap a ``Function``\n    from the current ``Vault,`` the ``FunctionVaultAssignmentSession``\n    should be used. These delete operations attempt to remove the\n    ``Function`` itself thus removing it from all known ``Vault``\n    catalogs.\n    \n    This session includes an ``Id`` aliasing mechanism to assign an\n    external ``Id`` to an internally assigned Id."
         }, 
         "inherit_fullnames": [
            "osid.OsidSession"
         ], 
         "inherit_shortnames": [
            "OsidSession"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidSession"
            }
         ], 
         "method_names": [
            "get_vault_id", 
            "get_vault", 
            "can_create_functions", 
            "can_create_function_with_record_types", 
            "get_function_form_for_create", 
            "create_function", 
            "can_update_functions", 
            "get_function_form_for_update", 
            "update_function", 
            "can_delete_functions", 
            "delete_function", 
            "can_manage_function_aliases", 
            "alias_function"
         ], 
         "methods": [
            {
               "name": "get_vault_id", 
               "doc": {
                  "headline": "Gets the ``Vault``  ``Id`` associated with this session.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.id.Id) - the ``Vault Id`` associated with this\n                session", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the ``Vault Id`` associated with this session\n        :rtype: ``osid.id.Id``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.id.Id", 
               "errors": {}
            }, 
            {
               "name": "get_vault", 
               "doc": {
                  "headline": "Gets the ``Vault`` associated with this session.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.authorization.Vault) - the vault", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the vault\n        :rtype: ``osid.authorization.Vault``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.authorization.Vault", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "can_create_functions", 
               "doc": {
                  "headline": "Tests if this user can create ``Functions``.", 
                  "body": "        A return of true does not guarantee successful authorization. A\n        return of false indicates that it is known creating a\n        ``Function`` will result in a ``PermissionDenied``. This is\n        intended as a hint to an application that may opt not to offer\n        create operations to an unauthorized user."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``false`` if ``Function`` creation is not\n                authorized, ``true`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``false`` if ``Function`` creation is not authorized, ``true`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "can_create_function_with_record_types", 
               "doc": {
                  "headline": "Tests if this user can create a single ``Function`` using the desired record types.", 
                  "body": "        While ``AuthorizationManager.getFunctionRecordTypes()`` can be\n        used to examine which records are supported, this method tests\n        which record(s) are required for creating a specific\n        ``Function``. Providing an empty array tests if a ``Function``\n        can be created with no records."
               }, 
               "arg_doc": "        arg:    function_record_types (osid.type.Type[]): array of\n                function record types\n", 
               "return_doc": "        return: (boolean) - ``true`` if ``Function`` creation using the\n                specified record ``Types`` is supported, ``false``\n                otherwise", 
               "error_doc": "        raise:  NullArgument - ``function_record_types`` is ``null``", 
               "sphinx_param_doc": "        :param function_record_types: array of function record types\n        :type function_record_types: ``osid.type.Type[]``\n", 
               "sphinx_return_doc": "        :return: ``true`` if ``Function`` creation using the specified record ``Types`` is supported, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``function_record_types`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type[]", 
                     "var_name": "function_record_types", 
                     "array": true
                  }
               ], 
               "arg_types": [
                  "osid.type.Type[]"
               ], 
               "return_type": "boolean", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "get_function_form_for_create", 
               "doc": {
                  "headline": "Gets the function form for creating new functions.", 
                  "body": "        A new form should be requested for each create transaction."
               }, 
               "arg_doc": "        arg:    function_record_types (osid.type.Type[]): array of\n                function record types\n", 
               "return_doc": "        return: (osid.authorization.FunctionForm) - the function form", 
               "error_doc": "        raise:  NullArgument - ``function_record_types`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        raise:  Unsupported - unable to get form qith requested record\n                types", 
               "sphinx_param_doc": "        :param function_record_types: array of function record types\n        :type function_record_types: ``osid.type.Type[]``\n", 
               "sphinx_return_doc": "        :return: the function form\n        :rtype: ``osid.authorization.FunctionForm``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``function_record_types`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure\n        :raise: ``Unsupported`` -- unable to get form qith requested record types", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type[]", 
                     "var_name": "function_record_types", 
                     "array": true
                  }
               ], 
               "arg_types": [
                  "osid.type.Type[]"
               ], 
               "return_type": "osid.authorization.FunctionForm", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }, 
            {
               "name": "create_function", 
               "doc": {
                  "headline": "Creates a new ``Function``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    function_form (osid.authorization.FunctionForm): the\n                form for this ``Function``\n", 
               "return_doc": "        return: (osid.authorization.Function) - the new ``Function``", 
               "error_doc": "        raise:  IllegalState - ``function_form`` already used in a\n                create transaction\n        raise:  InvalidArgument - one or more of the form elements is\n                invalid\n        raise:  NullArgument - ``function_form`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        raise:  Unsupported - ``function_form`` did not originate from\n                ``get_function_form_for_create()``", 
               "sphinx_param_doc": "        :param function_form: the form for this ``Function``\n        :type function_form: ``osid.authorization.FunctionForm``\n", 
               "sphinx_return_doc": "        :return: the new ``Function``\n        :rtype: ``osid.authorization.Function``", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- ``function_form`` already used in a create transaction\n        :raise: ``InvalidArgument`` -- one or more of the form elements is invalid\n        :raise: ``NullArgument`` -- ``function_form`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure\n        :raise: ``Unsupported`` -- ``function_form`` did not originate from ``get_function_form_for_create()``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.authorization.FunctionForm", 
                     "var_name": "function_form", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.authorization.FunctionForm"
               ], 
               "return_type": "osid.authorization.Function", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract", 
                  "INVALID_ARGUMENT": "ConsumerContract", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }, 
            {
               "name": "can_update_functions", 
               "doc": {
                  "headline": "Tests if this user can update ``Functions``.", 
                  "body": "        A return of true does not guarantee successful authorization. A\n        return of false indicates that it is known updating a\n        ``Function`` will result in a ``PermissionDenied``. This is\n        intended as a hint to an application that may opt not to offer\n        update operations to an unauthorized user."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``false`` if function modification is not\n                authorized, ``true`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``false`` if function modification is not authorized, ``true`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "get_function_form_for_update", 
               "doc": {
                  "headline": "Gets the function form for updating an existing function.", 
                  "body": "        A new function form should be requested for each update\n        transaction."
               }, 
               "arg_doc": "        arg:    function_id (osid.id.Id): the ``Id`` of the ``Function``\n", 
               "return_doc": "        return: (osid.authorization.FunctionForm) - the function form", 
               "error_doc": "        raise:  NotFound - ``function_id`` is not found\n        raise:  NullArgument - ``function_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param function_id: the ``Id`` of the ``Function``\n        :type function_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: the function form\n        :rtype: ``osid.authorization.FunctionForm``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``function_id`` is not found\n        :raise: ``NullArgument`` -- ``function_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "function_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "osid.authorization.FunctionForm", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "update_function", 
               "doc": {
                  "headline": "Updates an existing function.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    function_form (osid.authorization.FunctionForm): the\n                form containing the elements to be updated\n", 
               "return_doc": "", 
               "error_doc": "        raise:  IllegalState - ``function_form`` already used in an\n                update transaction\n        raise:  InvalidArgument - the form contains an invalid value\n        raise:  NullArgument - ``function_form`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        raise:  Unsupported - ``function_form`` did not originate from\n                ``get_function_form_for_update()``", 
               "sphinx_param_doc": "        :param function_form: the form containing the elements to be updated\n        :type function_form: ``osid.authorization.FunctionForm``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- ``function_form`` already used in an update transaction\n        :raise: ``InvalidArgument`` -- the form contains an invalid value\n        :raise: ``NullArgument`` -- ``function_form`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure\n        :raise: ``Unsupported`` -- ``function_form`` did not originate from ``get_function_form_for_update()``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.authorization.FunctionForm", 
                     "var_name": "function_form", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.authorization.FunctionForm"
               ], 
               "return_type": "", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract", 
                  "INVALID_ARGUMENT": "ConsumerContract", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }, 
            {
               "name": "can_delete_functions", 
               "doc": {
                  "headline": "Tests if this user can delete ``Functions``.", 
                  "body": "        A return of true does not guarantee successful authorization. A\n        return of false indicates that it is known deleting a\n        ``Function`` will result in a ``PermissionDenied``. This is\n        intended as a hint to an application that may opt not to offer\n        delete operations to an unauthorized user."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``false`` if ``Function`` deletion is not\n                authorized, ``true`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``false`` if ``Function`` deletion is not authorized, ``true`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "delete_function", 
               "doc": {
                  "headline": "Deletes the ``Function`` identified by the given ``Id``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    function_id (osid.id.Id): the ``Id`` of the ``Function``\n                to delete\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NotFound - a ``Function`` was not found identified by\n                the given ``Id``\n        raise:  NullArgument - ``function_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param function_id: the ``Id`` of the ``Function`` to delete\n        :type function_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- a ``Function`` was not found identified by the given ``Id``\n        :raise: ``NullArgument`` -- ``function_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "function_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "can_manage_function_aliases", 
               "doc": {
                  "headline": "Tests if this user can manage ``Id`` aliases for ``Functions``.", 
                  "body": "        A return of true does not guarantee successful authorization. A\n        return of false indicates that it is known changing an alias\n        will result in a ``PermissionDenied``. This is intended as a\n        hint to an application that may opt not to offer alias\n        operations to an unauthorized user."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``false`` if ``Function`` aliasing is not\n                authorized, ``true`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``false`` if ``Function`` aliasing is not authorized, ``true`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "alias_function", 
               "doc": {
                  "headline": "Adds an ``Id`` to a ``Function`` for the purpose of creating compatibility.", 
                  "body": "        The primary ``Id`` of the ``Function`` is determined by the\n        provider. The new ``Id`` performs as an alias to the primary\n        ``Id``. If the alias is a pointer to another function, it is\n        reassigned to the given function ``Id``."
               }, 
               "arg_doc": "        arg:    function_id (osid.id.Id): the ``Id`` of a ``Function``\n        arg:    alias_id (osid.id.Id): the alias ``Id``\n", 
               "return_doc": "", 
               "error_doc": "        raise:  AlreadyExists - ``alias_id`` is already assigned\n        raise:  NotFound - ``function_id`` not found\n        raise:  NullArgument - ``function_id`` or ``alias_id`` is\n                ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param function_id: the ``Id`` of a ``Function``\n        :type function_id: ``osid.id.Id``\n        :param alias_id: the alias ``Id``\n        :type alias_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``AlreadyExists`` -- ``alias_id`` is already assigned\n        :raise: ``NotFound`` -- ``function_id`` not found\n        :raise: ``NullArgument`` -- ``function_id`` or ``alias_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "function_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "alias_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {
                  "ALREADY_EXISTS": "User", 
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.authorization.FunctionNotificationSession", 
         "shortname": "FunctionNotificationSession", 
         "category": "sessions", 
         "doc": {
            "headline": "This session defines methods to receive asynchronous notifications on adds/changes to ``Function`` objects.", 
            "body": "    This session is intended for consumers needing to synchronize their\n    state with this service without the use of polling. Notifications\n    are cancelled when this session is closed.\n\n    The two views defined in this session correspond to the views in the\n    ``FunctionLookupSession``."
         }, 
         "inherit_fullnames": [
            "osid.OsidSession"
         ], 
         "inherit_shortnames": [
            "OsidSession"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidSession"
            }
         ], 
         "method_names": [
            "get_vault_id", 
            "get_vault", 
            "can_register_for_function_notifications", 
            "use_federated_vault_view", 
            "use_isolated_vault_view", 
            "register_for_new_functions", 
            "register_for_changed_functions", 
            "register_for_changed_function", 
            "register_for_deleted_functions", 
            "register_for_deleted_function"
         ], 
         "methods": [
            {
               "name": "get_vault_id", 
               "doc": {
                  "headline": "Gets the ``Vault``  ``Id`` associated with this session.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.id.Id) - the ``Vault Id`` associated with this\n                session", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the ``Vault Id`` associated with this session\n        :rtype: ``osid.id.Id``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.id.Id", 
               "errors": {}
            }, 
            {
               "name": "get_vault", 
               "doc": {
                  "headline": "Gets the ``Vault`` associated with this session.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.authorization.Vault) - the ``Vault`` associated\n                with this session", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the ``Vault`` associated with this session\n        :rtype: ``osid.authorization.Vault``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.authorization.Vault", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "can_register_for_function_notifications", 
               "doc": {
                  "headline": "Tests if this user can register for ``Function`` notifications.", 
                  "body": "        A return of true does not guarantee successful authorization. A\n        return of false indicates that it is known all methods in this\n        session will result in a ``PermissionDenied``. This is intended\n        as a hint to an application that may opt not to offer\n        notification operations."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``false`` if notification methods are not\n                authorized, ``true`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``false`` if notification methods are not authorized, ``true`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "use_federated_vault_view", 
               "doc": {
                  "headline": "Federates the view for methods in this session.", 
                  "body": "        A federated view will include functions in vaults which are\n        children of this vault in the vault hierarchy."
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "use_isolated_vault_view", 
               "doc": {
                  "headline": "Isolates the view for methods in this session.", 
                  "body": "        An isolated view restricts notifications to this vault only."
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "register_for_new_functions", 
               "doc": {
                  "headline": "Register for notifications of new functions.", 
                  "body": "        ``FunctionReceiver.newFunction()`` is invoked when a new\n        Function is created."
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "register_for_changed_functions", 
               "doc": {
                  "headline": "Registers for notification of updated functions.", 
                  "body": "        ``FunctionReceiver.changedFunction()`` is invoked when a\n        function is changed."
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "register_for_changed_function", 
               "doc": {
                  "headline": "Registers for notification of an updated function.", 
                  "body": "        ``FunctionReceiver.changedFunction()`` is invoked when the\n        specified function is changed."
               }, 
               "arg_doc": "        arg:    function_id (osid.id.Id): the ``Id`` of the ``Function``\n                to monitor\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``function_id is null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param function_id: the ``Id`` of the ``Function`` to monitor\n        :type function_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``function_id is null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "function_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "register_for_deleted_functions", 
               "doc": {
                  "headline": "Registers for notification of deleted functions.", 
                  "body": "        ``FunctionReceiver.deletedFunction()`` is invoked when a\n        function is removed from this vault."
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "register_for_deleted_function", 
               "doc": {
                  "headline": "Registers for notification of a deleted function.", 
                  "body": "        ``FunctionReceiver.changedFunction()`` is invoked when the\n        specified function is removed from this vault."
               }, 
               "arg_doc": "        arg:    function_id (osid.id.Id): the ``Id`` of the ``Function``\n                to monitor\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``function_id is null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param function_id: the ``Id`` of the ``Function`` to monitor\n        :type function_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``function_id is null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "function_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.authorization.FunctionVaultSession", 
         "shortname": "FunctionVaultSession", 
         "category": "sessions", 
         "doc": {
            "headline": "This session provides methods to retrieve ``Function`` to ``Vault`` mappings.", 
            "body": "    A ``Function`` may appear in multiple ``Vaults``. Each ``Vault`` may\n    have its own authorizations governing who is allowed to look at it.\n\n    This lookup session defines two views:\n    \n      * comparative view: elements may be silently omitted or re-ordered\n      * plenary view: provides a complete result set or is an error\n        condition\n"
         }, 
         "inherit_fullnames": [
            "osid.OsidSession"
         ], 
         "inherit_shortnames": [
            "OsidSession"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidSession"
            }
         ], 
         "method_names": [
            "can_lookup_function_vault_mappings", 
            "use_comparative_vault_view", 
            "use_plenary_vault_view", 
            "get_function_ids_by_vault", 
            "get_functions_by_vault", 
            "get_function_ids_by_vaults", 
            "get_functions_by_vaults", 
            "get_vault_ids_by_function", 
            "get_vaults_by_function"
         ], 
         "methods": [
            {
               "name": "can_lookup_function_vault_mappings", 
               "doc": {
                  "headline": "Tests if this user can perform lookups of function/vault mappings.", 
                  "body": "        A return of true does not guarantee successful authorization. A\n        return of false indicates that it is known lookup methods in\n        this session will result in a ``PermissionDenied``. This is\n        intended as a hint to an application that may opt not to offer\n        lookup operations to unauthorized users."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``false`` if looking up mappings is not\n                authorized, ``true`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``false`` if looking up mappings is not authorized, ``true`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "use_comparative_vault_view", 
               "doc": {
                  "headline": "The returns from the lookup methods may omit or translate elements based on this session, such as authorization, and not result in an error.", 
                  "body": "        This view is used when greater interoperability is desired at\n        the expense of precision."
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "use_plenary_vault_view", 
               "doc": {
                  "headline": "A complete view of the ``Function`` and ``Vault`` returns is desired.", 
                  "body": "        Methods will return what is requested or result in an error.\n        This view is used when greater precision is desired at the\n        expense of interoperability."
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "get_function_ids_by_vault", 
               "doc": {
                  "headline": "Gets the list of ``Function``  ``Ids`` associated with a ``Vault``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    vault_id (osid.id.Id): ``Id`` of the ``Vault``\n", 
               "return_doc": "        return: (osid.id.IdList) - list of related function ``Ids``", 
               "error_doc": "        raise:  NotFound - ``vault_id`` is not found\n        raise:  NullArgument - ``vault_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param vault_id: ``Id`` of the ``Vault``\n        :type vault_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: list of related function ``Ids``\n        :rtype: ``osid.id.IdList``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``vault_id`` is not found\n        :raise: ``NullArgument`` -- ``vault_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "vault_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "osid.id.IdList", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_functions_by_vault", 
               "doc": {
                  "headline": "Gets the list of ``Functions`` associated with a ``Vault``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    vault_id (osid.id.Id): ``Id`` of the ``Vault``\n", 
               "return_doc": "        return: (osid.authorization.FunctionList) - list of related\n                functions", 
               "error_doc": "        raise:  NotFound - ``vault_id`` is not found\n        raise:  NullArgument - ``vault_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param vault_id: ``Id`` of the ``Vault``\n        :type vault_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: list of related functions\n        :rtype: ``osid.authorization.FunctionList``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``vault_id`` is not found\n        :raise: ``NullArgument`` -- ``vault_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "vault_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "osid.authorization.FunctionList", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_function_ids_by_vaults", 
               "doc": {
                  "headline": "Gets the list of ``Function Ids`` corresponding to a list of ``Vaults``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    vault_ids (osid.id.IdList): list of vault ``Ids``\n", 
               "return_doc": "        return: (osid.id.IdList) - list of function ``Ids``", 
               "error_doc": "        raise:  NullArgument - ``vault_ids`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param vault_ids: list of vault ``Ids``\n        :type vault_ids: ``osid.id.IdList``\n", 
               "sphinx_return_doc": "        :return: list of function ``Ids``\n        :rtype: ``osid.id.IdList``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``vault_ids`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.IdList", 
                     "var_name": "vault_ids", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.IdList"
               ], 
               "return_type": "osid.id.IdList", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_functions_by_vaults", 
               "doc": {
                  "headline": "Gets the list of ``Functions`` corresponding to a list of ``Vaults``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    vault_ids (osid.id.IdList): list of vault ``Ids``\n", 
               "return_doc": "        return: (osid.authorization.FunctionList) - list of functions", 
               "error_doc": "        raise:  NullArgument - ``vault_ids`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param vault_ids: list of vault ``Ids``\n        :type vault_ids: ``osid.id.IdList``\n", 
               "sphinx_return_doc": "        :return: list of functions\n        :rtype: ``osid.authorization.FunctionList``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``vault_ids`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.IdList", 
                     "var_name": "vault_ids", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.IdList"
               ], 
               "return_type": "osid.authorization.FunctionList", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_vault_ids_by_function", 
               "doc": {
                  "headline": "Gets the list of ``Vault``  ``Ids`` mapped to a ``Function``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    function_id (osid.id.Id): ``Id`` of a ``Function``\n", 
               "return_doc": "        return: (osid.id.IdList) - list of vault ``Ids``", 
               "error_doc": "        raise:  NotFound - ``function_id`` is not found\n        raise:  NullArgument - ``function_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param function_id: ``Id`` of a ``Function``\n        :type function_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: list of vault ``Ids``\n        :rtype: ``osid.id.IdList``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``function_id`` is not found\n        :raise: ``NullArgument`` -- ``function_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "function_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "osid.id.IdList", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_vaults_by_function", 
               "doc": {
                  "headline": "Gets the list of ``Vaults`` mapped to a ``Function``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    function_id (osid.id.Id): ``Id`` of a ``Function``\n", 
               "return_doc": "        return: (osid.authorization.VaultList) - list of vaults", 
               "error_doc": "        raise:  NotFound - ``function_id`` is not found\n        raise:  NullArgument - ``function_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param function_id: ``Id`` of a ``Function``\n        :type function_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: list of vaults\n        :rtype: ``osid.authorization.VaultList``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``function_id`` is not found\n        :raise: ``NullArgument`` -- ``function_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "function_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "osid.authorization.VaultList", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.authorization.FunctionVaultAssignmentSession", 
         "shortname": "FunctionVaultAssignmentSession", 
         "category": "sessions", 
         "doc": {
            "headline": "This session provides methods to re-assign ``Functions`` to ``Vaults``.", 
            "body": "    A ``Function`` may map to multiple ``Vaults`` and removing the last\n    reference to a ``Function`` is the equivalent of deleting it. Each\n    ``Vault`` may have its own authorizations governing who is allowed\n    to operate on it.\n\n    Adding a reference of a ``Function`` to another ``Vault`` is not a\n    copy operation (eg: does not change its ``Id`` )."
         }, 
         "inherit_fullnames": [
            "osid.OsidSession"
         ], 
         "inherit_shortnames": [
            "OsidSession"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidSession"
            }
         ], 
         "method_names": [
            "can_assign_functions", 
            "can_assign_functions_to_vault", 
            "get_assignable_vault_ids", 
            "get_assignable_vault_ids_for_function", 
            "assign_function_to_vault", 
            "unassign_function_from_vault"
         ], 
         "methods": [
            {
               "name": "can_assign_functions", 
               "doc": {
                  "headline": "Tests if this user can alter function/vault mappings.", 
                  "body": "        A return of true does not guarantee successful authorization. A\n        return of false indicates that it is known mapping methods in\n        this session will result in a ``PermissionDenied``. This is\n        intended as a hint to an application that may opt not to offer\n        assignment operations to unauthorized users."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``false`` if mapping is not authorized,\n                ``true`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``false`` if mapping is not authorized, ``true`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "can_assign_functions_to_vault", 
               "doc": {
                  "headline": "Tests if this user can alter function/vault mappings.", 
                  "body": "        A return of true does not guarantee successful authorization. A\n        return of false indicates that it is known mapping methods in\n        this session will result in a ``PermissionDenied``. This is\n        intended as a hint to an application that may opt not to offer\n        assignment operations to unauthorized users."
               }, 
               "arg_doc": "        arg:    vault_id (osid.id.Id): the ``Id`` of the ``Vault``\n", 
               "return_doc": "        return: (boolean) - ``false`` if mapping is not authorized,\n                ``true`` otherwise", 
               "error_doc": "        raise:  NullArgument - ``vault_id`` is ``null``", 
               "sphinx_param_doc": "        :param vault_id: the ``Id`` of the ``Vault``\n        :type vault_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: ``false`` if mapping is not authorized, ``true`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``vault_id`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "vault_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "boolean", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "get_assignable_vault_ids", 
               "doc": {
                  "headline": "Gets a list of vault including and under the given vault node in which any function can be assigned.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    vault_id (osid.id.Id): the ``Id`` of the ``Vault``\n", 
               "return_doc": "        return: (osid.id.IdList) - list of assignable vault ``Ids``", 
               "error_doc": "        raise:  NullArgument - ``vault_id`` is ``null``\n        raise:  OperationFailed - unable to complete request", 
               "sphinx_param_doc": "        :param vault_id: the ``Id`` of the ``Vault``\n        :type vault_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: list of assignable vault ``Ids``\n        :rtype: ``osid.id.IdList``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``vault_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "vault_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "osid.id.IdList", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational"
               }
            }, 
            {
               "name": "get_assignable_vault_ids_for_function", 
               "doc": {
                  "headline": "Gets a list of vault including and under the given vault node in which a specific function can be assigned.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    vault_id (osid.id.Id): the ``Id`` of the ``Vault``\n        arg:    function_id (osid.id.Id): the ``Id`` of the ``Function``\n", 
               "return_doc": "        return: (osid.id.IdList) - list of assignable vault ``Ids``", 
               "error_doc": "        raise:  NullArgument - ``vault_id`` or ``function_id`` is\n                ``null``\n        raise:  OperationFailed - unable to complete request", 
               "sphinx_param_doc": "        :param vault_id: the ``Id`` of the ``Vault``\n        :type vault_id: ``osid.id.Id``\n        :param function_id: the ``Id`` of the ``Function``\n        :type function_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: list of assignable vault ``Ids``\n        :rtype: ``osid.id.IdList``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``vault_id`` or ``function_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "vault_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "function_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "osid.id.Id"
               ], 
               "return_type": "osid.id.IdList", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational"
               }
            }, 
            {
               "name": "assign_function_to_vault", 
               "doc": {
                  "headline": "Adds an existing ``Function`` to a ``Vault``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    function_id (osid.id.Id): the ``Id`` of the ``Function``\n        arg:    vault_id (osid.id.Id): the ``Id`` of the ``Vault``\n", 
               "return_doc": "", 
               "error_doc": "        raise:  AlreadyExists - ``function_id`` is already assigned to\n                ``vault_id``\n        raise:  NotFound - ``function_id`` or ``vault_id`` not found\n        raise:  NullArgument - ``function_id`` or ``vault_id`` is\n                ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param function_id: the ``Id`` of the ``Function``\n        :type function_id: ``osid.id.Id``\n        :param vault_id: the ``Id`` of the ``Vault``\n        :type vault_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``AlreadyExists`` -- ``function_id`` is already assigned to ``vault_id``\n        :raise: ``NotFound`` -- ``function_id`` or ``vault_id`` not found\n        :raise: ``NullArgument`` -- ``function_id`` or ``vault_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "function_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "vault_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {
                  "ALREADY_EXISTS": "User", 
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "unassign_function_from_vault", 
               "doc": {
                  "headline": "Removes a ``Function`` from a ``Vault``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    function_id (osid.id.Id): the ``Id`` of the ``Function``\n        arg:    vault_id (osid.id.Id): the ``Id`` of the ``Vault``\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NotFound - ``function_id`` or ``vault_id`` not found or\n                ``function_id`` not assigned to ``vault_id``\n        raise:  NullArgument - ``function_id`` or ``vault_id`` is\n                ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param function_id: the ``Id`` of the ``Function``\n        :type function_id: ``osid.id.Id``\n        :param vault_id: the ``Id`` of the ``Vault``\n        :type vault_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``function_id`` or ``vault_id`` not found or ``function_id`` not assigned to ``vault_id``\n        :raise: ``NullArgument`` -- ``function_id`` or ``vault_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "function_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "vault_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.authorization.FunctionSmartVaultSession", 
         "shortname": "FunctionSmartVaultSession", 
         "category": "sessions", 
         "doc": {
            "headline": "This session manages queries and sequencing to create \"smart\" dynamic catalogs.", 
            "body": "    A ``FunctionQuery`` can be retrieved from this session and mapped to\n    this ``Vault`` to create a virtual collection of ``Functions``. The\n    functions may be sequenced using the ``FunctionSearchOrder`` from\n    this session.\n\n    This ``Vault`` has a default query that matches any function and a\n    default search order that specifies no sequencing. The queries may\n    be examined using a ``FunctionQueryInspector``. The query may be\n    modified by converting the inspector back to a ``FunctionQuery``."
         }, 
         "inherit_fullnames": [
            "osid.OsidSession"
         ], 
         "inherit_shortnames": [
            "OsidSession"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidSession"
            }
         ], 
         "method_names": [
            "get_vault_id", 
            "get_vault", 
            "can_manage_smart_vaults", 
            "get_function_query", 
            "get_function_search_order", 
            "apply_function_query", 
            "inspect_function_query", 
            "apply_function_sequencing", 
            "get_function_query_from_inspector"
         ], 
         "methods": [
            {
               "name": "get_vault_id", 
               "doc": {
                  "headline": "Gets the ``Vault``  ``Id`` associated with this session.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.id.Id) - the ``Vault Id`` associated with this\n                session", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the ``Vault Id`` associated with this session\n        :rtype: ``osid.id.Id``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.id.Id", 
               "errors": {}
            }, 
            {
               "name": "get_vault", 
               "doc": {
                  "headline": "Gets the ``Vault`` associated with this session.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.authorization.Vault) - the ``Vault`` associated\n                with this session", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the ``Vault`` associated with this session\n        :rtype: ``osid.authorization.Vault``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.authorization.Vault", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "can_manage_smart_vaults", 
               "doc": {
                  "headline": "Tests if this user can manage smart vaults.", 
                  "body": "        A return of true does not guarantee successful authorization. A\n        return of false indicates that it is known methods in this\n        session will result in a ``PermissionDenied``. This is intended\n        as a hint to an application that may opt not to offer operations\n        to unauthorized users."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``false`` if smart vault management is not\n                authorized, ``true`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``false`` if smart vault management is not authorized, ``true`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "get_function_query", 
               "doc": {
                  "headline": "Gets a function query.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.authorization.FunctionQuery) - the function query", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the function query\n        :rtype: ``osid.authorization.FunctionQuery``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.authorization.FunctionQuery", 
               "errors": {}
            }, 
            {
               "name": "get_function_search_order", 
               "doc": {
                  "headline": "Gets a function search order.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.authorization.FunctionSearchOrder) - the function\n                search order", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the function search order\n        :rtype: ``osid.authorization.FunctionSearchOrder``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.authorization.FunctionSearchOrder", 
               "errors": {}
            }, 
            {
               "name": "apply_function_query", 
               "doc": {
                  "headline": "Applies a function query to this vault.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    function_query (osid.authorization.FunctionQuery): the\n                function query\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``function_query`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure occurred\n        raise:  Unsupported - ``function_query`` not of this service", 
               "sphinx_param_doc": "        :param function_query: the function query\n        :type function_query: ``osid.authorization.FunctionQuery``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``function_query`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure occurred\n        :raise: ``Unsupported`` -- ``function_query`` not of this service", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.authorization.FunctionQuery", 
                     "var_name": "function_query", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.authorization.FunctionQuery"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }, 
            {
               "name": "inspect_function_query", 
               "doc": {
                  "headline": "Gets a function query inspector for this vault.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.authorization.FunctionQueryInspector) - the\n                function query inspector", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure occurred", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the function query inspector\n        :rtype: ``osid.authorization.FunctionQueryInspector``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure occurred", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.authorization.FunctionQueryInspector", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "apply_function_sequencing", 
               "doc": {
                  "headline": "Applies a function search order to this vault.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    function_search_order\n                (osid.authorization.FunctionSearchOrder): the function\n                search order\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``function_search_order`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure occurred\n        raise:  Unsupported - ``function_search_order`` not of this\n                service", 
               "sphinx_param_doc": "        :param function_search_order: the function search order\n        :type function_search_order: ``osid.authorization.FunctionSearchOrder``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``function_search_order`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure occurred\n        :raise: ``Unsupported`` -- ``function_search_order`` not of this service", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.authorization.FunctionSearchOrder", 
                     "var_name": "function_search_order", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.authorization.FunctionSearchOrder"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_function_query_from_inspector", 
               "doc": {
                  "headline": "Gets a function query from an inspector.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    function_query_inspector\n                (osid.authorization.FunctionQueryInspector): a function\n                query inspector\n", 
               "return_doc": "        return: (osid.authorization.FunctionQuery) - the function query", 
               "error_doc": "        raise:  NullArgument - ``function_query_inspector`` is ``null``\n        raise:  Unsupported - ``function_query_inspector`` is not of\n                this service", 
               "sphinx_param_doc": "        :param function_query_inspector: a function query inspector\n        :type function_query_inspector: ``osid.authorization.FunctionQueryInspector``\n", 
               "sphinx_return_doc": "        :return: the function query\n        :rtype: ``osid.authorization.FunctionQuery``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``function_query_inspector`` is ``null``\n        :raise: ``Unsupported`` -- ``function_query_inspector`` is not of this service", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.authorization.FunctionQueryInspector", 
                     "var_name": "function_query_inspector", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.authorization.FunctionQueryInspector"
               ], 
               "return_type": "osid.authorization.FunctionQuery", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.authorization.QualifierLookupSession", 
         "shortname": "QualifierLookupSession", 
         "category": "sessions", 
         "doc": {
            "headline": "This session defines methods for retrieving qualifiers.", 
            "body": ""
         }, 
         "inherit_fullnames": [
            "osid.OsidSession"
         ], 
         "inherit_shortnames": [
            "OsidSession"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidSession"
            }
         ], 
         "method_names": [
            "get_vault_id", 
            "get_vault", 
            "can_lookup_qualifiers", 
            "use_comparative_qualifier_view", 
            "use_plenary_qualifier_view", 
            "use_federated_vault_view", 
            "use_isolated_vault_view", 
            "get_qualifier", 
            "get_qualifiers_by_ids", 
            "get_qualifiers_by_genus_type", 
            "get_qualifiers_by_parent_genus_type", 
            "get_qualifiers_by_record_type", 
            "get_qualifiers"
         ], 
         "methods": [
            {
               "name": "get_vault_id", 
               "doc": {
                  "headline": "Gets the ``Vault``  ``Id`` associated with this session.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.id.Id) - the ``Vault Id`` associated with this\n                session", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the ``Vault Id`` associated with this session\n        :rtype: ``osid.id.Id``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.id.Id", 
               "errors": {}
            }, 
            {
               "name": "get_vault", 
               "doc": {
                  "headline": "Gets the ``Vault`` associated with this session.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.authorization.Vault) - the ``Vault`` associated\n                with this session", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the ``Vault`` associated with this session\n        :rtype: ``osid.authorization.Vault``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.authorization.Vault", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "can_lookup_qualifiers", 
               "doc": {
                  "headline": "Tests if this user can perform ``Qualifier`` lookups.", 
                  "body": "        A return of true does not guarantee successful authorization. A\n        return of false indicates that it is known all methods in this\n        session will result in a ``PermissionDenied``. This is intended\n        as a hint to an application that may opt not to offer lookup\n        operations to unauthorized users."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``false`` if lookup methods are not\n                authorized, ``true`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``false`` if lookup methods are not authorized, ``true`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "use_comparative_qualifier_view", 
               "doc": {
                  "headline": "The returns from the lookup methods may omit or translate elements based on this session, such as authorization, and not result in an error.", 
                  "body": "        This view is used when greater interoperability is desired at\n        the expense of precision."
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "use_plenary_qualifier_view", 
               "doc": {
                  "headline": "A complete view of the ``Qualifier`` returns is desired.", 
                  "body": "        Methods will return what is requested or result in an error.\n        This view is used when greater precision is desired at the\n        expense of interoperability."
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "use_federated_vault_view", 
               "doc": {
                  "headline": "Federates the view for methods in this session.", 
                  "body": "        A federated view will include qualifiers in vaults which are\n        children of this vault in the vault hierarchy."
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "use_isolated_vault_view", 
               "doc": {
                  "headline": "Isolates the view for methods in this session.", 
                  "body": "        An isolated view restricts lookups to this vault only."
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "get_qualifier", 
               "doc": {
                  "headline": "Gets the ``Qualifier`` specified by its ``Id``.", 
                  "body": "        In plenary mode, the exact ``Id`` is found or a ``NotFound``\n        results. Otherwise, the returned ``Qualifier`` may have a\n        different ``Id`` than requested, such as the case where a\n        duplicate ``Id`` was assigned to a ``Qualifier`` and retained\n        for compatibility."
               }, 
               "arg_doc": "        arg:    qualifier_id (osid.id.Id): ``Id`` of the ``Qualifier``\n", 
               "return_doc": "        return: (osid.authorization.Qualifier) - the qualifier", 
               "error_doc": "        raise:  NotFound - ``qualifier_id`` not found\n        raise:  NullArgument - ``qualifier_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param qualifier_id: ``Id`` of the ``Qualifier``\n        :type qualifier_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: the qualifier\n        :rtype: ``osid.authorization.Qualifier``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``qualifier_id`` not found\n        :raise: ``NullArgument`` -- ``qualifier_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "qualifier_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "osid.authorization.Qualifier", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_qualifiers_by_ids", 
               "doc": {
                  "headline": "Gets a ``QualifierList`` corresponding to the given ``IdList``.", 
                  "body": "        In plenary mode, the returned list contains all of the\n        qualifiers specified in the ``Id`` list, in the order of the\n        list, including duplicates, or an error results if an ``Id`` in\n        the supplied list is not found or inaccessible. Otherwise,\n        inaccessible ``Qualifiers`` may be omitted from the list and may\n        present the elements in any order including returning a unique\n        set."
               }, 
               "arg_doc": "        arg:    qualifier_ids (osid.id.IdList): the list of ``Ids`` to\n                retrieve\n", 
               "return_doc": "        return: (osid.authorization.QualifierList) - the returned\n                ``Qualifier`` list", 
               "error_doc": "        raise:  NotFound - an ``Id was`` not found\n        raise:  NullArgument - ``qualifier_ids`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param qualifier_ids: the list of ``Ids`` to retrieve\n        :type qualifier_ids: ``osid.id.IdList``\n", 
               "sphinx_return_doc": "        :return: the returned ``Qualifier`` list\n        :rtype: ``osid.authorization.QualifierList``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- an ``Id was`` not found\n        :raise: ``NullArgument`` -- ``qualifier_ids`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.IdList", 
                     "var_name": "qualifier_ids", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.IdList"
               ], 
               "return_type": "osid.authorization.QualifierList", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_qualifiers_by_genus_type", 
               "doc": {
                  "headline": "Gets a ``QualifierList`` corresponding to the given qualifier genus ``Type`` which does not include qualifiers of types derived from the specified ``Type``.", 
                  "body": "        In plenary mode, the returned list contains all known qualifiers\n        or an error results. Otherwise, the returned list may contain\n        only those qualifiers that are accessible through this session.\n        In both cases, the order of the set is not specified."
               }, 
               "arg_doc": "        arg:    qualifier_genus_type (osid.type.Type): a qualifier genus\n                type\n", 
               "return_doc": "        return: (osid.authorization.QualifierList) - the returned\n                ``Qualifier`` list", 
               "error_doc": "        raise:  NullArgument - ``qualifier_genus_type`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param qualifier_genus_type: a qualifier genus type\n        :type qualifier_genus_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "        :return: the returned ``Qualifier`` list\n        :rtype: ``osid.authorization.QualifierList``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``qualifier_genus_type`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "qualifier_genus_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "osid.authorization.QualifierList", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_qualifiers_by_parent_genus_type", 
               "doc": {
                  "headline": "Gets a ``QualifierList`` corresponding to the given qualifier genus ``Type`` and include any additional qualifiers with genus types derived from the specified ``Type``.", 
                  "body": "        In plenary mode, the returned list contains all known qualifiers\n        or an error results. Otherwise, the returned list may contain\n        only those qualifiers that are accessible through this session."
               }, 
               "arg_doc": "        arg:    qualifier_genus_type (osid.type.Type): a qualifier genus\n                type\n", 
               "return_doc": "        return: (osid.authorization.QualifierList) - the returned\n                ``Qualifier`` list", 
               "error_doc": "        raise:  NullArgument - ``qualifier_genus_type`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param qualifier_genus_type: a qualifier genus type\n        :type qualifier_genus_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "        :return: the returned ``Qualifier`` list\n        :rtype: ``osid.authorization.QualifierList``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``qualifier_genus_type`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "qualifier_genus_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "osid.authorization.QualifierList", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_qualifiers_by_record_type", 
               "doc": {
                  "headline": "Gets a ``QualifierList`` corresponding to the given qualifier record ``Type``.", 
                  "body": "        The set of qualifiers implementing the given record type is\n        returned. In plenary mode, the returned list contains all known\n        qualifiers or an error results. Otherwise, the returned list may\n        contain only those qualifiers that are accessible through this\n        session."
               }, 
               "arg_doc": "        arg:    qualifier_record_type (osid.type.Type): a qualifier\n                record type\n", 
               "return_doc": "        return: (osid.authorization.QualifierList) - the returned\n                ``Qualifier`` list", 
               "error_doc": "        raise:  NullArgument - ``qualifier_record_type`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param qualifier_record_type: a qualifier record type\n        :type qualifier_record_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "        :return: the returned ``Qualifier`` list\n        :rtype: ``osid.authorization.QualifierList``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``qualifier_record_type`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "qualifier_record_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "osid.authorization.QualifierList", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_qualifiers", 
               "doc": {
                  "headline": "Gets all ``Qualifiers``.", 
                  "body": "        In plenary mode, the returned list contains all known qualifiers\n        or an error results. Otherwise, the returned list may contain\n        only those qualifiers that are accessible through this session."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.authorization.QualifierList) - a list of\n                ``Qualifiers``", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: a list of ``Qualifiers``\n        :rtype: ``osid.authorization.QualifierList``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.authorization.QualifierList", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.authorization.QualifierQuerySession", 
         "shortname": "QualifierQuerySession", 
         "category": "sessions", 
         "doc": {
            "headline": "This session provides methods for searching among ``Qualifier`` objects.", 
            "body": "    The search query is constructed using the ``QualifierQuery``. If\n    more than one search element is specified within a single\n    ``QualifierQuery,`` these elements form a boolean AND.\n\n    This session defines views that offer differing behaviors for\n    searching.\n    \n      * federated vault view: searches include qualifiers in vaults of\n        which this vault is an ancestor in the vault hierarchy\n      * isolated vault view: searches are restricted to qualifiers in\n        this vault\n\n    \n    Qualifiers may have a query record indicated by their respective\n    record types. The query record is accessed via the\n    ``QualifierQuery``."
         }, 
         "inherit_fullnames": [
            "osid.OsidSession"
         ], 
         "inherit_shortnames": [
            "OsidSession"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidSession"
            }
         ], 
         "method_names": [
            "get_vault_id", 
            "get_vault", 
            "can_search_qualifiers", 
            "use_federated_vault_view", 
            "use_isolated_vault_view", 
            "get_qualifier_query", 
            "get_qualifiers_by_query"
         ], 
         "methods": [
            {
               "name": "get_vault_id", 
               "doc": {
                  "headline": "Gets the ``Vault``  ``Id`` associated with this session.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.id.Id) - the ``Vault Id`` associated with this\n                session", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the ``Vault Id`` associated with this session\n        :rtype: ``osid.id.Id``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.id.Id", 
               "errors": {}
            }, 
            {
               "name": "get_vault", 
               "doc": {
                  "headline": "Gets the ``Vault`` associated with this session.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.authorization.Vault) - the ``Vault`` associated\n                with this session", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the ``Vault`` associated with this session\n        :rtype: ``osid.authorization.Vault``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.authorization.Vault", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "can_search_qualifiers", 
               "doc": {
                  "headline": "Tests if this user can perform ``Qualifier`` searches.", 
                  "body": "        A return of true does not guarantee successful authorization. A\n        return of false indicates that it is known all methods in this\n        session will result in a ``PermissionDenied``. This is intended\n        as a hint to an application that may opt not to offer search\n        operations to unauthorized users."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``false`` if search methods are not\n                authorized, ``true`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``false`` if search methods are not authorized, ``true`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "use_federated_vault_view", 
               "doc": {
                  "headline": "Federates the view for methods in this session.", 
                  "body": "        A federated view will include qualifiers in vaults which are\n        children of this vault in the vault hierarchy."
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "use_isolated_vault_view", 
               "doc": {
                  "headline": "Isolates the view for methods in this session.", 
                  "body": "        An isolated view restricts searches to this vault only."
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "get_qualifier_query", 
               "doc": {
                  "headline": "Gets a qualifier query.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.authorization.QualifierQuery) - the qualifier\n                query", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the qualifier query\n        :rtype: ``osid.authorization.QualifierQuery``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.authorization.QualifierQuery", 
               "errors": {}
            }, 
            {
               "name": "get_qualifiers_by_query", 
               "doc": {
                  "headline": "Gets a list of ``Qualifiers`` matching the given search.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    qualifier_query (osid.authorization.QualifierQuery): the\n                search query array\n", 
               "return_doc": "        return: (osid.authorization.QualifierList) - the returned\n                ``QualifierList``", 
               "error_doc": "        raise:  NullArgument - ``qualifier_query`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        raise:  Unsupported - ``qualifier_query`` is not of this service", 
               "sphinx_param_doc": "        :param qualifier_query: the search query array\n        :type qualifier_query: ``osid.authorization.QualifierQuery``\n", 
               "sphinx_return_doc": "        :return: the returned ``QualifierList``\n        :rtype: ``osid.authorization.QualifierList``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``qualifier_query`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure\n        :raise: ``Unsupported`` -- ``qualifier_query`` is not of this service", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.authorization.QualifierQuery", 
                     "var_name": "qualifier_query", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.authorization.QualifierQuery"
               ], 
               "return_type": "osid.authorization.QualifierList", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.authorization.QualifierSearchSession", 
         "shortname": "QualifierSearchSession", 
         "category": "sessions", 
         "doc": {
            "headline": "This session provides methods for searching among ``Qualifier`` objects.", 
            "body": "    The search query is constructed using the ``QualifierQuery``. If\n    more than one search element is specified within a single\n    ``QualifierQuery,`` these elements form a boolean AND.\n\n    ``get_qualifiers_by_query()`` is the basic search method and returns\n    a list of ``Qualifiers``. A more advanced search may be performed\n    with ``getQualifiersBySearch()``. It accepts a ``QualifierSearch``\n    in addition to the query for the purpose of specifying additional\n    options affecting the entire search, such as ordering.\n    ``get_qualifiers_by_search()`` returns a ``QualifierSearchResults``\n    that can be used to access the resulting ``QualifierList`` or be\n    used to perform a search within the result set through\n    ``QualifierSearch``.\n    \n    This session defines views that offer differing behaviors for\n    searching.\n    \n      * federated vault view: searches include qualifiers in vaults of\n        which this vault is an ancestor in the vault hierarchy\n      * isolated vault view: searches are restricted to qualifiers in\n        this vault\n\n    \n    Qualifiers may have a query record indicated by their respective\n    record types. The query record is accessed via the\n    ``QualifierQuery``."
         }, 
         "inherit_fullnames": [
            "osid.authorization.QualifierQuerySession"
         ], 
         "inherit_shortnames": [
            "QualifierQuerySession"
         ], 
         "inherit_pkg_names": [
            "authorization"
         ], 
         "inheritance": [
            {
               "pkg_name": "authorization", 
               "name": "QualifierQuerySession"
            }
         ], 
         "method_names": [
            "get_qualifier_search", 
            "get_qualifier_search_order", 
            "get_qualifiers_by_search", 
            "get_qualifier_query_from_inspector"
         ], 
         "methods": [
            {
               "name": "get_qualifier_search", 
               "doc": {
                  "headline": "Gets a qualifier search.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.authorization.QualifierSearch) - the qualifier\n                search", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the qualifier search\n        :rtype: ``osid.authorization.QualifierSearch``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.authorization.QualifierSearch", 
               "errors": {}
            }, 
            {
               "name": "get_qualifier_search_order", 
               "doc": {
                  "headline": "Gets a qualifier search order.", 
                  "body": "        The ``QualifierSearchOrder`` is supplied to a\n        ``QualifierSearch`` to specify the ordering of results."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.authorization.QualifierSearchOrder) - the\n                qualifier search order", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the qualifier search order\n        :rtype: ``osid.authorization.QualifierSearchOrder``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.authorization.QualifierSearchOrder", 
               "errors": {}
            }, 
            {
               "name": "get_qualifiers_by_search", 
               "doc": {
                  "headline": "Gets the search results matching the given search query using the given search.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    qualifier_query (osid.authorization.QualifierQuery): the\n                qualifier query\n        arg:    qualifier_search (osid.authorization.QualifierSearch):\n                the qualifier search\n", 
               "return_doc": "        return: (osid.authorization.QualifierSearchResults) - the search\n                results", 
               "error_doc": "        raise:  NullArgument - ``qualifier_queriy`` or\n                ``qualifier_search`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        raise:  Unsupported - ``qualifier_query`` or\n                ``qualifier_search`` is not of this service", 
               "sphinx_param_doc": "        :param qualifier_query: the qualifier query\n        :type qualifier_query: ``osid.authorization.QualifierQuery``\n        :param qualifier_search: the qualifier search\n        :type qualifier_search: ``osid.authorization.QualifierSearch``\n", 
               "sphinx_return_doc": "        :return: the search results\n        :rtype: ``osid.authorization.QualifierSearchResults``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``qualifier_queriy`` or ``qualifier_search`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure\n        :raise: ``Unsupported`` -- ``qualifier_query`` or ``qualifier_search`` is not of this service", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.authorization.QualifierQuery", 
                     "var_name": "qualifier_query", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.authorization.QualifierSearch", 
                     "var_name": "qualifier_search", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.authorization.QualifierQuery", 
                  "osid.authorization.QualifierSearch"
               ], 
               "return_type": "osid.authorization.QualifierSearchResults", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_qualifier_query_from_inspector", 
               "doc": {
                  "headline": "Gets a qualifier query from an inspector.", 
                  "body": "        The inspector is available from a ``QualifierSearchResults``."
               }, 
               "arg_doc": "        arg:    qualifier_query_inspector\n                (osid.authorization.QualifierQueryInspector): a\n                qualifier query inspector\n", 
               "return_doc": "        return: (osid.authorization.QualifierQuery) - the qualifier\n                query", 
               "error_doc": "        raise:  NullArgument - ``qualifier_query_inspector`` is ``null``\n        raise:  Unsupported - ``qualifier_query_inspector`` is not of\n                this service", 
               "sphinx_param_doc": "        :param qualifier_query_inspector: a qualifier query inspector\n        :type qualifier_query_inspector: ``osid.authorization.QualifierQueryInspector``\n", 
               "sphinx_return_doc": "        :return: the qualifier query\n        :rtype: ``osid.authorization.QualifierQuery``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``qualifier_query_inspector`` is ``null``\n        :raise: ``Unsupported`` -- ``qualifier_query_inspector`` is not of this service", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.authorization.QualifierQueryInspector", 
                     "var_name": "qualifier_query_inspector", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.authorization.QualifierQueryInspector"
               ], 
               "return_type": "osid.authorization.QualifierQuery", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.authorization.QualifierAdminSession", 
         "shortname": "QualifierAdminSession", 
         "category": "sessions", 
         "doc": {
            "headline": "This session creates, updates, and deletes ``Qualifiers``.", 
            "body": "    The data for create and update is provided by the consumer via the\n    form object. ``OsidForms`` are requested for each create or update\n    and may not be reused.\n\n    Create and update operations differ in their usage. To create a\n    ``Qualifier,`` a ``QualifierForm`` is requested using\n    ``get_qualifier_form_for_create()`` specifying the desired\n    relationship peers and record ``Types`` or none if no record\n    ``Types`` are needed. The returned ``QualifierForm`` will indicate\n    that it is to be used with a create operation and can be used to\n    examine metdata or validate data prior to creation. Once the\n    ``QualifierForm`` is submiited to a create operation, it cannot be\n    reused with another create operation unless the first operation was\n    unsuccessful. Each ``QualifierForm`` corresponds to an attempted\n    transaction.\n    \n    For updates, ``QualifierForms`` are requested to the ``Qualifier``\n    ``Id`` that is to be updated using ``getQualifierFormForUpdate()``.\n    Similarly, the ``QualifierForm`` has metadata about the data that\n    can be updated and it can perform validation before submitting the\n    update. The ``QualifierForm`` can only be used once for a successful\n    update and cannot be reused.\n    \n    The delete operations delete ``Qualifiers``. To unmap a\n    ``Qualifier`` from the current ``Vault,`` the\n    ``QualifierVaultAssignmentSession`` should be used. These delete\n    operations attempt to remove the ``Qualifier`` itself thus removing\n    it from all known ``Vault`` catalogs.\n    \n    This session includes an ``Id`` aliasing mechanism to assign an\n    external ``Id`` to an internally assigned Id."
         }, 
         "inherit_fullnames": [
            "osid.OsidSession"
         ], 
         "inherit_shortnames": [
            "OsidSession"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidSession"
            }
         ], 
         "method_names": [
            "get_vault_id", 
            "get_vault", 
            "can_create_qualifiers", 
            "can_create_qualifier_with_record_types", 
            "get_qualifier_form_for_create", 
            "create_qualifier", 
            "can_update_qualifiers", 
            "get_qualifier_form_for_update", 
            "update_qualifier", 
            "can_delete_qualifiers", 
            "delete_qualifier", 
            "can_manage_qualifier_aliases", 
            "alias_qualifier"
         ], 
         "methods": [
            {
               "name": "get_vault_id", 
               "doc": {
                  "headline": "Gets the ``Vault``  ``Id`` associated with this session.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.id.Id) - the ``Vault Id`` associated with this\n                session", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the ``Vault Id`` associated with this session\n        :rtype: ``osid.id.Id``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.id.Id", 
               "errors": {}
            }, 
            {
               "name": "get_vault", 
               "doc": {
                  "headline": "Gets the ``Vault`` associated with this session.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.authorization.Vault) - the ``Vault`` associated\n                with this session", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the ``Vault`` associated with this session\n        :rtype: ``osid.authorization.Vault``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.authorization.Vault", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "can_create_qualifiers", 
               "doc": {
                  "headline": "Tests if this user can create ``Qualifiers``.", 
                  "body": "        A return of true does not guarantee successful authorization. A\n        return of false indicates that it is known creating a\n        ``Qualifier`` will result in a ``PermissionDenied``. This is\n        intended as a hint to an application that may opt not to offer\n        create operations to an unauthorized user."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``false`` if ``Qualifier`` creation is not\n                authorized, ``true`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``false`` if ``Qualifier`` creation is not authorized, ``true`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "can_create_qualifier_with_record_types", 
               "doc": {
                  "headline": "Tests if this user can create a single ``Qualifier`` using the desired record types.", 
                  "body": "        While ``AuthorizationManager.getQualifierRecordTypes()`` can be\n        used to examine which records are supported, this method tests\n        which record(s) are required for creating a specific\n        ``Qualifier``. Providing an empty array tests if a ``Qualifier``\n        can be created with no records."
               }, 
               "arg_doc": "        arg:    qualifier_record_types (osid.type.Type[]): array of\n                qualifier record types\n", 
               "return_doc": "        return: (boolean) - ``true`` if ``Qualifier`` creation using the\n                specified ``Types`` is supported, ``false`` otherwise", 
               "error_doc": "        raise:  NullArgument - ``qualifier_record_types`` is ``null``", 
               "sphinx_param_doc": "        :param qualifier_record_types: array of qualifier record types\n        :type qualifier_record_types: ``osid.type.Type[]``\n", 
               "sphinx_return_doc": "        :return: ``true`` if ``Qualifier`` creation using the specified ``Types`` is supported, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``qualifier_record_types`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type[]", 
                     "var_name": "qualifier_record_types", 
                     "array": true
                  }
               ], 
               "arg_types": [
                  "osid.type.Type[]"
               ], 
               "return_type": "boolean", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "get_qualifier_form_for_create", 
               "doc": {
                  "headline": "Gets the qualifier form for creating new qualifiers.", 
                  "body": "        A new form should be requested for each create transaction."
               }, 
               "arg_doc": "        arg:    qualifier_record_types (osid.type.Type[]): array of\n                qualifier record types\n", 
               "return_doc": "        return: (osid.authorization.QualifierForm) - the qualifier form", 
               "error_doc": "        raise:  NullArgument - ``qualifier_record_types`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        raise:  Unsupported - unable to get form with requested record\n                types", 
               "sphinx_param_doc": "        :param qualifier_record_types: array of qualifier record types\n        :type qualifier_record_types: ``osid.type.Type[]``\n", 
               "sphinx_return_doc": "        :return: the qualifier form\n        :rtype: ``osid.authorization.QualifierForm``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``qualifier_record_types`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure\n        :raise: ``Unsupported`` -- unable to get form with requested record types", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type[]", 
                     "var_name": "qualifier_record_types", 
                     "array": true
                  }
               ], 
               "arg_types": [
                  "osid.type.Type[]"
               ], 
               "return_type": "osid.authorization.QualifierForm", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }, 
            {
               "name": "create_qualifier", 
               "doc": {
                  "headline": "Creates a new ``Qualifier``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    qualifier_form (osid.authorization.QualifierForm): the\n                form for this ``Qualifier``\n", 
               "return_doc": "        return: (osid.authorization.Qualifier) - the new ``Qualifier``", 
               "error_doc": "        raise:  IllegalState - ``qualifier_form`` already used for a\n                create transaction\n        raise:  InvalidArgument - one or more of the form elements is\n                invalid\n        raise:  NullArgument - ``qualifier_forms`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        raise:  Unsupported - ``qualifier_form`` did not originate from\n                ``get_qualifier_form_for_create()``", 
               "sphinx_param_doc": "        :param qualifier_form: the form for this ``Qualifier``\n        :type qualifier_form: ``osid.authorization.QualifierForm``\n", 
               "sphinx_return_doc": "        :return: the new ``Qualifier``\n        :rtype: ``osid.authorization.Qualifier``", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- ``qualifier_form`` already used for a create transaction\n        :raise: ``InvalidArgument`` -- one or more of the form elements is invalid\n        :raise: ``NullArgument`` -- ``qualifier_forms`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure\n        :raise: ``Unsupported`` -- ``qualifier_form`` did not originate from ``get_qualifier_form_for_create()``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.authorization.QualifierForm", 
                     "var_name": "qualifier_form", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.authorization.QualifierForm"
               ], 
               "return_type": "osid.authorization.Qualifier", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract", 
                  "INVALID_ARGUMENT": "ConsumerContract", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }, 
            {
               "name": "can_update_qualifiers", 
               "doc": {
                  "headline": "Tests if this user can update ``Qualifiers``.", 
                  "body": "        A return of true does not guarantee successful authorization. A\n        return of false indicates that it is known updating a\n        ``Qualifier`` will result in a ``PermissionDenied``. This is\n        intended as a hint to an application that may opt not to offer\n        update operations to an unauthorized user."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``false`` if ``Qualifier`` modification is\n                not authorized, ``true`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``false`` if ``Qualifier`` modification is not authorized, ``true`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "get_qualifier_form_for_update", 
               "doc": {
                  "headline": "Gets the qualifier form for updating an existing qualifier.", 
                  "body": "        A new qualifier form should be requested for each update\n        transaction."
               }, 
               "arg_doc": "        arg:    qualifier_id (osid.id.Id): the ``Id`` of the\n                ``Qualifier``\n", 
               "return_doc": "        return: (osid.authorization.QualifierForm) - the qualifier form", 
               "error_doc": "        raise:  NotFound - ``qualifier_id`` is not found\n        raise:  NullArgument - ``qualifier_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param qualifier_id: the ``Id`` of the ``Qualifier``\n        :type qualifier_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: the qualifier form\n        :rtype: ``osid.authorization.QualifierForm``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``qualifier_id`` is not found\n        :raise: ``NullArgument`` -- ``qualifier_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "qualifier_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "osid.authorization.QualifierForm", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "update_qualifier", 
               "doc": {
                  "headline": "Updates an existing qualifier.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    qualifier_form (osid.authorization.QualifierForm): the\n                form containing the elements to be updated\n", 
               "return_doc": "", 
               "error_doc": "        raise:  IllegalState - ``qualifier_form`` already used for an\n                update transaction\n        raise:  InvalidArgument - the form contains an invalid value\n        raise:  NullArgument - ``qualifier_form`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        raise:  Unsupported - ``qualifier_form`` did not originate from\n                ``get_qualifier_form_for_update()``", 
               "sphinx_param_doc": "        :param qualifier_form: the form containing the elements to be updated\n        :type qualifier_form: ``osid.authorization.QualifierForm``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- ``qualifier_form`` already used for an update transaction\n        :raise: ``InvalidArgument`` -- the form contains an invalid value\n        :raise: ``NullArgument`` -- ``qualifier_form`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure\n        :raise: ``Unsupported`` -- ``qualifier_form`` did not originate from ``get_qualifier_form_for_update()``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.authorization.QualifierForm", 
                     "var_name": "qualifier_form", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.authorization.QualifierForm"
               ], 
               "return_type": "", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract", 
                  "INVALID_ARGUMENT": "ConsumerContract", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }, 
            {
               "name": "can_delete_qualifiers", 
               "doc": {
                  "headline": "Tests if this user can delete ``Qualifiers``.", 
                  "body": "        A return of true does not guarantee successful authorization. A\n        return of false indicates that it is known deleting a\n        ``Qualifier`` will result in a ``PermissionDenied``. This is\n        intended as a hint to an application that may opt not to offer\n        delete operations to an unauthorized user."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``false`` if ``Qualifier`` deletion is not\n                authorized, ``true`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``false`` if ``Qualifier`` deletion is not authorized, ``true`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "delete_qualifier", 
               "doc": {
                  "headline": "Deletes a ``Qualifier``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    qualifier_id (osid.id.Id): the ``Id`` of the\n                ``Qualifier`` to remove\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NotFound - ``qualifier_id`` not found\n        raise:  NullArgument - ``qualifier_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param qualifier_id: the ``Id`` of the ``Qualifier`` to remove\n        :type qualifier_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``qualifier_id`` not found\n        :raise: ``NullArgument`` -- ``qualifier_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "qualifier_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "can_manage_qualifier_aliases", 
               "doc": {
                  "headline": "Tests if this user can manage ``Id`` aliases for ``Qualifiers``.", 
                  "body": "        A return of true does not guarantee successful authorization. A\n        return of false indicates that it is known changing an alias\n        will result in a ``PermissionDenied``. This is intended as a\n        hint to an application that may opt not to offer alias\n        operations to an unauthorized user."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``false`` if ``Qualifier`` aliasing is not\n                authorized, ``true`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``false`` if ``Qualifier`` aliasing is not authorized, ``true`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "alias_qualifier", 
               "doc": {
                  "headline": "Adds an ``Id`` to a ``Qualifier`` for the purpose of creating compatibility.", 
                  "body": "        The primary ``Id`` of the ``Qualifier`` is determined by the\n        provider. The new ``Id`` performs as an alias to the primary\n        ``Id``. If the alias is a pointer to another qualifier, it is\n        reassigned to the given qualifier ``Id``."
               }, 
               "arg_doc": "        arg:    qualifier_id (osid.id.Id): the ``Id`` of a ``Qualifier``\n        arg:    alias_id (osid.id.Id): the alias ``Id``\n", 
               "return_doc": "", 
               "error_doc": "        raise:  AlreadyExists - ``alias_id`` is already assigned\n        raise:  NotFound - ``qualifier_id`` not found\n        raise:  NullArgument - ``qualifier_id`` or ``alias_id`` is\n                ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param qualifier_id: the ``Id`` of a ``Qualifier``\n        :type qualifier_id: ``osid.id.Id``\n        :param alias_id: the alias ``Id``\n        :type alias_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``AlreadyExists`` -- ``alias_id`` is already assigned\n        :raise: ``NotFound`` -- ``qualifier_id`` not found\n        :raise: ``NullArgument`` -- ``qualifier_id`` or ``alias_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "qualifier_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "alias_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {
                  "ALREADY_EXISTS": "User", 
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.authorization.QualifierNotificationSession", 
         "shortname": "QualifierNotificationSession", 
         "category": "sessions", 
         "doc": {
            "headline": "This session defines methods to receive notifications on adds/changes to ``Qualifier`` objects in this ``Vault``.", 
            "body": "    This session is intended for consumers needing to synchronize their\n    state with this service without the use of polling. Notifications\n    are cancelled when this session is closed.\n\n    The two views defined in this session correspond to the views in the\n    ``QualifierLookupSession``."
         }, 
         "inherit_fullnames": [
            "osid.OsidSession"
         ], 
         "inherit_shortnames": [
            "OsidSession"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidSession"
            }
         ], 
         "method_names": [
            "get_vault_id", 
            "get_vault", 
            "can_register_for_qualifier_notifications", 
            "use_federated_vault_view", 
            "use_isolated_vault_view", 
            "register_for_new_qualifiers", 
            "register_for_new_qualifier_ancestors", 
            "register_for_new_qualifier_descendants", 
            "register_for_changed_qualifiers", 
            "register_for_changed_qualifier", 
            "register_for_deleted_qualifiers", 
            "register_for_deleted_qualifier", 
            "register_for_deleted_qualifier_ancestors", 
            "register_for_deleted_qualifier_descendants"
         ], 
         "methods": [
            {
               "name": "get_vault_id", 
               "doc": {
                  "headline": "Gets the ``Vault``  ``Id`` associated with this session.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.id.Id) - the ``Vault Id`` associated with this\n                session", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the ``Vault Id`` associated with this session\n        :rtype: ``osid.id.Id``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.id.Id", 
               "errors": {}
            }, 
            {
               "name": "get_vault", 
               "doc": {
                  "headline": "Gets the ``Vault`` associated with this session.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.authorization.Vault) - the ``Vault`` associated\n                with this session", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the ``Vault`` associated with this session\n        :rtype: ``osid.authorization.Vault``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.authorization.Vault", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "can_register_for_qualifier_notifications", 
               "doc": {
                  "headline": "Tests if this user can register for ``Qualifier`` notifications.", 
                  "body": "        A return of true does not guarantee successful authorization. A\n        return of false indicates that it is known all methods in this\n        session will result in a ``PermissionDenied``. This is intended\n        as a hint to an application that may opt not to offer\n        notification operations."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``false`` if notification methods are not\n                authorized, ``true`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``false`` if notification methods are not authorized, ``true`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "use_federated_vault_view", 
               "doc": {
                  "headline": "Federates the view for methods in this session.", 
                  "body": "        A federated view will include notifications for qualifiers in\n        vaults which are children of this vault in the vault hierarchy."
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "use_isolated_vault_view", 
               "doc": {
                  "headline": "Isolates the view for methods in this session.", 
                  "body": "        An isolated view restricts notifications for qualifiers to this\n        vault only."
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "register_for_new_qualifiers", 
               "doc": {
                  "headline": "Register for notifications of new qualifiers.", 
                  "body": "        ``QualifierReceiver.newQualifier()`` is invoked when a new\n        ``Qualifier`` is created."
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "register_for_new_qualifier_ancestors", 
               "doc": {
                  "headline": "Registers for notification if an ancestor is added to the specified qualifier in the qualifier hierarchy.", 
                  "body": "        ``QualifierReceiver.newQualifierAncestor()`` is invoked when the\n        specified qualifier experiences an addition in ancestry."
               }, 
               "arg_doc": "        arg:    qualifier_id (osid.id.Id): the ``Id`` of the qualifier\n                to monitor\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``qualifier_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param qualifier_id: the ``Id`` of the qualifier to monitor\n        :type qualifier_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``qualifier_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "qualifier_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "register_for_new_qualifier_descendants", 
               "doc": {
                  "headline": "Registers for notification if a descendant is added to fthe specified qualifier in the qualifier hierarchy.", 
                  "body": "        ``QualifierReceiver.newQualifierDescendant()`` is invoked when\n        the specified qualifier experiences an addition in descdendants."
               }, 
               "arg_doc": "        arg:    qualifier_id (osid.id.Id): the ``Id`` of the qualifier\n                to monitor\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``qualifier_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param qualifier_id: the ``Id`` of the qualifier to monitor\n        :type qualifier_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``qualifier_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "qualifier_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "register_for_changed_qualifiers", 
               "doc": {
                  "headline": "Registers for notification of updated qualifiers.", 
                  "body": "        ``QualifierReceiver.changedQualifier()`` is invoked when a\n        qualifier is changed."
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "register_for_changed_qualifier", 
               "doc": {
                  "headline": "Registers for notification of an updated qualifier.", 
                  "body": "        ``QualifierReceiver.changedQualifier()`` is invoked when the\n        specified qualifier is changed."
               }, 
               "arg_doc": "        arg:    qualifier_id (osid.id.Id): the ``Id`` of the\n                ``Qualifier`` to monitor\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``qualifier_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param qualifier_id: the ``Id`` of the ``Qualifier`` to monitor\n        :type qualifier_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``qualifier_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "qualifier_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "register_for_deleted_qualifiers", 
               "doc": {
                  "headline": "Registers for notification of deleted qualifiers.", 
                  "body": "        ``QualifierReceiver.deletedQualifier()`` is invoked when a\n        qualifier is removed from this vault."
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "register_for_deleted_qualifier", 
               "doc": {
                  "headline": "Registers for notification of a deleted qualifier.", 
                  "body": "        ``QualifierReceiver.deletedQualifier()`` is invoked when the\n        specified qualifier is removed from this vault."
               }, 
               "arg_doc": "        arg:    qualifier_id (osid.id.Id): the ``Id`` of the\n                ``Qualifier`` to monitor\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``qualifier_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param qualifier_id: the ``Id`` of the ``Qualifier`` to monitor\n        :type qualifier_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``qualifier_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "qualifier_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "register_for_deleted_qualifier_ancestors", 
               "doc": {
                  "headline": "Registers for notification if an ancestor is removed from the specified qualifier in the qualifier hierarchy.", 
                  "body": "        ``QualifierReceiver.deletedQualifierAncestor()`` is invoked when\n        the specified qualifier experiences a removal of an ancestor."
               }, 
               "arg_doc": "        arg:    qualifier_id (osid.id.Id): the ``Id`` of the qualifier\n                to monitor\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``qualifier_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param qualifier_id: the ``Id`` of the qualifier to monitor\n        :type qualifier_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``qualifier_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "qualifier_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "register_for_deleted_qualifier_descendants", 
               "doc": {
                  "headline": "Registers for notification if a descendant is removed from fthe specified qualifier in the qualifier hierarchy.", 
                  "body": "        ``QualifierReceiver.deletedQualifierDescednant()`` is invoked\n        when the specified qualifier experiences a removal of one of its\n        descendants."
               }, 
               "arg_doc": "        arg:    qualifier_id (osid.id.Id): the ``Id`` of the qualifier\n                to monitor\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``qualifier_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param qualifier_id: the ``Id`` of the qualifier to monitor\n        :type qualifier_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``qualifier_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "qualifier_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.authorization.QualifierHierarchySession", 
         "shortname": "QualifierHierarchySession", 
         "category": "sessions", 
         "doc": {
            "headline": "This session defines methods for traversing a hierarchy of ``Qualifier`` objects.", 
            "body": "    Each node in the hierarchy is a unique ``Qualifier``. The hierarchy\n    may be traversed recursively to establish the tree structure through\n    ``get_parent_qualifiers()`` and ``getChildQualifiers()``. To relate\n    these ``Ids`` to another OSID, ``get_qualifier_nodes()`` can be used\n    for retrievals that can be used for bulk lookups in other OSIDs. Any\n    ``Qualifier`` available in the Authorization OSID is known to this\n    hierarchy but does not appear in the hierarchy traversal until added\n    as a root node or a child of another node.\n\n    A user may not be authorized to traverse the entire hierarchy. Parts\n    of the hierarchy may be made invisible through omission from the\n    returns of ``get_parent_qualifiers()`` or ``get_child_qualifiers()``\n    in lieu of a ``PermissionDenied`` error that may disrupt the\n    traversal through authorized pathways.\n    \n    This session defines views that offer differing behaviors when\n    retrieving multiple objects.\n    \n      * comparative view: qualifier elements may be silently omitted or\n        re-ordered\n      * plenary view: provides a complete set or is an error condition\n"
         }, 
         "inherit_fullnames": [
            "osid.OsidSession"
         ], 
         "inherit_shortnames": [
            "OsidSession"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidSession"
            }
         ], 
         "method_names": [
            "get_qualifier_hierarchy_id", 
            "get_qualifier_hierarchy", 
            "can_access_qualifier_hierarchy", 
            "use_comparative_qualifier_view", 
            "use_plenary_qualifier_view", 
            "get_root_qualifier_ids", 
            "get_root_qualifiers", 
            "has_parent_qualifiers", 
            "is_parent_of_qualifier", 
            "get_parent_qualifier_ids", 
            "get_parent_qualifiers", 
            "is_ancestor_of_qualifier", 
            "has_child_qualifiers", 
            "is_child_of_qualifier", 
            "get_child_qualifier_ids", 
            "get_child_qualifiers", 
            "is_descendant_of_qualifier", 
            "get_qualifier_node_ids", 
            "get_qualifier_nodes"
         ], 
         "methods": [
            {
               "name": "get_qualifier_hierarchy_id", 
               "doc": {
                  "headline": "Gets the hierarchy ``Id`` associated with this session.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.id.Id) - the hierarchy ``Id`` associated with this\n                session", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the hierarchy ``Id`` associated with this session\n        :rtype: ``osid.id.Id``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.id.Id", 
               "errors": {}
            }, 
            {
               "name": "get_qualifier_hierarchy", 
               "doc": {
                  "headline": "Gets the hierarchy associated with this session.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.hierarchy.Hierarchy) - the hierarchy associated\n                with this session", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the hierarchy associated with this session\n        :rtype: ``osid.hierarchy.Hierarchy``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.hierarchy.Hierarchy", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "can_access_qualifier_hierarchy", 
               "doc": {
                  "headline": "Tests if this user can perform hierarchy queries.", 
                  "body": "        A return of true does not guarantee successful authorization. A\n        return of false indicates that it is known all methods in this\n        session will result in a ``PermissionDenied``. This is intended\n        as a hint to an application that may opt not to offer lookup\n        operations."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``false`` if hierarchy traversal methods are\n                not authorized, ``true`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``false`` if hierarchy traversal methods are not authorized, ``true`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "use_comparative_qualifier_view", 
               "doc": {
                  "headline": "The returns from the qualifier methods may omit or translate elements based on this session, such as authorization, and not result in an error.", 
                  "body": "        This view is used when greater interoperability is desired at\n        the expense of precision."
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "use_plenary_qualifier_view", 
               "doc": {
                  "headline": "A complete view of the ``Hierarchy`` returns is desired.", 
                  "body": "        Methods will return what is requested or result in an error.\n        This view is used when greater precision is desired at the\n        expense of interoperability."
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "get_root_qualifier_ids", 
               "doc": {
                  "headline": "Gets the root qualifier ``Ids`` in this hierarchy.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.id.IdList) - the root qualifier ``Ids``", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the root qualifier ``Ids``\n        :rtype: ``osid.id.IdList``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.id.IdList", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_root_qualifiers", 
               "doc": {
                  "headline": "Gets the root qualifiers in this qualifier hierarchy.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.authorization.QualifierList) - the root qualifiers", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the root qualifiers\n        :rtype: ``osid.authorization.QualifierList``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.authorization.QualifierList", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "has_parent_qualifiers", 
               "doc": {
                  "headline": "Tests if the ``Qualifier`` has any parents.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    qualifier_id (osid.id.Id): a qualifier ``Id``\n", 
               "return_doc": "        return: (boolean) - ``true`` if the qualifier has parents,\n                ``false`` otherwise", 
               "error_doc": "        raise:  NotFound - ``qualifier_id`` is not found\n        raise:  NullArgument - ``qualifier_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param qualifier_id: a qualifier ``Id``\n        :type qualifier_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: ``true`` if the qualifier has parents, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``qualifier_id`` is not found\n        :raise: ``NullArgument`` -- ``qualifier_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "qualifier_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "boolean", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "is_parent_of_qualifier", 
               "doc": {
                  "headline": "Tests if an ``Id`` is a direct parent of qualifier.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    id (osid.id.Id): an ``Id``\n        arg:    qualifier_id (osid.id.Id): the ``Id`` of a qualifier\n", 
               "return_doc": "        return: (boolean) - ``true`` if this ``id`` is a parent of\n                ``qualifier_id,``  ``false`` otherwise", 
               "error_doc": "        raise:  NotFound - ``qualifier_id`` is not found\n        raise:  NullArgument - ``id`` or ``qualifier_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param id: an ``Id``\n        :type id: ``osid.id.Id``\n        :param qualifier_id: the ``Id`` of a qualifier\n        :type qualifier_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: ``true`` if this ``id`` is a parent of ``qualifier_id,``  ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``qualifier_id`` is not found\n        :raise: ``NullArgument`` -- ``id`` or ``qualifier_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "        *implementation notes*: If ``id`` not found return ``false``.\n", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "id_", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "qualifier_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "osid.id.Id"
               ], 
               "return_type": "boolean", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_parent_qualifier_ids", 
               "doc": {
                  "headline": "Gets the parent ``Ids`` of the given qualifier.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    qualifier_id (osid.id.Id): a qualifier ``Id``\n", 
               "return_doc": "        return: (osid.id.IdList) - the parent ``Ids`` of the qualifier", 
               "error_doc": "        raise:  NotFound - ``qualifier_id`` is not found\n        raise:  NullArgument - ``qualifier_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param qualifier_id: a qualifier ``Id``\n        :type qualifier_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: the parent ``Ids`` of the qualifier\n        :rtype: ``osid.id.IdList``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``qualifier_id`` is not found\n        :raise: ``NullArgument`` -- ``qualifier_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "qualifier_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "osid.id.IdList", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_parent_qualifiers", 
               "doc": {
                  "headline": "Gets the parents of the given qualifier.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    qualifier_id (osid.id.Id): a qualifier ``Id``\n", 
               "return_doc": "        return: (osid.authorization.QualifierList) - the parents of the\n                qualifier", 
               "error_doc": "        raise:  NotFound - ``qualifier_id`` is not found\n        raise:  NullArgument - ``qualifier_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param qualifier_id: a qualifier ``Id``\n        :type qualifier_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: the parents of the qualifier\n        :rtype: ``osid.authorization.QualifierList``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``qualifier_id`` is not found\n        :raise: ``NullArgument`` -- ``qualifier_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "qualifier_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "osid.authorization.QualifierList", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "is_ancestor_of_qualifier", 
               "doc": {
                  "headline": "Tests if an ``Id`` is an ancestor of a qualifier.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    id (osid.id.Id): an ``Id``\n        arg:    qualifier_id (osid.id.Id): the ``Id`` of a qualifier\n", 
               "return_doc": "        return: (boolean) - ``true`` if this ``id`` is an ancestor of\n                ``qualifier_id,``  ``false`` otherwise", 
               "error_doc": "        raise:  NotFound - ``qualifier_id`` not found\n        raise:  NullArgument - ``qualifier_id`` or ``id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param id: an ``Id``\n        :type id: ``osid.id.Id``\n        :param qualifier_id: the ``Id`` of a qualifier\n        :type qualifier_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: ``true`` if this ``id`` is an ancestor of ``qualifier_id,``  ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``qualifier_id`` not found\n        :raise: ``NullArgument`` -- ``qualifier_id`` or ``id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "        *implementation notes*: If ``id`` not found return ``false``.\n", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "id_", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "qualifier_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "osid.id.Id"
               ], 
               "return_type": "boolean", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "has_child_qualifiers", 
               "doc": {
                  "headline": "Tests if a qualifier has any children.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    qualifier_id (osid.id.Id): a qualifier ``Id``\n", 
               "return_doc": "        return: (boolean) - ``true`` if the ``qualifier_id`` has\n                children, ``false`` otherwise", 
               "error_doc": "        raise:  NotFound - ``qualifier_id`` not found\n        raise:  NullArgument - ``qualifier_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param qualifier_id: a qualifier ``Id``\n        :type qualifier_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: ``true`` if the ``qualifier_id`` has children, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``qualifier_id`` not found\n        :raise: ``NullArgument`` -- ``qualifier_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "qualifier_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "boolean", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "is_child_of_qualifier", 
               "doc": {
                  "headline": "Tests if a node is a direct child of another.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    id (osid.id.Id): an ``Id``\n        arg:    qualifier_id (osid.id.Id): the ``Id`` of a qualifier\n", 
               "return_doc": "        return: (boolean) - ``true`` if the ``id`` is a child of\n                ``qualifier_id,``  ``false`` otherwise", 
               "error_doc": "        raise:  NotFound - ``qualifier_id`` not found\n        raise:  NullArgument - ``qualifier_id`` or ``id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param id: an ``Id``\n        :type id: ``osid.id.Id``\n        :param qualifier_id: the ``Id`` of a qualifier\n        :type qualifier_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: ``true`` if the ``id`` is a child of ``qualifier_id,``  ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``qualifier_id`` not found\n        :raise: ``NullArgument`` -- ``qualifier_id`` or ``id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "        *implementation notes*: If ``id`` not found return ``false``.\n", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "id_", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "qualifier_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "osid.id.Id"
               ], 
               "return_type": "boolean", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_child_qualifier_ids", 
               "doc": {
                  "headline": "Gets the child ``Ids`` of the given qualifier.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    qualifier_id (osid.id.Id): the ``Id`` to query\n", 
               "return_doc": "        return: (osid.id.IdList) - the children of the qualifier", 
               "error_doc": "        raise:  NotFound - ``qualifier_id`` is not found\n        raise:  NullArgument - ``qualifier_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param qualifier_id: the ``Id`` to query\n        :type qualifier_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: the children of the qualifier\n        :rtype: ``osid.id.IdList``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``qualifier_id`` is not found\n        :raise: ``NullArgument`` -- ``qualifier_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "qualifier_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "osid.id.IdList", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_child_qualifiers", 
               "doc": {
                  "headline": "Gets the children of the given qualifier.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    qualifier_id (osid.id.Id): the ``Id`` to query\n", 
               "return_doc": "        return: (osid.authorization.QualifierList) - the children of the\n                qualifier", 
               "error_doc": "        raise:  NotFound - ``qualifier_id`` is not found\n        raise:  NullArgument - ``qualifier_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param qualifier_id: the ``Id`` to query\n        :type qualifier_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: the children of the qualifier\n        :rtype: ``osid.authorization.QualifierList``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``qualifier_id`` is not found\n        :raise: ``NullArgument`` -- ``qualifier_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "qualifier_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "osid.authorization.QualifierList", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "is_descendant_of_qualifier", 
               "doc": {
                  "headline": "Tests if an ``Id`` is a descendant of a qualifier.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    id (osid.id.Id): an ``Id``\n        arg:    qualifier_id (osid.id.Id): the ``Id`` of a qualifier\n", 
               "return_doc": "        return: (boolean) - ``true`` if the ``id`` is a descendant of\n                the ``qualifier_id,`` ``false`` otherwise", 
               "error_doc": "        raise:  NotFound - ``qualifier_id`` not found\n        raise:  NullArgument - ``qualifier_id`` or ``id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param id: an ``Id``\n        :type id: ``osid.id.Id``\n        :param qualifier_id: the ``Id`` of a qualifier\n        :type qualifier_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: ``true`` if the ``id`` is a descendant of the ``qualifier_id,``  ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``qualifier_id`` not found\n        :raise: ``NullArgument`` -- ``qualifier_id`` or ``id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "        *implementation notes*: If ``id`` is not found return ``false``.\n", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "id_", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "qualifier_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "osid.id.Id"
               ], 
               "return_type": "boolean", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_qualifier_node_ids", 
               "doc": {
                  "headline": "Gets a portion of the hierarchy for the given qualifier.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    qualifier_id (osid.id.Id): the ``Id`` to query\n        arg:    ancestor_levels (cardinal): the maximum number of\n                ancestor levels to include. A value of 0 returns no\n                parents in the node.\n        arg:    descendant_levels (cardinal): the maximum number of\n                descendant levels to include. A value of 0 returns no\n                children in the node.\n        arg:    include_siblings (boolean): ``true`` to include the\n                siblings of the given node, ``false`` to omit the\n                siblings\n", 
               "return_doc": "        return: (osid.hierarchy.Node) - a qualifier node", 
               "error_doc": "        raise:  NotFound - ``function_id`` is not found\n        raise:  NullArgument - ``function_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param qualifier_id: the ``Id`` to query\n        :type qualifier_id: ``osid.id.Id``\n        :param ancestor_levels: the maximum number of ancestor levels to include. A value of 0 returns no parents in the node.\n        :type ancestor_levels: ``cardinal``\n        :param descendant_levels: the maximum number of descendant levels to include. A value of 0 returns no children in the node.\n        :type descendant_levels: ``cardinal``\n        :param include_siblings: ``true`` to include the siblings of the given node, ``false`` to omit the siblings\n        :type include_siblings: ``boolean``\n", 
               "sphinx_return_doc": "        :return: a qualifier node\n        :rtype: ``osid.hierarchy.Node``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``function_id`` is not found\n        :raise: ``NullArgument`` -- ``function_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "qualifier_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "cardinal", 
                     "var_name": "ancestor_levels", 
                     "array": false
                  }, 
                  {
                     "arg_type": "cardinal", 
                     "var_name": "descendant_levels", 
                     "array": false
                  }, 
                  {
                     "arg_type": "boolean", 
                     "var_name": "include_siblings", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "cardinal", 
                  "cardinal", 
                  "boolean"
               ], 
               "return_type": "osid.hierarchy.Node", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_qualifier_nodes", 
               "doc": {
                  "headline": "Gets a portion of the hierarchy for the given qualifier.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    qualifier_id (osid.id.Id): the ``Id`` to query\n        arg:    ancestor_levels (cardinal): the maximum number of\n                ancestor levels to include. A value of 0 returns no\n                parents in the node.\n        arg:    descendant_levels (cardinal): the maximum number of\n                descendant levels to include. A value of 0 returns no\n                children in the node.\n        arg:    include_siblings (boolean): ``true`` to include the\n                siblings of the given node, ``false`` to omit the\n                siblings\n", 
               "return_doc": "        return: (osid.authorization.QualifierNode) - a qualifier node", 
               "error_doc": "        raise:  NotFound - ``function_id`` is not found\n        raise:  NullArgument - ``function_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param qualifier_id: the ``Id`` to query\n        :type qualifier_id: ``osid.id.Id``\n        :param ancestor_levels: the maximum number of ancestor levels to include. A value of 0 returns no parents in the node.\n        :type ancestor_levels: ``cardinal``\n        :param descendant_levels: the maximum number of descendant levels to include. A value of 0 returns no children in the node.\n        :type descendant_levels: ``cardinal``\n        :param include_siblings: ``true`` to include the siblings of the given node, ``false`` to omit the siblings\n        :type include_siblings: ``boolean``\n", 
               "sphinx_return_doc": "        :return: a qualifier node\n        :rtype: ``osid.authorization.QualifierNode``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``function_id`` is not found\n        :raise: ``NullArgument`` -- ``function_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "qualifier_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "cardinal", 
                     "var_name": "ancestor_levels", 
                     "array": false
                  }, 
                  {
                     "arg_type": "cardinal", 
                     "var_name": "descendant_levels", 
                     "array": false
                  }, 
                  {
                     "arg_type": "boolean", 
                     "var_name": "include_siblings", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "cardinal", 
                  "cardinal", 
                  "boolean"
               ], 
               "return_type": "osid.authorization.QualifierNode", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.authorization.QualifierHierarchyDesignSession", 
         "shortname": "QualifierHierarchyDesignSession", 
         "category": "sessions", 
         "doc": {
            "headline": "This session defines methods for managing a hierarchy of ``Qualifier`` objects.", 
            "body": "    Each node in the hierarchy is a unique ``Qualifier``."
         }, 
         "inherit_fullnames": [
            "osid.OsidSession"
         ], 
         "inherit_shortnames": [
            "OsidSession"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidSession"
            }
         ], 
         "method_names": [
            "get_qualifier_hierarchy_id", 
            "get_qualifier_hierarchy", 
            "can_modify_qualifier_hierarchy", 
            "add_root_qualifier", 
            "remove_root_qualifier", 
            "add_child_qualifier", 
            "remove_child_qualifier", 
            "remove_child_qualifiers"
         ], 
         "methods": [
            {
               "name": "get_qualifier_hierarchy_id", 
               "doc": {
                  "headline": "Gets the hierarchy ``Id`` associated with this session.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.id.Id) - the hierarchy ``Id`` associated with this\n                session", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the hierarchy ``Id`` associated with this session\n        :rtype: ``osid.id.Id``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.id.Id", 
               "errors": {}
            }, 
            {
               "name": "get_qualifier_hierarchy", 
               "doc": {
                  "headline": "Gets the hierarchy associated with this session.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.hierarchy.Hierarchy) - the hierarchy associated\n                with this session", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the hierarchy associated with this session\n        :rtype: ``osid.hierarchy.Hierarchy``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.hierarchy.Hierarchy", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "can_modify_qualifier_hierarchy", 
               "doc": {
                  "headline": "Tests if this user can change the hierarchy.", 
                  "body": "        A return of true does not guarantee successful authorization. A\n        return of false indicates that it is known performing any update\n        will result in a ``PermissionDenied``. This is intended as a\n        hint to an application that may opt not to offer these\n        operations to an unauthorized user."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``false`` if changing this hierarchy is not\n                authorized, ``true`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``false`` if changing this hierarchy is not authorized, ``true`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "add_root_qualifier", 
               "doc": {
                  "headline": "Adds a root qualifier.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    qualifier_id (osid.id.Id): the ``Id`` of a qualifier\n", 
               "return_doc": "", 
               "error_doc": "        raise:  AlreadyExists - ``qualifier_id`` is already in hierarchy\n        raise:  NotFound - ``qualifier_id`` not found\n        raise:  NullArgument - ``qualifier_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param qualifier_id: the ``Id`` of a qualifier\n        :type qualifier_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``AlreadyExists`` -- ``qualifier_id`` is already in hierarchy\n        :raise: ``NotFound`` -- ``qualifier_id`` not found\n        :raise: ``NullArgument`` -- ``qualifier_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "qualifier_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {
                  "ALREADY_EXISTS": "User", 
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "remove_root_qualifier", 
               "doc": {
                  "headline": "Removes a root qualifier from this hierarchy.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    qualifier_id (osid.id.Id): the ``Id`` of a qualifier\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NotFound - ``qualifier_id`` not a parent of ``child_id``\n        raise:  NullArgument - ``qualifier_id`` or ``child_id`` is\n                ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param qualifier_id: the ``Id`` of a qualifier\n        :type qualifier_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``qualifier_id`` not a parent of ``child_id``\n        :raise: ``NullArgument`` -- ``qualifier_id`` or ``child_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "qualifier_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "add_child_qualifier", 
               "doc": {
                  "headline": "Adds a child to a qualifier.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    qualifier_id (osid.id.Id): the ``Id`` of a qualifier\n        arg:    child_id (osid.id.Id): the ``Id`` of the new child\n", 
               "return_doc": "", 
               "error_doc": "        raise:  AlreadyExists - ``qualifier_id`` is already a parent of\n                ``child_id``\n        raise:  NotFound - ``qualifier_id`` or ``child_id`` not found\n        raise:  NullArgument - ``qualifier_id`` or ``child_id`` is\n                ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param qualifier_id: the ``Id`` of a qualifier\n        :type qualifier_id: ``osid.id.Id``\n        :param child_id: the ``Id`` of the new child\n        :type child_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``AlreadyExists`` -- ``qualifier_id`` is already a parent of ``child_id``\n        :raise: ``NotFound`` -- ``qualifier_id`` or ``child_id`` not found\n        :raise: ``NullArgument`` -- ``qualifier_id`` or ``child_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "qualifier_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "child_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {
                  "ALREADY_EXISTS": "User", 
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "remove_child_qualifier", 
               "doc": {
                  "headline": "Removes a child from a qualifier.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    qualifier_id (osid.id.Id): the ``Id`` of a qualifier\n        arg:    child_id (osid.id.Id): the ``Id`` of the child\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NotFound - ``qualifier_id`` not parent of ``child_id``\n        raise:  NullArgument - ``qualifier_id`` or ``child_id`` is\n                ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param qualifier_id: the ``Id`` of a qualifier\n        :type qualifier_id: ``osid.id.Id``\n        :param child_id: the ``Id`` of the child\n        :type child_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``qualifier_id`` not parent of ``child_id``\n        :raise: ``NullArgument`` -- ``qualifier_id`` or ``child_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "qualifier_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "child_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "remove_child_qualifiers", 
               "doc": {
                  "headline": "Removes all children from a qualifier.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    qualifier_id (osid.id.Id): the ``Id`` of a qualifier\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NotFound - ``qualifier_id`` is not in hierarchy\n        raise:  NullArgument - ``qualifier_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param qualifier_id: the ``Id`` of a qualifier\n        :type qualifier_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``qualifier_id`` is not in hierarchy\n        :raise: ``NullArgument`` -- ``qualifier_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "qualifier_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.authorization.QualifierVaultSession", 
         "shortname": "QualifierVaultSession", 
         "category": "sessions", 
         "doc": {
            "headline": "This session provides methods to retrieve ``Qualifier`` to ``Vault`` mappings.", 
            "body": "    A ``Qualifier`` may appear in multiple ``Vaults``. Each ``Vault``\n    may have its own authorizations governing who is allowed to look at\n    it.\n\n    This lookup session defines two views:\n    \n      * comparative view: elements may be silently omitted or re-ordered\n      * plenary view: provides a complete result set or is an error\n        condition\n"
         }, 
         "inherit_fullnames": [
            "osid.OsidSession"
         ], 
         "inherit_shortnames": [
            "OsidSession"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidSession"
            }
         ], 
         "method_names": [
            "can_lookup_qualifier_vault_mappings", 
            "use_comparative_vault_view", 
            "use_plenary_vault_view", 
            "get_qualifier_ids_by_vault", 
            "get_qualifiers_by_vault", 
            "get_qualifier_ids_by_vaults", 
            "get_qualifiers_by_vaults", 
            "get_vault_ids_by_qualifier", 
            "get_vaults_by_qualifier"
         ], 
         "methods": [
            {
               "name": "can_lookup_qualifier_vault_mappings", 
               "doc": {
                  "headline": "Tests if this user can perform lookups of qualifier/vault mappings.", 
                  "body": "        A return of true does not guarantee successful authorization. A\n        return of false indicates that it is known lookup methods in\n        this session will result in a ``PermissionDenied``. This is\n        intended as a hint to an application that may opt not to offer\n        lookup operations to unauthorized users."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``false`` if looking up mappings is not\n                authorized, ``true`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``false`` if looking up mappings is not authorized, ``true`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "use_comparative_vault_view", 
               "doc": {
                  "headline": "The returns from the lookup methods may omit or translate elements based on this session, such as authorization, and not result in an error.", 
                  "body": "        This view is used when greater interoperability is desired at\n        the expense of precision."
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "use_plenary_vault_view", 
               "doc": {
                  "headline": "A complete view of the ``Qualifier`` and ``Vault`` returns is desired.", 
                  "body": "        Methods will return what is requested or result in an error.\n        This view is used when greater precision is desired at the\n        expense of interoperability."
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "get_qualifier_ids_by_vault", 
               "doc": {
                  "headline": "Gets the list of ``Qualifier``  ``Ids`` associated with a ``Vault``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    vault_id (osid.id.Id): ``Id`` of the ``Vault``\n", 
               "return_doc": "        return: (osid.id.IdList) - list of related qualifier ``Ids``", 
               "error_doc": "        raise:  NotFound - ``vault_id`` is not found\n        raise:  NullArgument - ``vault_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param vault_id: ``Id`` of the ``Vault``\n        :type vault_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: list of related qualifier ``Ids``\n        :rtype: ``osid.id.IdList``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``vault_id`` is not found\n        :raise: ``NullArgument`` -- ``vault_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "vault_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "osid.id.IdList", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_qualifiers_by_vault", 
               "doc": {
                  "headline": "Gets the list of ``Qualifier`` associated with a ``Vault``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    vault_id (osid.id.Id): ``Id`` of the ``Vault``\n", 
               "return_doc": "        return: (osid.authorization.QualifierList) - list of related\n                qualifiers", 
               "error_doc": "        raise:  NotFound - ``vault_id`` is not found\n        raise:  NullArgument - ``vault_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param vault_id: ``Id`` of the ``Vault``\n        :type vault_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: list of related qualifiers\n        :rtype: ``osid.authorization.QualifierList``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``vault_id`` is not found\n        :raise: ``NullArgument`` -- ``vault_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "vault_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "osid.authorization.QualifierList", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_qualifier_ids_by_vaults", 
               "doc": {
                  "headline": "Gets the list of ``Qualifier Ids`` corresponding to a list of ``Vaults``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    vault_ids (osid.id.IdList): list of vault ``Ids``\n", 
               "return_doc": "        return: (osid.id.IdList) - list of vault ``Ids``", 
               "error_doc": "        raise:  NullArgument - ``vault_ids`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param vault_ids: list of vault ``Ids``\n        :type vault_ids: ``osid.id.IdList``\n", 
               "sphinx_return_doc": "        :return: list of vault ``Ids``\n        :rtype: ``osid.id.IdList``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``vault_ids`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.IdList", 
                     "var_name": "vault_ids", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.IdList"
               ], 
               "return_type": "osid.id.IdList", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_qualifiers_by_vaults", 
               "doc": {
                  "headline": "Gets the list of ``Qualifiers`` corresponding to a list of ``Vaults``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    vault_ids (osid.id.IdList): list of vault ``Ids``\n", 
               "return_doc": "        return: (osid.authorization.QualifierList) - list of qualifiers", 
               "error_doc": "        raise:  NullArgument - ``vault_ids`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param vault_ids: list of vault ``Ids``\n        :type vault_ids: ``osid.id.IdList``\n", 
               "sphinx_return_doc": "        :return: list of qualifiers\n        :rtype: ``osid.authorization.QualifierList``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``vault_ids`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.IdList", 
                     "var_name": "vault_ids", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.IdList"
               ], 
               "return_type": "osid.authorization.QualifierList", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_vault_ids_by_qualifier", 
               "doc": {
                  "headline": "Gets the list of ``Vault``  ``Ids`` mapped to a ``Qualifier``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    qualifier_id (osid.id.Id): ``Id`` of a ``Qualifier``\n", 
               "return_doc": "        return: (osid.id.IdList) - list of vault ``Ids``", 
               "error_doc": "        raise:  NotFound - ``qualifier_id`` is not found\n        raise:  NullArgument - ``qualifier_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param qualifier_id: ``Id`` of a ``Qualifier``\n        :type qualifier_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: list of vault ``Ids``\n        :rtype: ``osid.id.IdList``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``qualifier_id`` is not found\n        :raise: ``NullArgument`` -- ``qualifier_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "qualifier_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "osid.id.IdList", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_vaults_by_qualifier", 
               "doc": {
                  "headline": "Gets the list of ``Vaults`` mapped to a ``Qualifier``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    qualifier_id (osid.id.Id): ``Id`` of a ``Qualifier``\n", 
               "return_doc": "        return: (osid.authorization.VaultList) - list of vaults", 
               "error_doc": "        raise:  NotFound - ``qualifier_id`` is not found\n        raise:  NullArgument - ``qualifier_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param qualifier_id: ``Id`` of a ``Qualifier``\n        :type qualifier_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: list of vaults\n        :rtype: ``osid.authorization.VaultList``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``qualifier_id`` is not found\n        :raise: ``NullArgument`` -- ``qualifier_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "qualifier_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "osid.authorization.VaultList", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.authorization.QualifierVaultAssignmentSession", 
         "shortname": "QualifierVaultAssignmentSession", 
         "category": "sessions", 
         "doc": {
            "headline": "This session provides methods to re-assign ``Qualifiers`` to ``Vaults``.", 
            "body": "    A ``Qualifier`` may map to multiple ``Vaults`` and removing the last\n    reference to a ``Qualifier`` is the equivalent of deleting it. Each\n    ``Vault`` may have its own authorizations governing who is allowed\n    to operate on it.\n\n    Adding a reference of a ``Qualifier`` to another ``Vault`` is not a\n    copy operation (eg: does not change its ``Id`` )."
         }, 
         "inherit_fullnames": [
            "osid.OsidSession"
         ], 
         "inherit_shortnames": [
            "OsidSession"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidSession"
            }
         ], 
         "method_names": [
            "can_assign_qualifiers", 
            "can_assign_qualifiers_to_vault", 
            "get_assignable_vault_ids", 
            "get_assignable_vault_ids_for_qualifier", 
            "assign_qualifier_to_vault", 
            "unassign_qualifier_from_vault"
         ], 
         "methods": [
            {
               "name": "can_assign_qualifiers", 
               "doc": {
                  "headline": "Tests if this user can alter qualifier/vault mappings.", 
                  "body": "        A return of true does not guarantee successful authorization. A\n        return of false indicates that it is known mapping methods in\n        this session will result in a ``PermissionDenied``. This is\n        intended as a hint to an application that may opt not to offer\n        assignment operations to unauthorized users."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``false`` if mapping is not authorized,\n                ``true`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``false`` if mapping is not authorized, ``true`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "can_assign_qualifiers_to_vault", 
               "doc": {
                  "headline": "Tests if this user can alter qualifier/vault mappings.", 
                  "body": "        A return of true does not guarantee successful authorization. A\n        return of false indicates that it is known mapping methods in\n        this session will result in a ``PermissionDenied``. This is\n        intended as a hint to an application that may opt not to offer\n        assignment operations to unauthorized users."
               }, 
               "arg_doc": "        arg:    vault_id (osid.id.Id): the ``Id`` of the ``Vault``\n", 
               "return_doc": "        return: (boolean) - ``false`` if mapping is not authorized,\n                ``true`` otherwise", 
               "error_doc": "        raise:  NullArgument - ``vault_id`` is ``null``", 
               "sphinx_param_doc": "        :param vault_id: the ``Id`` of the ``Vault``\n        :type vault_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: ``false`` if mapping is not authorized, ``true`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``vault_id`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "vault_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "boolean", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "get_assignable_vault_ids", 
               "doc": {
                  "headline": "Gets a list of vault including and under the given vault node in which any qualifier can be assigned.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    vault_id (osid.id.Id): the ``Id`` of the ``Vault``\n", 
               "return_doc": "        return: (osid.id.IdList) - list of assignable vault ``Ids``", 
               "error_doc": "        raise:  NullArgument - ``vault_id`` is ``null``\n        raise:  OperationFailed - unable to complete request", 
               "sphinx_param_doc": "        :param vault_id: the ``Id`` of the ``Vault``\n        :type vault_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: list of assignable vault ``Ids``\n        :rtype: ``osid.id.IdList``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``vault_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "vault_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "osid.id.IdList", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational"
               }
            }, 
            {
               "name": "get_assignable_vault_ids_for_qualifier", 
               "doc": {
                  "headline": "Gets a list of vault including and under the given vault node in which a specific qualifier can be assigned.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    vault_id (osid.id.Id): the ``Id`` of the ``Vault``\n        arg:    qualifier_id (osid.id.Id): the ``Id`` of the\n                ``Qualifier``\n", 
               "return_doc": "        return: (osid.id.IdList) - list of assignable vault ``Ids``", 
               "error_doc": "        raise:  NullArgument - ``vault_id`` or ``qualifier_id`` is\n                ``null``\n        raise:  OperationFailed - unable to complete request", 
               "sphinx_param_doc": "        :param vault_id: the ``Id`` of the ``Vault``\n        :type vault_id: ``osid.id.Id``\n        :param qualifier_id: the ``Id`` of the ``Qualifier``\n        :type qualifier_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: list of assignable vault ``Ids``\n        :rtype: ``osid.id.IdList``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``vault_id`` or ``qualifier_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "vault_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "qualifier_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "osid.id.Id"
               ], 
               "return_type": "osid.id.IdList", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational"
               }
            }, 
            {
               "name": "assign_qualifier_to_vault", 
               "doc": {
                  "headline": "Adds an existing ``Qualifier`` to a ``Vault``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    qualifier_id (osid.id.Id): the ``Id`` of the\n                ``Qualifier``\n        arg:    vault_id (osid.id.Id): the ``Id`` of the ``Vault``\n", 
               "return_doc": "", 
               "error_doc": "        raise:  AlreadyExists - ``qualifier_id`` is already assigned to\n                ``vault_id``\n        raise:  NotFound - ``qualifier_id`` or ``vault_id`` not found\n        raise:  NullArgument - ``qualifier_id`` or ``vault_id`` is\n                ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param qualifier_id: the ``Id`` of the ``Qualifier``\n        :type qualifier_id: ``osid.id.Id``\n        :param vault_id: the ``Id`` of the ``Vault``\n        :type vault_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``AlreadyExists`` -- ``qualifier_id`` is already assigned to ``vault_id``\n        :raise: ``NotFound`` -- ``qualifier_id`` or ``vault_id`` not found\n        :raise: ``NullArgument`` -- ``qualifier_id`` or ``vault_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "qualifier_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "vault_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {
                  "ALREADY_EXISTS": "User", 
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "unassign_qualifier_from_vault", 
               "doc": {
                  "headline": "Removes a ``Qualifier`` from a ``Vault``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    qualifier_id (osid.id.Id): the ``Id`` of the\n                ``Qualifier``\n        arg:    vault_id (osid.id.Id): the ``Id`` of the ``Vault``\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NotFound - ``qualifier_id`` or ``vault_id`` not found or\n                ``qualifier_id`` not assigned to ``vault_id``\n        raise:  NullArgument - ``qualifier_id`` or ``vault_id`` is\n                ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param qualifier_id: the ``Id`` of the ``Qualifier``\n        :type qualifier_id: ``osid.id.Id``\n        :param vault_id: the ``Id`` of the ``Vault``\n        :type vault_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``qualifier_id`` or ``vault_id`` not found or ``qualifier_id`` not assigned to ``vault_id``\n        :raise: ``NullArgument`` -- ``qualifier_id`` or ``vault_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "qualifier_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "vault_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.authorization.QualifierSmartVaultSession", 
         "shortname": "QualifierSmartVaultSession", 
         "category": "sessions", 
         "doc": {
            "headline": "This session manages queries and sequencing to create \"smart\" dynamic catalogs.", 
            "body": "    A ``QualifierQuery`` can be retrieved from this session and mapped\n    to this ``Vault`` to create a virtual collection of ``Qualifiers``.\n    The qualifiers may be sequenced using the ``QualifierSearchOrder``\n    from this session.\n\n    This ``Vault`` has a default query that matches any qualifier and a\n    default search order that specifies no sequencing. The queries may\n    be examined using a ``QualifierQueryInspector``. The query may be\n    modified by converting the inspector back to a ``QualifierQuery``."
         }, 
         "inherit_fullnames": [
            "osid.OsidSession"
         ], 
         "inherit_shortnames": [
            "OsidSession"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidSession"
            }
         ], 
         "method_names": [
            "get_vault_id", 
            "get_vault", 
            "can_manage_smart_vaults", 
            "get_qualifier_query", 
            "get_qualifier_search_order", 
            "apply_qualifier_query", 
            "inspect_qualifier_query", 
            "apply_qualifier_sequencing", 
            "get_qualifier_query_from_inspector"
         ], 
         "methods": [
            {
               "name": "get_vault_id", 
               "doc": {
                  "headline": "Gets the ``Vault``  ``Id`` associated with this session.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.id.Id) - the ``Vault Id`` associated with this\n                session", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the ``Vault Id`` associated with this session\n        :rtype: ``osid.id.Id``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.id.Id", 
               "errors": {}
            }, 
            {
               "name": "get_vault", 
               "doc": {
                  "headline": "Gets the ``Vault`` associated with this session.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.authorization.Vault) - the ``Vault`` associated\n                with this session", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the ``Vault`` associated with this session\n        :rtype: ``osid.authorization.Vault``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.authorization.Vault", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "can_manage_smart_vaults", 
               "doc": {
                  "headline": "Tests if this user can manage smart vaults.", 
                  "body": "        A return of true does not guarantee successful authorization. A\n        return of false indicates that it is known methods in this\n        session will result in a ``PermissionDenied``. This is intended\n        as a hint to an application that may opt not to offer operations\n        to unauthorized users."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``false`` if smart vault management is not\n                authorized, ``true`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``false`` if smart vault management is not authorized, ``true`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "get_qualifier_query", 
               "doc": {
                  "headline": "Gets a qualifier query.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.authorization.QualifierQuery) - the qualifier\n                query", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the qualifier query\n        :rtype: ``osid.authorization.QualifierQuery``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.authorization.QualifierQuery", 
               "errors": {}
            }, 
            {
               "name": "get_qualifier_search_order", 
               "doc": {
                  "headline": "Gets a qualifier search order.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.authorization.QualifierSearchOrder) - the\n                qualifier search order", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the qualifier search order\n        :rtype: ``osid.authorization.QualifierSearchOrder``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.authorization.QualifierSearchOrder", 
               "errors": {}
            }, 
            {
               "name": "apply_qualifier_query", 
               "doc": {
                  "headline": "Applies a qualifier query to this vault.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    qualifier_query (osid.authorization.QualifierQuery): the\n                qualifier query\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``qualifier_query`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure occurred\n        raise:  Unsupported - ``qualifier_query`` not of this service", 
               "sphinx_param_doc": "        :param qualifier_query: the qualifier query\n        :type qualifier_query: ``osid.authorization.QualifierQuery``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``qualifier_query`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure occurred\n        :raise: ``Unsupported`` -- ``qualifier_query`` not of this service", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.authorization.QualifierQuery", 
                     "var_name": "qualifier_query", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.authorization.QualifierQuery"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }, 
            {
               "name": "inspect_qualifier_query", 
               "doc": {
                  "headline": "Gets a qualifier query inspector for this vault.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.authorization.QualifierQueryInspector) - the\n                qualifier query inspector", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure occurred", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the qualifier query inspector\n        :rtype: ``osid.authorization.QualifierQueryInspector``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure occurred", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.authorization.QualifierQueryInspector", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "apply_qualifier_sequencing", 
               "doc": {
                  "headline": "Applies a qualifier search order to this vault.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    qualifier_search_order\n                (osid.authorization.QualifierSearchOrder): the qualifier\n                search order\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``qualifier_search_order`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure occurred\n        raise:  Unsupported - ``qualifier_search_order`` not of this\n                service", 
               "sphinx_param_doc": "        :param qualifier_search_order: the qualifier search order\n        :type qualifier_search_order: ``osid.authorization.QualifierSearchOrder``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``qualifier_search_order`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure occurred\n        :raise: ``Unsupported`` -- ``qualifier_search_order`` not of this service", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.authorization.QualifierSearchOrder", 
                     "var_name": "qualifier_search_order", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.authorization.QualifierSearchOrder"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_qualifier_query_from_inspector", 
               "doc": {
                  "headline": "Gets a qualifier query from an inspector.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    qualifier_query_inspector\n                (osid.authorization.QualifierQueryInspector): a query\n                inspector\n", 
               "return_doc": "        return: (osid.authorization.QualifierQuery) - the qualifier\n                query", 
               "error_doc": "        raise:  NullArgument - ``qualifier_query_inspector`` is ``null``\n        raise:  Unsupported - ``qualifier_query_inspector`` is not of\n                this service", 
               "sphinx_param_doc": "        :param qualifier_query_inspector: a query inspector\n        :type qualifier_query_inspector: ``osid.authorization.QualifierQueryInspector``\n", 
               "sphinx_return_doc": "        :return: the qualifier query\n        :rtype: ``osid.authorization.QualifierQuery``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``qualifier_query_inspector`` is ``null``\n        :raise: ``Unsupported`` -- ``qualifier_query_inspector`` is not of this service", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.authorization.QualifierQueryInspector", 
                     "var_name": "qualifier_query_inspector", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.authorization.QualifierQueryInspector"
               ], 
               "return_type": "osid.authorization.QualifierQuery", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.authorization.VaultLookupSession", 
         "shortname": "VaultLookupSession", 
         "category": "sessions", 
         "doc": {
            "headline": "This session provides methods for retrieving ``Vault`` objects.", 
            "body": "    The ``Vault`` represents a collection of ``Functions`` and\n    ``Authorizations``.\n\n    This session defines views that offer differing behaviors when\n    retrieving multiple objects.\n    \n      * comparative view: elements may be silently omitted or re-ordered\n      * plenary view: provides a complete set or is an error condition\n\n    \n    Generally, the comparative view should be used for most applications\n    as it permits operation even if there is data that cannot be\n    accessed. For example, a browsing application may only need to\n    examine the ``Vaults`` it can access, without breaking execution.\n    However, an administrative application may require all ``Vault``\n    elements to be available.\n    \n    Vaults may have an additional records indicated by their respective\n    record types. The record may not be accessed through a cast of the\n    ``Vault``."
         }, 
         "inherit_fullnames": [
            "osid.OsidSession"
         ], 
         "inherit_shortnames": [
            "OsidSession"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidSession"
            }
         ], 
         "method_names": [
            "can_lookup_vaults", 
            "use_comparative_vault_view", 
            "use_plenary_vault_view", 
            "get_vault", 
            "get_vaults_by_ids", 
            "get_vaults_by_genus_type", 
            "get_vaults_by_parent_genus_type", 
            "get_vaults_by_record_type", 
            "get_vaults_by_provider", 
            "get_vaults"
         ], 
         "methods": [
            {
               "name": "can_lookup_vaults", 
               "doc": {
                  "headline": "Tests if this user can perform ``Vault`` lookups.", 
                  "body": "        A return of true does not guarantee successful authorization. A\n        return of false indicates that it is known all methods in this\n        session will result in a ``PermissionDenied``. This is intended\n        as a hint to an application that may opt not to offer lookup\n        operations to unauthorized users."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``false`` if lookup methods are not\n                authorized, ``true`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``false`` if lookup methods are not authorized, ``true`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "use_comparative_vault_view", 
               "doc": {
                  "headline": "The returns from the lookup methods may omit or translate elements based on this session, such as authorization, and not result in an error.", 
                  "body": "        This view is used when greater interoperability is desired at\n        the expense of precision."
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "use_plenary_vault_view", 
               "doc": {
                  "headline": "A complete view of the ``Vault`` returns is desired.", 
                  "body": "        Methods will return what is requested or result in an error.\n        This view is used when greater precision is desired at the\n        expense of interoperability."
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "get_vault", 
               "doc": {
                  "headline": "Gets the ``Vault`` specified by its ``Id``.", 
                  "body": "        In plenary mode, the exact ``Id`` is found or a ``NotFound``\n        results. Otherwise, the returned ``Vault`` may have a different\n        ``Id`` than requested, such as the case where a duplicate ``Id``\n        was assigned to a ``Vault`` and retained for compatibility."
               }, 
               "arg_doc": "        arg:    vault_id (osid.id.Id): ``Id`` of the ``Vault``\n", 
               "return_doc": "        return: (osid.authorization.Vault) - the vault", 
               "error_doc": "        raise:  NotFound - ``vault_id`` not found\n        raise:  NullArgument - ``vault_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param vault_id: ``Id`` of the ``Vault``\n        :type vault_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: the vault\n        :rtype: ``osid.authorization.Vault``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``vault_id`` not found\n        :raise: ``NullArgument`` -- ``vault_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "vault_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "osid.authorization.Vault", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_vaults_by_ids", 
               "doc": {
                  "headline": "Gets a ``VaultList`` corresponding to the given ``IdList``.", 
                  "body": "        In plenary mode, the returned list contains all of the vaults\n        specified in the ``Id`` list, in the order of the list,\n        including duplicates, or an error results if an ``Id`` in the\n        supplied list is not found or inaccessible. Otherwise,\n        inaccessible ``Vault`` objects may be omitted from the list and\n        may present the elements in any order including returning a\n        unique set."
               }, 
               "arg_doc": "        arg:    vault_ids (osid.id.IdList): the list of ``Ids`` to\n                retrieve\n", 
               "return_doc": "        return: (osid.authorization.VaultList) - the returned ``Vault``\n                list", 
               "error_doc": "        raise:  NotFound - an ``Id was`` not found\n        raise:  NullArgument - ``vault_ids`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param vault_ids: the list of ``Ids`` to retrieve\n        :type vault_ids: ``osid.id.IdList``\n", 
               "sphinx_return_doc": "        :return: the returned ``Vault`` list\n        :rtype: ``osid.authorization.VaultList``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- an ``Id was`` not found\n        :raise: ``NullArgument`` -- ``vault_ids`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.IdList", 
                     "var_name": "vault_ids", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.IdList"
               ], 
               "return_type": "osid.authorization.VaultList", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_vaults_by_genus_type", 
               "doc": {
                  "headline": "Gets a ``VaultList`` corresponding to the given vault genus ``Type`` which does not include vaults of types derived from the specified ``Type``.", 
                  "body": "        In plenary mode, the returned list contains all known vaults or\n        an error results. Otherwise, the returned list may contain only\n        those vaults that are accessible through this session."
               }, 
               "arg_doc": "        arg:    vault_genus_type (osid.type.Type): a vault genus type\n", 
               "return_doc": "        return: (osid.authorization.VaultList) - the returned ``Vault``\n                list", 
               "error_doc": "        raise:  NullArgument - ``vault_genus_type`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param vault_genus_type: a vault genus type\n        :type vault_genus_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "        :return: the returned ``Vault`` list\n        :rtype: ``osid.authorization.VaultList``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``vault_genus_type`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "vault_genus_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "osid.authorization.VaultList", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_vaults_by_parent_genus_type", 
               "doc": {
                  "headline": "Gets a ``VaultList`` corresponding to the given vault genus ``Type`` and include any additional vaults with genus types derived from the specified ``Type``.", 
                  "body": "        In plenary mode, the returned list contains all known vaults or\n        an error results. Otherwise, the returned list may contain only\n        those vaults that are accessible through this session."
               }, 
               "arg_doc": "        arg:    vault_genus_type (osid.type.Type): a vault genus type\n", 
               "return_doc": "        return: (osid.authorization.VaultList) - the returned ``Vault``\n                list", 
               "error_doc": "        raise:  NullArgument - ``vault_genus_type`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param vault_genus_type: a vault genus type\n        :type vault_genus_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "        :return: the returned ``Vault`` list\n        :rtype: ``osid.authorization.VaultList``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``vault_genus_type`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "vault_genus_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "osid.authorization.VaultList", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_vaults_by_record_type", 
               "doc": {
                  "headline": "Gets a ``VaultList`` containing the given vault record ``Type``.", 
                  "body": "        In plenary mode, the returned list contains all known vaults or\n        an error results. Otherwise, the returned list may contain only\n        those vaults that are accessible through this session."
               }, 
               "arg_doc": "        arg:    vault_record_type (osid.type.Type): a vault record type\n", 
               "return_doc": "        return: (osid.authorization.VaultList) - the returned ``Vault``\n                list", 
               "error_doc": "        raise:  NullArgument - ``vault_record_type`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param vault_record_type: a vault record type\n        :type vault_record_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "        :return: the returned ``Vault`` list\n        :rtype: ``osid.authorization.VaultList``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``vault_record_type`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "vault_record_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "osid.authorization.VaultList", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_vaults_by_provider", 
               "doc": {
                  "headline": "Gets a ``VaultList`` from the given provider ````.", 
                  "body": "        In plenary mode, the returned list contains all known vaults or\n        an error results. Otherwise, the returned list may contain only\n        those vaults that are accessible through this session."
               }, 
               "arg_doc": "        arg:    resource_id (osid.id.Id): a resource ``Id``\n", 
               "return_doc": "        return: (osid.authorization.VaultList) - the returned ``Vault``\n                list", 
               "error_doc": "        raise:  NullArgument - ``resource_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param resource_id: a resource ``Id``\n        :type resource_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: the returned ``Vault`` list\n        :rtype: ``osid.authorization.VaultList``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``resource_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "resource_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "osid.authorization.VaultList", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_vaults", 
               "doc": {
                  "headline": "Gets all ``Vaults``.", 
                  "body": "        In plenary mode, the returned list contains all known vaults or\n        an error results. Otherwise, the returned list may contain only\n        those vaults that are accessible through this session."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.authorization.VaultList) - a ``VaultList``", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: a ``VaultList``\n        :rtype: ``osid.authorization.VaultList``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.authorization.VaultList", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.authorization.VaultQuerySession", 
         "shortname": "VaultQuerySession", 
         "category": "sessions", 
         "doc": {
            "headline": "This session provides methods for searching among ``Vault`` objects.", 
            "body": "    The search query is constructed using the ``VaultQuery``.\n\n    Vaults may have a query record indicated by their respective record\n    types. The query record is accessed via the ``VaultQuery``."
         }, 
         "inherit_fullnames": [
            "osid.OsidSession"
         ], 
         "inherit_shortnames": [
            "OsidSession"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidSession"
            }
         ], 
         "method_names": [
            "can_search_vaults", 
            "get_vault_query", 
            "get_vaults_by_query"
         ], 
         "methods": [
            {
               "name": "can_search_vaults", 
               "doc": {
                  "headline": "Tests if this user can perform ``Vault`` searches.", 
                  "body": "        A return of true does not guarantee successful authorization. A\n        return of false indicates that it is known all methods in this\n        session will result in a ``PermissionDenied``. This is intended\n        as a hint to an application that may opt not to offer search\n        operations to unauthorized users."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``false`` if search methods are not\n                authorized, ``true`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``false`` if search methods are not authorized, ``true`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "get_vault_query", 
               "doc": {
                  "headline": "Gets a vault query.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.authorization.VaultQuery) - a vault query", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: a vault query\n        :rtype: ``osid.authorization.VaultQuery``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.authorization.VaultQuery", 
               "errors": {}
            }, 
            {
               "name": "get_vaults_by_query", 
               "doc": {
                  "headline": "Gets a list of ``Vault`` objects matching the given search.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    vault_query (osid.authorization.VaultQuery): the vault\n                query\n", 
               "return_doc": "        return: (osid.authorization.VaultList) - the returned\n                ``VaultList``", 
               "error_doc": "        raise:  NullArgument - ``vault_query`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        raise:  Unsupported - ``vault_query`` is not of this service", 
               "sphinx_param_doc": "        :param vault_query: the vault query\n        :type vault_query: ``osid.authorization.VaultQuery``\n", 
               "sphinx_return_doc": "        :return: the returned ``VaultList``\n        :rtype: ``osid.authorization.VaultList``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``vault_query`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure\n        :raise: ``Unsupported`` -- ``vault_query`` is not of this service", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.authorization.VaultQuery", 
                     "var_name": "vault_query", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.authorization.VaultQuery"
               ], 
               "return_type": "osid.authorization.VaultList", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.authorization.VaultSearchSession", 
         "shortname": "VaultSearchSession", 
         "category": "sessions", 
         "doc": {
            "headline": "This session provides methods for searching among ``Vault`` objects.", 
            "body": "    The search query is constructed using the ``VaultQuery``.\n\n    ``get_vaults_by_query()`` is the basic search method and returns a\n    list of ``Vault`` objects.A more advanced search may be performed\n    with ``getVaultsBySearch()``. It accepts a ``VaultSearch`` in\n    addition to the query for the purpose of specifying additional\n    options affecting the entire search, such as ordering.\n    ``get_vaults_by_search()`` returns a ``VaultSearchResults`` that can\n    be used to access the resulting ``VaultList`` or be used to perform\n    a search within the result set through ``VaultSearch``.\n    \n    Vaults may have a query record indicated by their respective record\n    types. The query record is accessed via the ``VaultQuery``."
         }, 
         "inherit_fullnames": [
            "osid.authorization.VaultQuerySession"
         ], 
         "inherit_shortnames": [
            "VaultQuerySession"
         ], 
         "inherit_pkg_names": [
            "authorization"
         ], 
         "inheritance": [
            {
               "pkg_name": "authorization", 
               "name": "VaultQuerySession"
            }
         ], 
         "method_names": [
            "get_vault_search", 
            "get_vault_search_order", 
            "get_vaults_by_search", 
            "get_vault_query_from_inspector"
         ], 
         "methods": [
            {
               "name": "get_vault_search", 
               "doc": {
                  "headline": "Gets a vault search.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.authorization.VaultSearch) - a vault search", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: a vault search\n        :rtype: ``osid.authorization.VaultSearch``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.authorization.VaultSearch", 
               "errors": {}
            }, 
            {
               "name": "get_vault_search_order", 
               "doc": {
                  "headline": "Gets a vault search order.", 
                  "body": "        The ``VaultSearchOrder`` is supplied to a ``VaultSearch`` to\n        specify the ordering of results."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.authorization.VaultSearchOrder) - the vault search\n                order", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the vault search order\n        :rtype: ``osid.authorization.VaultSearchOrder``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.authorization.VaultSearchOrder", 
               "errors": {}
            }, 
            {
               "name": "get_vaults_by_search", 
               "doc": {
                  "headline": "Gets the search results matching the given search query using the given search.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    vault_query (osid.authorization.VaultQuery): the vault\n                query\n        arg:    vault_search (osid.authorization.VaultSearch): the vault\n                search\n", 
               "return_doc": "        return: (osid.authorization.VaultSearchResults) - the search\n                results", 
               "error_doc": "        raise:  NullArgument - ``vault_query`` or ``vault_search`` is\n                ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        raise:  Unsupported - ``vault_query`` or ``vault_search`` is not\n                of this service", 
               "sphinx_param_doc": "        :param vault_query: the vault query\n        :type vault_query: ``osid.authorization.VaultQuery``\n        :param vault_search: the vault search\n        :type vault_search: ``osid.authorization.VaultSearch``\n", 
               "sphinx_return_doc": "        :return: the search results\n        :rtype: ``osid.authorization.VaultSearchResults``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``vault_query`` or ``vault_search`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure\n        :raise: ``Unsupported`` -- ``vault_query`` or ``vault_search`` is not of this service", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.authorization.VaultQuery", 
                     "var_name": "vault_query", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.authorization.VaultSearch", 
                     "var_name": "vault_search", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.authorization.VaultQuery", 
                  "osid.authorization.VaultSearch"
               ], 
               "return_type": "osid.authorization.VaultSearchResults", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_vault_query_from_inspector", 
               "doc": {
                  "headline": "Gets a vault query from an inspector.", 
                  "body": "        The inspector is available from a ``VaultSearchResults``."
               }, 
               "arg_doc": "        arg:    vault_query_inspector\n                (osid.authorization.VaultQueryInspector): a vault query\n                inspector\n", 
               "return_doc": "        return: (osid.authorization.VaultQuery) - the vault query", 
               "error_doc": "        raise:  NullArgument - ``vault_query_inspector`` is ``null``\n        raise:  Unsupported - ``vault_query_inspector`` is not of this\n                service", 
               "sphinx_param_doc": "        :param vault_query_inspector: a vault query inspector\n        :type vault_query_inspector: ``osid.authorization.VaultQueryInspector``\n", 
               "sphinx_return_doc": "        :return: the vault query\n        :rtype: ``osid.authorization.VaultQuery``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``vault_query_inspector`` is ``null``\n        :raise: ``Unsupported`` -- ``vault_query_inspector`` is not of this service", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.authorization.VaultQueryInspector", 
                     "var_name": "vault_query_inspector", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.authorization.VaultQueryInspector"
               ], 
               "return_type": "osid.authorization.VaultQuery", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.authorization.VaultAdminSession", 
         "shortname": "VaultAdminSession", 
         "category": "sessions", 
         "doc": {
            "headline": "This session creates, updates, and deletes ``Vaults``.", 
            "body": "    The data for create and update is provided by the consumer via the\n    form object. ``OsidForms`` are requested for each create or update\n    and may not be reused.\n\n    Create and update operations differ in their usage. To create a\n    ``Vault,`` a ``VaultForm`` is requested using\n    ``get_vault_form_for_create()`` specifying the desired record\n    ``Types`` or none if no record ``Types`` are needed. The returned\n    ``VaultForm`` will indicate that it is to be used with a create\n    operation and can be used to examine metdata or validate data prior\n    to creation. Once the ``VaultForm`` is submiited to a create\n    operation, it cannot be reused with another create operation unless\n    the first operation was unsuccessful. Each ``VaultForm`` corresponds\n    to an attempted transaction.\n    \n    For updates, ``VaultForms`` are requested to the ``Vault``  ``Id``\n    that is to be updated using ``getVaultFormForUpdate()``. Similarly,\n    the ``VaultForm`` has metadata about the data that can be updated\n    and it can perform validation before submitting the update. The\n    ``VaultForm`` can only be used once for a successful update and\n    cannot be reused.\n    \n    The delete operations delete ``Vaults``. It is safer to remove all\n    mappings to the ``Vault`` catalogs before deletion.\n    \n    This session includes an ``Id`` aliasing mechanism to assign an\n    external ``Id`` to an internally assigned Id."
         }, 
         "inherit_fullnames": [
            "osid.OsidSession"
         ], 
         "inherit_shortnames": [
            "OsidSession"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidSession"
            }
         ], 
         "method_names": [
            "can_create_vaults", 
            "can_create_vault_with_record_types", 
            "get_vault_form_for_create", 
            "create_vault", 
            "can_update_vaults", 
            "get_vault_form_for_update", 
            "update_vault", 
            "can_delete_vaults", 
            "delete_vault", 
            "can_manage_vault_aliases", 
            "alias_vault"
         ], 
         "methods": [
            {
               "name": "can_create_vaults", 
               "doc": {
                  "headline": "Tests if this user can create ``Vaults``.", 
                  "body": "        A return of true does not guarantee successful authorization. A\n        return of false indicates that it is known creating a ``Vault``\n        will result in a ``PermissionDenied``. This is intended as a\n        hint to an application that may not wish to offer create\n        operations to unauthorized users."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``false`` if ``Vault`` creation is not\n                authorized, ``true`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``false`` if ``Vault`` creation is not authorized, ``true`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "can_create_vault_with_record_types", 
               "doc": {
                  "headline": "Tests if this user can create a single ``Vault`` using the desired record types.", 
                  "body": "        While ``AuthorizationManager.getVaultRecordTypes()`` can be used\n        to examine which records are supported, this method tests which\n        record(s) are required for creating a specific ``Vault``.\n        Providing an empty array tests if a ``Vault`` can be created\n        with no records."
               }, 
               "arg_doc": "        arg:    vault_record_types (osid.type.Type[]): array of vault\n                record types\n", 
               "return_doc": "        return: (boolean) - ``true`` if ``Vault`` creation using the\n                specified ``Types`` is supported, ``false`` otherwise", 
               "error_doc": "        raise:  NullArgument - ``vault_record_types`` is ``null``", 
               "sphinx_param_doc": "        :param vault_record_types: array of vault record types\n        :type vault_record_types: ``osid.type.Type[]``\n", 
               "sphinx_return_doc": "        :return: ``true`` if ``Vault`` creation using the specified ``Types`` is supported, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``vault_record_types`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type[]", 
                     "var_name": "vault_record_types", 
                     "array": true
                  }
               ], 
               "arg_types": [
                  "osid.type.Type[]"
               ], 
               "return_type": "boolean", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "get_vault_form_for_create", 
               "doc": {
                  "headline": "Gets the vault form for creating new vaults.", 
                  "body": "        A new form should be requested for each create transaction."
               }, 
               "arg_doc": "        arg:    vault_record_types (osid.type.Type[]): array of vault\n                record types\n", 
               "return_doc": "        return: (osid.authorization.VaultForm) - the vault form", 
               "error_doc": "        raise:  NullArgument - ``vault_record_types`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        raise:  Unsupported - unable to get form qith requested record\n                types", 
               "sphinx_param_doc": "        :param vault_record_types: array of vault record types\n        :type vault_record_types: ``osid.type.Type[]``\n", 
               "sphinx_return_doc": "        :return: the vault form\n        :rtype: ``osid.authorization.VaultForm``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``vault_record_types`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure\n        :raise: ``Unsupported`` -- unable to get form qith requested record types", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type[]", 
                     "var_name": "vault_record_types", 
                     "array": true
                  }
               ], 
               "arg_types": [
                  "osid.type.Type[]"
               ], 
               "return_type": "osid.authorization.VaultForm", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }, 
            {
               "name": "create_vault", 
               "doc": {
                  "headline": "Creates a new ``Vault``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    vault_form (osid.authorization.VaultForm): the form for\n                this ``Vault``\n", 
               "return_doc": "        return: (osid.authorization.Vault) - the new ``Vault``", 
               "error_doc": "        raise:  IllegalState - ``vault_form`` already used in a create\n                transaction\n        raise:  InvalidArgument - one or more of the form elements is\n                invalid\n        raise:  NullArgument - ``vault_form`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        raise:  Unsupported - ``vault_form`` did not originate from\n                ``get_vault_form_for_create()``", 
               "sphinx_param_doc": "        :param vault_form: the form for this ``Vault``\n        :type vault_form: ``osid.authorization.VaultForm``\n", 
               "sphinx_return_doc": "        :return: the new ``Vault``\n        :rtype: ``osid.authorization.Vault``", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- ``vault_form`` already used in a create transaction\n        :raise: ``InvalidArgument`` -- one or more of the form elements is invalid\n        :raise: ``NullArgument`` -- ``vault_form`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure\n        :raise: ``Unsupported`` -- ``vault_form`` did not originate from ``get_vault_form_for_create()``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.authorization.VaultForm", 
                     "var_name": "vault_form", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.authorization.VaultForm"
               ], 
               "return_type": "osid.authorization.Vault", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract", 
                  "INVALID_ARGUMENT": "ConsumerContract", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }, 
            {
               "name": "can_update_vaults", 
               "doc": {
                  "headline": "Tests if this user can update ``Vaults``.", 
                  "body": "        A return of true does not guarantee successful authorization. A\n        return of false indicates that it is known updating a ``Vault``\n        will result in a ``PermissionDenied``. This is intended as a\n        hint to an application that may not wish to offer update\n        operations to unauthorized users."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``false`` if ``Vault`` modification is not\n                authorized, ``true`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``false`` if ``Vault`` modification is not authorized, ``true`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "get_vault_form_for_update", 
               "doc": {
                  "headline": "Gets the vault form for updating an existing vault.", 
                  "body": "        A new vault form should be requested for each update\n        transaction."
               }, 
               "arg_doc": "        arg:    vault_id (osid.id.Id): the ``Id`` of the ``Vault``\n", 
               "return_doc": "        return: (osid.authorization.VaultForm) - the vault form", 
               "error_doc": "        raise:  NotFound - ``vault_id`` is not found\n        raise:  NullArgument - ``vault_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param vault_id: the ``Id`` of the ``Vault``\n        :type vault_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: the vault form\n        :rtype: ``osid.authorization.VaultForm``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``vault_id`` is not found\n        :raise: ``NullArgument`` -- ``vault_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "vault_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "osid.authorization.VaultForm", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "update_vault", 
               "doc": {
                  "headline": "Updates an existing vault.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    vault_form (osid.authorization.VaultForm): the form\n                containing the elements to be updated\n", 
               "return_doc": "", 
               "error_doc": "        raise:  IllegalState - ``vault_form`` already used in an update\n                transaction\n        raise:  InvalidArgument - the form contains an invalid value\n        raise:  NullArgument - ``vault_form`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        raise:  Unsupported - ``vault_form`` did not originate from\n                ``get_vault_form_for_update()``", 
               "sphinx_param_doc": "        :param vault_form: the form containing the elements to be updated\n        :type vault_form: ``osid.authorization.VaultForm``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- ``vault_form`` already used in an update transaction\n        :raise: ``InvalidArgument`` -- the form contains an invalid value\n        :raise: ``NullArgument`` -- ``vault_form`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure\n        :raise: ``Unsupported`` -- ``vault_form`` did not originate from ``get_vault_form_for_update()``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.authorization.VaultForm", 
                     "var_name": "vault_form", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.authorization.VaultForm"
               ], 
               "return_type": "", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract", 
                  "INVALID_ARGUMENT": "ConsumerContract", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }, 
            {
               "name": "can_delete_vaults", 
               "doc": {
                  "headline": "Tests if this user can delete vaults.", 
                  "body": "        A return of true does not guarantee successful authorization. A\n        return of false indicates that it is known deleting a ``Vault``\n        will result in a ``PermissionDenied``. This is intended as a\n        hint to an application that may not wish to offer delete\n        operations to unauthorized users."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``false`` if ``Vault`` deletion is not\n                authorized, ``true`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``false`` if ``Vault`` deletion is not authorized, ``true`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "delete_vault", 
               "doc": {
                  "headline": "Deletes a ``Vault``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    vault_id (osid.id.Id): the ``Id`` of the ``Vault`` to\n                remove\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NotFound - ``vault_id`` not found\n        raise:  NullArgument - ``vault_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param vault_id: the ``Id`` of the ``Vault`` to remove\n        :type vault_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``vault_id`` not found\n        :raise: ``NullArgument`` -- ``vault_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "vault_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "can_manage_vault_aliases", 
               "doc": {
                  "headline": "Tests if this user can manage ``Id`` aliases for ``Vaults``.", 
                  "body": "        A return of true does not guarantee successful authorization. A\n        return of false indicates that it is known changing an alias\n        will result in a ``PermissionDenied``. This is intended as a\n        hint to an application that may opt not to offer alias\n        operations to an unauthorized user."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``false`` if ``Vault`` aliasing is not\n                authorized, ``true`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``false`` if ``Vault`` aliasing is not authorized, ``true`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "alias_vault", 
               "doc": {
                  "headline": "Adds an ``Id`` to a ``Vault`` for the purpose of creating compatibility.", 
                  "body": "        The primary ``Id`` of the ``Vault`` is determined by the\n        provider. The new ``Id`` performs as an alias to the primary\n        ``Id``. If the alias is a pointer to another vault it is\n        reassigned to the given vault ``Id``."
               }, 
               "arg_doc": "        arg:    vault_id (osid.id.Id): the ``Id`` of a ``Vault``\n        arg:    alias_id (osid.id.Id): the alias ``Id``\n", 
               "return_doc": "", 
               "error_doc": "        raise:  AlreadyExists - ``alias_id`` is already assigned\n        raise:  NotFound - ``vault_id`` not found\n        raise:  NullArgument - ``vault_id`` or ``alias_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param vault_id: the ``Id`` of a ``Vault``\n        :type vault_id: ``osid.id.Id``\n        :param alias_id: the alias ``Id``\n        :type alias_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``AlreadyExists`` -- ``alias_id`` is already assigned\n        :raise: ``NotFound`` -- ``vault_id`` not found\n        :raise: ``NullArgument`` -- ``vault_id`` or ``alias_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "vault_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "alias_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {
                  "ALREADY_EXISTS": "User", 
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.authorization.VaultNotificationSession", 
         "shortname": "VaultNotificationSession", 
         "category": "sessions", 
         "doc": {
            "headline": "This session defines methods to receive notifications on adds/changes to ``Vault`` objects.", 
            "body": "    This session is intended for consumers needing to synchronize their\n    state with this service without the use of polling. Notifications\n    are cancelled when this session is closed."
         }, 
         "inherit_fullnames": [
            "osid.OsidSession"
         ], 
         "inherit_shortnames": [
            "OsidSession"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidSession"
            }
         ], 
         "method_names": [
            "can_register_for_vault_notifications", 
            "register_for_new_vaults", 
            "register_for_new_vault_ancestors", 
            "register_for_new_vault_descendants", 
            "register_for_changed_vaults", 
            "register_for_changed_vault", 
            "register_for_deleted_vaults", 
            "register_for_deleted_vault", 
            "register_for_deleted_vault_ancestors", 
            "register_for_deleted_vault_descendants"
         ], 
         "methods": [
            {
               "name": "can_register_for_vault_notifications", 
               "doc": {
                  "headline": "Tests if this user can register for ``Vault`` notifications.", 
                  "body": "        A return of true does not guarantee successful authorization. A\n        return of false indicates that it is known all methods in this\n        session will result in a ``PermissionDenied``. This is intended\n        as a hint to an application that may opt not to offer\n        notification operations."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``false`` if notification methods are not\n                authorized, ``true`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``false`` if notification methods are not authorized, ``true`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "register_for_new_vaults", 
               "doc": {
                  "headline": "Register for notifications of new vaults.", 
                  "body": "        ``VaultReceiver.newVault()`` is invoked when a new ``Vault`` is\n        created."
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "register_for_new_vault_ancestors", 
               "doc": {
                  "headline": "Registers for notification if an ancestor is added to the specified vault in the vault hierarchy.", 
                  "body": "        ``VaultReceiver.newVaultAncestor()`` is invoked when the\n        specified vault experiences an addition in ancestry."
               }, 
               "arg_doc": "        arg:    vault_id (osid.id.Id): the ``Id`` of the vault to\n                monitor\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``vault_id is null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param vault_id: the ``Id`` of the vault to monitor\n        :type vault_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``vault_id is null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "vault_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "register_for_new_vault_descendants", 
               "doc": {
                  "headline": "Registers for notification if a descendant is added to the specified vault in the vault hierarchy.", 
                  "body": "        ``VaultReceiver.newVaultDescendant()`` is invoked when the\n        specified vault experiences an addition in descendants."
               }, 
               "arg_doc": "        arg:    vault_id (osid.id.Id): the ``Id`` of the vault to\n                monitor\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``vault_id is null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param vault_id: the ``Id`` of the vault to monitor\n        :type vault_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``vault_id is null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "vault_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "register_for_changed_vaults", 
               "doc": {
                  "headline": "Registers for notification of updated vaults.", 
                  "body": "        ``VaultReceiver.changedVault()`` is invoked when a vault is\n        changed."
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "register_for_changed_vault", 
               "doc": {
                  "headline": "Registers for notification of an updated vault.", 
                  "body": "        ``VaultReceiver.changedVault()`` is invoked when the specified\n        vault is changed."
               }, 
               "arg_doc": "        arg:    vault_id (osid.id.Id): the Id of the vault to monitor\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``vault_id is null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param vault_id: the Id of the vault to monitor\n        :type vault_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``vault_id is null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "vault_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "register_for_deleted_vaults", 
               "doc": {
                  "headline": "Registers for notification of deleted vaults.", 
                  "body": "        ``VaultReceiver.deletedVault()`` is invoked when a vault is\n        deleted."
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "register_for_deleted_vault", 
               "doc": {
                  "headline": "Registers for notification of a deleted vault.", 
                  "body": "        ``VaultReceiver.deletedVault()`` is invoked when the specified\n        vault is deleted."
               }, 
               "arg_doc": "        arg:    vault_id (osid.id.Id): the Id of the vault to monitor\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``vault_id is null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param vault_id: the Id of the vault to monitor\n        :type vault_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``vault_id is null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "vault_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "register_for_deleted_vault_ancestors", 
               "doc": {
                  "headline": "Registers for notification if an ancestor is removed from the specified vault in the vault hierarchy.", 
                  "body": "        ``VaultReceiver.deletedVaultAncestor()`` is invoked when the\n        specified vault experiences a removal of an ancestor."
               }, 
               "arg_doc": "        arg:    vault_id (osid.id.Id): the Id of the vault to monitor\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``vault_id is null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param vault_id: the Id of the vault to monitor\n        :type vault_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``vault_id is null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "vault_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "register_for_deleted_vault_descendants", 
               "doc": {
                  "headline": "Registers for notification if a descendant is removed from fthe specified vault in the vault hierarchy.", 
                  "body": "        ``VaultReceiver.deletedVaultDescednant()`` is invoked when the\n        specified vault experiences a removal of one of its descendants."
               }, 
               "arg_doc": "        arg:    vault_id (osid.id.Id): the Id of the vault to monitor\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``vault_id is null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param vault_id: the Id of the vault to monitor\n        :type vault_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``vault_id is null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "vault_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.authorization.VaultHierarchySession", 
         "shortname": "VaultHierarchySession", 
         "category": "sessions", 
         "doc": {
            "headline": "This session defines methods for traversing a hierarchy of ``Vault`` objects.", 
            "body": "    Each node in the hierarchy is a unique ``Vault``. The hierarchy may\n    be traversed recursively to establish the tree structure through\n    ``get_parent_vaults()`` and ``getChildVaults()``. To relate these\n    ``Ids`` to another OSID, ``get_vault_nodes()`` can be used for\n    retrievals that can be used for bulk lookups in other OSIDs. Any\n    ``Vault`` available in the Authorization OSID is known to this\n    hierarchy but does not appear in the hierarchy traversal until added\n    as a root node or a child of another node.\n\n    A user may not be authorized to traverse the entire hierarchy. Parts\n    of the hierarchy may be made invisible through omission from the\n    returns of ``get_parent_vaults()`` or ``get_child_vaults()`` in lieu\n    of a ``PermissionDenied`` error that may disrupt the traversal\n    through authorized pathways.\n    \n    This session defines views that offer differing behaviors when\n    retrieving multiple objects.\n    \n      * comparative view: vault elements may be silently omitted or re-\n        ordered\n      * plenary view: provides a complete set or is an error condition\n"
         }, 
         "inherit_fullnames": [
            "osid.OsidSession"
         ], 
         "inherit_shortnames": [
            "OsidSession"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidSession"
            }
         ], 
         "method_names": [
            "get_vault_hierarchy_id", 
            "get_vault_hierarchy", 
            "can_access_vault_hierarchy", 
            "use_comparative_vault_view", 
            "use_plenary_vault_view", 
            "get_root_vault_ids", 
            "get_root_vaults", 
            "has_parent_vaults", 
            "is_parent_of_vault", 
            "get_parent_vault_ids", 
            "get_parent_vaults", 
            "is_ancestor_of_vault", 
            "has_child_vaults", 
            "is_child_of_vault", 
            "get_child_vault_ids", 
            "get_child_vaults", 
            "is_descendant_of_vault", 
            "get_vault_node_ids", 
            "get_vault_nodes"
         ], 
         "methods": [
            {
               "name": "get_vault_hierarchy_id", 
               "doc": {
                  "headline": "Gets the hierarchy ``Id`` associated with this session.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.id.Id) - the hierarchy ``Id`` associated with this\n                session", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the hierarchy ``Id`` associated with this session\n        :rtype: ``osid.id.Id``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.id.Id", 
               "errors": {}
            }, 
            {
               "name": "get_vault_hierarchy", 
               "doc": {
                  "headline": "Gets the hierarchy associated with this session.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.hierarchy.Hierarchy) - the hierarchy associated\n                with this session", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the hierarchy associated with this session\n        :rtype: ``osid.hierarchy.Hierarchy``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.hierarchy.Hierarchy", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "can_access_vault_hierarchy", 
               "doc": {
                  "headline": "Tests if this user can perform hierarchy queries.", 
                  "body": "        A return of true does not guarantee successful authorization. A\n        return of false indicates that it is known all methods in this\n        session will result in a ``PermissionDenied``. This is intended\n        as a hint to an application that may opt not to offer lookup\n        operations."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``false`` if hierarchy traversal methods are\n                not authorized, ``true`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``false`` if hierarchy traversal methods are not authorized, ``true`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "use_comparative_vault_view", 
               "doc": {
                  "headline": "The returns from the vault methods may omit or translate elements based on this session, such as authorization, and not result in an error.", 
                  "body": "        This view is used when greater interoperability is desired at\n        the expense of precision."
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "use_plenary_vault_view", 
               "doc": {
                  "headline": "A complete view of the ``Hierarchy`` returns is desired.", 
                  "body": "        Methods will return what is requested or result in an error.\n        This view is used when greater precision is desired at the\n        expense of interoperability."
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "get_root_vault_ids", 
               "doc": {
                  "headline": "Gets the root vault ``Ids`` in this hierarchy.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.id.IdList) - the root vault ``Ids``", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the root vault ``Ids``\n        :rtype: ``osid.id.IdList``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.id.IdList", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_root_vaults", 
               "doc": {
                  "headline": "Gets the root vaults in this vault hierarchy.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.authorization.VaultList) - the root vaults", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the root vaults\n        :rtype: ``osid.authorization.VaultList``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.authorization.VaultList", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "has_parent_vaults", 
               "doc": {
                  "headline": "Tests if the ``Vault`` has any parents.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    vault_id (osid.id.Id): a vault ``Id``\n", 
               "return_doc": "        return: (boolean) - ``true`` if the vault has parents, ``false``\n                otherwise", 
               "error_doc": "        raise:  NotFound - ``vault_id`` is not found\n        raise:  NullArgument - ``vault_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param vault_id: a vault ``Id``\n        :type vault_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: ``true`` if the vault has parents, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``vault_id`` is not found\n        :raise: ``NullArgument`` -- ``vault_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "vault_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "boolean", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "is_parent_of_vault", 
               "doc": {
                  "headline": "Tests if an ``Id`` is a direct parent of a vault.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    id (osid.id.Id): an ``Id``\n        arg:    vault_id (osid.id.Id): the ``Id`` of a vault\n", 
               "return_doc": "        return: (boolean) - ``true`` if this ``id`` is a parent of\n                ``vault_id,``  ``false`` otherwise", 
               "error_doc": "        raise:  NotFound - ``vault_id`` is not found\n        raise:  NullArgument - ``id`` or ``vault_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param id: an ``Id``\n        :type id: ``osid.id.Id``\n        :param vault_id: the ``Id`` of a vault\n        :type vault_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: ``true`` if this ``id`` is a parent of ``vault_id,``  ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``vault_id`` is not found\n        :raise: ``NullArgument`` -- ``id`` or ``vault_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "        *implementation notes*: If ``id`` not found return ``false``.\n", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "id_", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "vault_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "osid.id.Id"
               ], 
               "return_type": "boolean", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_parent_vault_ids", 
               "doc": {
                  "headline": "Gets the parent ``Ids`` of the given vault.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    vault_id (osid.id.Id): a vault ``Id``\n", 
               "return_doc": "        return: (osid.id.IdList) - the parent ``Ids`` of the vault", 
               "error_doc": "        raise:  NotFound - ``vault_id`` is not found\n        raise:  NullArgument - ``vault_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param vault_id: a vault ``Id``\n        :type vault_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: the parent ``Ids`` of the vault\n        :rtype: ``osid.id.IdList``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``vault_id`` is not found\n        :raise: ``NullArgument`` -- ``vault_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "vault_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "osid.id.IdList", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_parent_vaults", 
               "doc": {
                  "headline": "Gets the parents of the given vault.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    vault_id (osid.id.Id): a vault ``Id``\n", 
               "return_doc": "        return: (osid.authorization.VaultList) - the parents of the\n                vault", 
               "error_doc": "        raise:  NotFound - ``vault_id`` is not found\n        raise:  NullArgument - ``vault_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param vault_id: a vault ``Id``\n        :type vault_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: the parents of the vault\n        :rtype: ``osid.authorization.VaultList``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``vault_id`` is not found\n        :raise: ``NullArgument`` -- ``vault_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "vault_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "osid.authorization.VaultList", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "is_ancestor_of_vault", 
               "doc": {
                  "headline": "Tests if an ``Id`` is an ancestor of a vault.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    id (osid.id.Id): an ``Id``\n        arg:    vault_id (osid.id.Id): the ``Id`` of a vault\n", 
               "return_doc": "        return: (boolean) - ``true`` if this ``id`` is an ancestor of\n                ``vault_id,``  ``false`` otherwise", 
               "error_doc": "        raise:  NotFound - ``vault_id`` is not found\n        raise:  NullArgument - ``vault_id`` or ``id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param id: an ``Id``\n        :type id: ``osid.id.Id``\n        :param vault_id: the ``Id`` of a vault\n        :type vault_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: ``true`` if this ``id`` is an ancestor of ``vault_id,``  ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``vault_id`` is not found\n        :raise: ``NullArgument`` -- ``vault_id`` or ``id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "        *implementation notes*: If ``id`` not found return ``false``.\n", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "id_", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "vault_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "osid.id.Id"
               ], 
               "return_type": "boolean", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "has_child_vaults", 
               "doc": {
                  "headline": "Tests if a vault has any children.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    vault_id (osid.id.Id): a ``vault_id``\n", 
               "return_doc": "        return: (boolean) - ``true`` if the ``vault_id`` has children,\n                ``false`` otherwise", 
               "error_doc": "        raise:  NotFound - ``vault_id`` is not found\n        raise:  NullArgument - ``vault_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param vault_id: a ``vault_id``\n        :type vault_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: ``true`` if the ``vault_id`` has children, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``vault_id`` is not found\n        :raise: ``NullArgument`` -- ``vault_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "vault_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "boolean", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "is_child_of_vault", 
               "doc": {
                  "headline": "Tests if a vault is a direct child of another.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    id (osid.id.Id): an ``Id``\n        arg:    vault_id (osid.id.Id): the ``Id`` of a vault\n", 
               "return_doc": "        return: (boolean) - ``true`` if the ``id`` is a child of\n                ``vault_id,``  ``false`` otherwise", 
               "error_doc": "        raise:  NotFound - ``vault_id`` not found\n        raise:  NullArgument - ``vault_id`` or ``id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param id: an ``Id``\n        :type id: ``osid.id.Id``\n        :param vault_id: the ``Id`` of a vault\n        :type vault_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: ``true`` if the ``id`` is a child of ``vault_id,``  ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``vault_id`` not found\n        :raise: ``NullArgument`` -- ``vault_id`` or ``id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "        *implementation notes*: If ``id`` not found return ``false``.\n", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "id_", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "vault_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "osid.id.Id"
               ], 
               "return_type": "boolean", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_child_vault_ids", 
               "doc": {
                  "headline": "Gets the child ``Ids`` of the given vault.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    vault_id (osid.id.Id): the ``Id`` to query\n", 
               "return_doc": "        return: (osid.id.IdList) - the children of the vault", 
               "error_doc": "        raise:  NotFound - ``vault_id`` is not found\n        raise:  NullArgument - ``vault_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param vault_id: the ``Id`` to query\n        :type vault_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: the children of the vault\n        :rtype: ``osid.id.IdList``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``vault_id`` is not found\n        :raise: ``NullArgument`` -- ``vault_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "vault_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "osid.id.IdList", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_child_vaults", 
               "doc": {
                  "headline": "Gets the children of the given vault.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    vault_id (osid.id.Id): the ``Id`` to query\n", 
               "return_doc": "        return: (osid.authorization.VaultList) - the children of the\n                vault", 
               "error_doc": "        raise:  NotFound - ``vault_id`` is not found\n        raise:  NullArgument - ``vault_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param vault_id: the ``Id`` to query\n        :type vault_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: the children of the vault\n        :rtype: ``osid.authorization.VaultList``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``vault_id`` is not found\n        :raise: ``NullArgument`` -- ``vault_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "vault_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "osid.authorization.VaultList", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "is_descendant_of_vault", 
               "doc": {
                  "headline": "Tests if an ``Id`` is a descendant of a vault.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    id (osid.id.Id): an ``Id``\n        arg:    vault_id (osid.id.Id): the ``Id`` of a vault\n", 
               "return_doc": "        return: (boolean) - ``true`` if the ``id`` is a descendant of\n                the ``vault_id,``  ``false`` otherwise", 
               "error_doc": "        raise:  NotFound - ``vault_id`` not found\n        raise:  NullArgument - ``vault_id`` or ``id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param id: an ``Id``\n        :type id: ``osid.id.Id``\n        :param vault_id: the ``Id`` of a vault\n        :type vault_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: ``true`` if the ``id`` is a descendant of the ``vault_id,``  ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``vault_id`` not found\n        :raise: ``NullArgument`` -- ``vault_id`` or ``id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "        *implementation notes*: If ``id`` is not found return ``false``.\n", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "id_", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "vault_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "osid.id.Id"
               ], 
               "return_type": "boolean", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_vault_node_ids", 
               "doc": {
                  "headline": "Gets a portion of the hierarchy for the given vault.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    vault_id (osid.id.Id): the ``Id`` to query\n        arg:    ancestor_levels (cardinal): the maximum number of\n                ancestor levels to include. A value of 0 returns no\n                parents in the node.\n        arg:    descendant_levels (cardinal): the maximum number of\n                descendant levels to include. A value of 0 returns no\n                children in the node.\n        arg:    include_siblings (boolean): ``true`` to include the\n                siblings of the given node, ``false`` to omit the\n                siblings\n", 
               "return_doc": "        return: (osid.hierarchy.Node) - a vault node", 
               "error_doc": "        raise:  NotFound - ``vault_id`` is not found\n        raise:  NullArgument - ``vault_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param vault_id: the ``Id`` to query\n        :type vault_id: ``osid.id.Id``\n        :param ancestor_levels: the maximum number of ancestor levels to include. A value of 0 returns no parents in the node.\n        :type ancestor_levels: ``cardinal``\n        :param descendant_levels: the maximum number of descendant levels to include. A value of 0 returns no children in the node.\n        :type descendant_levels: ``cardinal``\n        :param include_siblings: ``true`` to include the siblings of the given node, ``false`` to omit the siblings\n        :type include_siblings: ``boolean``\n", 
               "sphinx_return_doc": "        :return: a vault node\n        :rtype: ``osid.hierarchy.Node``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``vault_id`` is not found\n        :raise: ``NullArgument`` -- ``vault_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "vault_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "cardinal", 
                     "var_name": "ancestor_levels", 
                     "array": false
                  }, 
                  {
                     "arg_type": "cardinal", 
                     "var_name": "descendant_levels", 
                     "array": false
                  }, 
                  {
                     "arg_type": "boolean", 
                     "var_name": "include_siblings", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "cardinal", 
                  "cardinal", 
                  "boolean"
               ], 
               "return_type": "osid.hierarchy.Node", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_vault_nodes", 
               "doc": {
                  "headline": "Gets a portion of the hierarchy for the given vault.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    vault_id (osid.id.Id): the ``Id`` to query\n        arg:    ancestor_levels (cardinal): the maximum number of\n                ancestor levels to include. A value of 0 returns no\n                parents in the node.\n        arg:    descendant_levels (cardinal): the maximum number of\n                descendant levels to include. A value of 0 returns no\n                children in the node.\n        arg:    include_siblings (boolean): ``true`` to include the\n                siblings of the given node, ``false`` to omit the\n                siblings\n", 
               "return_doc": "        return: (osid.authorization.VaultNode) - a vault node", 
               "error_doc": "        raise:  NotFound - ``vault_id`` is not found\n        raise:  NullArgument - ``vault_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param vault_id: the ``Id`` to query\n        :type vault_id: ``osid.id.Id``\n        :param ancestor_levels: the maximum number of ancestor levels to include. A value of 0 returns no parents in the node.\n        :type ancestor_levels: ``cardinal``\n        :param descendant_levels: the maximum number of descendant levels to include. A value of 0 returns no children in the node.\n        :type descendant_levels: ``cardinal``\n        :param include_siblings: ``true`` to include the siblings of the given node, ``false`` to omit the siblings\n        :type include_siblings: ``boolean``\n", 
               "sphinx_return_doc": "        :return: a vault node\n        :rtype: ``osid.authorization.VaultNode``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``vault_id`` is not found\n        :raise: ``NullArgument`` -- ``vault_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "vault_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "cardinal", 
                     "var_name": "ancestor_levels", 
                     "array": false
                  }, 
                  {
                     "arg_type": "cardinal", 
                     "var_name": "descendant_levels", 
                     "array": false
                  }, 
                  {
                     "arg_type": "boolean", 
                     "var_name": "include_siblings", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "cardinal", 
                  "cardinal", 
                  "boolean"
               ], 
               "return_type": "osid.authorization.VaultNode", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.authorization.VaultHierarchyDesignSession", 
         "shortname": "VaultHierarchyDesignSession", 
         "category": "sessions", 
         "doc": {
            "headline": "This session defines methods for managing a hierarchy of ``Vault`` objects.", 
            "body": "    Each node in the hierarchy is a unique ``Vault``."
         }, 
         "inherit_fullnames": [
            "osid.OsidSession"
         ], 
         "inherit_shortnames": [
            "OsidSession"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidSession"
            }
         ], 
         "method_names": [
            "get_vault_hierarchy_id", 
            "get_vault_hierarchy", 
            "can_modify_vault_hierarchy", 
            "add_root_vault", 
            "remove_root_vault", 
            "add_child_vault", 
            "remove_child_vault", 
            "remove_child_vaults"
         ], 
         "methods": [
            {
               "name": "get_vault_hierarchy_id", 
               "doc": {
                  "headline": "Gets the hierarchy ``Id`` associated with this session.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.id.Id) - the hierarchy ``Id`` associated with this\n                session", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the hierarchy ``Id`` associated with this session\n        :rtype: ``osid.id.Id``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.id.Id", 
               "errors": {}
            }, 
            {
               "name": "get_vault_hierarchy", 
               "doc": {
                  "headline": "Gets the hierarchy associated with this session.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.hierarchy.Hierarchy) - the hierarchy associated\n                with this session", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the hierarchy associated with this session\n        :rtype: ``osid.hierarchy.Hierarchy``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.hierarchy.Hierarchy", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "can_modify_vault_hierarchy", 
               "doc": {
                  "headline": "Tests if this user can change the hierarchy.", 
                  "body": "        A return of true does not guarantee successful authorization. A\n        return of false indicates that it is known performing any update\n        will result in a ``PermissionDenied``. This is intended as a\n        hint to an application that may opt not to offer these\n        operations to an unauthorized user."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``false`` if changing this hierarchy is not\n                authorized, ``true`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``false`` if changing this hierarchy is not authorized, ``true`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "add_root_vault", 
               "doc": {
                  "headline": "Adds a root vault.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    vault_id (osid.id.Id): the ``Id`` of a vault\n", 
               "return_doc": "", 
               "error_doc": "        raise:  AlreadyExists - ``vault_id`` is already in hierarchy\n        raise:  NotFound - ``vault_id`` not found\n        raise:  NullArgument - ``vault_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param vault_id: the ``Id`` of a vault\n        :type vault_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``AlreadyExists`` -- ``vault_id`` is already in hierarchy\n        :raise: ``NotFound`` -- ``vault_id`` not found\n        :raise: ``NullArgument`` -- ``vault_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "vault_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {
                  "ALREADY_EXISTS": "User", 
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "remove_root_vault", 
               "doc": {
                  "headline": "Removes a root vault from this hierarchy.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    vault_id (osid.id.Id): the ``Id`` of a vault\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NotFound - ``vault_id`` not a parent of ``child_id``\n        raise:  NullArgument - ``vault_id`` or ``child_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param vault_id: the ``Id`` of a vault\n        :type vault_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``vault_id`` not a parent of ``child_id``\n        :raise: ``NullArgument`` -- ``vault_id`` or ``child_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "vault_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "add_child_vault", 
               "doc": {
                  "headline": "Adds a child to a vault.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    vault_id (osid.id.Id): the ``Id`` of a vault\n        arg:    child_id (osid.id.Id): the ``Id`` of the new child\n", 
               "return_doc": "", 
               "error_doc": "        raise:  AlreadyExists - ``vault_id`` is already a parent of\n                ``child_id``\n        raise:  NotFound - ``vault_id`` or ``child_id`` not found\n        raise:  NullArgument - ``vault_id`` or ``child_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param vault_id: the ``Id`` of a vault\n        :type vault_id: ``osid.id.Id``\n        :param child_id: the ``Id`` of the new child\n        :type child_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``AlreadyExists`` -- ``vault_id`` is already a parent of ``child_id``\n        :raise: ``NotFound`` -- ``vault_id`` or ``child_id`` not found\n        :raise: ``NullArgument`` -- ``vault_id`` or ``child_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "vault_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "child_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {
                  "ALREADY_EXISTS": "User", 
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "remove_child_vault", 
               "doc": {
                  "headline": "Removes a child from a vault.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    vault_id (osid.id.Id): the ``Id`` of a vault\n        arg:    child_id (osid.id.Id): the ``Id`` of the child\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NotFound - ``vault_id`` not parent of ``child_id``\n        raise:  NullArgument - ``vault_id`` or ``child_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param vault_id: the ``Id`` of a vault\n        :type vault_id: ``osid.id.Id``\n        :param child_id: the ``Id`` of the child\n        :type child_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``vault_id`` not parent of ``child_id``\n        :raise: ``NullArgument`` -- ``vault_id`` or ``child_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "vault_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "child_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "remove_child_vaults", 
               "doc": {
                  "headline": "Removes all children from a vault.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    vault_id (osid.id.Id): the ``Id`` of a vault\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NotFound - ``vault_id`` is not in hierarchy\n        raise:  NullArgument - ``vault_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param vault_id: the ``Id`` of a vault\n        :type vault_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``vault_id`` is not in hierarchy\n        :raise: ``NullArgument`` -- ``vault_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "vault_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.authorization.Authorization", 
         "shortname": "Authorization", 
         "category": "objects", 
         "doc": {
            "headline": "An Authorization is a mapping among an actor, a ``Function`` and a ``Qualifier``.", 
            "body": "    This interface is not required for performing authorization checks\n    but is used for examining and managing authorizations.\n\n    The actor of an authorization may be specified in a variety of\n    forms.\n    \n      * ``Agent``\n      * ``Resource:`` the authorization provider uses all the ``Agents``\n        associated with a ``Resource`` for matching authorizations\n      * ``Resource`` and ``Trust:`` the authorization provider uses the\n        associated ``Agents`` within a cicle of ``Trust``\n\n    \n    An explicit ``Authorization`` represents the mappings as they are\n    specified in the authorization provdier. Implicit authorizations may\n    be retrieved which are authorizations inferred through the\n    ``Function`` or ``Qualifier`` hierarchies. An implicit\n    ``Authorization`` is one where ``is_implicit()`` is true and should\n    not be used for modification as it is only available for auditing\n    purposes.\n    \n    An ``Authorization`` containing a ``Resource`` may also provide the\n    associated Agent in a request for implicit authorizations or for all\n    the authorizations, both explicit and implicit, for a given\n    ``Agent``."
         }, 
         "inherit_fullnames": [
            "osid.OsidRelationship"
         ], 
         "inherit_shortnames": [
            "OsidRelationship"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidRelationship"
            }
         ], 
         "method_names": [
            "is_implicit", 
            "has_resource", 
            "get_resource_id", 
            "get_resource", 
            "has_trust", 
            "get_trust_id", 
            "get_trust", 
            "has_agent", 
            "get_agent_id", 
            "get_agent", 
            "get_function_id", 
            "get_function", 
            "get_qualifier_id", 
            "get_qualifier", 
            "get_authorization_record"
         ], 
         "methods": [
            {
               "name": "is_implicit", 
               "doc": {
                  "headline": "Tests if this authorization is implicit.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if this authorization is implicit,\n                ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if this authorization is implicit, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "has_resource", 
               "doc": {
                  "headline": "Tests if this authorization has a ``Resource``.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if this authorization has a\n                ``Resource,``  ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if this authorization has a ``Resource,``  ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "get_resource_id", 
               "doc": {
                  "headline": "Gets the ``resource _id`` for this authorization.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.id.Id) - the ``Resource Id``", 
               "error_doc": "        raise:  IllegalState - ``has_resource()`` is ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the ``Resource Id``\n        :rtype: ``osid.id.Id``", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- ``has_resource()`` is ``false``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.id.Id", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract"
               }
            }, 
            {
               "name": "get_resource", 
               "doc": {
                  "headline": "Gets the ``Resource`` for this authorization.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.resource.Resource) - the ``Resource``", 
               "error_doc": "        raise:  IllegalState - ``has_resource()`` is ``false``\n        raise:  OperationFailed - unable to complete request", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the ``Resource``\n        :rtype: ``osid.resource.Resource``", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- ``has_resource()`` is ``false``\n        :raise: ``OperationFailed`` -- unable to complete request", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.resource.Resource", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational"
               }
            }, 
            {
               "name": "has_trust", 
               "doc": {
                  "headline": "Tests if this authorization has a ``Trust``.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if this authorization has a\n                ``Trust,``  ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if this authorization has a ``Trust,``  ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "get_trust_id", 
               "doc": {
                  "headline": "Gets the ``Trust``  ``Id`` for this authorization.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.id.Id) - the trust ``Id``", 
               "error_doc": "        raise:  IllegalState - ``has_trust()`` is ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the trust ``Id``\n        :rtype: ``osid.id.Id``", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- ``has_trust()`` is ``false``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.id.Id", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract"
               }
            }, 
            {
               "name": "get_trust", 
               "doc": {
                  "headline": "Gets the ``Trust`` for this authorization.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.authentication.process.Trust) - the ``Trust``", 
               "error_doc": "        raise:  IllegalState - ``has_trust()`` is ``false``\n        raise:  OperationFailed - unable to complete request", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the ``Trust``\n        :rtype: ``osid.authentication.process.Trust``", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- ``has_trust()`` is ``false``\n        :raise: ``OperationFailed`` -- unable to complete request", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.authentication.process.Trust", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational"
               }
            }, 
            {
               "name": "has_agent", 
               "doc": {
                  "headline": "Tests if this authorization has an ``Agent``.", 
                  "body": "        An implied authorization may have an ``Agent`` in addition to a\n        specified ``Resource``."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if this authorization has an\n                ``Agent,``  ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if this authorization has an ``Agent,``  ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "get_agent_id", 
               "doc": {
                  "headline": "Gets the ``Agent Id`` for this authorization.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.id.Id) - the ``Agent Id``", 
               "error_doc": "        raise:  IllegalState - ``has_agent()`` is ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the ``Agent Id``\n        :rtype: ``osid.id.Id``", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- ``has_agent()`` is ``false``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.id.Id", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract"
               }
            }, 
            {
               "name": "get_agent", 
               "doc": {
                  "headline": "Gets the ``Agent`` for this authorization.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.authentication.Agent) - the ``Agent``", 
               "error_doc": "        raise:  IllegalState - ``has_agent()`` is ``false``\n        raise:  OperationFailed - unable to complete request", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the ``Agent``\n        :rtype: ``osid.authentication.Agent``", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- ``has_agent()`` is ``false``\n        :raise: ``OperationFailed`` -- unable to complete request", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.authentication.Agent", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational"
               }
            }, 
            {
               "name": "get_function_id", 
               "doc": {
                  "headline": "Gets the ``Function Id`` for this authorization.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.id.Id) - the function ``Id``", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the function ``Id``\n        :rtype: ``osid.id.Id``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.id.Id", 
               "errors": {}
            }, 
            {
               "name": "get_function", 
               "doc": {
                  "headline": "Gets the ``Function`` for this authorization.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.authorization.Function) - the function", 
               "error_doc": "        raise:  OperationFailed - unable to complete request", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the function\n        :rtype: ``osid.authorization.Function``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.authorization.Function", 
               "errors": {
                  "OPERATION_FAILED": "Operational"
               }
            }, 
            {
               "name": "get_qualifier_id", 
               "doc": {
                  "headline": "Gets the ``Qualifier Id`` for this authorization.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.id.Id) - the qualifier ``Id``", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the qualifier ``Id``\n        :rtype: ``osid.id.Id``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.id.Id", 
               "errors": {}
            }, 
            {
               "name": "get_qualifier", 
               "doc": {
                  "headline": "Gets the qualifier for this authorization.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.authorization.Qualifier) - the qualifier", 
               "error_doc": "        raise:  OperationFailed - unable to complete request", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the qualifier\n        :rtype: ``osid.authorization.Qualifier``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.authorization.Qualifier", 
               "errors": {
                  "OPERATION_FAILED": "Operational"
               }
            }, 
            {
               "name": "get_authorization_record", 
               "doc": {
                  "headline": "Gets the authorization record corresponding to the given ``Authorization`` record ``Type``.", 
                  "body": "        This method is used to retrieve an object implementing the\n        requested record. The ``authorization_record_type`` may be the\n        ``Type`` returned in ``get_record_types()`` or any of its\n        parents in a ``Type`` hierarchy where\n        ``has_record_type(authorization_record_type)`` is ``true`` ."
               }, 
               "arg_doc": "        arg:    authorization_record_type (osid.type.Type): the type of\n                the record to retrieve\n", 
               "return_doc": "        return: (osid.authorization.records.AuthorizationRecord) - the\n                authorization record", 
               "error_doc": "        raise:  NullArgument - ``authorization_record_type`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unsupported -\n                ``has_record_type(authorization_record_type)`` is\n                ``false``", 
               "sphinx_param_doc": "        :param authorization_record_type: the type of the record to retrieve\n        :type authorization_record_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "        :return: the authorization record\n        :rtype: ``osid.authorization.records.AuthorizationRecord``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``authorization_record_type`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unsupported`` -- ``has_record_type(authorization_record_type)`` is ``false``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "authorization_record_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "osid.authorization.records.AuthorizationRecord", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.authorization.records.AuthorizationRecord", 
         "shortname": "AuthorizationRecord", 
         "category": "records", 
         "doc": {
            "headline": "A record for an ``Authorization`` The methods specified by the record type are available through the underlying object.", 
            "body": ""
         }, 
         "inherit_fullnames": [
            "osid.OsidRecord"
         ], 
         "inherit_shortnames": [
            "OsidRecord"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidRecord"
            }
         ], 
         "method_names": [], 
         "methods": []
      }, 
      {
         "fullname": "osid.authorization.AuthorizationQuery", 
         "shortname": "AuthorizationQuery", 
         "category": "queries", 
         "doc": {
            "headline": "The query for authorizations.", 
            "body": ""
         }, 
         "inherit_fullnames": [
            "osid.OsidRelationshipQuery"
         ], 
         "inherit_shortnames": [
            "OsidRelationshipQuery"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidRelationshipQuery"
            }
         ], 
         "method_names": [
            "match_explicit_authorizations", 
            "clear_explicit_authorizations_terms", 
            "match_related_authorization_id", 
            "clear_related_authorization_id_terms", 
            "supports_related_authorization_query", 
            "get_related_authorization_query", 
            "clear_related_authorization_terms", 
            "match_resource_id", 
            "clear_resource_id_terms", 
            "supports_resource_query", 
            "get_resource_query", 
            "match_any_resource", 
            "clear_resource_terms", 
            "match_trust_id", 
            "match_any_trust_id", 
            "clear_trust_id_terms", 
            "match_agent_id", 
            "clear_agent_id_terms", 
            "supports_agent_query", 
            "get_agent_query", 
            "match_any_agent", 
            "clear_agent_terms", 
            "match_function_id", 
            "clear_function_id_terms", 
            "supports_function_query", 
            "get_function_query", 
            "clear_function_terms", 
            "match_qualifier_id", 
            "clear_qualifier_id_terms", 
            "supports_qualifier_query", 
            "get_qualifier_query", 
            "clear_qualifier_terms", 
            "match_vault_id", 
            "clear_vault_id_terms", 
            "supports_vault_query", 
            "get_vault_query", 
            "clear_vault_terms", 
            "get_authorization_query_record"
         ], 
         "methods": [
            {
               "name": "match_explicit_authorizations", 
               "doc": {
                  "headline": "Matches explciit authorizations.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    match (boolean): ``true`` to match explicit\n                authorizations, ``false`` to match implciit\n                authorizations\n", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "        :param match: ``true`` to match explicit authorizations, ``false`` to match implciit authorizations\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "clear_explicit_authorizations_terms", 
               "doc": {
                  "headline": "Clears the explicit authorization query terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "match_related_authorization_id", 
               "doc": {
                  "headline": "Adds an ``Id`` to match explicit or implicitly related authorizations depending on ``matchExplicitAuthorizations()``.", 
                  "body": "        Multiple ``Ids`` can be added to perform a boolean ``OR`` among\n        them."
               }, 
               "arg_doc": "        arg:    id (osid.id.Id): ``Id`` to match\n        arg:    match (boolean): ``true`` for a positive match,\n                ``false`` for a negative match\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``id`` is ``null``", 
               "sphinx_param_doc": "        :param id: ``Id`` to match\n        :type id: ``osid.id.Id``\n        :param match: ``true`` for a positive match, ``false`` for a negative match\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``id`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "id_", 
                     "array": false
                  }, 
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "clear_related_authorization_id_terms", 
               "doc": {
                  "headline": "Clears the related authorization ``Id`` query terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "supports_related_authorization_query", 
               "doc": {
                  "headline": "Tests if an ``AuthorizationQuery`` is available.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if an authorization query is\n                available, ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if an authorization query is available, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "get_related_authorization_query", 
               "doc": {
                  "headline": "Gets the authorization query.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    match (boolean): ``true`` if a positive match, ``false``\n                for a negative match\n", 
               "return_doc": "        return: (osid.authorization.AuthorizationQuery) - the\n                ``AuthorizationQuery``", 
               "error_doc": "        raise:  Unimplemented -\n                ``supports_related_authorization_query()`` is ``false``", 
               "sphinx_param_doc": "        :param match: ``true`` if a positive match, ``false`` for a negative match\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "        :return: the ``AuthorizationQuery``\n        :rtype: ``osid.authorization.AuthorizationQuery``", 
               "sphinx_error_doc": "        :raise: ``Unimplemented`` -- ``supports_related_authorization_query()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_related_authorization_query()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "boolean"
               ], 
               "return_type": "osid.authorization.AuthorizationQuery", 
               "errors": {
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "clear_related_authorization_terms", 
               "doc": {
                  "headline": "Clears the related authorization query terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "match_resource_id", 
               "doc": {
                  "headline": "Matches the resource identified by the given ``Id``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    resource_id (osid.id.Id): the ``Id`` of the ``Resource``\n        arg:    match (boolean): ``true`` if a positive match, ``false``\n                for a negative match\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``resource_id`` is ``null``", 
               "sphinx_param_doc": "        :param resource_id: the ``Id`` of the ``Resource``\n        :type resource_id: ``osid.id.Id``\n        :param match: ``true`` if a positive match, ``false`` for a negative match\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``resource_id`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "resource_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "clear_resource_id_terms", 
               "doc": {
                  "headline": "Clears the resource ``Id`` query terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "supports_resource_query", 
               "doc": {
                  "headline": "Tests if a ``ResourceQuery`` is available.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if a resource query is available,\n                ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if a resource query is available, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "get_resource_query", 
               "doc": {
                  "headline": "Gets the resource query.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    match (boolean): ``true`` if a positive match, ``false``\n                for a negative match\n", 
               "return_doc": "        return: (osid.resource.ResourceQuery) - the ``ResourceQuery``", 
               "error_doc": "        raise:  Unimplemented - ``supports_resource_query()`` is\n                ``false``", 
               "sphinx_param_doc": "        :param match: ``true`` if a positive match, ``false`` for a negative match\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "        :return: the ``ResourceQuery``\n        :rtype: ``osid.resource.ResourceQuery``", 
               "sphinx_error_doc": "        :raise: ``Unimplemented`` -- ``supports_resource_query()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_resource_query()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "boolean"
               ], 
               "return_type": "osid.resource.ResourceQuery", 
               "errors": {
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "match_any_resource", 
               "doc": {
                  "headline": "Matches authorizations that have any resource.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    match (boolean): ``true`` to match authorizations with\n                any resource, ``false`` to match authorizations with no\n                resource\n", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "        :param match: ``true`` to match authorizations with any resource, ``false`` to match authorizations with no resource\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "clear_resource_terms", 
               "doc": {
                  "headline": "Clears the resource query terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "match_trust_id", 
               "doc": {
                  "headline": "Matches the trust identified by the given ``Id``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    trust_id (osid.id.Id): the ``Id`` of the ``Trust``\n        arg:    match (boolean): ``true`` if a positive match, ``false``\n                for a negative match\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``trust_id`` is ``null``", 
               "sphinx_param_doc": "        :param trust_id: the ``Id`` of the ``Trust``\n        :type trust_id: ``osid.id.Id``\n        :param match: ``true`` if a positive match, ``false`` for a negative match\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``trust_id`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "trust_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "match_any_trust_id", 
               "doc": {
                  "headline": "Matches authorizations that have any trust defined.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    match (boolean): ``true`` to match authorizations with\n                any trust, ``false`` to match authorizations with no\n                trusts\n", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "        :param match: ``true`` to match authorizations with any trust, ``false`` to match authorizations with no trusts\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "clear_trust_id_terms", 
               "doc": {
                  "headline": "Clears the trust ``Id`` query terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "match_agent_id", 
               "doc": {
                  "headline": "Matches the agent identified by the given ``Id``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    agent_id (osid.id.Id): the Id of the ``Agent``\n        arg:    match (boolean): ``true`` if a positive match, ``false``\n                for a negative match\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``agent_id`` is ``null``", 
               "sphinx_param_doc": "        :param agent_id: the Id of the ``Agent``\n        :type agent_id: ``osid.id.Id``\n        :param match: ``true`` if a positive match, ``false`` for a negative match\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``agent_id`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "agent_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "clear_agent_id_terms", 
               "doc": {
                  "headline": "Clears the agent ``Id`` query terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "supports_agent_query", 
               "doc": {
                  "headline": "Tests if an ``AgentQuery`` is available.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if an agent query is available,\n                ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if an agent query is available, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "get_agent_query", 
               "doc": {
                  "headline": "Gets the agent query.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    match (boolean): ``true`` if a positive match, ``false``\n                for a negative match\n", 
               "return_doc": "        return: (osid.authentication.AgentQuery) - the ``AgentQuery``", 
               "error_doc": "        raise:  Unimplemented - ``supports_agent_query()`` is ``false``", 
               "sphinx_param_doc": "        :param match: ``true`` if a positive match, ``false`` for a negative match\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "        :return: the ``AgentQuery``\n        :rtype: ``osid.authentication.AgentQuery``", 
               "sphinx_error_doc": "        :raise: ``Unimplemented`` -- ``supports_agent_query()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_agent_query()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "boolean"
               ], 
               "return_type": "osid.authentication.AgentQuery", 
               "errors": {
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "match_any_agent", 
               "doc": {
                  "headline": "Matches authorizations that have any agent.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    match (boolean): ``true`` to match authorizations with\n                any agent, ``false`` to match authorizations with no\n                agent\n", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "        :param match: ``true`` to match authorizations with any agent, ``false`` to match authorizations with no agent\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "clear_agent_terms", 
               "doc": {
                  "headline": "Clears the agent query terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "match_function_id", 
               "doc": {
                  "headline": "Matches the function identified by the given ``Id``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    function_id (osid.id.Id): the Id of the ``Function``\n        arg:    match (boolean): ``true`` if a positive match, ``false``\n                for a negative match\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``function_id`` is ``null``", 
               "sphinx_param_doc": "        :param function_id: the Id of the ``Function``\n        :type function_id: ``osid.id.Id``\n        :param match: ``true`` if a positive match, ``false`` for a negative match\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``function_id`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "function_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "clear_function_id_terms", 
               "doc": {
                  "headline": "Clears the function ``Id`` query terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "supports_function_query", 
               "doc": {
                  "headline": "Tests if a ``FunctionQuery`` is available.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if a function query is available,\n                ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if a function query is available, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "get_function_query", 
               "doc": {
                  "headline": "Gets the function query.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    match (boolean): ``true`` if a positive match, ``false``\n                for a negative match\n", 
               "return_doc": "        return: (osid.authorization.FunctionQuery) - the\n                ``FunctinQuery``", 
               "error_doc": "        raise:  Unimplemented - ``supports_function_query()`` is\n                ``false``", 
               "sphinx_param_doc": "        :param match: ``true`` if a positive match, ``false`` for a negative match\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "        :return: the ``FunctinQuery``\n        :rtype: ``osid.authorization.FunctionQuery``", 
               "sphinx_error_doc": "        :raise: ``Unimplemented`` -- ``supports_function_query()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_function_query()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "boolean"
               ], 
               "return_type": "osid.authorization.FunctionQuery", 
               "errors": {
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "clear_function_terms", 
               "doc": {
                  "headline": "Clears the function query terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "match_qualifier_id", 
               "doc": {
                  "headline": "Matches the qualifier identified by the given ``Id``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    qualifier_id (osid.id.Id): the Id of the ``Qualifier``\n        arg:    match (boolean): ``true`` if a positive match, ``false``\n                for a negative match\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``qualifier_id`` is ``null``", 
               "sphinx_param_doc": "        :param qualifier_id: the Id of the ``Qualifier``\n        :type qualifier_id: ``osid.id.Id``\n        :param match: ``true`` if a positive match, ``false`` for a negative match\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``qualifier_id`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "qualifier_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "clear_qualifier_id_terms", 
               "doc": {
                  "headline": "Clears the qualifier ``Id`` query terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "supports_qualifier_query", 
               "doc": {
                  "headline": "Tests if a ``QualifierQuery`` is available.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if a qualifier query is available,\n                ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if a qualifier query is available, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "get_qualifier_query", 
               "doc": {
                  "headline": "Gets the qualiier query.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    match (boolean): ``true`` if a positive match, ``false``\n                for a negative match\n", 
               "return_doc": "        return: (osid.authorization.QualifierQuery) - the\n                ``QualifierQuery``", 
               "error_doc": "        raise:  Unimplemented - ``supports_qualifier_query()`` is\n                ``false``", 
               "sphinx_param_doc": "        :param match: ``true`` if a positive match, ``false`` for a negative match\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "        :return: the ``QualifierQuery``\n        :rtype: ``osid.authorization.QualifierQuery``", 
               "sphinx_error_doc": "        :raise: ``Unimplemented`` -- ``supports_qualifier_query()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_qualifier_query()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "boolean"
               ], 
               "return_type": "osid.authorization.QualifierQuery", 
               "errors": {
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "clear_qualifier_terms", 
               "doc": {
                  "headline": "Clears the qualifier query terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "match_vault_id", 
               "doc": {
                  "headline": "Sets the vault ``Id`` for this query.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    vault_id (osid.id.Id): a vault ``Id``\n        arg:    match (boolean): ``true`` for a positive match,\n                ``false`` for a negative match\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``vault_id`` is ``null``", 
               "sphinx_param_doc": "        :param vault_id: a vault ``Id``\n        :type vault_id: ``osid.id.Id``\n        :param match: ``true`` for a positive match, ``false`` for a negative match\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``vault_id`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "vault_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "clear_vault_id_terms", 
               "doc": {
                  "headline": "Clears the vault ``Id`` query terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "supports_vault_query", 
               "doc": {
                  "headline": "Tests if a ``VaultQuery`` is available.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if a vault query is available,\n                ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if a vault query is available, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "get_vault_query", 
               "doc": {
                  "headline": "Gets the query for a vault.", 
                  "body": "        Multiple retrievals produce a nested ``OR`` term."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.authorization.VaultQuery) - the vault query", 
               "error_doc": "        raise:  Unimplemented - ``supports_vault_query()`` is ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the vault query\n        :rtype: ``osid.authorization.VaultQuery``", 
               "sphinx_error_doc": "        :raise: ``Unimplemented`` -- ``supports_vault_query()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_vault_query()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.authorization.VaultQuery", 
               "errors": {
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "clear_vault_terms", 
               "doc": {
                  "headline": "Clears the vault query terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "get_authorization_query_record", 
               "doc": {
                  "headline": "Gets the authorization query record corresponding to the given ``Authorization`` record ``Type``.", 
                  "body": "        Multiple retrievals produce a nested ``OR`` term."
               }, 
               "arg_doc": "        arg:    authorization_record_type (osid.type.Type): an\n                authorization record type\n", 
               "return_doc": "        return: (osid.authorization.records.AuthorizationQueryRecord) -\n                the authorization query record", 
               "error_doc": "        raise:  NullArgument - ``authorization_record_type`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unsupported -\n                ``has_record_type(authorization_record_type)`` is\n                ``false``", 
               "sphinx_param_doc": "        :param authorization_record_type: an authorization record type\n        :type authorization_record_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "        :return: the authorization query record\n        :rtype: ``osid.authorization.records.AuthorizationQueryRecord``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``authorization_record_type`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unsupported`` -- ``has_record_type(authorization_record_type)`` is ``false``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "authorization_record_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "osid.authorization.records.AuthorizationQueryRecord", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.authorization.records.AuthorizationQueryRecord", 
         "shortname": "AuthorizationQueryRecord", 
         "category": "records", 
         "doc": {
            "headline": "A record for an ``AuthorizationQuery``.", 
            "body": "    The methods specified by the record type are available through the\n    underlying object."
         }, 
         "inherit_fullnames": [
            "osid.OsidRecord"
         ], 
         "inherit_shortnames": [
            "OsidRecord"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidRecord"
            }
         ], 
         "method_names": [], 
         "methods": []
      }, 
      {
         "fullname": "osid.authorization.AuthorizationQueryInspector", 
         "shortname": "AuthorizationQueryInspector", 
         "category": "query_inspectors", 
         "doc": {
            "headline": "The query inspector for examining authorization queries.", 
            "body": ""
         }, 
         "inherit_fullnames": [
            "osid.OsidRelationshipQueryInspector"
         ], 
         "inherit_shortnames": [
            "OsidRelationshipQueryInspector"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidRelationshipQueryInspector"
            }
         ], 
         "method_names": [
            "get_explicit_authorizations_terms", 
            "get_related_authorization_id_terms", 
            "get_related_authorization_terms", 
            "get_resource_id_terms", 
            "get_resource_terms", 
            "get_trust_id_terms", 
            "get_agent_id_terms", 
            "get_agent_terms", 
            "get_function_id_terms", 
            "get_function_terms", 
            "get_qualifier_id_terms", 
            "get_qualifier_terms", 
            "get_vault_id_terms", 
            "get_vault_terms", 
            "get_authorization_query_inspector_record"
         ], 
         "methods": [
            {
               "name": "get_explicit_authorizations_terms", 
               "doc": {
                  "headline": "Gets the explicit authorization query terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.search.terms.BooleanTerm) - the query terms", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the query terms\n        :rtype: ``osid.search.terms.BooleanTerm``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.search.terms.BooleanTerm", 
               "errors": {}
            }, 
            {
               "name": "get_related_authorization_id_terms", 
               "doc": {
                  "headline": "Gets the related authorization ``Id`` query terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.search.terms.IdTerm) - the query terms", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the query terms\n        :rtype: ``osid.search.terms.IdTerm``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.search.terms.IdTerm", 
               "errors": {}
            }, 
            {
               "name": "get_related_authorization_terms", 
               "doc": {
                  "headline": "Gets the related authorization query terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.authorization.AuthorizationQueryInspector) - the\n                query terms", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the query terms\n        :rtype: ``osid.authorization.AuthorizationQueryInspector``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.authorization.AuthorizationQueryInspector", 
               "errors": {}
            }, 
            {
               "name": "get_resource_id_terms", 
               "doc": {
                  "headline": "Gets the resource ``Id`` query terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.search.terms.IdTerm) - the query terms", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the query terms\n        :rtype: ``osid.search.terms.IdTerm``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.search.terms.IdTerm", 
               "errors": {}
            }, 
            {
               "name": "get_resource_terms", 
               "doc": {
                  "headline": "Gets the resource query terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.resource.ResourceQueryInspector) - the query terms", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the query terms\n        :rtype: ``osid.resource.ResourceQueryInspector``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.resource.ResourceQueryInspector", 
               "errors": {}
            }, 
            {
               "name": "get_trust_id_terms", 
               "doc": {
                  "headline": "Gets the trust ``Id`` query terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.search.terms.IdTerm) - the query terms", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the query terms\n        :rtype: ``osid.search.terms.IdTerm``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.search.terms.IdTerm", 
               "errors": {}
            }, 
            {
               "name": "get_agent_id_terms", 
               "doc": {
                  "headline": "Gets the agent ``Id`` query terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.search.terms.IdTerm) - the query terms", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the query terms\n        :rtype: ``osid.search.terms.IdTerm``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.search.terms.IdTerm", 
               "errors": {}
            }, 
            {
               "name": "get_agent_terms", 
               "doc": {
                  "headline": "Gets the agent query terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.authentication.AgentQueryInspector) - the query\n                terms", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the query terms\n        :rtype: ``osid.authentication.AgentQueryInspector``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.authentication.AgentQueryInspector", 
               "errors": {}
            }, 
            {
               "name": "get_function_id_terms", 
               "doc": {
                  "headline": "Gets the function ``Id`` query terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.search.terms.IdTerm) - the query terms", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the query terms\n        :rtype: ``osid.search.terms.IdTerm``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.search.terms.IdTerm", 
               "errors": {}
            }, 
            {
               "name": "get_function_terms", 
               "doc": {
                  "headline": "Gets the function query terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.authorization.FunctionQueryInspector) - the query\n                terms", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the query terms\n        :rtype: ``osid.authorization.FunctionQueryInspector``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.authorization.FunctionQueryInspector", 
               "errors": {}
            }, 
            {
               "name": "get_qualifier_id_terms", 
               "doc": {
                  "headline": "Gets the qualifier ``Id`` query terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.search.terms.IdTerm) - the query terms", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the query terms\n        :rtype: ``osid.search.terms.IdTerm``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.search.terms.IdTerm", 
               "errors": {}
            }, 
            {
               "name": "get_qualifier_terms", 
               "doc": {
                  "headline": "Gets the qualifier query terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.authorization.QualifierQueryInspector) - the query\n                terms", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the query terms\n        :rtype: ``osid.authorization.QualifierQueryInspector``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.authorization.QualifierQueryInspector", 
               "errors": {}
            }, 
            {
               "name": "get_vault_id_terms", 
               "doc": {
                  "headline": "Gets the vault ``Id`` query terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.search.terms.IdTerm) - the query terms", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the query terms\n        :rtype: ``osid.search.terms.IdTerm``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.search.terms.IdTerm", 
               "errors": {}
            }, 
            {
               "name": "get_vault_terms", 
               "doc": {
                  "headline": "Gets the vault query terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.authorization.VaultQueryInspector) - the query\n                terms", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the query terms\n        :rtype: ``osid.authorization.VaultQueryInspector``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.authorization.VaultQueryInspector", 
               "errors": {}
            }, 
            {
               "name": "get_authorization_query_inspector_record", 
               "doc": {
                  "headline": "Gets the authorization query inspector record corresponding to the given ``Authorization`` record ``Type``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    authorization_record_type (osid.type.Type): an\n                authorization record type\n", 
               "return_doc": "        return:\n                (osid.authorization.records.AuthorizationQueryInspectorR\n                ecord) - the authorization query inspector record", 
               "error_doc": "        raise:  NullArgument - ``authorization_record_type`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unsupported -\n                ``has_record_type(authorization_record_type)`` is\n                ``false``", 
               "sphinx_param_doc": "        :param authorization_record_type: an authorization record type\n        :type authorization_record_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "        :return: the authorization query inspector record\n        :rtype: ``osid.authorization.records.AuthorizationQueryInspectorRecord``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``authorization_record_type`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unsupported`` -- ``has_record_type(authorization_record_type)`` is ``false``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "authorization_record_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "osid.authorization.records.AuthorizationQueryInspectorRecord", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.authorization.records.AuthorizationQueryInspectorRecord", 
         "shortname": "AuthorizationQueryInspectorRecord", 
         "category": "records", 
         "doc": {
            "headline": "A record for an ``AuthorizationQueryInspector``.", 
            "body": "    The methods specified by the record type are available through the\n    underlying object."
         }, 
         "inherit_fullnames": [
            "osid.OsidRecord"
         ], 
         "inherit_shortnames": [
            "OsidRecord"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidRecord"
            }
         ], 
         "method_names": [], 
         "methods": []
      }, 
      {
         "fullname": "osid.authorization.AuthorizationForm", 
         "shortname": "AuthorizationForm", 
         "category": "objects", 
         "doc": {
            "headline": "This is the form for creating and updating ``Authorizations``.", 
            "body": "    Like all ``OsidForm`` objects, various data elements may be set here\n    for use in the create and update methods in the\n    ``AuthorizationAdminSession``. For each data element that may be\n    set, metadata may be examined to provide display hints or data\n    constraints."
         }, 
         "inherit_fullnames": [
            "osid.OsidRelationshipForm"
         ], 
         "inherit_shortnames": [
            "OsidRelationshipForm"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidRelationshipForm"
            }
         ], 
         "method_names": [
            "get_authorization_form_record"
         ], 
         "methods": [
            {
               "name": "get_authorization_form_record", 
               "doc": {
                  "headline": "Gets the ``AuthorizationFormRecord`` corresponding to the given authorization record ``Type``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    authorization_record_type (osid.type.Type): the\n                authorization record type\n", 
               "return_doc": "        return: (osid.authorization.records.AuthorizationFormRecord) -\n                the authorization form record", 
               "error_doc": "        raise:  NullArgument - ``authorization_record_type`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unsupported -\n                ``has_record_type(authorization_record_type)`` is\n                ``false``", 
               "sphinx_param_doc": "        :param authorization_record_type: the authorization record type\n        :type authorization_record_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "        :return: the authorization form record\n        :rtype: ``osid.authorization.records.AuthorizationFormRecord``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``authorization_record_type`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unsupported`` -- ``has_record_type(authorization_record_type)`` is ``false``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "authorization_record_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "osid.authorization.records.AuthorizationFormRecord", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.authorization.records.AuthorizationFormRecord", 
         "shortname": "AuthorizationFormRecord", 
         "category": "records", 
         "doc": {
            "headline": "A record for an ``AuthorizationForm``.", 
            "body": "    The methods specified by the record type are available through the\n    underlying object."
         }, 
         "inherit_fullnames": [
            "osid.OsidRecord"
         ], 
         "inherit_shortnames": [
            "OsidRecord"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidRecord"
            }
         ], 
         "method_names": [], 
         "methods": []
      }, 
      {
         "fullname": "osid.authorization.AuthorizationSearchOrder", 
         "shortname": "AuthorizationSearchOrder", 
         "category": "search_orders", 
         "doc": {
            "headline": "An interface for specifying the ordering of search results.", 
            "body": ""
         }, 
         "inherit_fullnames": [
            "osid.OsidRelationshipSearchOrder"
         ], 
         "inherit_shortnames": [
            "OsidRelationshipSearchOrder"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidRelationshipSearchOrder"
            }
         ], 
         "method_names": [
            "order_by_resource", 
            "supports_resource_search_order", 
            "get_resource_search_order", 
            "order_by_trust", 
            "order_by_agent", 
            "supports_agent_search_order", 
            "get_agent_search_order", 
            "order_by_function", 
            "supports_function_search_order", 
            "get_function_search_order", 
            "order_by_qualifier", 
            "supports_qualifier_search_order", 
            "get_qualifier_search_order", 
            "get_authorization_search_order_record"
         ], 
         "methods": [
            {
               "name": "order_by_resource", 
               "doc": {
                  "headline": "Specifies a preference for ordering the result set by the resource.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    style (osid.SearchOrderStyle): the search order style\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``style`` is ``null``", 
               "sphinx_param_doc": "        :param style: the search order style\n        :type style: ``osid.SearchOrderStyle``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``style`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.SearchOrderStyle", 
                     "var_name": "style", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.SearchOrderStyle"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "supports_resource_search_order", 
               "doc": {
                  "headline": "Tests if a ``Resource`` is available.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if a resource search order\n                interface is available, ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if a resource search order interface is available, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "get_resource_search_order", 
               "doc": {
                  "headline": "Gets the resource search order.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.resource.ResourceSearchOrder) - the resource\n                search order", 
               "error_doc": "        raise:  Unimplemented - ``supports_resource_search_order()`` is\n                ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the resource search order\n        :rtype: ``osid.resource.ResourceSearchOrder``", 
               "sphinx_error_doc": "        :raise: ``Unimplemented`` -- ``supports_resource_search_order()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_resource_search_order()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.resource.ResourceSearchOrder", 
               "errors": {
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "order_by_trust", 
               "doc": {
                  "headline": "Specifies a preference for ordering the result set by the trust.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    style (osid.SearchOrderStyle): the search order style\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``style`` is ``null``", 
               "sphinx_param_doc": "        :param style: the search order style\n        :type style: ``osid.SearchOrderStyle``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``style`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.SearchOrderStyle", 
                     "var_name": "style", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.SearchOrderStyle"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "order_by_agent", 
               "doc": {
                  "headline": "Specifies a preference for ordering the result set by the agent.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    style (osid.SearchOrderStyle): the search order style\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``style`` is ``null``", 
               "sphinx_param_doc": "        :param style: the search order style\n        :type style: ``osid.SearchOrderStyle``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``style`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.SearchOrderStyle", 
                     "var_name": "style", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.SearchOrderStyle"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "supports_agent_search_order", 
               "doc": {
                  "headline": "Tests if an ``Agent`` is available.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if an agent search order interface\n                is available, ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if an agent search order interface is available, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "get_agent_search_order", 
               "doc": {
                  "headline": "Gets the agent search order.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.authentication.AgentSearchOrder) - the agent\n                search order", 
               "error_doc": "        raise:  Unimplemented - ``supports_agent_search_order()`` is\n                ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the agent search order\n        :rtype: ``osid.authentication.AgentSearchOrder``", 
               "sphinx_error_doc": "        :raise: ``Unimplemented`` -- ``supports_agent_search_order()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_agent_search_order()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.authentication.AgentSearchOrder", 
               "errors": {
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "order_by_function", 
               "doc": {
                  "headline": "Specifies a preference for ordering the result set by the active status.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    style (osid.SearchOrderStyle): the search order style\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``style`` is ``null``", 
               "sphinx_param_doc": "        :param style: the search order style\n        :type style: ``osid.SearchOrderStyle``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``style`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.SearchOrderStyle", 
                     "var_name": "style", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.SearchOrderStyle"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "supports_function_search_order", 
               "doc": {
                  "headline": "Tests if a ``Function`` is available.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if a function search order\n                interface is available, ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if a function search order interface is available, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "get_function_search_order", 
               "doc": {
                  "headline": "Gets the function search order.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.authorization.FunctionSearchOrder) - the function\n                search order", 
               "error_doc": "        raise:  Unimplemented - ``supports_function_search_order()`` is\n                ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the function search order\n        :rtype: ``osid.authorization.FunctionSearchOrder``", 
               "sphinx_error_doc": "        :raise: ``Unimplemented`` -- ``supports_function_search_order()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_qualifier_search_order()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.authorization.FunctionSearchOrder", 
               "errors": {
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "order_by_qualifier", 
               "doc": {
                  "headline": "Specifies a preference for ordering the result set by the qualifier,.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    style (osid.SearchOrderStyle): the search order style\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``style`` is ``null``", 
               "sphinx_param_doc": "        :param style: the search order style\n        :type style: ``osid.SearchOrderStyle``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``style`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.SearchOrderStyle", 
                     "var_name": "style", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.SearchOrderStyle"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "supports_qualifier_search_order", 
               "doc": {
                  "headline": "Tests if a ``Qualifier`` is available.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if a qualifier search order\n                interface is available, ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if a qualifier search order interface is available, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "get_qualifier_search_order", 
               "doc": {
                  "headline": "Gets the qualifier search order.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.authorization.QualifierSearchOrder) - the\n                qualifier search order", 
               "error_doc": "        raise:  Unimplemented - ``supports_qualifier_search_order()`` is\n                ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the qualifier search order\n        :rtype: ``osid.authorization.QualifierSearchOrder``", 
               "sphinx_error_doc": "        :raise: ``Unimplemented`` -- ``supports_qualifier_search_order()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_qualifier_search_order()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.authorization.QualifierSearchOrder", 
               "errors": {
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_authorization_search_order_record", 
               "doc": {
                  "headline": "Gets the authorization search order record corresponding to the given function record ``Type``.", 
                  "body": "        Multiple retrievals return the same underlying object."
               }, 
               "arg_doc": "        arg:    authorization_record_type (osid.type.Type): an\n                authorization record type\n", 
               "return_doc": "        return:\n                (osid.authorization.records.AuthorizationSearchOrderReco\n                rd) - the authorization search order record", 
               "error_doc": "        raise:  NullArgument - ``authorization_record_type`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unsupported -\n                ``has_record_type(authorization_record_type)`` is\n                ``false``", 
               "sphinx_param_doc": "        :param authorization_record_type: an authorization record type\n        :type authorization_record_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "        :return: the authorization search order record\n        :rtype: ``osid.authorization.records.AuthorizationSearchOrderRecord``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``authorization_record_type`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unsupported`` -- ``has_record_type(authorization_record_type)`` is ``false``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "authorization_record_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "osid.authorization.records.AuthorizationSearchOrderRecord", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.authorization.records.AuthorizationSearchOrderRecord", 
         "shortname": "AuthorizationSearchOrderRecord", 
         "category": "records", 
         "doc": {
            "headline": "A record for an ``AuthorizationSearchOrder``.", 
            "body": "    The methods specified by the record type are available through the\n    underlying object."
         }, 
         "inherit_fullnames": [
            "osid.OsidRecord"
         ], 
         "inherit_shortnames": [
            "OsidRecord"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidRecord"
            }
         ], 
         "method_names": [], 
         "methods": []
      }, 
      {
         "fullname": "osid.authorization.AuthorizationSearch", 
         "shortname": "AuthorizationSearch", 
         "category": "searches", 
         "doc": {
            "headline": "``AuthorizationSearch`` defines the interface for specifying authorization search options.", 
            "body": ""
         }, 
         "inherit_fullnames": [
            "osid.OsidSearch"
         ], 
         "inherit_shortnames": [
            "OsidSearch"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidSearch"
            }
         ], 
         "method_names": [
            "search_among_authorizations", 
            "order_authorization_results", 
            "get_authorization_search_record"
         ], 
         "methods": [
            {
               "name": "search_among_authorizations", 
               "doc": {
                  "headline": "Execute this search among the given list of authorizations.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    authorization_ids (osid.id.IdList): list of\n                authorizations\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``authorization_ids`` is ``null``", 
               "sphinx_param_doc": "        :param authorization_ids: list of authorizations\n        :type authorization_ids: ``osid.id.IdList``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``authorization_ids`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.IdList", 
                     "var_name": "authorization_ids", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.IdList"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "order_authorization_results", 
               "doc": {
                  "headline": "Specify an ordering to the search results.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    authorization_search_order\n                (osid.authorization.AuthorizationSearchOrder):\n                authorization search order\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``authorization_search_order`` is\n                ``null``\n        raise:  Unsupported - ``authorization_search_order`` is not of\n                this service", 
               "sphinx_param_doc": "        :param authorization_search_order: authorization search order\n        :type authorization_search_order: ``osid.authorization.AuthorizationSearchOrder``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``authorization_search_order`` is ``null``\n        :raise: ``Unsupported`` -- ``authorization_search_order`` is not of this service", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.authorization.AuthorizationSearchOrder", 
                     "var_name": "authorization_search_order", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.authorization.AuthorizationSearchOrder"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_authorization_search_record", 
               "doc": {
                  "headline": "Gets the authorization search record corresponding to the given authorization search record ``Type``.", 
                  "body": "        This method is used to retrieve an object implementing the\n        requested record."
               }, 
               "arg_doc": "        arg:    authorization_search_record_type (osid.type.Type): an\n                authorization search record type\n", 
               "return_doc": "        return: (osid.authorization.records.AuthorizationSearchRecord) -\n                the authorization search record", 
               "error_doc": "        raise:  NullArgument - ``authorization_search_record_type`` is\n                ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unsupported -\n                ``has_record_type(authorization_search_record_type)`` is\n                ``false``", 
               "sphinx_param_doc": "        :param authorization_search_record_type: an authorization search record type\n        :type authorization_search_record_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "        :return: the authorization search record\n        :rtype: ``osid.authorization.records.AuthorizationSearchRecord``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``authorization_search_record_type`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unsupported`` -- ``has_record_type(authorization_search_record_type)`` is ``false``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "authorization_search_record_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "osid.authorization.records.AuthorizationSearchRecord", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.authorization.records.AuthorizationSearchRecord", 
         "shortname": "AuthorizationSearchRecord", 
         "category": "records", 
         "doc": {
            "headline": "A record for an ``AuthorizationSearch``.", 
            "body": "    The methods specified by the record type are available through the\n    underlying object."
         }, 
         "inherit_fullnames": [
            "osid.OsidRecord"
         ], 
         "inherit_shortnames": [
            "OsidRecord"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidRecord"
            }
         ], 
         "method_names": [], 
         "methods": []
      }, 
      {
         "fullname": "osid.authorization.AuthorizationSearchResults", 
         "shortname": "AuthorizationSearchResults", 
         "category": "searches", 
         "doc": {
            "headline": "This interface provides a means to capture results of a search.", 
            "body": ""
         }, 
         "inherit_fullnames": [
            "osid.OsidSearchResults"
         ], 
         "inherit_shortnames": [
            "OsidSearchResults"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidSearchResults"
            }
         ], 
         "method_names": [
            "get_authorizations", 
            "get_authorization_query_inspector", 
            "get_authorization_search_results_record"
         ], 
         "methods": [
            {
               "name": "get_authorizations", 
               "doc": {
                  "headline": "Gets the authorization list resulting from the search.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.authorization.AuthorizationList) - the\n                authorization list", 
               "error_doc": "        raise:  IllegalState - list has already been retrieved", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the authorization list\n        :rtype: ``osid.authorization.AuthorizationList``", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- list has already been retrieved", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.authorization.AuthorizationList", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract"
               }
            }, 
            {
               "name": "get_authorization_query_inspector", 
               "doc": {
                  "headline": "Gets the inspector for the query to examine the terms used in the search.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.authorization.AuthorizationQueryInspector) - the\n                query inspector", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the query inspector\n        :rtype: ``osid.authorization.AuthorizationQueryInspector``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.authorization.AuthorizationQueryInspector", 
               "errors": {}
            }, 
            {
               "name": "get_authorization_search_results_record", 
               "doc": {
                  "headline": "Gets the authorization search results record corresponding to the given authorization search record ``Type``.", 
                  "body": "        This method is used to retrieve an object implementing the\n        requested record."
               }, 
               "arg_doc": "        arg:    authorization_search_record_type (osid.type.Type): an\n                authorization search record type\n", 
               "return_doc": "        return:\n                (osid.authorization.records.AuthorizationSearchResultsRe\n                cord) - the authorization search results record", 
               "error_doc": "        raise:  NullArgument - ``authorization_search_record_type`` is\n                ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unsupported -\n                ``has_record_type(authorization_search_record_type)`` is\n                ``false``", 
               "sphinx_param_doc": "        :param authorization_search_record_type: an authorization search record type\n        :type authorization_search_record_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "        :return: the authorization search results record\n        :rtype: ``osid.authorization.records.AuthorizationSearchResultsRecord``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``authorization_search_record_type`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unsupported`` -- ``has_record_type(authorization_search_record_type)`` is ``false``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "authorization_search_record_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "osid.authorization.records.AuthorizationSearchResultsRecord", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.authorization.records.AuthorizationSearchResultsRecord", 
         "shortname": "AuthorizationSearchResultsRecord", 
         "category": "records", 
         "doc": {
            "headline": "A record for an ``AuthorizationSearchResults``.", 
            "body": "    The methods specified by the record type are available through the\n    underlying object."
         }, 
         "inherit_fullnames": [
            "osid.OsidRecord"
         ], 
         "inherit_shortnames": [
            "OsidRecord"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidRecord"
            }
         ], 
         "method_names": [], 
         "methods": []
      }, 
      {
         "fullname": "osid.authorization.AuthorizationReceiver", 
         "shortname": "AuthorizationReceiver", 
         "category": "receivers", 
         "doc": {
            "headline": "The authorization receiver is the consumer supplied interface for receiving notifications pertaining to new, updated or deleted ``Authorizations``.", 
            "body": ""
         }, 
         "inherit_fullnames": [
            "osid.OsidReceiver"
         ], 
         "inherit_shortnames": [
            "OsidReceiver"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidReceiver"
            }
         ], 
         "method_names": [
            "new_authorization", 
            "changed_authorization", 
            "deleted_authorization"
         ], 
         "methods": [
            {
               "name": "new_authorization", 
               "doc": {
                  "headline": "The callback for notifications of new authorizations.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    authorization_id (osid.id.Id): the Id of the new\n                ``Authorization``\n", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "        :param authorization_id: the Id of the new ``Authorization``\n        :type authorization_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "authorization_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "changed_authorization", 
               "doc": {
                  "headline": "The callback for notification of updated authorization.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    authorization_id (osid.id.Id): the Id of the updated\n                ``Authorization``\n", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "        :param authorization_id: the Id of the updated ``Authorization``\n        :type authorization_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "authorization_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "deleted_authorization", 
               "doc": {
                  "headline": "The callback for notification of deleted authorizations.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    authorization_id (osid.id.Id): the Id of the deleted\n                ``Authorization``\n", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "        :param authorization_id: the Id of the deleted ``Authorization``\n        :type authorization_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "authorization_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {}
            }
         ]
      }, 
      {
         "fullname": "osid.authorization.AuthorizationList", 
         "shortname": "AuthorizationList", 
         "category": "objects", 
         "doc": {
            "headline": "Like all ``OsidLists,``  ``AuthorizationList`` provides a means for accessing ``Authorization`` elements sequentially either one at a time or many at a time.", 
            "body": "    Examples: while (al.hasNext()) { Authorization authorization =\n    al.getNextAuthorization(); }\n\n    or\n      while (al.hasNext()) {\n           Authorization[] authorizations = al.getNextAuthorizations(al.available());\n      }\n    \n"
         }, 
         "inherit_fullnames": [
            "osid.OsidList"
         ], 
         "inherit_shortnames": [
            "OsidList"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidList"
            }
         ], 
         "method_names": [
            "get_next_authorization", 
            "get_next_authorizations"
         ], 
         "methods": [
            {
               "name": "get_next_authorization", 
               "doc": {
                  "headline": "Gets the next ``Authorization`` in this list.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.authorization.Authorization) - the next\n                ``Authorization`` in this list. The ``has_next()``\n                method should be used to test that a next\n                ``Authorization`` is available before calling this\n                method.", 
               "error_doc": "        raise:  IllegalState - no more elements available in this list\n        raise:  OperationFailed - unable to complete request", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the next ``Authorization`` in this list. The ``has_next()`` method should be used to test that a next ``Authorization`` is available before calling this method.\n        :rtype: ``osid.authorization.Authorization``", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- no more elements available in this list\n        :raise: ``OperationFailed`` -- unable to complete request", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.authorization.Authorization", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational"
               }
            }, 
            {
               "name": "get_next_authorizations", 
               "doc": {
                  "headline": "Gets the next set of ``Authorization`` elements in this list which must be less than or equal to the number returned from ``available()``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    n (cardinal): the number of ``Authorization`` elements\n                requested which should be less than or equal to\n                ``available()``\n", 
               "return_doc": "        return: (osid.authorization.Authorization) - an array of\n                ``Authorization`` elements.The length of the array is\n                less than or equal to the number specified.", 
               "error_doc": "        raise:  IllegalState - no more elements available in this list\n        raise:  OperationFailed - unable to complete request", 
               "sphinx_param_doc": "        :param n: the number of ``Authorization`` elements requested which should be less than or equal to ``available()``\n        :type n: ``cardinal``\n", 
               "sphinx_return_doc": "        :return: an array of ``Authorization`` elements.The length of the array is less than or equal to the number specified.\n        :rtype: ``osid.authorization.Authorization``", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- no more elements available in this list\n        :raise: ``OperationFailed`` -- unable to complete request", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "cardinal", 
                     "var_name": "n", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "cardinal"
               ], 
               "return_type": "osid.authorization.Authorization", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.authorization.AuthorizationCondition", 
         "shortname": "AuthorizationCondition", 
         "category": "rules", 
         "doc": {
            "headline": "An authorization condition interface.", 
            "body": ""
         }, 
         "inherit_fullnames": [
            "osid.OsidCondition"
         ], 
         "inherit_shortnames": [
            "OsidCondition"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidCondition"
            }
         ], 
         "method_names": [
            "get_authorization_condition_record"
         ], 
         "methods": [
            {
               "name": "get_authorization_condition_record", 
               "doc": {
                  "headline": "Gets the authorization condition record corresponding to the given ``AuthorizationCondition`` record ``Type``.", 
                  "body": "        This method is used to retrieve an object implementing the\n        requested record. The ``authorization_condition_record_type``\n        may be the ``Type`` returned in ``get_condition_record_types()``\n        or any of its parents in a ``Type`` hierarchy where\n        ``has_condition_record_typ\n        e(authorization_condition_record_type)`` is ``true`` ."
               }, 
               "arg_doc": "        arg:    authorization_condition_record_type (osid.type.Type): an\n                authorization condition record type\n", 
               "return_doc": "        return:\n                (osid.authorization.records.AuthorizationConditionRecord\n                ) - the authorization condition record", 
               "error_doc": "        raise:  NullArgument - ``authorization_condition_record_type``\n                is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unsupported -\n                ``has_record_type(authorization_condition_record_type)``\n                is ``false``", 
               "sphinx_param_doc": "        :param authorization_condition_record_type: an authorization condition record type\n        :type authorization_condition_record_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "        :return: the authorization condition record\n        :rtype: ``osid.authorization.records.AuthorizationConditionRecord``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``authorization_condition_record_type`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unsupported`` -- ``has_record_type(authorization_condition_record_type)`` is ``false``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "authorization_condition_record_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "osid.authorization.records.AuthorizationConditionRecord", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.authorization.records.AuthorizationConditionRecord", 
         "shortname": "AuthorizationConditionRecord", 
         "category": "records", 
         "doc": {
            "headline": "A record for an ``AuthorizationCondition``.", 
            "body": "    The methods specified by the record type are available through the\n    underlying object."
         }, 
         "inherit_fullnames": [
            "osid.OsidRecord"
         ], 
         "inherit_shortnames": [
            "OsidRecord"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidRecord"
            }
         ], 
         "method_names": [], 
         "methods": []
      }, 
      {
         "fullname": "osid.authorization.Function", 
         "shortname": "Function", 
         "category": "objects", 
         "doc": {
            "headline": "A ``Function`` represents an authenticatable identity.", 
            "body": "    Like all OSID objects, a ``Function`` is identified by its ``Id``\n    and any persisted references should use the ``Id``. A rule\n    associated with the ``Function`` specifies conditions that can be\n    supplied to authorization checks."
         }, 
         "inherit_fullnames": [
            "osid.OsidRule"
         ], 
         "inherit_shortnames": [
            "OsidRule"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidRule"
            }
         ], 
         "method_names": [
            "get_qualifier_hierarchy_id", 
            "get_qualifier_hierarchy", 
            "get_function_record"
         ], 
         "methods": [
            {
               "name": "get_qualifier_hierarchy_id", 
               "doc": {
                  "headline": "Gets the qualifier hierarchy ``Id`` for this function.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.id.Id) - the qualifier hierarchy ``Id``", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the qualifier hierarchy ``Id``\n        :rtype: ``osid.id.Id``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.id.Id", 
               "errors": {}
            }, 
            {
               "name": "get_qualifier_hierarchy", 
               "doc": {
                  "headline": "Gets the qualifier hierarchy for this function.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.hierarchy.Hierarchy) - the qualifier hierarchy", 
               "error_doc": "        raise:  OperationFailed - unable to complete request", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the qualifier hierarchy\n        :rtype: ``osid.hierarchy.Hierarchy``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.hierarchy.Hierarchy", 
               "errors": {
                  "OPERATION_FAILED": "Operational"
               }
            }, 
            {
               "name": "get_function_record", 
               "doc": {
                  "headline": "Gets the function record corresponding to the given ``Function`` record ``Type``.", 
                  "body": "        This method is used to retrieve an object implementing the\n        requested record. The ``function_record_type`` may be the\n        ``Type`` returned in ``get_record_types()`` or any of its\n        parents in a ``Type`` hierarchy where\n        ``has_record_type(function_record_type)`` is ``true`` ."
               }, 
               "arg_doc": "        arg:    function_record_type (osid.type.Type): the type of the\n                record to retrieve\n", 
               "return_doc": "        return: (osid.authorization.records.FunctionRecord) - the\n                function record", 
               "error_doc": "        raise:  NullArgument - ``function_record_type`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unsupported - ``has_record_type(function_record_type)``\n                is ``false``", 
               "sphinx_param_doc": "        :param function_record_type: the type of the record to retrieve\n        :type function_record_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "        :return: the function record\n        :rtype: ``osid.authorization.records.FunctionRecord``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``function_record_type`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unsupported`` -- ``has_record_type(function_record_type)`` is ``false``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "function_record_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "osid.authorization.records.FunctionRecord", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.authorization.records.FunctionRecord", 
         "shortname": "FunctionRecord", 
         "category": "records", 
         "doc": {
            "headline": "A record for a ``Function``.", 
            "body": "    The methods specified by the record type are available through the\n    underlying object."
         }, 
         "inherit_fullnames": [
            "osid.OsidRecord"
         ], 
         "inherit_shortnames": [
            "OsidRecord"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidRecord"
            }
         ], 
         "method_names": [], 
         "methods": []
      }, 
      {
         "fullname": "osid.authorization.FunctionQuery", 
         "shortname": "FunctionQuery", 
         "category": "queries", 
         "doc": {
            "headline": "This is the query for searching functions.", 
            "body": "    Each method match request produces an ``AND`` term while multiple\n    invocations of a method produces a nested ``OR``."
         }, 
         "inherit_fullnames": [
            "osid.OsidRuleQuery"
         ], 
         "inherit_shortnames": [
            "OsidRuleQuery"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidRuleQuery"
            }
         ], 
         "method_names": [
            "match_qualifier_hierarchy_id", 
            "clear_qualifier_hierarchy_id_terms", 
            "supports_qualifier_hierarchy_query", 
            "get_qualifier_hierarchy_query", 
            "match_any_qualifier_hierarchy", 
            "clear_qualifier_hierarchy_terms", 
            "match_authorization_id", 
            "clear_authorization_id_terms", 
            "supports_authorization_query", 
            "get_authorization_query", 
            "match_any_authorization", 
            "clear_authorization_terms", 
            "match_vault_id", 
            "clear_vault_id_terms", 
            "supports_vault_query", 
            "get_vault_query", 
            "clear_vault_terms", 
            "get_function_query_record"
         ], 
         "methods": [
            {
               "name": "match_qualifier_hierarchy_id", 
               "doc": {
                  "headline": "Sets the qualifier hierarchy ``Id`` for this query.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    qualifier_hierarchy_id (osid.id.Id): a hierarchy ``Id``\n        arg:    match (boolean): ``true`` for a positive match,\n                ``false`` for a negative match\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``qualifier_hierarchy_id`` is ``null``", 
               "sphinx_param_doc": "        :param qualifier_hierarchy_id: a hierarchy ``Id``\n        :type qualifier_hierarchy_id: ``osid.id.Id``\n        :param match: ``true`` for a positive match, ``false`` for a negative match\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``qualifier_hierarchy_id`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "qualifier_hierarchy_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "clear_qualifier_hierarchy_id_terms", 
               "doc": {
                  "headline": "Clears the qualifier hierarchy ``Id`` query terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "supports_qualifier_hierarchy_query", 
               "doc": {
                  "headline": "Tests if a ``HierarchyQuery`` is available.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if a qualifier hierarchy query is\n                available, ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if a qualifier hierarchy query is available, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "get_qualifier_hierarchy_query", 
               "doc": {
                  "headline": "Gets the query for a qualifier hierarchy.", 
                  "body": "        Multiple retrievals produce a nested ``OR`` term."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.hierarchy.HierarchyQuery) - the qualifier\n                hierarchy query", 
               "error_doc": "        raise:  Unimplemented - ``supports_qualifier_hierarchy_query()``\n                is ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the qualifier hierarchy query\n        :rtype: ``osid.hierarchy.HierarchyQuery``", 
               "sphinx_error_doc": "        :raise: ``Unimplemented`` -- ``supports_qualifier_hierarchy_query()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_qualifier_hierarchy_query()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.hierarchy.HierarchyQuery", 
               "errors": {
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "match_any_qualifier_hierarchy", 
               "doc": {
                  "headline": "Matches functions that have any qualifier hierarchy.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    match (boolean): ``true`` to match functions with any\n                qualifier hierarchy, ``false`` to match functions with\n                no qualifier hierarchy\n", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "        :param match: ``true`` to match functions with any qualifier hierarchy, ``false`` to match functions with no qualifier hierarchy\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "clear_qualifier_hierarchy_terms", 
               "doc": {
                  "headline": "Clears the qualifier hierarchy query terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "match_authorization_id", 
               "doc": {
                  "headline": "Sets the authorization ``Id`` for this query.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    authorization_id (osid.id.Id): an authorization ``Id``\n        arg:    match (boolean): ``true`` for a positive match,\n                ``false`` for a negative match\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``authorization_id`` is ``null``", 
               "sphinx_param_doc": "        :param authorization_id: an authorization ``Id``\n        :type authorization_id: ``osid.id.Id``\n        :param match: ``true`` for a positive match, ``false`` for a negative match\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``authorization_id`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "authorization_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "clear_authorization_id_terms", 
               "doc": {
                  "headline": "Clears the authorization ``Id`` query terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "supports_authorization_query", 
               "doc": {
                  "headline": "Tests if an ``AuthorizationQuery`` is available.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if an authorization query is\n                available, ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if an authorization query is available, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "get_authorization_query", 
               "doc": {
                  "headline": "Gets the query for an authorization.", 
                  "body": "        Multiple retrievals produce a nested ``OR`` term."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.authorization.AuthorizationQuery) - the\n                authorization query", 
               "error_doc": "        raise:  Unimplemented - ``supports_authorization_query()`` is\n                ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the authorization query\n        :rtype: ``osid.authorization.AuthorizationQuery``", 
               "sphinx_error_doc": "        :raise: ``Unimplemented`` -- ``supports_authorization_query()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_authorization_query()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.authorization.AuthorizationQuery", 
               "errors": {
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "match_any_authorization", 
               "doc": {
                  "headline": "Matches functions that have any authorization mapping.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    match (boolean): ``true`` to match functions with any\n                authorization mapping, ``false`` to match functions with\n                no authorization mapping\n", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "        :param match: ``true`` to match functions with any authorization mapping, ``false`` to match functions with no authorization mapping\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "clear_authorization_terms", 
               "doc": {
                  "headline": "Clears the authorization query terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "match_vault_id", 
               "doc": {
                  "headline": "Sets the vault ``Id`` for this query.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    vault_id (osid.id.Id): a vault ``Id``\n        arg:    match (boolean): ``true`` for a positive match,\n                ``false`` for a negative match\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``vault_id`` is ``null``", 
               "sphinx_param_doc": "        :param vault_id: a vault ``Id``\n        :type vault_id: ``osid.id.Id``\n        :param match: ``true`` for a positive match, ``false`` for a negative match\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``vault_id`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "vault_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "clear_vault_id_terms", 
               "doc": {
                  "headline": "Clears the vault ``Id`` query terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "supports_vault_query", 
               "doc": {
                  "headline": "Tests if a ``VaultQuery`` is available.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if a vault query is available,\n                ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if a vault query is available, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "get_vault_query", 
               "doc": {
                  "headline": "Gets the query for a vault.", 
                  "body": "        Multiple retrievals produce a nested ``OR`` term."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.authorization.VaultQuery) - the vault query", 
               "error_doc": "        raise:  Unimplemented - ``supports_vault_query()`` is ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the vault query\n        :rtype: ``osid.authorization.VaultQuery``", 
               "sphinx_error_doc": "        :raise: ``Unimplemented`` -- ``supports_vault_query()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_vault_query()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.authorization.VaultQuery", 
               "errors": {
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "clear_vault_terms", 
               "doc": {
                  "headline": "Clears the vault query terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "get_function_query_record", 
               "doc": {
                  "headline": "Gets the function query record corresponding to the given ``Function`` record ``Type``.", 
                  "body": "        Multiple retrievals produce a nested ``OR`` term."
               }, 
               "arg_doc": "        arg:    function_record_type (osid.type.Type): a function record\n                type\n", 
               "return_doc": "        return: (osid.authorization.records.FunctionQueryRecord) - the\n                function query record", 
               "error_doc": "        raise:  NullArgument - ``function_record_type`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unsupported - ``has_record_type(function_record_type)``\n                is ``false``", 
               "sphinx_param_doc": "        :param function_record_type: a function record type\n        :type function_record_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "        :return: the function query record\n        :rtype: ``osid.authorization.records.FunctionQueryRecord``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``function_record_type`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unsupported`` -- ``has_record_type(function_record_type)`` is ``false``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "function_record_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "osid.authorization.records.FunctionQueryRecord", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.authorization.records.FunctionQueryRecord", 
         "shortname": "FunctionQueryRecord", 
         "category": "records", 
         "doc": {
            "headline": "A record for a ``FunctionQuery``.", 
            "body": "    The methods specified by the record type are available through the\n    underlying object."
         }, 
         "inherit_fullnames": [
            "osid.OsidRecord"
         ], 
         "inherit_shortnames": [
            "OsidRecord"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidRecord"
            }
         ], 
         "method_names": [], 
         "methods": []
      }, 
      {
         "fullname": "osid.authorization.FunctionQueryInspector", 
         "shortname": "FunctionQueryInspector", 
         "category": "query_inspectors", 
         "doc": {
            "headline": "This is the query inspector for examining function queries.", 
            "body": ""
         }, 
         "inherit_fullnames": [
            "osid.OsidRuleQueryInspector"
         ], 
         "inherit_shortnames": [
            "OsidRuleQueryInspector"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidRuleQueryInspector"
            }
         ], 
         "method_names": [
            "get_qualifier_hierarchy_id_terms", 
            "get_qualifier_hierarchy_terms", 
            "get_authorization_id_terms", 
            "get_authorization_terms", 
            "get_vault_id_terms", 
            "get_vault_terms", 
            "get_function_query_inspector_record"
         ], 
         "methods": [
            {
               "name": "get_qualifier_hierarchy_id_terms", 
               "doc": {
                  "headline": "Gets the qualifier hierarchy ``Id`` query terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.search.terms.IdTerm) - the query terms", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the query terms\n        :rtype: ``osid.search.terms.IdTerm``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.search.terms.IdTerm", 
               "errors": {}
            }, 
            {
               "name": "get_qualifier_hierarchy_terms", 
               "doc": {
                  "headline": "Gets the qualifier hierarchy query terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.hierarchy.HierarchyQueryInspector) - the query\n                terms", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the query terms\n        :rtype: ``osid.hierarchy.HierarchyQueryInspector``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.hierarchy.HierarchyQueryInspector", 
               "errors": {}
            }, 
            {
               "name": "get_authorization_id_terms", 
               "doc": {
                  "headline": "Gets the authorization ``Id`` query terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.search.terms.IdTerm) - the query terms", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the query terms\n        :rtype: ``osid.search.terms.IdTerm``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.search.terms.IdTerm", 
               "errors": {}
            }, 
            {
               "name": "get_authorization_terms", 
               "doc": {
                  "headline": "Gets the authorization query terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.authorization.AuthorizationQueryInspector) - the\n                query terms", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the query terms\n        :rtype: ``osid.authorization.AuthorizationQueryInspector``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.authorization.AuthorizationQueryInspector", 
               "errors": {}
            }, 
            {
               "name": "get_vault_id_terms", 
               "doc": {
                  "headline": "Gets the vault ``Id`` query terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.search.terms.IdTerm) - the query terms", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the query terms\n        :rtype: ``osid.search.terms.IdTerm``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.search.terms.IdTerm", 
               "errors": {}
            }, 
            {
               "name": "get_vault_terms", 
               "doc": {
                  "headline": "Gets the vault query terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.authorization.VaultQueryInspector) - the query\n                terms", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the query terms\n        :rtype: ``osid.authorization.VaultQueryInspector``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.authorization.VaultQueryInspector", 
               "errors": {}
            }, 
            {
               "name": "get_function_query_inspector_record", 
               "doc": {
                  "headline": "Gets the function query inspector record corresponding to the given ``Function`` record ``Type``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    function_record_type (osid.type.Type): a function record\n                type\n", 
               "return_doc": "        return:\n                (osid.authorization.records.FunctionQueryInspectorRecord\n                ) - the function query inspector record", 
               "error_doc": "        raise:  NullArgument - ``function_record_type`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unsupported - ``has_record_type(function_record_type)``\n                is ``false``", 
               "sphinx_param_doc": "        :param function_record_type: a function record type\n        :type function_record_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "        :return: the function query inspector record\n        :rtype: ``osid.authorization.records.FunctionQueryInspectorRecord``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``function_record_type`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unsupported`` -- ``has_record_type(function_record_type)`` is ``false``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "function_record_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "osid.authorization.records.FunctionQueryInspectorRecord", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.authorization.records.FunctionQueryInspectorRecord", 
         "shortname": "FunctionQueryInspectorRecord", 
         "category": "records", 
         "doc": {
            "headline": "A record for a ``FunctionQueryInspector``.", 
            "body": "    The methods specified by the record type are available through the\n    underlying object."
         }, 
         "inherit_fullnames": [
            "osid.OsidRecord"
         ], 
         "inherit_shortnames": [
            "OsidRecord"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidRecord"
            }
         ], 
         "method_names": [], 
         "methods": []
      }, 
      {
         "fullname": "osid.authorization.FunctionForm", 
         "shortname": "FunctionForm", 
         "category": "objects", 
         "doc": {
            "headline": "This is the form for creating and updating ``Functions``.", 
            "body": "    Like all ``OsidForm`` objects, various data elements may be set here\n    for use in the create and update methods in the\n    ``FunctionAdminSession``. For each data element that may be set,\n    metadata may be examined to provide display hints or data\n    constraints."
         }, 
         "inherit_fullnames": [
            "osid.OsidRuleForm"
         ], 
         "inherit_shortnames": [
            "OsidRuleForm"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidRuleForm"
            }
         ], 
         "method_names": [
            "get_qualifier_hierarchy_metadata", 
            "set_qualifier_hierarchy", 
            "clear_qualifier_hierarchy", 
            "get_function_form_record"
         ], 
         "methods": [
            {
               "name": "get_qualifier_hierarchy_metadata", 
               "doc": {
                  "headline": "Gets the metadata for a qualifier hierarchy.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.Metadata) - metadata for the qualifier hierarchy", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: metadata for the qualifier hierarchy\n        :rtype: ``osid.Metadata``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.Metadata", 
               "errors": {}
            }, 
            {
               "name": "set_qualifier_hierarchy", 
               "doc": {
                  "headline": "Sets the qualifier hierarchy.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    qualifier_hierarchy_id (osid.id.Id): the new qualifier\n                hierarchy\n", 
               "return_doc": "", 
               "error_doc": "        raise:  InvalidArgument - ``qualifier_hierarchy_id`` is invalid\n        raise:  NoAccess - ``Metadata.isReadOnly()`` is ``true``\n        raise:  NullArgument - ``qualifier_hierarchy_id`` is ``null``", 
               "sphinx_param_doc": "        :param qualifier_hierarchy_id: the new qualifier hierarchy\n        :type qualifier_hierarchy_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``InvalidArgument`` -- ``qualifier_hierarchy_id`` is invalid\n        :raise: ``NoAccess`` -- ``Metadata.isReadOnly()`` is ``true``\n        :raise: ``NullArgument`` -- ``qualifier_hierarchy_id`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "qualifier_hierarchy_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {
                  "INVALID_ARGUMENT": "ConsumerContract", 
                  "NO_ACCESS": "ConsumerContract", 
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "clear_qualifier_hierarchy", 
               "doc": {
                  "headline": "Clears the qualifier hierarchy.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "        raise:  NoAccess - ``Metadata.isRequired()`` or\n                ``Metadata.isReadOnly()`` is ``true``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NoAccess`` -- ``Metadata.isRequired()`` or ``Metadata.isReadOnly()`` is ``true``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {
                  "NO_ACCESS": "ConsumerContract"
               }
            }, 
            {
               "name": "get_function_form_record", 
               "doc": {
                  "headline": "Gets the ``FunctionFormRecord`` corresponding to the given function record ``Type``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    function_record_type (osid.type.Type): the function\n                record type\n", 
               "return_doc": "        return: (osid.authorization.records.FunctionFormRecord) - the\n                function form record", 
               "error_doc": "        raise:  NullArgument - ``function_record_type`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unsupported - ``has_record_type(function_record_type)``\n                is ``false``", 
               "sphinx_param_doc": "        :param function_record_type: the function record type\n        :type function_record_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "        :return: the function form record\n        :rtype: ``osid.authorization.records.FunctionFormRecord``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``function_record_type`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unsupported`` -- ``has_record_type(function_record_type)`` is ``false``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "function_record_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "osid.authorization.records.FunctionFormRecord", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.authorization.records.FunctionFormRecord", 
         "shortname": "FunctionFormRecord", 
         "category": "records", 
         "doc": {
            "headline": "A record for a ``FunctionForm``.", 
            "body": "    The methods specified by the record type are available through the\n    underlying object."
         }, 
         "inherit_fullnames": [
            "osid.OsidRecord"
         ], 
         "inherit_shortnames": [
            "OsidRecord"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidRecord"
            }
         ], 
         "method_names": [], 
         "methods": []
      }, 
      {
         "fullname": "osid.authorization.FunctionSearchOrder", 
         "shortname": "FunctionSearchOrder", 
         "category": "search_orders", 
         "doc": {
            "headline": "An interface for specifying the ordering of search results.", 
            "body": ""
         }, 
         "inherit_fullnames": [
            "osid.OsidRuleSearchOrder"
         ], 
         "inherit_shortnames": [
            "OsidRuleSearchOrder"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidRuleSearchOrder"
            }
         ], 
         "method_names": [
            "order_by_qualifier_hierarchy", 
            "supports_qualifier_hierarchy_search_order", 
            "get_qualifier_hierarchy_search_order", 
            "get_function_search_order_record"
         ], 
         "methods": [
            {
               "name": "order_by_qualifier_hierarchy", 
               "doc": {
                  "headline": "Specified a preference for ordering results by the qualifier hierarchy.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    style (osid.SearchOrderStyle): the search order style\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``style`` is ``null``", 
               "sphinx_param_doc": "        :param style: the search order style\n        :type style: ``osid.SearchOrderStyle``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``style`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.SearchOrderStyle", 
                     "var_name": "style", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.SearchOrderStyle"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "supports_qualifier_hierarchy_search_order", 
               "doc": {
                  "headline": "Tests if a ``HierarchySearchOrder`` interface is available.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if a qualifier hierarchy search\n                order interface is available, ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if a qualifier hierarchy search order interface is available, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "get_qualifier_hierarchy_search_order", 
               "doc": {
                  "headline": "Gets the search order interface for a qualifier hierarchy.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.hierarchy.HierarchySearchOrder) - the hierarchy\n                search order", 
               "error_doc": "        raise:  Unimplemented -\n                ``supports_qualifier_hierarchy_search_order()`` is\n                ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the hierarchy search order\n        :rtype: ``osid.hierarchy.HierarchySearchOrder``", 
               "sphinx_error_doc": "        :raise: ``Unimplemented`` -- ``supports_qualifier_hierarchy_search_order()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_qualifier_hierarchy_search_order()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.hierarchy.HierarchySearchOrder", 
               "errors": {
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_function_search_order_record", 
               "doc": {
                  "headline": "Gets the function search order record corresponding to the given function record ``Type``.", 
                  "body": "        Multiple retrievals return the same underlying object."
               }, 
               "arg_doc": "        arg:    function_record_type (osid.type.Type): a function record\n                type\n", 
               "return_doc": "        return: (osid.authorization.records.FunctionSearchOrderRecord) -\n                the function search order record", 
               "error_doc": "        raise:  NullArgument - ``function_record_type`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unsupported - ``has_record_type(function_record_type)``\n                is ``false``", 
               "sphinx_param_doc": "        :param function_record_type: a function record type\n        :type function_record_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "        :return: the function search order record\n        :rtype: ``osid.authorization.records.FunctionSearchOrderRecord``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``function_record_type`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unsupported`` -- ``has_record_type(function_record_type)`` is ``false``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "function_record_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "osid.authorization.records.FunctionSearchOrderRecord", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.authorization.records.FunctionSearchOrderRecord", 
         "shortname": "FunctionSearchOrderRecord", 
         "category": "records", 
         "doc": {
            "headline": "A record for a ``FunctionSearchOrder``.", 
            "body": "    The methods specified by the record type are available through the\n    underlying object."
         }, 
         "inherit_fullnames": [
            "osid.OsidRecord"
         ], 
         "inherit_shortnames": [
            "OsidRecord"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidRecord"
            }
         ], 
         "method_names": [], 
         "methods": []
      }, 
      {
         "fullname": "osid.authorization.FunctionSearch", 
         "shortname": "FunctionSearch", 
         "category": "searches", 
         "doc": {
            "headline": "``FunctionSearch`` defines the interface for specifying function search options.", 
            "body": ""
         }, 
         "inherit_fullnames": [
            "osid.OsidSearch"
         ], 
         "inherit_shortnames": [
            "OsidSearch"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidSearch"
            }
         ], 
         "method_names": [
            "search_among_functions", 
            "order_function_results", 
            "get_function_search_record"
         ], 
         "methods": [
            {
               "name": "search_among_functions", 
               "doc": {
                  "headline": "Execute this search among the given list of functions.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    function_ids (osid.id.IdList): list of functions\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``function_ids`` is ``null``", 
               "sphinx_param_doc": "        :param function_ids: list of functions\n        :type function_ids: ``osid.id.IdList``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``function_ids`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.IdList", 
                     "var_name": "function_ids", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.IdList"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "order_function_results", 
               "doc": {
                  "headline": "Specify an ordering to the search results.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    function_search_order\n                (osid.authorization.FunctionSearchOrder): function\n                search order\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``function_search_order`` is ``null``\n        raise:  Unsupported - ``function_search_order`` is not of this\n                service", 
               "sphinx_param_doc": "        :param function_search_order: function search order\n        :type function_search_order: ``osid.authorization.FunctionSearchOrder``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``function_search_order`` is ``null``\n        :raise: ``Unsupported`` -- ``function_search_order`` is not of this service", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.authorization.FunctionSearchOrder", 
                     "var_name": "function_search_order", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.authorization.FunctionSearchOrder"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_function_search_record", 
               "doc": {
                  "headline": "Gets the function search record corresponding to the given function search record ``Type``.", 
                  "body": "        This method is used to retrieve an object implementing the\n        requested record."
               }, 
               "arg_doc": "        arg:    function_search_record_type (osid.type.Type): a function\n                search record type\n", 
               "return_doc": "        return: (osid.authorization.records.FunctionSearchRecord) - the\n                function search record", 
               "error_doc": "        raise:  NullArgument - ``function_search_record_type`` is\n                ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unsupported -\n                ``has_record_type(function_search_record_type)`` is\n                ``false``", 
               "sphinx_param_doc": "        :param function_search_record_type: a function search record type\n        :type function_search_record_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "        :return: the function search record\n        :rtype: ``osid.authorization.records.FunctionSearchRecord``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``function_search_record_type`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unsupported`` -- ``has_record_type(function_search_record_type)`` is ``false``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "function_search_record_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "osid.authorization.records.FunctionSearchRecord", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.authorization.records.FunctionSearchRecord", 
         "shortname": "FunctionSearchRecord", 
         "category": "records", 
         "doc": {
            "headline": "A record for a ``FunctionSearch``.", 
            "body": "    The methods specified by the record type are available through the\n    underlying object."
         }, 
         "inherit_fullnames": [
            "osid.OsidRecord"
         ], 
         "inherit_shortnames": [
            "OsidRecord"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidRecord"
            }
         ], 
         "method_names": [], 
         "methods": []
      }, 
      {
         "fullname": "osid.authorization.FunctionSearchResults", 
         "shortname": "FunctionSearchResults", 
         "category": "searches", 
         "doc": {
            "headline": "This interface provides a means to capture results of a search.", 
            "body": ""
         }, 
         "inherit_fullnames": [
            "osid.OsidSearchResults"
         ], 
         "inherit_shortnames": [
            "OsidSearchResults"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidSearchResults"
            }
         ], 
         "method_names": [
            "get_functions", 
            "get_function_query_inspector", 
            "get_function_search_results_record"
         ], 
         "methods": [
            {
               "name": "get_functions", 
               "doc": {
                  "headline": "Gets the function list resulting from the search.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.authorization.FunctionList) - the function list", 
               "error_doc": "        raise:  IllegalState - list has already been retrieved", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the function list\n        :rtype: ``osid.authorization.FunctionList``", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- list has already been retrieved", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.authorization.FunctionList", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract"
               }
            }, 
            {
               "name": "get_function_query_inspector", 
               "doc": {
                  "headline": "Gets the inspector for the query to examine the terms used in the search.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.authorization.FunctionQueryInspector) - the\n                function query inspector", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the function query inspector\n        :rtype: ``osid.authorization.FunctionQueryInspector``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.authorization.FunctionQueryInspector", 
               "errors": {}
            }, 
            {
               "name": "get_function_search_results_record", 
               "doc": {
                  "headline": "Gets the function search results record corresponding to the given function search record ``Type``.", 
                  "body": "        This method is used to retrieve an object implementing the\n        requested record."
               }, 
               "arg_doc": "        arg:    function_search_record_type (osid.type.Type): a function\n                search record type\n", 
               "return_doc": "        return: (osid.authorization.records.FunctionSearchResultsRecord)\n                - the function search results record", 
               "error_doc": "        raise:  NullArgument - ``function_search_record_type`` is\n                ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unsupported -\n                ``has_record_type(function_search_record_type)`` is\n                ``false``", 
               "sphinx_param_doc": "        :param function_search_record_type: a function search record type\n        :type function_search_record_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "        :return: the function search results record\n        :rtype: ``osid.authorization.records.FunctionSearchResultsRecord``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``function_search_record_type`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unsupported`` -- ``has_record_type(function_search_record_type)`` is ``false``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "function_search_record_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "osid.authorization.records.FunctionSearchResultsRecord", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.authorization.records.FunctionSearchResultsRecord", 
         "shortname": "FunctionSearchResultsRecord", 
         "category": "records", 
         "doc": {
            "headline": "A record for a ``FunctionSearchResults``.", 
            "body": "    The methods specified by the record type are available through the\n    underlying object."
         }, 
         "inherit_fullnames": [
            "osid.OsidRecord"
         ], 
         "inherit_shortnames": [
            "OsidRecord"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidRecord"
            }
         ], 
         "method_names": [], 
         "methods": []
      }, 
      {
         "fullname": "osid.authorization.FunctionReceiver", 
         "shortname": "FunctionReceiver", 
         "category": "receivers", 
         "doc": {
            "headline": "The function receiver is the consumer supplied interface for receiving notifications pertaining to new, updated or deleted ``Functions``.", 
            "body": ""
         }, 
         "inherit_fullnames": [
            "osid.OsidReceiver"
         ], 
         "inherit_shortnames": [
            "OsidReceiver"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidReceiver"
            }
         ], 
         "method_names": [
            "new_function", 
            "changed_function", 
            "deleted_function"
         ], 
         "methods": [
            {
               "name": "new_function", 
               "doc": {
                  "headline": "The callback for notifications of new functions.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    function_id (osid.id.Id): the Id of the new ``Function``\n", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "        :param function_id: the Id of the new ``Function``\n        :type function_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "function_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "changed_function", 
               "doc": {
                  "headline": "The callback for notification of updated functions.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    function_id (osid.id.Id): the Id of the updated\n                ``Function``\n", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "        :param function_id: the Id of the updated ``Function``\n        :type function_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "function_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "deleted_function", 
               "doc": {
                  "headline": "The callback for notification of deleted functions.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    function_id (osid.id.Id): the Id of the deleted\n                ``Function``\n", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "        :param function_id: the Id of the deleted ``Function``\n        :type function_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "function_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {}
            }
         ]
      }, 
      {
         "fullname": "osid.authorization.FunctionList", 
         "shortname": "FunctionList", 
         "category": "objects", 
         "doc": {
            "headline": "Like all ``OsidLists,``  ``FunctionList`` provides a means for accessing ``Function`` elements sequentially either one at a time or many at a time.", 
            "body": "    Examples: while (fl.hasNext()) { Function function =\n    fl.getNextFunction(); }\n\n    or\n      while (fl.hasNext()) {\n           Function[] functions = fl.getNextFunctions(fl.available());\n      }\n    \n"
         }, 
         "inherit_fullnames": [
            "osid.OsidList"
         ], 
         "inherit_shortnames": [
            "OsidList"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidList"
            }
         ], 
         "method_names": [
            "get_next_function", 
            "get_next_functions"
         ], 
         "methods": [
            {
               "name": "get_next_function", 
               "doc": {
                  "headline": "Gets the next ``Function`` in this list.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.authorization.Function) - the next ``Function`` in\n                this list. The ``has_next()`` method should be used to\n                test that a next ``Function`` is available before\n                calling this method.", 
               "error_doc": "        raise:  IllegalState - no more elements available in this list\n        raise:  OperationFailed - unable to complete request", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the next ``Function`` in this list. The ``has_next()`` method should be used to test that a next ``Function`` is available before calling this method.\n        :rtype: ``osid.authorization.Function``", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- no more elements available in this list\n        :raise: ``OperationFailed`` -- unable to complete request", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.authorization.Function", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational"
               }
            }, 
            {
               "name": "get_next_functions", 
               "doc": {
                  "headline": "Gets the next set of ``Function`` elements in this list which must be less than or equal to the number returned from ``available()``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    n (cardinal): the number of ``Function`` elements\n                requested which should be less than or equal to\n                ``available()``\n", 
               "return_doc": "        return: (osid.authorization.Function) - an array of ``Function``\n                elements.The length of the array is less than or equal\n                to the number specified.", 
               "error_doc": "        raise:  IllegalState - no more elements available in this list\n        raise:  OperationFailed - unable to complete request", 
               "sphinx_param_doc": "        :param n: the number of ``Function`` elements requested which should be less than or equal to ``available()``\n        :type n: ``cardinal``\n", 
               "sphinx_return_doc": "        :return: an array of ``Function`` elements.The length of the array is less than or equal to the number specified.\n        :rtype: ``osid.authorization.Function``", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- no more elements available in this list\n        :raise: ``OperationFailed`` -- unable to complete request", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "cardinal", 
                     "var_name": "n", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "cardinal"
               ], 
               "return_type": "osid.authorization.Function", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.authorization.Qualifier", 
         "shortname": "Qualifier", 
         "category": "objects", 
         "doc": {
            "headline": "A ``Qualifier`` represents an authenticatable identity.", 
            "body": "    Like all OSID objects, a ``Qualifier`` is identified by its ``Id``\n    and any persisted references should use the ``Id``."
         }, 
         "inherit_fullnames": [
            "osid.OsidObject", 
            "osid.Federateable"
         ], 
         "inherit_shortnames": [
            "OsidObject", 
            "Federateable"
         ], 
         "inherit_pkg_names": [
            "osid", 
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidObject"
            }, 
            {
               "pkg_name": "osid", 
               "name": "Federateable"
            }
         ], 
         "method_names": [
            "get_qualifier_record"
         ], 
         "methods": [
            {
               "name": "get_qualifier_record", 
               "doc": {
                  "headline": "Gets the qualifier record corresponding to the given ``Qualifier`` record ``Type``.", 
                  "body": "        This method is used to retrieve an object implementing the\n        requested record. The ``qualifier_record_type`` may be the\n        ``Type`` returned in ``get_record_types()`` or any of its\n        parents in a ``Type`` hierarchy where\n        ``has_record_type(qualifier_record_type)`` is ``true`` ."
               }, 
               "arg_doc": "        arg:    qualifier_record_type (osid.type.Type): the type of the\n                record to retrieve\n", 
               "return_doc": "        return: (osid.authorization.records.QualifierRecord) - the\n                qualifier record", 
               "error_doc": "        raise:  NullArgument - ``qualifier_record_type`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unsupported - ``has_record_type(qualifier_record_type)``\n                is ``false``", 
               "sphinx_param_doc": "        :param qualifier_record_type: the type of the record to retrieve\n        :type qualifier_record_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "        :return: the qualifier record\n        :rtype: ``osid.authorization.records.QualifierRecord``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``qualifier_record_type`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unsupported`` -- ``has_record_type(qualifier_record_type)`` is ``false``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "qualifier_record_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "osid.authorization.records.QualifierRecord", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.authorization.records.QualifierRecord", 
         "shortname": "QualifierRecord", 
         "category": "records", 
         "doc": {
            "headline": "A record for a ``Qualifier``.", 
            "body": "    The methods specified by the record type are available through the\n    underlying object."
         }, 
         "inherit_fullnames": [
            "osid.OsidRecord"
         ], 
         "inherit_shortnames": [
            "OsidRecord"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidRecord"
            }
         ], 
         "method_names": [], 
         "methods": []
      }, 
      {
         "fullname": "osid.authorization.QualifierQuery", 
         "shortname": "QualifierQuery", 
         "category": "queries", 
         "doc": {
            "headline": "This is the query for searching qualifiers.", 
            "body": "    Each method match request produces an ``AND`` term while multiple\n    invocations of a method produces a nested ``OR``."
         }, 
         "inherit_fullnames": [
            "osid.OsidObjectQuery", 
            "osid.OsidFederateableQuery"
         ], 
         "inherit_shortnames": [
            "OsidObjectQuery", 
            "OsidFederateableQuery"
         ], 
         "inherit_pkg_names": [
            "osid", 
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidObjectQuery"
            }, 
            {
               "pkg_name": "osid", 
               "name": "OsidFederateableQuery"
            }
         ], 
         "method_names": [
            "match_qualifier_hierarchy_id", 
            "clear_qualifier_hierarchy_id_terms", 
            "supports_qualifier_hierarchy_query", 
            "get_qualifier_hierarchy_query", 
            "clear_qualifier_hierarchy_terms", 
            "match_authorization_id", 
            "clear_authorization_id_terms", 
            "supports_authorization_query", 
            "get_authorization_query", 
            "match_any_authorization", 
            "clear_authorization_terms", 
            "match_ancestor_qualifier_id", 
            "clear_ancestor_qualifier_id_terms", 
            "supports_ancestor_qualifier_query", 
            "get_ancestor_qualifier_query", 
            "match_any_ancestor_qualifier", 
            "clear_ancestor_qualifier_terms", 
            "match_descendant_qualifier_id", 
            "clear_descendant_qualifier_id_terms", 
            "supports_descendant_qualifier_query", 
            "get_descendant_qualifier_query", 
            "match_any_descendant_qualifier", 
            "clear_descendant_qualifier_terms", 
            "match_vault_id", 
            "clear_vault_id_terms", 
            "supports_vault_query", 
            "get_vault_query", 
            "clear_vault_terms", 
            "get_qualifier_query_record"
         ], 
         "methods": [
            {
               "name": "match_qualifier_hierarchy_id", 
               "doc": {
                  "headline": "Sets the qualifier hierarchy ``Id`` for this query.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    qualifier_hierarchy_id (osid.id.Id): a hierarchy ``Id``\n        arg:    match (boolean): ``true`` for a positive match,\n                ``false`` for a negative match\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``qualifier_hierarchy_id`` is ``null``", 
               "sphinx_param_doc": "        :param qualifier_hierarchy_id: a hierarchy ``Id``\n        :type qualifier_hierarchy_id: ``osid.id.Id``\n        :param match: ``true`` for a positive match, ``false`` for a negative match\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``qualifier_hierarchy_id`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "qualifier_hierarchy_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "clear_qualifier_hierarchy_id_terms", 
               "doc": {
                  "headline": "Clears the qualifier hierarchy ``Id`` query terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "supports_qualifier_hierarchy_query", 
               "doc": {
                  "headline": "Tests if a ``HierarchyQuery`` is available.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if a qualifier hierarchy query is\n                available, ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if a qualifier hierarchy query is available, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "get_qualifier_hierarchy_query", 
               "doc": {
                  "headline": "Gets the query for a qualifier hierarchy.", 
                  "body": "        Multiple retrievals produce a nested ``OR`` term."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.hierarchy.HierarchyQuery) - the qualifier\n                hierarchy query", 
               "error_doc": "        raise:  Unimplemented - ``supports_qualifier_hierarchy_query()``\n                is ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the qualifier hierarchy query\n        :rtype: ``osid.hierarchy.HierarchyQuery``", 
               "sphinx_error_doc": "        :raise: ``Unimplemented`` -- ``supports_qualifier_hierarchy_query()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_qualifier_hierarchy_query()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.hierarchy.HierarchyQuery", 
               "errors": {
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "clear_qualifier_hierarchy_terms", 
               "doc": {
                  "headline": "Clears the qualifier hierarchy query terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "match_authorization_id", 
               "doc": {
                  "headline": "Sets the authorization ``Id`` for this query.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    authorization_id (osid.id.Id): an authorization ``Id``\n        arg:    match (boolean): ``true`` for a positive match,\n                ``false`` for a negative match\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``authorization_id`` is ``null``", 
               "sphinx_param_doc": "        :param authorization_id: an authorization ``Id``\n        :type authorization_id: ``osid.id.Id``\n        :param match: ``true`` for a positive match, ``false`` for a negative match\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``authorization_id`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "authorization_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "clear_authorization_id_terms", 
               "doc": {
                  "headline": "Clears the authorization ``Id`` query terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "supports_authorization_query", 
               "doc": {
                  "headline": "Tests if an ``AuthorizationQuery`` is available.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if an authorization query is\n                available, ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if an authorization query is available, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "get_authorization_query", 
               "doc": {
                  "headline": "Gets the query for an authorization.", 
                  "body": "        Multiple retrievals produce a nested ``OR`` term."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.authorization.AuthorizationQuery) - the\n                authorization query", 
               "error_doc": "        raise:  Unimplemented - ``supports_authorization_query()`` is\n                ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the authorization query\n        :rtype: ``osid.authorization.AuthorizationQuery``", 
               "sphinx_error_doc": "        :raise: ``Unimplemented`` -- ``supports_authorization_query()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_authorization_query()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.authorization.AuthorizationQuery", 
               "errors": {
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "match_any_authorization", 
               "doc": {
                  "headline": "Matches qualifiers that have any authorization mapping.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    match (boolean): ``true`` to match qualifiers with any\n                authorization mapping, ``false`` to match qualifiers\n                with no authorization mapping\n", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "        :param match: ``true`` to match qualifiers with any authorization mapping, ``false`` to match qualifiers with no authorization mapping\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "clear_authorization_terms", 
               "doc": {
                  "headline": "Clears the authorization query terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "match_ancestor_qualifier_id", 
               "doc": {
                  "headline": "Sets the qualifier ``Id`` for this query to match qualifiers that have the specified qualifier as an ancestor.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    qualifier_id (osid.id.Id): a qualifier ``Id``\n        arg:    match (boolean): ``true`` for a positive match,\n                ``false`` for a negative match\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``qualifier_id`` is ``null``", 
               "sphinx_param_doc": "        :param qualifier_id: a qualifier ``Id``\n        :type qualifier_id: ``osid.id.Id``\n        :param match: ``true`` for a positive match, ``false`` for a negative match\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``qualifier_id`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "qualifier_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "clear_ancestor_qualifier_id_terms", 
               "doc": {
                  "headline": "Clears the ancestor qualifier ``Id`` query terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "supports_ancestor_qualifier_query", 
               "doc": {
                  "headline": "Tests if a ``QualifierQuery`` is available.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if a qualifier query is available,\n                ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if a qualifier query is available, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "get_ancestor_qualifier_query", 
               "doc": {
                  "headline": "Gets the query for a qualifier.", 
                  "body": "        Multiple retrievals produce a nested ``OR`` term."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.authorization.QualifierQuery) - the qualifier\n                query", 
               "error_doc": "        raise:  Unimplemented - ``supports_ancestor_qualifier_query()``\n                is ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the qualifier query\n        :rtype: ``osid.authorization.QualifierQuery``", 
               "sphinx_error_doc": "        :raise: ``Unimplemented`` -- ``supports_ancestor_qualifier_query()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_ancestor_qualifier_query()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.authorization.QualifierQuery", 
               "errors": {
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "match_any_ancestor_qualifier", 
               "doc": {
                  "headline": "Matches qualifiers that have any ancestor.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    match (boolean): ``true`` to match qualifiers with any\n                ancestor, ``false`` to match root qualifiers\n", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "        :param match: ``true`` to match qualifiers with any ancestor, ``false`` to match root qualifiers\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "clear_ancestor_qualifier_terms", 
               "doc": {
                  "headline": "Clears the ancestor qualifier query terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "match_descendant_qualifier_id", 
               "doc": {
                  "headline": "Sets the qualifier ``Id`` for this query to match qualifiers that have the specified qualifier as a descendant.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    qualifier_id (osid.id.Id): a qualifier ``Id``\n        arg:    match (boolean): ``true`` for a positive match,\n                ``false`` for a negative match\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``qualifier_id`` is ``null``", 
               "sphinx_param_doc": "        :param qualifier_id: a qualifier ``Id``\n        :type qualifier_id: ``osid.id.Id``\n        :param match: ``true`` for a positive match, ``false`` for a negative match\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``qualifier_id`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "qualifier_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "clear_descendant_qualifier_id_terms", 
               "doc": {
                  "headline": "Clears the descendant qualifier ``Id`` query terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "supports_descendant_qualifier_query", 
               "doc": {
                  "headline": "Tests if a ``QualifierQuery`` is available.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if a qualifier query is available,\n                ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if a qualifier query is available, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "get_descendant_qualifier_query", 
               "doc": {
                  "headline": "Gets the query for a qualifier.", 
                  "body": "        Multiple retrievals produce a nested ``OR`` term."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.authorization.QualifierQuery) - the qualifier\n                query", 
               "error_doc": "        raise:  Unimplemented -\n                ``supports_descendant_qualifier_query()`` is ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the qualifier query\n        :rtype: ``osid.authorization.QualifierQuery``", 
               "sphinx_error_doc": "        :raise: ``Unimplemented`` -- ``supports_descendant_qualifier_query()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_descendant_qualifier_query()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.authorization.QualifierQuery", 
               "errors": {
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "match_any_descendant_qualifier", 
               "doc": {
                  "headline": "Matches qualifiers that have any ancestor.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    match (boolean): ``true`` to match qualifiers with any\n                ancestor, ``false`` to match leaf qualifiers\n", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "        :param match: ``true`` to match qualifiers with any ancestor, ``false`` to match leaf qualifiers\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "clear_descendant_qualifier_terms", 
               "doc": {
                  "headline": "Clears the descendant qualifier query terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "match_vault_id", 
               "doc": {
                  "headline": "Sets the vault ``Id`` for this query.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    vault_id (osid.id.Id): a vault ``Id``\n        arg:    match (boolean): ``true`` for a positive match,\n                ``false`` for a negative match\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``vault_id`` is ``null``", 
               "sphinx_param_doc": "        :param vault_id: a vault ``Id``\n        :type vault_id: ``osid.id.Id``\n        :param match: ``true`` for a positive match, ``false`` for a negative match\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``vault_id`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "vault_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "clear_vault_id_terms", 
               "doc": {
                  "headline": "Clears the vault ``Id`` query terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "supports_vault_query", 
               "doc": {
                  "headline": "Tests if a ``VaultQuery`` is available.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if a vault query is available,\n                ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if a vault query is available, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "get_vault_query", 
               "doc": {
                  "headline": "Gets the query for a vault.", 
                  "body": "        Multiple retrievals produce a nested ``OR`` term."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.authorization.VaultQuery) - the vault query", 
               "error_doc": "        raise:  Unimplemented - ``supports_vault_query()`` is ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the vault query\n        :rtype: ``osid.authorization.VaultQuery``", 
               "sphinx_error_doc": "        :raise: ``Unimplemented`` -- ``supports_vault_query()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_vault_query()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.authorization.VaultQuery", 
               "errors": {
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "clear_vault_terms", 
               "doc": {
                  "headline": "Clears the vault query terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "get_qualifier_query_record", 
               "doc": {
                  "headline": "Gets the qualfiier query record corresponding to the given ``Qualifier`` record ``Type``.", 
                  "body": "        Multiple retrievals produce a nested ``OR`` term."
               }, 
               "arg_doc": "        arg:    qualifier_record_type (osid.type.Type): a qualifier\n                record type\n", 
               "return_doc": "        return: (osid.authorization.records.QualifierQueryRecord) - the\n                qualifier query record", 
               "error_doc": "        raise:  NullArgument - ``qualifier_record_type`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unsupported - ``has_record_type(qualifier_record_type)``\n                is ``false``", 
               "sphinx_param_doc": "        :param qualifier_record_type: a qualifier record type\n        :type qualifier_record_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "        :return: the qualifier query record\n        :rtype: ``osid.authorization.records.QualifierQueryRecord``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``qualifier_record_type`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unsupported`` -- ``has_record_type(qualifier_record_type)`` is ``false``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "qualifier_record_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "osid.authorization.records.QualifierQueryRecord", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.authorization.records.QualifierQueryRecord", 
         "shortname": "QualifierQueryRecord", 
         "category": "records", 
         "doc": {
            "headline": "A record for a ``QualifierQuery``.", 
            "body": "    The methods specified by the record type are available through the\n    underlying object."
         }, 
         "inherit_fullnames": [
            "osid.OsidRecord"
         ], 
         "inherit_shortnames": [
            "OsidRecord"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidRecord"
            }
         ], 
         "method_names": [], 
         "methods": []
      }, 
      {
         "fullname": "osid.authorization.QualifierQueryInspector", 
         "shortname": "QualifierQueryInspector", 
         "category": "query_inspectors", 
         "doc": {
            "headline": "This is the query inspector for examining qualifiers queries.", 
            "body": ""
         }, 
         "inherit_fullnames": [
            "osid.OsidObjectQueryInspector", 
            "osid.OsidFederateableQueryInspector"
         ], 
         "inherit_shortnames": [
            "OsidObjectQueryInspector", 
            "OsidFederateableQueryInspector"
         ], 
         "inherit_pkg_names": [
            "osid", 
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidObjectQueryInspector"
            }, 
            {
               "pkg_name": "osid", 
               "name": "OsidFederateableQueryInspector"
            }
         ], 
         "method_names": [
            "get_qualifier_hierarchy_id_terms", 
            "get_qualifier_hierarchy_terms", 
            "get_authorization_id_terms", 
            "get_authorization_terms", 
            "get_ancestor_qualifier_id_terms", 
            "get_ancestor_qualifier_terms", 
            "get_descendant_qualifier_id_terms", 
            "get_descendant_qualifier_terms", 
            "get_vault_id_terms", 
            "get_vault_terms", 
            "get_qualifier_query_inspector_record"
         ], 
         "methods": [
            {
               "name": "get_qualifier_hierarchy_id_terms", 
               "doc": {
                  "headline": "Gets the qualifier hierarchy ``Id`` query terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.search.terms.IdTerm) - the query terms", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the query terms\n        :rtype: ``osid.search.terms.IdTerm``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.search.terms.IdTerm", 
               "errors": {}
            }, 
            {
               "name": "get_qualifier_hierarchy_terms", 
               "doc": {
                  "headline": "Gets the qualifier hierarchy query terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.hierarchy.HierarchyQueryInspector) - the query\n                terms", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the query terms\n        :rtype: ``osid.hierarchy.HierarchyQueryInspector``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.hierarchy.HierarchyQueryInspector", 
               "errors": {}
            }, 
            {
               "name": "get_authorization_id_terms", 
               "doc": {
                  "headline": "Gets the authorization ``Id`` query terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.search.terms.IdTerm) - the query terms", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the query terms\n        :rtype: ``osid.search.terms.IdTerm``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.search.terms.IdTerm", 
               "errors": {}
            }, 
            {
               "name": "get_authorization_terms", 
               "doc": {
                  "headline": "Gets the authorization query terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.authorization.AuthorizationQueryInspector) - the\n                query terms", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the query terms\n        :rtype: ``osid.authorization.AuthorizationQueryInspector``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.authorization.AuthorizationQueryInspector", 
               "errors": {}
            }, 
            {
               "name": "get_ancestor_qualifier_id_terms", 
               "doc": {
                  "headline": "Gets the ancestor qualifier ``Id`` query terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.search.terms.IdTerm) - the query terms", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the query terms\n        :rtype: ``osid.search.terms.IdTerm``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.search.terms.IdTerm", 
               "errors": {}
            }, 
            {
               "name": "get_ancestor_qualifier_terms", 
               "doc": {
                  "headline": "Gets the ancestor qualifier query terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.authorization.FunctionQueryInspector) - the query\n                terms", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the query terms\n        :rtype: ``osid.authorization.FunctionQueryInspector``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.authorization.FunctionQueryInspector", 
               "errors": {}
            }, 
            {
               "name": "get_descendant_qualifier_id_terms", 
               "doc": {
                  "headline": "Gets the descendant qualifier ``Id`` query terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.search.terms.IdTerm) - the query terms", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the query terms\n        :rtype: ``osid.search.terms.IdTerm``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.search.terms.IdTerm", 
               "errors": {}
            }, 
            {
               "name": "get_descendant_qualifier_terms", 
               "doc": {
                  "headline": "Gets the descendant qualifier query terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.authorization.FunctionQueryInspector) - the query\n                terms", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the query terms\n        :rtype: ``osid.authorization.FunctionQueryInspector``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.authorization.FunctionQueryInspector", 
               "errors": {}
            }, 
            {
               "name": "get_vault_id_terms", 
               "doc": {
                  "headline": "Gets the vault ``Id`` query terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.search.terms.IdTerm) - the query terms", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the query terms\n        :rtype: ``osid.search.terms.IdTerm``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.search.terms.IdTerm", 
               "errors": {}
            }, 
            {
               "name": "get_vault_terms", 
               "doc": {
                  "headline": "Gets the vault query terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.authorization.VaultQueryInspector) - the query\n                terms", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the query terms\n        :rtype: ``osid.authorization.VaultQueryInspector``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.authorization.VaultQueryInspector", 
               "errors": {}
            }, 
            {
               "name": "get_qualifier_query_inspector_record", 
               "doc": {
                  "headline": "Gets the qualifier query inspector record corresponding to the given ``Qualifier`` record ``Type``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    qualifier_record_type (osid.type.Type): a qualifier\n                query inspector record type\n", 
               "return_doc": "        return:\n                (osid.authorization.records.QualifierQueryInspectorRecor\n                d) - the qualifier query inspector record", 
               "error_doc": "        raise:  NullArgument - ``qualifier_record_type`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unsupported - ``has_record_type(qualifier_record_type)``\n                is ``false``", 
               "sphinx_param_doc": "        :param qualifier_record_type: a qualifier query inspector record type\n        :type qualifier_record_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "        :return: the qualifier query inspector record\n        :rtype: ``osid.authorization.records.QualifierQueryInspectorRecord``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``qualifier_record_type`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unsupported`` -- ``has_record_type(qualifier_record_type)`` is ``false``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "qualifier_record_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "osid.authorization.records.QualifierQueryInspectorRecord", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.authorization.records.QualifierQueryInspectorRecord", 
         "shortname": "QualifierQueryInspectorRecord", 
         "category": "records", 
         "doc": {
            "headline": "A record for a ``QualifierQueryInspector``.", 
            "body": "    The methods specified by the record type are available through the\n    underlying object."
         }, 
         "inherit_fullnames": [
            "osid.OsidRecord"
         ], 
         "inherit_shortnames": [
            "OsidRecord"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidRecord"
            }
         ], 
         "method_names": [], 
         "methods": []
      }, 
      {
         "fullname": "osid.authorization.QualifierForm", 
         "shortname": "QualifierForm", 
         "category": "objects", 
         "doc": {
            "headline": "This is the form for creating and updating ``Qualifiers``.", 
            "body": "    Like all ``OsidForm`` objects, various data elements may be set here\n    for use in the create and update methods in the\n    ``QualifierAdminSession``. For each data element that may be set,\n    metadata may be examined to provide display hints or data\n    constraints."
         }, 
         "inherit_fullnames": [
            "osid.OsidObjectForm", 
            "osid.OsidFederateableForm"
         ], 
         "inherit_shortnames": [
            "OsidObjectForm", 
            "OsidFederateableForm"
         ], 
         "inherit_pkg_names": [
            "osid", 
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidObjectForm"
            }, 
            {
               "pkg_name": "osid", 
               "name": "OsidFederateableForm"
            }
         ], 
         "method_names": [
            "get_qualifier_form_record"
         ], 
         "methods": [
            {
               "name": "get_qualifier_form_record", 
               "doc": {
                  "headline": "Gets the ``QualifierFormRecord`` corresponding to the given qualifier record ``Type``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    qualifier_record_type (osid.type.Type): the qualifier\n                record type\n", 
               "return_doc": "        return: (osid.authorization.records.QualifierFormRecord) - the\n                qualifier form record", 
               "error_doc": "        raise:  NullArgument - ``qualifier_record_type`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unsupported - ``has_record_type(qualifier_record_type)``\n                is ``false``", 
               "sphinx_param_doc": "        :param qualifier_record_type: the qualifier record type\n        :type qualifier_record_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "        :return: the qualifier form record\n        :rtype: ``osid.authorization.records.QualifierFormRecord``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``qualifier_record_type`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unsupported`` -- ``has_record_type(qualifier_record_type)`` is ``false``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "qualifier_record_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "osid.authorization.records.QualifierFormRecord", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.authorization.records.QualifierFormRecord", 
         "shortname": "QualifierFormRecord", 
         "category": "records", 
         "doc": {
            "headline": "A record for a ``QualifierForm``.", 
            "body": "    The methods specified by the record type are available through the\n    underlying object."
         }, 
         "inherit_fullnames": [
            "osid.OsidRecord"
         ], 
         "inherit_shortnames": [
            "OsidRecord"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidRecord"
            }
         ], 
         "method_names": [], 
         "methods": []
      }, 
      {
         "fullname": "osid.authorization.QualifierSearchOrder", 
         "shortname": "QualifierSearchOrder", 
         "category": "search_orders", 
         "doc": {
            "headline": "An interface for specifying the ordering of search results.", 
            "body": ""
         }, 
         "inherit_fullnames": [
            "osid.OsidObjectSearchOrder", 
            "osid.OsidFederateableSearchOrder"
         ], 
         "inherit_shortnames": [
            "OsidObjectSearchOrder", 
            "OsidFederateableSearchOrder"
         ], 
         "inherit_pkg_names": [
            "osid", 
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidObjectSearchOrder"
            }, 
            {
               "pkg_name": "osid", 
               "name": "OsidFederateableSearchOrder"
            }
         ], 
         "method_names": [
            "get_qualifier_search_order_record"
         ], 
         "methods": [
            {
               "name": "get_qualifier_search_order_record", 
               "doc": {
                  "headline": "Gets the qualifier search order record corresponding to the given qualifier record ``Type``.", 
                  "body": "        Multiple retrievals return the same underlying object."
               }, 
               "arg_doc": "        arg:    qualifier_record_type (osid.type.Type): a qualifier\n                record type\n", 
               "return_doc": "        return: (osid.authorization.records.QualifierSearchOrderRecord)\n                - the qualifier search order record", 
               "error_doc": "        raise:  NullArgument - ``qualifier_record_type`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unsupported - ``has_record_type(qualifier_record_type)``\n                is ``false``", 
               "sphinx_param_doc": "        :param qualifier_record_type: a qualifier record type\n        :type qualifier_record_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "        :return: the qualifier search order record\n        :rtype: ``osid.authorization.records.QualifierSearchOrderRecord``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``qualifier_record_type`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unsupported`` -- ``has_record_type(qualifier_record_type)`` is ``false``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "qualifier_record_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "osid.authorization.records.QualifierSearchOrderRecord", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.authorization.records.QualifierSearchOrderRecord", 
         "shortname": "QualifierSearchOrderRecord", 
         "category": "records", 
         "doc": {
            "headline": "A record for a ``QualifierSearchOrder``.", 
            "body": "    The methods specified by the record type are available through the\n    underlying object."
         }, 
         "inherit_fullnames": [
            "osid.OsidRecord"
         ], 
         "inherit_shortnames": [
            "OsidRecord"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidRecord"
            }
         ], 
         "method_names": [], 
         "methods": []
      }, 
      {
         "fullname": "osid.authorization.QualifierSearch", 
         "shortname": "QualifierSearch", 
         "category": "searches", 
         "doc": {
            "headline": "``QualifierSearch`` defines the interface for specifying qualifier search options.", 
            "body": ""
         }, 
         "inherit_fullnames": [
            "osid.OsidSearch"
         ], 
         "inherit_shortnames": [
            "OsidSearch"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidSearch"
            }
         ], 
         "method_names": [
            "search_among_qualifiers", 
            "order_qualifier_results", 
            "get_qualifier_search_record"
         ], 
         "methods": [
            {
               "name": "search_among_qualifiers", 
               "doc": {
                  "headline": "Execute this search among the given list of qualifiers.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    qualifier_ids (osid.id.IdList): list of qualifiers\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``qualifier_ids`` is ``null``", 
               "sphinx_param_doc": "        :param qualifier_ids: list of qualifiers\n        :type qualifier_ids: ``osid.id.IdList``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``qualifier_ids`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.IdList", 
                     "var_name": "qualifier_ids", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.IdList"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "order_qualifier_results", 
               "doc": {
                  "headline": "Specify an ordering to the search results.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    qualifier_search_order\n                (osid.authorization.QualifierSearchOrder): qualifier\n                search order\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``qualifier_search_order`` is ``null``\n        raise:  Unsupported - ``qualifier_search_order`` is not of this\n                service", 
               "sphinx_param_doc": "        :param qualifier_search_order: qualifier search order\n        :type qualifier_search_order: ``osid.authorization.QualifierSearchOrder``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``qualifier_search_order`` is ``null``\n        :raise: ``Unsupported`` -- ``qualifier_search_order`` is not of this service", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.authorization.QualifierSearchOrder", 
                     "var_name": "qualifier_search_order", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.authorization.QualifierSearchOrder"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_qualifier_search_record", 
               "doc": {
                  "headline": "Gets the qualifier search record corresponding to the given qualifier search record ``Type``.", 
                  "body": "        This method is used to retrieve an object implementing the\n        requested record."
               }, 
               "arg_doc": "        arg:    qualifier_search_record_type (osid.type.Type): a\n                qualifier search record type\n", 
               "return_doc": "        return: (osid.authorization.records.QualifierSearchRecord) - the\n                qualifier search record", 
               "error_doc": "        raise:  NullArgument - ``qualifier_search_record_type`` is\n                ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unsupported -\n                ``has_record_type(qualifier_search_record_type)`` is\n                ``false``", 
               "sphinx_param_doc": "        :param qualifier_search_record_type: a qualifier search record type\n        :type qualifier_search_record_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "        :return: the qualifier search record\n        :rtype: ``osid.authorization.records.QualifierSearchRecord``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``qualifier_search_record_type`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unsupported`` -- ``has_record_type(qualifier_search_record_type)`` is ``false``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "qualifier_search_record_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "osid.authorization.records.QualifierSearchRecord", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.authorization.records.QualifierSearchRecord", 
         "shortname": "QualifierSearchRecord", 
         "category": "records", 
         "doc": {
            "headline": "A record for a ``QualifierSearch``.", 
            "body": "    The methods specified by the record type are available through the\n    underlying object."
         }, 
         "inherit_fullnames": [
            "osid.OsidRecord"
         ], 
         "inherit_shortnames": [
            "OsidRecord"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidRecord"
            }
         ], 
         "method_names": [], 
         "methods": []
      }, 
      {
         "fullname": "osid.authorization.QualifierSearchResults", 
         "shortname": "QualifierSearchResults", 
         "category": "searches", 
         "doc": {
            "headline": "This interface provides a means to capture results of a search.", 
            "body": ""
         }, 
         "inherit_fullnames": [
            "osid.OsidSearchResults"
         ], 
         "inherit_shortnames": [
            "OsidSearchResults"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidSearchResults"
            }
         ], 
         "method_names": [
            "get_qualifiers", 
            "get_qualifier_query_inspector", 
            "get_qualifier_search_results_record"
         ], 
         "methods": [
            {
               "name": "get_qualifiers", 
               "doc": {
                  "headline": "Gets the qualifier list resulting from the search.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.authorization.QualifierList) - the qualifier list", 
               "error_doc": "        raise:  IllegalState - list has already been retrieved", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the qualifier list\n        :rtype: ``osid.authorization.QualifierList``", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- list has already been retrieved", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.authorization.QualifierList", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract"
               }
            }, 
            {
               "name": "get_qualifier_query_inspector", 
               "doc": {
                  "headline": "Gets the inspector for the query to examine the terms used in the search.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.authorization.QualifierQueryInspector) - the query\n                inspector", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the query inspector\n        :rtype: ``osid.authorization.QualifierQueryInspector``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.authorization.QualifierQueryInspector", 
               "errors": {}
            }, 
            {
               "name": "get_qualifier_search_results_record", 
               "doc": {
                  "headline": "Gets the qualifier search results record corresponding to the given qualifier search record ``Type``.", 
                  "body": "        This method is used to retrieve an object implementing the\n        requested record."
               }, 
               "arg_doc": "        arg:    qualifier_search_record_type (osid.type.Type): a\n                qualifier search record type\n", 
               "return_doc": "        return:\n                (osid.authorization.records.QualifierSearchResultsRecord\n                ) - the qualifier search results record", 
               "error_doc": "        raise:  NullArgument - ``qualifier_search_record_type`` is\n                ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unsupported -\n                ``has_record_type(qualifier_search_record_type)`` is\n                ``false``", 
               "sphinx_param_doc": "        :param qualifier_search_record_type: a qualifier search record type\n        :type qualifier_search_record_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "        :return: the qualifier search results record\n        :rtype: ``osid.authorization.records.QualifierSearchResultsRecord``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``qualifier_search_record_type`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unsupported`` -- ``has_record_type(qualifier_search_record_type)`` is ``false``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "qualifier_search_record_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "osid.authorization.records.QualifierSearchResultsRecord", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.authorization.records.QualifierSearchResultsRecord", 
         "shortname": "QualifierSearchResultsRecord", 
         "category": "records", 
         "doc": {
            "headline": "A record for a ``QualifierSearchResults``.", 
            "body": "    The methods specified by the record type are available through the\n    underlying object."
         }, 
         "inherit_fullnames": [
            "osid.OsidRecord"
         ], 
         "inherit_shortnames": [
            "OsidRecord"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidRecord"
            }
         ], 
         "method_names": [], 
         "methods": []
      }, 
      {
         "fullname": "osid.authorization.QualifierReceiver", 
         "shortname": "QualifierReceiver", 
         "category": "receivers", 
         "doc": {
            "headline": "The qualifier receiver is the consumer supplied interface for receiving notifications pertaining to new, updated or deleted ``Qualifier`` objects.", 
            "body": ""
         }, 
         "inherit_fullnames": [
            "osid.OsidReceiver"
         ], 
         "inherit_shortnames": [
            "OsidReceiver"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidReceiver"
            }
         ], 
         "method_names": [
            "new_qualifier", 
            "new_ancestor_qualifier", 
            "new_descendant_qualifier", 
            "changed_qualifier", 
            "deleted_qualifier", 
            "deleted_ancestor_qualifier", 
            "deleted_descendant_qualifier"
         ], 
         "methods": [
            {
               "name": "new_qualifier", 
               "doc": {
                  "headline": "The callback for notifications of new qualifiers.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    qualifier_id (osid.id.Id): the ``Id`` of the new\n                ``Qualifier``\n", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "        :param qualifier_id: the ``Id`` of the new ``Qualifier``\n        :type qualifier_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "qualifier_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "new_ancestor_qualifier", 
               "doc": {
                  "headline": "The callback for notifications of new qualifier ancestors.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    qualifier_id (osid.id.Id): the ``Id`` of the\n                ``Qualifier``\n        arg:    ancestor_id (osid.id.Id): the ``Id`` of the new\n                ``Qualifier`` ancestor\n", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "        :param qualifier_id: the ``Id`` of the ``Qualifier``\n        :type qualifier_id: ``osid.id.Id``\n        :param ancestor_id: the ``Id`` of the new ``Qualifier`` ancestor\n        :type ancestor_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "qualifier_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "ancestor_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "new_descendant_qualifier", 
               "doc": {
                  "headline": "The callback for notifications of new qualifier descendants.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    qualifier_id (osid.id.Id): the ``Id`` of the\n                ``Qualifier``\n        arg:    descendant_id (osid.id.Id): the ``Id`` of the new\n                ``Qualifier`` descendant\n", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "        :param qualifier_id: the ``Id`` of the ``Qualifier``\n        :type qualifier_id: ``osid.id.Id``\n        :param descendant_id: the ``Id`` of the new ``Qualifier`` descendant\n        :type descendant_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "qualifier_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "descendant_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "changed_qualifier", 
               "doc": {
                  "headline": "The callback for notification of updated qualifiers.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    qualifier_id (osid.id.Id): the ``Id`` of the updated\n                ``Qualifier``\n", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "        :param qualifier_id: the ``Id`` of the updated ``Qualifier``\n        :type qualifier_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "qualifier_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "deleted_qualifier", 
               "doc": {
                  "headline": "the callback for notification of deleted qualifiers.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    qualifier_id (osid.id.Id): the ``Id`` of the deleted\n                ``Qualifier``\n", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "        :param qualifier_id: the ``Id`` of the deleted ``Qualifier``\n        :type qualifier_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "qualifier_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "deleted_ancestor_qualifier", 
               "doc": {
                  "headline": "The callback for notifications of deleted qualifier ancestors.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    qualifier_id (osid.id.Id): the ``Id`` of the\n                ``Qualifier``\n        arg:    ancestor_id (osid.id.Id): the ``Id`` of the removed\n                ``Qualifier`` ancestor\n", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "        :param qualifier_id: the ``Id`` of the ``Qualifier``\n        :type qualifier_id: ``osid.id.Id``\n        :param ancestor_id: the ``Id`` of the removed ``Qualifier`` ancestor\n        :type ancestor_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "qualifier_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "ancestor_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "deleted_descendant_qualifier", 
               "doc": {
                  "headline": "The callback for notifications of deleted qualifier descendants.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    qualifier_id (osid.id.Id): the ``Id`` of the\n                ``Qualifier``\n        arg:    descendant_id (osid.id.Id): the ``Id`` of the removed\n                ``Qualifier`` descendant\n", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "        :param qualifier_id: the ``Id`` of the ``Qualifier``\n        :type qualifier_id: ``osid.id.Id``\n        :param descendant_id: the ``Id`` of the removed ``Qualifier`` descendant\n        :type descendant_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "qualifier_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "descendant_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {}
            }
         ]
      }, 
      {
         "fullname": "osid.authorization.QualifierList", 
         "shortname": "QualifierList", 
         "category": "objects", 
         "doc": {
            "headline": "Like all ``OsidLists,``  ``QualifierList`` provides a means for accessing ``Qualifier`` elements sequentially either one at a time or many at a time.", 
            "body": "    Examples: while (ql.hasNext()) { Qualifier qualifier =\n    ql.getNextQualifier(); }\n\n    or\n      while (ql.hasNext()) {\n           Qualifier[] qualifiers = ql.hetNextQualifiers(ql.available());\n      }\n    \n"
         }, 
         "inherit_fullnames": [
            "osid.OsidList"
         ], 
         "inherit_shortnames": [
            "OsidList"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidList"
            }
         ], 
         "method_names": [
            "get_next_qualifier", 
            "get_next_qualifiers"
         ], 
         "methods": [
            {
               "name": "get_next_qualifier", 
               "doc": {
                  "headline": "Gets the next ``Qualifier`` in this list.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.authorization.Qualifier) - the next ``Qualifier``\n                in this list. The ``has_next()`` method should be used\n                to test that a next ``Qualifier`` is available before\n                calling this method.", 
               "error_doc": "        raise:  IllegalState - no more elements available in this list\n        raise:  OperationFailed - unable to complete request", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the next ``Qualifier`` in this list. The ``has_next()`` method should be used to test that a next ``Qualifier`` is available before calling this method.\n        :rtype: ``osid.authorization.Qualifier``", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- no more elements available in this list\n        :raise: ``OperationFailed`` -- unable to complete request", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.authorization.Qualifier", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational"
               }
            }, 
            {
               "name": "get_next_qualifiers", 
               "doc": {
                  "headline": "Gets the next set of ``Qualifier`` elements in this list which must be less than or equal to the number returned from ``available()``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    n (cardinal): the number of ``Qualifier`` elements\n                requested which should be less than or equal to\n                ``available()``\n", 
               "return_doc": "        return: (osid.authorization.Qualifier) - an array of\n                ``Qualifier`` elements.The length of the array is less\n                than or equal to the number specified.", 
               "error_doc": "        raise:  IllegalState - no more elements available in this list\n        raise:  OperationFailed - unable to complete request", 
               "sphinx_param_doc": "        :param n: the number of ``Qualifier`` elements requested which should be less than or equal to ``available()``\n        :type n: ``cardinal``\n", 
               "sphinx_return_doc": "        :return: an array of ``Qualifier`` elements.The length of the array is less than or equal to the number specified.\n        :rtype: ``osid.authorization.Qualifier``", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- no more elements available in this list\n        :raise: ``OperationFailed`` -- unable to complete request", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "cardinal", 
                     "var_name": "n", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "cardinal"
               ], 
               "return_type": "osid.authorization.Qualifier", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.authorization.QualifierNode", 
         "shortname": "QualifierNode", 
         "category": "objects", 
         "doc": {
            "headline": "This interface is a container for a partial hierarchy retrieval.", 
            "body": "    The number of hierarchy levels traversable through this interface\n    depend on the number of levels requested in the\n    ``QualifierHierarchySession``."
         }, 
         "inherit_fullnames": [
            "osid.OsidNode"
         ], 
         "inherit_shortnames": [
            "OsidNode"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidNode"
            }
         ], 
         "method_names": [
            "get_qualifier", 
            "get_parent_qualifier_nodes", 
            "get_child_qualifier_nodes"
         ], 
         "methods": [
            {
               "name": "get_qualifier", 
               "doc": {
                  "headline": "Gets the ``Qualifier`` at this node.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.authorization.Qualifier) - the qualifier\n                represented by this node", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the qualifier represented by this node\n        :rtype: ``osid.authorization.Qualifier``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.authorization.Qualifier", 
               "errors": {}
            }, 
            {
               "name": "get_parent_qualifier_nodes", 
               "doc": {
                  "headline": "Gets the parents of this qualifier.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.authorization.QualifierNodeList) - the parents of\n                this qualifier", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the parents of this qualifier\n        :rtype: ``osid.authorization.QualifierNodeList``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.authorization.QualifierNodeList", 
               "errors": {}
            }, 
            {
               "name": "get_child_qualifier_nodes", 
               "doc": {
                  "headline": "Gets the children of this qualifier.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.authorization.QualifierNodeList) - the children of\n                this qualifier", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the children of this qualifier\n        :rtype: ``osid.authorization.QualifierNodeList``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.authorization.QualifierNodeList", 
               "errors": {}
            }
         ]
      }, 
      {
         "fullname": "osid.authorization.QualifierNodeList", 
         "shortname": "QualifierNodeList", 
         "category": "objects", 
         "doc": {
            "headline": "Like all ``OsidLists,``  ``QualifierNodeList`` provides a means for accessing ``QualifierNode`` elements sequentially either one at a time or many at a time.", 
            "body": "    Examples: while (qnl.hasNext()) { QualifierNode node =\n    qnl.getNextQualifierNode(); }\n\n    or\n      while (qnl.hasNext()) {\n           QualifierNode[] nodes = qnl.hetNextQualifierNodes(qnl.available());\n      }\n    \n"
         }, 
         "inherit_fullnames": [
            "osid.OsidList"
         ], 
         "inherit_shortnames": [
            "OsidList"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidList"
            }
         ], 
         "method_names": [
            "get_next_qualifier_node", 
            "get_next_qualifier_nodes"
         ], 
         "methods": [
            {
               "name": "get_next_qualifier_node", 
               "doc": {
                  "headline": "Gets the next ``QualifierNode`` in this list.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.authorization.QualifierNode) - the next\n                ``QualifierNode`` in this list. The ``has_next()``\n                method should be used to test that a next\n                ``QualifierNode`` is available before calling this\n                method.", 
               "error_doc": "        raise:  IllegalState - no more elements available in this list\n        raise:  OperationFailed - unable to complete request", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the next ``QualifierNode`` in this list. The ``has_next()`` method should be used to test that a next ``QualifierNode`` is available before calling this method.\n        :rtype: ``osid.authorization.QualifierNode``", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- no more elements available in this list\n        :raise: ``OperationFailed`` -- unable to complete request", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.authorization.QualifierNode", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational"
               }
            }, 
            {
               "name": "get_next_qualifier_nodes", 
               "doc": {
                  "headline": "Gets the next set of ``QualifierNode`` elements in this list which must be less than or equal to the number returned from ``available()``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    n (cardinal): the number of ``QualifierNode`` elements\n                requested which should be less than or equal to\n                ``available()``\n", 
               "return_doc": "        return: (osid.authorization.QualifierNode) - an array of\n                ``QualifierNode`` elements.The length of the array is\n                less than or equal to the number specified.", 
               "error_doc": "        raise:  IllegalState - no more elements available in this list\n        raise:  OperationFailed - unable to complete request", 
               "sphinx_param_doc": "        :param n: the number of ``QualifierNode`` elements requested which should be less than or equal to ``available()``\n        :type n: ``cardinal``\n", 
               "sphinx_return_doc": "        :return: an array of ``QualifierNode`` elements.The length of the array is less than or equal to the number specified.\n        :rtype: ``osid.authorization.QualifierNode``", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- no more elements available in this list\n        :raise: ``OperationFailed`` -- unable to complete request", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "cardinal", 
                     "var_name": "n", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "cardinal"
               ], 
               "return_type": "osid.authorization.QualifierNode", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.authorization.Vault", 
         "shortname": "Vault", 
         "category": "objects", 
         "doc": {
            "headline": "A vault defines a collection of authorizations and functions.", 
            "body": ""
         }, 
         "inherit_fullnames": [
            "osid.OsidCatalog"
         ], 
         "inherit_shortnames": [
            "OsidCatalog"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidCatalog"
            }
         ], 
         "method_names": [
            "get_vault_record"
         ], 
         "methods": [
            {
               "name": "get_vault_record", 
               "doc": {
                  "headline": "Gets the vault record corresponding to the given ``Vault`` record ``Type``.", 
                  "body": "        This method is used to retrieve an object implementing the\n        requested record. The ``vault_record_type`` may be the ``Type``\n        returned in ``get_record_types()`` or any of its parents in a\n        ``Type`` hierarchy where ``has_record_type(vault_record_type)``\n        is ``true`` ."
               }, 
               "arg_doc": "        arg:    vault_record_type (osid.type.Type): a vault record type\n", 
               "return_doc": "        return: (osid.authorization.records.VaultRecord) - the vault\n                record", 
               "error_doc": "        raise:  NullArgument - ``vault_record_type`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unsupported - ``has_record_type(vault_record_type)`` is\n                ``false``", 
               "sphinx_param_doc": "        :param vault_record_type: a vault record type\n        :type vault_record_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "        :return: the vault record\n        :rtype: ``osid.authorization.records.VaultRecord``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``vault_record_type`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unsupported`` -- ``has_record_type(vault_record_type)`` is ``false``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "vault_record_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "osid.authorization.records.VaultRecord", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.authorization.records.VaultRecord", 
         "shortname": "VaultRecord", 
         "category": "records", 
         "doc": {
            "headline": "A record for a ``Vault``.", 
            "body": "    The methods specified by the record type are available through the\n    underlying object."
         }, 
         "inherit_fullnames": [
            "osid.OsidRecord"
         ], 
         "inherit_shortnames": [
            "OsidRecord"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidRecord"
            }
         ], 
         "method_names": [], 
         "methods": []
      }, 
      {
         "fullname": "osid.authorization.VaultQuery", 
         "shortname": "VaultQuery", 
         "category": "queries", 
         "doc": {
            "headline": "This is the query for searching vaults.", 
            "body": "    Each method specifies an ``AND`` term while multiple invocations of\n    the same method produce a nested ``OR``."
         }, 
         "inherit_fullnames": [
            "osid.OsidCatalogQuery"
         ], 
         "inherit_shortnames": [
            "OsidCatalogQuery"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidCatalogQuery"
            }
         ], 
         "method_names": [
            "match_function_id", 
            "clear_function_id_terms", 
            "supports_function_query", 
            "get_function_query", 
            "match_any_function", 
            "clear_function_terms", 
            "match_qualifier_id", 
            "clear_qualifier_id_terms", 
            "supports_qualifier_query", 
            "get_qualifier_query", 
            "match_any_qualifier", 
            "clear_qualifier_terms", 
            "match_authorization_id", 
            "clear_authorization_id_terms", 
            "supports_authorization_query", 
            "get_authorization_query", 
            "match_any_authorization", 
            "clear_authorization_terms", 
            "match_ancestor_vault_id", 
            "clear_ancestor_vault_id_terms", 
            "supports_ancestor_vault_query", 
            "get_ancestor_vault_query", 
            "match_any_ancestor_vault", 
            "clear_ancestor_vault_terms", 
            "match_descendant_vault_id", 
            "clear_descendant_vault_id_terms", 
            "supports_descendant_vault_query", 
            "get_descendant_vault_query", 
            "match_any_descendant_vault", 
            "clear_descendant_vault_terms", 
            "get_vault_query_record"
         ], 
         "methods": [
            {
               "name": "match_function_id", 
               "doc": {
                  "headline": "Sets the function ``Id`` for this query.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    function_id (osid.id.Id): a function ``Id``\n        arg:    match (boolean): ``true`` for a positive match,\n                ``false`` for a negative match\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``function_id`` is ``null``", 
               "sphinx_param_doc": "        :param function_id: a function ``Id``\n        :type function_id: ``osid.id.Id``\n        :param match: ``true`` for a positive match, ``false`` for a negative match\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``function_id`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "function_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "clear_function_id_terms", 
               "doc": {
                  "headline": "Clears the function ``Id`` query terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "supports_function_query", 
               "doc": {
                  "headline": "Tests if a ``FunctionQuery`` is available.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if a function query is available,\n                ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if a function query is available, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "get_function_query", 
               "doc": {
                  "headline": "Gets the query for a function.", 
                  "body": "        Multiple retrievals produce a nested ``OR`` term."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.authorization.FunctionQuery) - the function query", 
               "error_doc": "        raise:  Unimplemented - ``supports_function_query()`` is\n                ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the function query\n        :rtype: ``osid.authorization.FunctionQuery``", 
               "sphinx_error_doc": "        :raise: ``Unimplemented`` -- ``supports_function_query()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_function_query()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.authorization.FunctionQuery", 
               "errors": {
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "match_any_function", 
               "doc": {
                  "headline": "Matches vaults that have any function.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    match (boolean): ``true`` to match vaults with any\n                function mapping, ``false`` to match vaults with no\n                function mapping\n", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "        :param match: ``true`` to match vaults with any function mapping, ``false`` to match vaults with no function mapping\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "clear_function_terms", 
               "doc": {
                  "headline": "Clears the function query terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "match_qualifier_id", 
               "doc": {
                  "headline": "Sets the qualifier ``Id`` for this query.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    qualifier_id (osid.id.Id): a qualifier ``Id``\n        arg:    match (boolean): ``true`` for a positive match,\n                ``false`` for a negative match\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``qualifier_id`` is ``null``", 
               "sphinx_param_doc": "        :param qualifier_id: a qualifier ``Id``\n        :type qualifier_id: ``osid.id.Id``\n        :param match: ``true`` for a positive match, ``false`` for a negative match\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``qualifier_id`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "qualifier_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "clear_qualifier_id_terms", 
               "doc": {
                  "headline": "Clears the qualifier ``Id`` query terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "supports_qualifier_query", 
               "doc": {
                  "headline": "Tests if a ``QualifierQuery`` is available.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if a qualifier query is available,\n                ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if a qualifier query is available, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "get_qualifier_query", 
               "doc": {
                  "headline": "Gets the query for a qualifier.", 
                  "body": "        Multiple retrievals produce a nested ``OR`` term."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.authorization.QualifierQuery) - the qualifier\n                query", 
               "error_doc": "        raise:  Unimplemented - ``supports_qualifier_query()`` is\n                ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the qualifier query\n        :rtype: ``osid.authorization.QualifierQuery``", 
               "sphinx_error_doc": "        :raise: ``Unimplemented`` -- ``supports_qualifier_query()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_qualifier_query()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.authorization.QualifierQuery", 
               "errors": {
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "match_any_qualifier", 
               "doc": {
                  "headline": "Matches vaults that have any qualifier.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    match (boolean): ``true`` to match vaults with any\n                qualifier mapping, ``false`` to match vaults with no\n                qualifier mapping\n", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "        :param match: ``true`` to match vaults with any qualifier mapping, ``false`` to match vaults with no qualifier mapping\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "clear_qualifier_terms", 
               "doc": {
                  "headline": "Clears the qualifier query terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "match_authorization_id", 
               "doc": {
                  "headline": "Sets the authorization ``Id`` for this query.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    authorization_id (osid.id.Id): an authorization ``Id``\n        arg:    match (boolean): ``true`` for a positive match,\n                ``false`` for a negative match\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``authorization_id`` is ``null``", 
               "sphinx_param_doc": "        :param authorization_id: an authorization ``Id``\n        :type authorization_id: ``osid.id.Id``\n        :param match: ``true`` for a positive match, ``false`` for a negative match\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``authorization_id`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "authorization_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "clear_authorization_id_terms", 
               "doc": {
                  "headline": "Clears the authorization ``Id`` query terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "supports_authorization_query", 
               "doc": {
                  "headline": "Tests if an ``AuthorizationQuery`` is available.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if an authorization query is\n                available, ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if an authorization query is available, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "get_authorization_query", 
               "doc": {
                  "headline": "Gets the query for an authorization.", 
                  "body": "        Multiple retrievals produce a nested ``OR`` term."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.authorization.AuthorizationQuery) - the\n                authorization query", 
               "error_doc": "        raise:  Unimplemented - ``supports_authorization_query()`` is\n                ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the authorization query\n        :rtype: ``osid.authorization.AuthorizationQuery``", 
               "sphinx_error_doc": "        :raise: ``Unimplemented`` -- ``supports_authorization_query()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_authorization_query()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.authorization.AuthorizationQuery", 
               "errors": {
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "match_any_authorization", 
               "doc": {
                  "headline": "Matches vaults that have any authorization.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    match (boolean): ``true`` to match vaults with any\n                authorization mapping, ``false`` to match vaults with no\n                authorization mapping\n", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "        :param match: ``true`` to match vaults with any authorization mapping, ``false`` to match vaults with no authorization mapping\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "clear_authorization_terms", 
               "doc": {
                  "headline": "Clears the authorization query terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "match_ancestor_vault_id", 
               "doc": {
                  "headline": "Sets the vault ``Id`` for this query to match vaults that have the specified vault as an ancestor.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    vault_id (osid.id.Id): a vault ``Id``\n        arg:    match (boolean): ``true`` for a positive match,\n                ``false`` for a negative match\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``vault_id`` is ``null``", 
               "sphinx_param_doc": "        :param vault_id: a vault ``Id``\n        :type vault_id: ``osid.id.Id``\n        :param match: ``true`` for a positive match, ``false`` for a negative match\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``vault_id`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "vault_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "clear_ancestor_vault_id_terms", 
               "doc": {
                  "headline": "Clears the ancestor vault ``Id`` query terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "supports_ancestor_vault_query", 
               "doc": {
                  "headline": "Tests if a ``VaultQuery`` is available.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if a vault query is available,\n                ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if a vault query is available, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "get_ancestor_vault_query", 
               "doc": {
                  "headline": "Gets the query for a vault.", 
                  "body": "        Multiple retrievals produce a nested ``OR`` term."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.authorization.VaultQuery) - the vault query", 
               "error_doc": "        raise:  Unimplemented - ``supports_ancestor_vault_query()`` is\n                ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the vault query\n        :rtype: ``osid.authorization.VaultQuery``", 
               "sphinx_error_doc": "        :raise: ``Unimplemented`` -- ``supports_ancestor_vault_query()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_ancestor_vault_query()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.authorization.VaultQuery", 
               "errors": {
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "match_any_ancestor_vault", 
               "doc": {
                  "headline": "Matches vaults that have any ancestor.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    match (boolean): ``true`` to match vaults with any\n                ancestor, ``false`` to match root vaults\n", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "        :param match: ``true`` to match vaults with any ancestor, ``false`` to match root vaults\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "clear_ancestor_vault_terms", 
               "doc": {
                  "headline": "Clears the ancestor vault query terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "match_descendant_vault_id", 
               "doc": {
                  "headline": "Sets the vault ``Id`` for this query to match vaults that have the specified vault as a descendant.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    vault_id (osid.id.Id): a vault ``Id``\n        arg:    match (boolean): ``true`` for a positive match,\n                ``false`` for negative match\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``vault_id`` is ``null``", 
               "sphinx_param_doc": "        :param vault_id: a vault ``Id``\n        :type vault_id: ``osid.id.Id``\n        :param match: ``true`` for a positive match, ``false`` for negative match\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``vault_id`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "vault_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "clear_descendant_vault_id_terms", 
               "doc": {
                  "headline": "Clears the descendant vault ``Id`` query terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "supports_descendant_vault_query", 
               "doc": {
                  "headline": "Tests if a ``VaultQuery`` is available.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if a vault query is available,\n                ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if a vault query is available, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "get_descendant_vault_query", 
               "doc": {
                  "headline": "Gets the query for a vault.", 
                  "body": "        Multiple retrievals produce a nested ``OR`` term."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.authorization.VaultQuery) - the vault query", 
               "error_doc": "        raise:  Unimplemented - ``supports_descendant_vault_query()`` is\n                ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the vault query\n        :rtype: ``osid.authorization.VaultQuery``", 
               "sphinx_error_doc": "        :raise: ``Unimplemented`` -- ``supports_descendant_vault_query()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_descendant_vault_query()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.authorization.VaultQuery", 
               "errors": {
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "match_any_descendant_vault", 
               "doc": {
                  "headline": "Matches vaults that have any descendant.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    match (boolean): ``true`` to match vaults with any\n                Ddscendant, ``false`` to match leaf vaults\n", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "        :param match: ``true`` to match vaults with any Ddscendant, ``false`` to match leaf vaults\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "clear_descendant_vault_terms", 
               "doc": {
                  "headline": "Clears the descendant vault query terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "get_vault_query_record", 
               "doc": {
                  "headline": "Gets the vault query record corresponding to the given ``Vault`` record ``Type``.", 
                  "body": "        Multiple record retrievals produce a nested ``OR`` term."
               }, 
               "arg_doc": "        arg:    vault_record_type (osid.type.Type): a vault record type\n", 
               "return_doc": "        return: (osid.authorization.records.VaultQueryRecord) - the\n                vault query record", 
               "error_doc": "        raise:  NullArgument - ``vault_record_type`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unsupported - ``has_record_type(vault_record_type)`` is\n                ``false``", 
               "sphinx_param_doc": "        :param vault_record_type: a vault record type\n        :type vault_record_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "        :return: the vault query record\n        :rtype: ``osid.authorization.records.VaultQueryRecord``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``vault_record_type`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unsupported`` -- ``has_record_type(vault_record_type)`` is ``false``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "vault_record_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "osid.authorization.records.VaultQueryRecord", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.authorization.records.VaultQueryRecord", 
         "shortname": "VaultQueryRecord", 
         "category": "records", 
         "doc": {
            "headline": "A record for a ``VaultQuery``.", 
            "body": "    The methods specified by the record type are available through the\n    underlying object."
         }, 
         "inherit_fullnames": [
            "osid.OsidRecord"
         ], 
         "inherit_shortnames": [
            "OsidRecord"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidRecord"
            }
         ], 
         "method_names": [], 
         "methods": []
      }, 
      {
         "fullname": "osid.authorization.VaultQueryInspector", 
         "shortname": "VaultQueryInspector", 
         "category": "query_inspectors", 
         "doc": {
            "headline": "This is the query inspector for examining vault queries.", 
            "body": ""
         }, 
         "inherit_fullnames": [
            "osid.OsidCatalogQueryInspector"
         ], 
         "inherit_shortnames": [
            "OsidCatalogQueryInspector"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidCatalogQueryInspector"
            }
         ], 
         "method_names": [
            "get_function_id_terms", 
            "get_function_terms", 
            "get_qualifier_id_terms", 
            "get_qualifier_terms", 
            "get_authorization_id_terms", 
            "get_authorization_terms", 
            "get_ancestor_vault_id_terms", 
            "get_ancestor_vault_terms", 
            "get_descendant_vault_id_terms", 
            "get_descendant_vault_terms", 
            "get_vault_query_inspector_record"
         ], 
         "methods": [
            {
               "name": "get_function_id_terms", 
               "doc": {
                  "headline": "Gets the function ``Id`` query terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.search.terms.IdTerm) - the query terms", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the query terms\n        :rtype: ``osid.search.terms.IdTerm``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.search.terms.IdTerm", 
               "errors": {}
            }, 
            {
               "name": "get_function_terms", 
               "doc": {
                  "headline": "Gets the function query terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.authorization.FunctionQueryInspector) - the query\n                terms", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the query terms\n        :rtype: ``osid.authorization.FunctionQueryInspector``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.authorization.FunctionQueryInspector", 
               "errors": {}
            }, 
            {
               "name": "get_qualifier_id_terms", 
               "doc": {
                  "headline": "Gets the qualifier ``Id`` query terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.search.terms.IdTerm) - the query terms", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the query terms\n        :rtype: ``osid.search.terms.IdTerm``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.search.terms.IdTerm", 
               "errors": {}
            }, 
            {
               "name": "get_qualifier_terms", 
               "doc": {
                  "headline": "Gets the qualifier query terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.authorization.QualifierQueryInspector) - the query\n                terms", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the query terms\n        :rtype: ``osid.authorization.QualifierQueryInspector``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.authorization.QualifierQueryInspector", 
               "errors": {}
            }, 
            {
               "name": "get_authorization_id_terms", 
               "doc": {
                  "headline": "Gets the authorization ``Id`` query terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.search.terms.IdTerm) - the query terms", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the query terms\n        :rtype: ``osid.search.terms.IdTerm``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.search.terms.IdTerm", 
               "errors": {}
            }, 
            {
               "name": "get_authorization_terms", 
               "doc": {
                  "headline": "Gets the authorization query terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.authorization.AuthorizationQueryInspector) - the\n                query terms", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the query terms\n        :rtype: ``osid.authorization.AuthorizationQueryInspector``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.authorization.AuthorizationQueryInspector", 
               "errors": {}
            }, 
            {
               "name": "get_ancestor_vault_id_terms", 
               "doc": {
                  "headline": "Gets the ancestor vault ``Id`` query terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.search.terms.IdTerm) - the query terms", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the query terms\n        :rtype: ``osid.search.terms.IdTerm``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.search.terms.IdTerm", 
               "errors": {}
            }, 
            {
               "name": "get_ancestor_vault_terms", 
               "doc": {
                  "headline": "Gets the ancestor vault query terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.authorization.VaultQueryInspector) - the query\n                terms", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the query terms\n        :rtype: ``osid.authorization.VaultQueryInspector``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.authorization.VaultQueryInspector", 
               "errors": {}
            }, 
            {
               "name": "get_descendant_vault_id_terms", 
               "doc": {
                  "headline": "Gets the descendant vault ``Id`` query terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.search.terms.IdTerm) - the query terms", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the query terms\n        :rtype: ``osid.search.terms.IdTerm``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.search.terms.IdTerm", 
               "errors": {}
            }, 
            {
               "name": "get_descendant_vault_terms", 
               "doc": {
                  "headline": "Gets the descendant vault query terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.authorization.VaultQueryInspector) - the query\n                terms", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the query terms\n        :rtype: ``osid.authorization.VaultQueryInspector``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.authorization.VaultQueryInspector", 
               "errors": {}
            }, 
            {
               "name": "get_vault_query_inspector_record", 
               "doc": {
                  "headline": "Gets the vault query inspector record corresponding to the given ``Vault`` record ``Type``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    vault_record_type (osid.type.Type): a vault query\n                inspector record type\n", 
               "return_doc": "        return: (osid.authorization.records.VaultQueryInspectorRecord) -\n                the vault query inspector record", 
               "error_doc": "        raise:  NullArgument - ``vault_record_type`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unsupported - ``has_record_type(vault_record_type)`` is\n                ``false``", 
               "sphinx_param_doc": "        :param vault_record_type: a vault query inspector record type\n        :type vault_record_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "        :return: the vault query inspector record\n        :rtype: ``osid.authorization.records.VaultQueryInspectorRecord``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``vault_record_type`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unsupported`` -- ``has_record_type(vault_record_type)`` is ``false``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "vault_record_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "osid.authorization.records.VaultQueryInspectorRecord", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.authorization.records.VaultQueryInspectorRecord", 
         "shortname": "VaultQueryInspectorRecord", 
         "category": "records", 
         "doc": {
            "headline": "A record for a ``VaultQueryInspector``.", 
            "body": "    The methods specified by the record type are available through the\n    underlying object."
         }, 
         "inherit_fullnames": [
            "osid.OsidRecord"
         ], 
         "inherit_shortnames": [
            "OsidRecord"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidRecord"
            }
         ], 
         "method_names": [], 
         "methods": []
      }, 
      {
         "fullname": "osid.authorization.VaultForm", 
         "shortname": "VaultForm", 
         "category": "objects", 
         "doc": {
            "headline": "This is the form for creating and updating vaults.", 
            "body": "    Like all ``OsidForm`` objects, various data elements may be set here\n    for use in the create and update methods in the\n    ``VaultAdminSession``. For each data element that may be set,\n    metadata may be examined to provide display hints or data\n    constraints."
         }, 
         "inherit_fullnames": [
            "osid.OsidCatalogForm"
         ], 
         "inherit_shortnames": [
            "OsidCatalogForm"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidCatalogForm"
            }
         ], 
         "method_names": [
            "get_vault_form_record"
         ], 
         "methods": [
            {
               "name": "get_vault_form_record", 
               "doc": {
                  "headline": "Gets the ``VaultFormRecord`` corresponding to the given vault record ``Type``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    vault_record_type (osid.type.Type): a vault record type\n", 
               "return_doc": "        return: (osid.authorization.records.VaultFormRecord) - the vault\n                form record", 
               "error_doc": "        raise:  NullArgument - ``vault_record_type`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unsupported - ``has_record_type(vault_record_type)`` is\n                ``false``", 
               "sphinx_param_doc": "        :param vault_record_type: a vault record type\n        :type vault_record_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "        :return: the vault form record\n        :rtype: ``osid.authorization.records.VaultFormRecord``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``vault_record_type`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unsupported`` -- ``has_record_type(vault_record_type)`` is ``false``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "vault_record_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "osid.authorization.records.VaultFormRecord", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.authorization.records.VaultFormRecord", 
         "shortname": "VaultFormRecord", 
         "category": "records", 
         "doc": {
            "headline": "A record for a ``VaultForm``.", 
            "body": "    The methods specified by the record type are available through the\n    underlying object."
         }, 
         "inherit_fullnames": [
            "osid.OsidRecord"
         ], 
         "inherit_shortnames": [
            "OsidRecord"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidRecord"
            }
         ], 
         "method_names": [], 
         "methods": []
      }, 
      {
         "fullname": "osid.authorization.VaultSearchOrder", 
         "shortname": "VaultSearchOrder", 
         "category": "search_orders", 
         "doc": {
            "headline": "An interface for specifying the ordering of search results.", 
            "body": ""
         }, 
         "inherit_fullnames": [
            "osid.OsidCatalogSearchOrder"
         ], 
         "inherit_shortnames": [
            "OsidCatalogSearchOrder"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidCatalogSearchOrder"
            }
         ], 
         "method_names": [
            "get_vault_search_order_record"
         ], 
         "methods": [
            {
               "name": "get_vault_search_order_record", 
               "doc": {
                  "headline": "Gets the vault search order record corresponding to the given vault record ``Type``.", 
                  "body": "        Multiple retrievals return the same underlying object."
               }, 
               "arg_doc": "        arg:    vault_record_type (osid.type.Type): a vault record type\n", 
               "return_doc": "        return: (osid.authorization.records.VaultSearchOrderRecord) -\n                the vault search order record", 
               "error_doc": "        raise:  NullArgument - ``vault_record_type`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unsupported - ``has_record_type(vault_record_type)`` is\n                ``false``", 
               "sphinx_param_doc": "        :param vault_record_type: a vault record type\n        :type vault_record_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "        :return: the vault search order record\n        :rtype: ``osid.authorization.records.VaultSearchOrderRecord``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``vault_record_type`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unsupported`` -- ``has_record_type(vault_record_type)`` is ``false``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "vault_record_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "osid.authorization.records.VaultSearchOrderRecord", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.authorization.records.VaultSearchOrderRecord", 
         "shortname": "VaultSearchOrderRecord", 
         "category": "records", 
         "doc": {
            "headline": "A record for a ``VaultSearchOrder``.", 
            "body": "    The methods specified by the record type are available through the\n    underlying object."
         }, 
         "inherit_fullnames": [
            "osid.OsidRecord"
         ], 
         "inherit_shortnames": [
            "OsidRecord"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidRecord"
            }
         ], 
         "method_names": [], 
         "methods": []
      }, 
      {
         "fullname": "osid.authorization.VaultSearch", 
         "shortname": "VaultSearch", 
         "category": "searches", 
         "doc": {
            "headline": "The interface for governing vault searches.", 
            "body": ""
         }, 
         "inherit_fullnames": [
            "osid.OsidSearch"
         ], 
         "inherit_shortnames": [
            "OsidSearch"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidSearch"
            }
         ], 
         "method_names": [
            "search_among_vaults", 
            "order_vault_results", 
            "get_vault_search_record"
         ], 
         "methods": [
            {
               "name": "search_among_vaults", 
               "doc": {
                  "headline": "Execute this search among the given list of vaults.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    vault_ids (osid.id.IdList): list of vaults\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``vault_ids`` is ``null``", 
               "sphinx_param_doc": "        :param vault_ids: list of vaults\n        :type vault_ids: ``osid.id.IdList``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``vault_ids`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.IdList", 
                     "var_name": "vault_ids", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.IdList"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "order_vault_results", 
               "doc": {
                  "headline": "Specify an ordering to the search results.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    vault_search_order\n                (osid.authorization.VaultSearchOrder): vault search\n                order\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``vault_search_order`` is ``null``\n        raise:  Unsupported - ``vault_search_order`` is not of this\n                service", 
               "sphinx_param_doc": "        :param vault_search_order: vault search order\n        :type vault_search_order: ``osid.authorization.VaultSearchOrder``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``vault_search_order`` is ``null``\n        :raise: ``Unsupported`` -- ``vault_search_order`` is not of this service", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.authorization.VaultSearchOrder", 
                     "var_name": "vault_search_order", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.authorization.VaultSearchOrder"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_vault_search_record", 
               "doc": {
                  "headline": "Gets the vault search record corresponding to the given vault search record ``Type``.", 
                  "body": "        This method is used to retrieve an object implementing the\n        requested record."
               }, 
               "arg_doc": "        arg:    vault_search_record_type (osid.type.Type): a vault\n                search record type\n", 
               "return_doc": "        return: (osid.authorization.records.VaultSearchRecord) - the\n                vault search record", 
               "error_doc": "        raise:  NullArgument - ``vault_search_record_type`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unsupported -\n                ``has_record_type(vault_search_record_type)`` is\n                ``false``", 
               "sphinx_param_doc": "        :param vault_search_record_type: a vault search record type\n        :type vault_search_record_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "        :return: the vault search record\n        :rtype: ``osid.authorization.records.VaultSearchRecord``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``vault_search_record_type`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unsupported`` -- ``has_record_type(vault_search_record_type)`` is ``false``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "vault_search_record_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "osid.authorization.records.VaultSearchRecord", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.authorization.records.VaultSearchRecord", 
         "shortname": "VaultSearchRecord", 
         "category": "records", 
         "doc": {
            "headline": "A record for a ``VaultSearch``.", 
            "body": "    The methods specified by the record type are available through the\n    underlying object."
         }, 
         "inherit_fullnames": [
            "osid.OsidRecord"
         ], 
         "inherit_shortnames": [
            "OsidRecord"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidRecord"
            }
         ], 
         "method_names": [], 
         "methods": []
      }, 
      {
         "fullname": "osid.authorization.VaultSearchResults", 
         "shortname": "VaultSearchResults", 
         "category": "searches", 
         "doc": {
            "headline": "This interface provides a means to capture results of a search.", 
            "body": ""
         }, 
         "inherit_fullnames": [
            "osid.OsidSearchResults"
         ], 
         "inherit_shortnames": [
            "OsidSearchResults"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidSearchResults"
            }
         ], 
         "method_names": [
            "get_vaults", 
            "get_vault_query_inspector", 
            "get_vault_search_results_record"
         ], 
         "methods": [
            {
               "name": "get_vaults", 
               "doc": {
                  "headline": "Gets the vault list resulting from the search.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.authorization.VaultList) - the vault list", 
               "error_doc": "        raise:  IllegalState - list has already been retrieved", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the vault list\n        :rtype: ``osid.authorization.VaultList``", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- list has already been retrieved", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.authorization.VaultList", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract"
               }
            }, 
            {
               "name": "get_vault_query_inspector", 
               "doc": {
                  "headline": "Gets the inspector for the query to examine the terms used in the search.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.authorization.VaultQueryInspector) - the vault\n                query inspector", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the vault query inspector\n        :rtype: ``osid.authorization.VaultQueryInspector``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.authorization.VaultQueryInspector", 
               "errors": {}
            }, 
            {
               "name": "get_vault_search_results_record", 
               "doc": {
                  "headline": "Gets the vault search results record corresponding to the given vault search record ``Type``.", 
                  "body": "        This method is used to retrieve an object implementing the\n        requested record."
               }, 
               "arg_doc": "        arg:    vault_search_record_type (osid.type.Type): a vault\n                search record type\n", 
               "return_doc": "        return: (osid.authorization.records.VaultSearchResultsRecord) -\n                the vault search results record", 
               "error_doc": "        raise:  NullArgument - ``vault_search_record_type`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unsupported -\n                ``has_record_type(vault_search_record_type)`` is\n                ``false``", 
               "sphinx_param_doc": "        :param vault_search_record_type: a vault search record type\n        :type vault_search_record_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "        :return: the vault search results record\n        :rtype: ``osid.authorization.records.VaultSearchResultsRecord``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``vault_search_record_type`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unsupported`` -- ``has_record_type(vault_search_record_type)`` is ``false``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "vault_search_record_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "osid.authorization.records.VaultSearchResultsRecord", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.authorization.records.VaultSearchResultsRecord", 
         "shortname": "VaultSearchResultsRecord", 
         "category": "records", 
         "doc": {
            "headline": "A record for a ``VaultSearchResults``.", 
            "body": "    The methods specified by the record type are available through the\n    underlying object."
         }, 
         "inherit_fullnames": [
            "osid.OsidRecord"
         ], 
         "inherit_shortnames": [
            "OsidRecord"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidRecord"
            }
         ], 
         "method_names": [], 
         "methods": []
      }, 
      {
         "fullname": "osid.authorization.VaultReceiver", 
         "shortname": "VaultReceiver", 
         "category": "receivers", 
         "doc": {
            "headline": "The vault receiver is the consumer supplied interface for receiving notifications pertaining to new, updated or deleted ``Vault`` objects.", 
            "body": ""
         }, 
         "inherit_fullnames": [
            "osid.OsidReceiver"
         ], 
         "inherit_shortnames": [
            "OsidReceiver"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidReceiver"
            }
         ], 
         "method_names": [
            "new_vault", 
            "new_ancestor_vault", 
            "new_descendant_vault", 
            "changed_vault", 
            "deleted_vault", 
            "deleted_ancestor_vault", 
            "deleted_descendant_vault"
         ], 
         "methods": [
            {
               "name": "new_vault", 
               "doc": {
                  "headline": "The callback for notifications of new vaults.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    vault_id (osid.id.Id): the ``Id`` of the new ``Vault``\n", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "        :param vault_id: the ``Id`` of the new ``Vault``\n        :type vault_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "vault_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "new_ancestor_vault", 
               "doc": {
                  "headline": "The callback for notifications of new vault ancestors.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    vault_id (osid.id.Id): the ``Id`` of the ``Vault``\n        arg:    ancestor_id (osid.id.Id):\n                ``has_record_type(vault_record_type) is false``\n", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "        :param vault_id: the ``Id`` of the ``Vault``\n        :type vault_id: ``osid.id.Id``\n        :param ancestor_id: ``has_record_type(vault_record_type) is false``\n        :type ancestor_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "vault_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "ancestor_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "new_descendant_vault", 
               "doc": {
                  "headline": "The callback for notifications of new vault descendants.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    vault_id (osid.id.Id): the ``Id`` of the ``Vault``\n        arg:    descendant_id (osid.id.Id): the ``Id`` of the new\n                ``Vault`` descendant\n", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "        :param vault_id: the ``Id`` of the ``Vault``\n        :type vault_id: ``osid.id.Id``\n        :param descendant_id: the ``Id`` of the new ``Vault`` descendant\n        :type descendant_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "vault_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "descendant_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "changed_vault", 
               "doc": {
                  "headline": "The callback for notification of updated vaults.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    vault_id (osid.id.Id): the ``Id`` of the updated\n                ``Vault``\n", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "        :param vault_id: the ``Id`` of the updated ``Vault``\n        :type vault_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "vault_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "deleted_vault", 
               "doc": {
                  "headline": "The callback for notification of deleted vaults.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    vault_id (osid.id.Id): the ``Id`` of the deleted\n                ``Vault``\n", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "        :param vault_id: the ``Id`` of the deleted ``Vault``\n        :type vault_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "vault_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "deleted_ancestor_vault", 
               "doc": {
                  "headline": "The callback for notifications of deleted vault ancestors.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    vault_id (osid.id.Id): the ``Id`` of the ``Vault``\n        arg:    ancestor_id (osid.id.Id): the ``Id`` of the removed\n                ``Vault`` ancestor\n", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "        :param vault_id: the ``Id`` of the ``Vault``\n        :type vault_id: ``osid.id.Id``\n        :param ancestor_id: the ``Id`` of the removed ``Vault`` ancestor\n        :type ancestor_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "vault_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "ancestor_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "deleted_descendant_vault", 
               "doc": {
                  "headline": "The callback for notifications of deleted vault descendants.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    vault_id (osid.id.Id): the ``Id`` of the ``Vault``\n        arg:    descendant_id (osid.id.Id): the ``Id`` of the removed\n                ``Vault`` descendant\n", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "        :param vault_id: the ``Id`` of the ``Vault``\n        :type vault_id: ``osid.id.Id``\n        :param descendant_id: the ``Id`` of the removed ``Vault`` descendant\n        :type descendant_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "vault_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "descendant_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {}
            }
         ]
      }, 
      {
         "fullname": "osid.authorization.VaultList", 
         "shortname": "VaultList", 
         "category": "objects", 
         "doc": {
            "headline": "Like all ``OsidLists,``  ``VaultList`` provides a means for accessing ``Vault`` elements sequentially either one at a time or many at a time.", 
            "body": "    Examples: while (vl.hasNext()) { Vault vault = vl.getNextVault(); }\n\n    or\n      while (vl.hasNext()) {\n           Vault[] vaults = vl.getNextVaults(vl.available());\n      }\n    \n"
         }, 
         "inherit_fullnames": [
            "osid.OsidList"
         ], 
         "inherit_shortnames": [
            "OsidList"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidList"
            }
         ], 
         "method_names": [
            "get_next_vault", 
            "get_next_vaults"
         ], 
         "methods": [
            {
               "name": "get_next_vault", 
               "doc": {
                  "headline": "Gets the next ``Vault`` in this list.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.authorization.Vault) - the next ``Vault`` in this\n                list. The ``has_next()`` method should be used to test\n                that a next ``Vault`` is available before calling this\n                method.", 
               "error_doc": "        raise:  IllegalState - no more elements available in this list\n        raise:  OperationFailed - unable to complete request", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the next ``Vault`` in this list. The ``has_next()`` method should be used to test that a next ``Vault`` is available before calling this method.\n        :rtype: ``osid.authorization.Vault``", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- no more elements available in this list\n        :raise: ``OperationFailed`` -- unable to complete request", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.authorization.Vault", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational"
               }
            }, 
            {
               "name": "get_next_vaults", 
               "doc": {
                  "headline": "Gets the next set of ``Vault`` elements in this list which must be less than or equal to the return from ``available()``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    n (cardinal): the number of ``Vault`` elements requested\n                which must be less than or equal to ``available()``\n", 
               "return_doc": "        return: (osid.authorization.Vault) - an array of ``Vault``\n                elements.The length of the array is less than or equal\n                to the number specified.", 
               "error_doc": "        raise:  IllegalState - no more elements available in this list\n        raise:  OperationFailed - unable to complete request", 
               "sphinx_param_doc": "        :param n: the number of ``Vault`` elements requested which must be less than or equal to ``available()``\n        :type n: ``cardinal``\n", 
               "sphinx_return_doc": "        :return: an array of ``Vault`` elements.The length of the array is less than or equal to the number specified.\n        :rtype: ``osid.authorization.Vault``", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- no more elements available in this list\n        :raise: ``OperationFailed`` -- unable to complete request", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "cardinal", 
                     "var_name": "n", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "cardinal"
               ], 
               "return_type": "osid.authorization.Vault", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.authorization.VaultNode", 
         "shortname": "VaultNode", 
         "category": "objects", 
         "doc": {
            "headline": "This interface is a container for a partial hierarchy retrieval.", 
            "body": "    The number of hierarchy levels traversable through this interface\n    depend on the number of levels requested in the\n    ``VaultHierarchySession``."
         }, 
         "inherit_fullnames": [
            "osid.OsidNode"
         ], 
         "inherit_shortnames": [
            "OsidNode"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidNode"
            }
         ], 
         "method_names": [
            "get_vault", 
            "get_parent_vault_nodes", 
            "get_child_vault_nodes"
         ], 
         "methods": [
            {
               "name": "get_vault", 
               "doc": {
                  "headline": "Gets the ``Vault`` at this node.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.authorization.Vault) - the vault represented by\n                this node", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the vault represented by this node\n        :rtype: ``osid.authorization.Vault``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.authorization.Vault", 
               "errors": {}
            }, 
            {
               "name": "get_parent_vault_nodes", 
               "doc": {
                  "headline": "Gets the parents of this vault.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.authorization.VaultNodeList) - the parents of this\n                vault", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the parents of this vault\n        :rtype: ``osid.authorization.VaultNodeList``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.authorization.VaultNodeList", 
               "errors": {}
            }, 
            {
               "name": "get_child_vault_nodes", 
               "doc": {
                  "headline": "Gets the children of this vault.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.authorization.VaultNodeList) - the children of\n                this vault", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the children of this vault\n        :rtype: ``osid.authorization.VaultNodeList``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.authorization.VaultNodeList", 
               "errors": {}
            }
         ]
      }, 
      {
         "fullname": "osid.authorization.VaultNodeList", 
         "shortname": "VaultNodeList", 
         "category": "objects", 
         "doc": {
            "headline": "Like all ``OsidLists,``  ``VaultNodeList`` provides a means for accessing ``VaultNode`` elements sequentially either one at a time or many at a time.", 
            "body": "    Examples: while (vnl.hasNext()) { VaultNode node =\n    vnl.getNextVaultNode(); }\n\n    or\n      while (vnl.hasNext()) {\n           VaultNode[] nodes = vnl.getNextVaultNodes(vnl.available());\n      }\n    \n"
         }, 
         "inherit_fullnames": [
            "osid.OsidList"
         ], 
         "inherit_shortnames": [
            "OsidList"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidList"
            }
         ], 
         "method_names": [
            "get_next_vault_node", 
            "get_next_vault_nodes"
         ], 
         "methods": [
            {
               "name": "get_next_vault_node", 
               "doc": {
                  "headline": "Gets the next ``VaultNode`` in this list.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.authorization.VaultNode) - the next ``VaultNode``\n                in this list. The ``has_next()`` method should be used\n                to test that a next ``VaultNode`` is available before\n                calling this method.", 
               "error_doc": "        raise:  IllegalState - no more elements available in this list\n        raise:  OperationFailed - unable to complete request", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the next ``VaultNode`` in this list. The ``has_next()`` method should be used to test that a next ``VaultNode`` is available before calling this method.\n        :rtype: ``osid.authorization.VaultNode``", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- no more elements available in this list\n        :raise: ``OperationFailed`` -- unable to complete request", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.authorization.VaultNode", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational"
               }
            }, 
            {
               "name": "get_next_vault_nodes", 
               "doc": {
                  "headline": "Gets the next set of ``VaultNode`` elements in this list which must be less than or equal to the return from ``available()``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    n (cardinal): the number of ``VaultNode`` elements\n                requested which must be less than or equal to\n                ``available()``\n", 
               "return_doc": "        return: (osid.authorization.VaultNode) - an array of\n                ``VaultNode`` elements.The length of the array is less\n                than or equal to the number specified.", 
               "error_doc": "        raise:  IllegalState - no more elements available in this list\n        raise:  OperationFailed - unable to complete request", 
               "sphinx_param_doc": "        :param n: the number of ``VaultNode`` elements requested which must be less than or equal to ``available()``\n        :type n: ``cardinal``\n", 
               "sphinx_return_doc": "        :return: an array of ``VaultNode`` elements.The length of the array is less than or equal to the number specified.\n        :rtype: ``osid.authorization.VaultNode``", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- no more elements available in this list\n        :raise: ``OperationFailed`` -- unable to complete request", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "cardinal", 
                     "var_name": "n", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "cardinal"
               ], 
               "return_type": "osid.authorization.VaultNode", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational"
               }
            }
         ]
      }
   ], 
   "full_name": "osid.authorization"
}
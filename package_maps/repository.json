{
   "name": "repository", 
   "version": "3.0.0", 
   "title": "Repository Open Service Interface Definitions", 
   "copyright": "Copyright (c) 2002-2004, 2007-2008 Massachusetts Institute of\nTechnology.\n\nCopyright (c) 2010-2011 Ingenescus. All Rights Reserved.", 
   "license": "This Work is being provided by the copyright holder(s) subject to the\nfollowing license. By obtaining, using and/or copying this Work, you\nagree that you have read, understand, and will comply with the following\nterms and conditions.\n\nPermission to use, copy and distribute unmodified versions of this Work,\nfor any purpose, without fee or royalty is hereby granted, provided that\nyou include the above copyright notices and the terms of this license on\nALL copies of the Work or portions thereof.\n\nYou may nodify or create Derivatives of this Work only for your internal\npurposes. You shall not distribute or transfer any such Derivative of\nthis Work to any location or to any third party. For the purposes of\nthis license, \"Derivative\" shall mean any derivative of the Work as\ndefined in the United States Copyright Act of 1976, such as a\ntranslation or modification.\n\nThis Work and the information contained herein is provided on an \"AS IS\"\nbasis WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT\nNOT LIMITED TO WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR\nPURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\nHOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN\nAN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\nCONNECTION WITH THE WORK OR THE USE OR OTHER DEALINGS IN THE WORK.\n\nThe export of software employing encryption technology may require a\nspecific license from the United States Government. It is the\nresponsibility of any person or organization contemplating export to\nobtain such a license before exporting this Work.", 
   "summary": "The Repository OSID provides the service of finding and managing digital\nassets.\n\nAssets\n\nAn ``Asset`` represents a unit of content, whether it be an image, a\nvideo, an application document or some text. The Asset defines a core\nset of definitions applicable to digital content, such as copyright and\npublisher, and allows for a type specification to be appended as with\nother ``OsidObjects``.\n\nAsset content, such as a document, is defined such that there may be\nmultiple formats contained with the same asset. A document may be\naccessible in both PDF and MS Word, but is the same document, for\nexample. An image may have both a large size and a thumbnail version.\nGenerally, an asset contains more than one version of content when it is\nleft to the application to decide which is most appropriate.\n\nThe ``Asset``  ``Type`` may define methods in common throughout the\ncontent variations. An example asset is one whose content ``Types`` are\n\"Quicktime\" and \"MPEG\", but the ``Asset``  ``Type`` is \"movie\" and\ndefines methods that describe the move aside from the formats. This\n\"double\" Type hierarchy stemming from the asset requires more care in\ndefining interfaces.\n\n``Assets`` also have \"credits\" which define the authors, editors,\ncreators, performers, producers or any other \"role\", identified with a\nrole ``Type,`` with the production of the asset. These are managed\nexternally to the asset through another ``OsidSession``.\n\nThrough additional optional ``OsidSessions,`` the ``Asset`` can be\n\"extended\" to offer temporal information. An asset may pertain to a\ndate, a period of time, or a series of dates and periods. This mechanism\nis to offer the ability to search for assets pertaining to a desired\ndate range without requiring understanding of a ``Type``.\n\nSimilarly, the ``Asset`` can also map to spatial information. A\nphotograph may be \"geotagged\" with the GPS coordinates where it was\ntaken, a conical shape in stellar coordinates could be described for an\nastronimocal image, or there may be a desire to may a historical book to\nthe spatial coordinates of Boston and Philadelphia. Unlike temporal\nmappings, the definition of the spatial coordinate is left to a spatial\nType to define. The Repository OSID simply manages spatial mappings to\nthe Asset.\n\nAsset Tagging\n\n``Assets`` may also relate to Ontology OSID ``Subjects``. The\n``Subject`` provides the ability to normalize information related to\nsubject matter across the ``Assets`` to simplify management and provide\na more robust searching mechanism. For example, with a photograph of the\nEmpire State Building, one may wish to describe that it was designed by\nShreve, Lamb and Harmon and completed in 1931. The information about the\nbuilding itself can be described using a ``Subject`` and related to the\nphotograph, and any other photograph that captures the building. The\n``Asset``  ``Type`` for the photograph may simply be \"photograph\" and\ndoesn't attempt to describe a building, while the ``AssetContent``\n``Type`` is \"image/jpeg\".\n\nAn application performing a search for Empire State Building can be\nexecute the search over the ``Subjects,`` and once the user has narrowed\nthe subject area, then the related Assets can be retrieved, and from\nthere negotiate the content.\n\nA provider wishing to construct a simple inventory database of buildings\nin New York may decide to do so using the Resource OSID. The\n``Resource``  ``Type`` may describe the construction dates, height,\nlocation, style and architects of buildings. The ``Type`` may also\ninclude a means of getting a reference image using the ``Asset``\ninterface. Since there is no explicit relationship between ``Subject``\nand ``Resource,`` the ``Resource`` can be adapted to the ``Subject``\ninterface (mapping a ``building_resource_type`` to a\n``building_subject_type`` ) to use the same data for ``Subject`` to\n``Asset`` mappings and searching.\n\nAsset Compositions\n\nAsset compositions can be created using the ``Composition`` interface. A\n``Composition`` is a group of ``Assets`` and compositions may be\nstructured into a hierarchy for the purpose of \"building\" larger\ncontent. A content management system may make use of this interface to\nconstruct a web page. The ``Composition`` hierarchy may map into an\nXHTML structure and each ``Asset`` represent an image or a link in the\ndocument. However, the produced web page at a given URL may be\nrepresented by another single ``Asset`` that whose content has both the\nURL and the XHTML stream.\n\nAnother example is an IMS Common Cartridge. The ``Composition`` may be\nused to produce the zip file cartridge, but consumers may access the zip\nfile via an ``Asset`` .\n\nRepository Cataloging\n\nFinally, ``Assets`` and ``Compositions`` may be categorized into\n``Repository`` objects. A ``Repository`` is a catalog-like interface to\nhelp organize assets and subject matter. Repositories may be organized\ninto hierarchies for organization or federation purposes.\n\nThis number of service aspects to this Repository OSID produce a large\nnumber of definitions. It is recommended to use the\n``RepositoryManager`` definition to select a single ``OsidSession`` of\ninterest, and work that definition through its dependencies before\ntackling another aspect.\n\nSub Packages\n\nThe Repository OSID includes a rules subpackage for managing dynamic\ncompositions.", 
   "interfaces": [
      {
         "fullname": "osid.repository.RepositoryProfile", 
         "shortname": "RepositoryProfile", 
         "category": "managers", 
         "doc": {
            "headline": "The repository profile describes interoperability among repository services.", 
            "body": ""
         }, 
         "inherit_fullnames": [
            "osid.OsidProfile"
         ], 
         "inherit_shortnames": [
            "OsidProfile"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidProfile"
            }
         ], 
         "method_names": [
            "supports_visible_federation", 
            "supports_asset_lookup", 
            "supports_asset_query", 
            "supports_asset_search", 
            "supports_asset_admin", 
            "supports_asset_notification", 
            "supports_asset_repository", 
            "supports_asset_repository_assignment", 
            "supports_asset_smart_repository", 
            "supports_asset_temporal", 
            "supports_asset_temporal_assignment", 
            "supports_asset_spatial", 
            "supports_asset_spatial_assignment", 
            "supports_asset_composition", 
            "supports_asset_composition_design", 
            "supports_composition_lookup", 
            "supports_composition_query", 
            "supports_composition_search", 
            "supports_composition_admin", 
            "supports_composition_notification", 
            "supports_composition_repository", 
            "supports_composition_repository_assignment", 
            "supports_composition_smart_repository", 
            "supports_repository_lookup", 
            "supports_repository_query", 
            "supports_repository_search", 
            "supports_repository_admin", 
            "supports_repository_notification", 
            "supports_repository_hierarchy", 
            "supports_repository_hierarchy_design", 
            "supports_repository_batch", 
            "supports_repository_rules", 
            "get_asset_record_types", 
            "supports_asset_record_type", 
            "get_asset_search_record_types", 
            "supports_asset_search_record_type", 
            "get_asset_content_record_types", 
            "supports_asset_content_record_type", 
            "get_composition_record_types", 
            "supports_composition_record_type", 
            "get_composition_search_record_types", 
            "supports_composition_search_record_type", 
            "get_repository_record_types", 
            "supports_repository_record_type", 
            "get_repository_search_record_types", 
            "supports_repository_search_record_type", 
            "get_spatial_unit_record_types", 
            "supports_spatial_unit_record_type", 
            "get_coordinate_types", 
            "supports_coordinate_type"
         ], 
         "methods": [
            {
               "name": "supports_visible_federation", 
               "doc": {
                  "headline": "Tests if federation is visible.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if visible federation is supported\n                ``,``  ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if visible federation is supported ``,``  ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "supports_asset_lookup", 
               "doc": {
                  "headline": "Tests if asset lookup is supported.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if asset lookup is supported ``,``\n                ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if asset lookup is supported ``,``  ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "supports_asset_query", 
               "doc": {
                  "headline": "Tests if asset query is supported.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if asset query is supported ``,``\n                ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if asset query is supported ``,``  ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "supports_asset_search", 
               "doc": {
                  "headline": "Tests if asset search is supported.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if asset search is supported ``,``\n                ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if asset search is supported ``,``  ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "supports_asset_admin", 
               "doc": {
                  "headline": "Tests if asset administration is supported.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if asset administration is\n                supported, ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if asset administration is supported, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "supports_asset_notification", 
               "doc": {
                  "headline": "Tests if asset notification is supported.", 
                  "body": "        A repository may send messages when assets are created,\n        modified, or deleted."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if asset notification is supported\n                ``,``  ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if asset notification is supported ``,``  ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "supports_asset_repository", 
               "doc": {
                  "headline": "Tests if retrieving mappings of assets and repositories is supported.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if asset repository mapping\n                retrieval is supported ``,`` ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if asset repository mapping retrieval is supported ``,``  ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "supports_asset_repository_assignment", 
               "doc": {
                  "headline": "Tests if managing mappings of assets and repositories is supported.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if asset repository assignment is\n                supported ``,``  ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if asset repository assignment is supported ``,``  ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "supports_asset_smart_repository", 
               "doc": {
                  "headline": "Tests if asset smart repository is supported.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if asset smart repository is\n                supported ``,``  ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if asset smart repository is supported ``,``  ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "supports_asset_temporal", 
               "doc": {
                  "headline": "Tests if retrieving mappings of assets and time coverage is supported.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if asset temporal mapping retrieval\n                is supported ``,`` ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if asset temporal mapping retrieval is supported ``,``  ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "supports_asset_temporal_assignment", 
               "doc": {
                  "headline": "Tests if managing mappings of assets and time ocverage is supported.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if asset temporal assignment is\n                supported ``,``  ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if asset temporal assignment is supported ``,``  ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "supports_asset_spatial", 
               "doc": {
                  "headline": "Tests if retrieving mappings of assets and spatial coverage is supported.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if asset spatial mapping retrieval\n                is supported ``,`` ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if asset spatial mapping retrieval is supported ``,``  ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "supports_asset_spatial_assignment", 
               "doc": {
                  "headline": "Tests if managing mappings of assets and spatial ocverage is supported.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if asset spatial assignment is\n                supported ``,``  ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if asset spatial assignment is supported ``,``  ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "supports_asset_composition", 
               "doc": {
                  "headline": "Tests if assets are included in compositions.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if asset composition supported\n                ``,``  ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if asset composition supported ``,``  ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "supports_asset_composition_design", 
               "doc": {
                  "headline": "Tests if mapping assets to compositions is supported.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if designing asset compositions is\n                supported ``,``  ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if designing asset compositions is supported ``,``  ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "supports_composition_lookup", 
               "doc": {
                  "headline": "Tests if composition lookup is supported.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if composition lookup is supported\n                ``,``  ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if composition lookup is supported ``,``  ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "supports_composition_query", 
               "doc": {
                  "headline": "Tests if composition query is supported.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if composition query is supported\n                ``,``  ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if composition query is supported ``,``  ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "supports_composition_search", 
               "doc": {
                  "headline": "Tests if composition search is supported.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if composition search is supported\n                ``,``  ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if composition search is supported ``,``  ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "supports_composition_admin", 
               "doc": {
                  "headline": "Tests if composition administration is supported.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if composition administration is\n                supported, ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if composition administration is supported, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "supports_composition_notification", 
               "doc": {
                  "headline": "Tests if composition notification is supported.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if composition notification is\n                supported ``,``  ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if composition notification is supported ``,``  ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "supports_composition_repository", 
               "doc": {
                  "headline": "Tests if retrieval of composition to repository mappings is supported.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if composition to repository\n                mapping is supported ``,`` ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if composition to repository mapping is supported ``,``  ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "supports_composition_repository_assignment", 
               "doc": {
                  "headline": "Tests if assigning composition to repository mappings is supported.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if composition to repository\n                assignment is supported ``,`` ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if composition to repository assignment is supported ``,``  ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "supports_composition_smart_repository", 
               "doc": {
                  "headline": "Tests if composition smart repository is supported.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if composition smart repository is\n                supported ``,``  ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if composition smart repository is supported ``,``  ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "supports_repository_lookup", 
               "doc": {
                  "headline": "Tests if repository lookup is supported.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if repository lookup is supported\n                ``,``  ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if repository lookup is supported ``,``  ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "supports_repository_query", 
               "doc": {
                  "headline": "Tests if repository query is supported.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if repository query is supported\n                ``,``  ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if repository query is supported ``,``  ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "supports_repository_search", 
               "doc": {
                  "headline": "Tests if repository search is supported.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if repository search is supported\n                ``,``  ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if repository search is supported ``,``  ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "supports_repository_admin", 
               "doc": {
                  "headline": "Tests if repository administration is supported.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if repository administration is\n                supported, ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if repository administration is supported, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "supports_repository_notification", 
               "doc": {
                  "headline": "Tests if repository notification is supported.", 
                  "body": "        Messages may be sent when ``Repository`` objects are created,\n        deleted or updated. Notifications for assets within repositories\n        are sent via the asset notification session."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if repository notification is\n                supported ``,``  ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if repository notification is supported ``,``  ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "supports_repository_hierarchy", 
               "doc": {
                  "headline": "Tests if a repository hierarchy traversal is supported.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if a repository hierarchy traversal\n                is supported, ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if a repository hierarchy traversal is supported, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "supports_repository_hierarchy_design", 
               "doc": {
                  "headline": "Tests if a repository hierarchy design is supported.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if a repository hierarchy design is\n                supported, ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if a repository hierarchy design is supported, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "supports_repository_batch", 
               "doc": {
                  "headline": "Tests if a repository batch service is supported.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if a repository batch service is\n                supported, ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if a repository batch service is supported, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "supports_repository_rules", 
               "doc": {
                  "headline": "Tests if a repository rules service is supported.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if a repository rules service is\n                supported, ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if a repository rules service is supported, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "get_asset_record_types", 
               "doc": {
                  "headline": "Gets all the asset record types supported.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.type.TypeList) - the list of supported asset\n                record types", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the list of supported asset record types\n        :rtype: ``osid.type.TypeList``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.type.TypeList", 
               "errors": {}
            }, 
            {
               "name": "supports_asset_record_type", 
               "doc": {
                  "headline": "Tests if a given asset type is supported.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    asset_record_type (osid.type.Type): the asset record\n                type\n", 
               "return_doc": "        return: (boolean) - ``true`` if the asset record type is\n                supported ``,``  ``false`` otherwise", 
               "error_doc": "        raise:  NullArgument - ``asset_record_type`` is ``null``", 
               "sphinx_param_doc": "        :param asset_record_type: the asset record type\n        :type asset_record_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "        :return: ``true`` if the asset record type is supported ``,``  ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``asset_record_type`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "asset_record_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "boolean", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "get_asset_search_record_types", 
               "doc": {
                  "headline": "Gets all the asset search record types supported.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.type.TypeList) - the list of supported asset\n                search record types", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the list of supported asset search record types\n        :rtype: ``osid.type.TypeList``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.type.TypeList", 
               "errors": {}
            }, 
            {
               "name": "supports_asset_search_record_type", 
               "doc": {
                  "headline": "Tests if a given asset search record type is supported.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    asset_search_record_type (osid.type.Type): the asset\n                search record type\n", 
               "return_doc": "        return: (boolean) - ``true`` if the asset search record type is\n                supported ``,``  ``false`` otherwise", 
               "error_doc": "        raise:  NullArgument - ``asset_search_record_type`` is ``null``", 
               "sphinx_param_doc": "        :param asset_search_record_type: the asset search record type\n        :type asset_search_record_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "        :return: ``true`` if the asset search record type is supported ``,``  ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``asset_search_record_type`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "asset_search_record_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "boolean", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "get_asset_content_record_types", 
               "doc": {
                  "headline": "Gets all the asset content record types supported.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.type.TypeList) - the list of supported asset\n                content record types", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the list of supported asset content record types\n        :rtype: ``osid.type.TypeList``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.type.TypeList", 
               "errors": {}
            }, 
            {
               "name": "supports_asset_content_record_type", 
               "doc": {
                  "headline": "Tests if a given asset content record type is supported.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    asset_content_record_type (osid.type.Type): the asset\n                content record type\n", 
               "return_doc": "        return: (boolean) - ``true`` if the asset content record type is\n                supported ``,``  ``false`` otherwise", 
               "error_doc": "        raise:  NullArgument - ``asset_content_record_type`` is ``null``", 
               "sphinx_param_doc": "        :param asset_content_record_type: the asset content record type\n        :type asset_content_record_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "        :return: ``true`` if the asset content record type is supported ``,``  ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``asset_content_record_type`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "asset_content_record_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "boolean", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "get_composition_record_types", 
               "doc": {
                  "headline": "Gets all the composition record types supported.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.type.TypeList) - the list of supported composition\n                record types", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the list of supported composition record types\n        :rtype: ``osid.type.TypeList``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.type.TypeList", 
               "errors": {}
            }, 
            {
               "name": "supports_composition_record_type", 
               "doc": {
                  "headline": "Tests if a given composition record type is supported.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    composition_record_type (osid.type.Type): the\n                composition record type\n", 
               "return_doc": "        return: (boolean) - ``true`` if the composition record type is\n                supported ``,``  ``false`` otherwise", 
               "error_doc": "        raise:  NullArgument - ``composition_record_type`` is ``null``", 
               "sphinx_param_doc": "        :param composition_record_type: the composition record type\n        :type composition_record_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "        :return: ``true`` if the composition record type is supported ``,``  ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``composition_record_type`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "composition_record_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "boolean", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "get_composition_search_record_types", 
               "doc": {
                  "headline": "Gets all the composition search record types supported.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.type.TypeList) - the list of supported composition\n                search record types", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the list of supported composition search record types\n        :rtype: ``osid.type.TypeList``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.type.TypeList", 
               "errors": {}
            }, 
            {
               "name": "supports_composition_search_record_type", 
               "doc": {
                  "headline": "Tests if a given composition search record type is supported.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    composition_search_record_type (osid.type.Type): the\n                composition serach type\n", 
               "return_doc": "        return: (boolean) - ``true`` if the composition search record\n                type is supported ``,`` ``false`` otherwise", 
               "error_doc": "        raise:  NullArgument - ``composition_search_record_type`` is\n                ``null``", 
               "sphinx_param_doc": "        :param composition_search_record_type: the composition serach type\n        :type composition_search_record_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "        :return: ``true`` if the composition search record type is supported ``,``  ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``composition_search_record_type`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "composition_search_record_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "boolean", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "get_repository_record_types", 
               "doc": {
                  "headline": "Gets all the repository record types supported.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.type.TypeList) - the list of supported repository\n                record types", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the list of supported repository record types\n        :rtype: ``osid.type.TypeList``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.type.TypeList", 
               "errors": {}
            }, 
            {
               "name": "supports_repository_record_type", 
               "doc": {
                  "headline": "Tests if a given repository record type is supported.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    repository_record_type (osid.type.Type): the repository\n                record type\n", 
               "return_doc": "        return: (boolean) - ``true`` if the repository record type is\n                supported ``,``  ``false`` otherwise", 
               "error_doc": "        raise:  NullArgument - ``repository_record_type`` is ``null``", 
               "sphinx_param_doc": "        :param repository_record_type: the repository record type\n        :type repository_record_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "        :return: ``true`` if the repository record type is supported ``,``  ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``repository_record_type`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "repository_record_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "boolean", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "get_repository_search_record_types", 
               "doc": {
                  "headline": "Gets all the repository search record types supported.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.type.TypeList) - the list of supported repository\n                search record types", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the list of supported repository search record types\n        :rtype: ``osid.type.TypeList``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.type.TypeList", 
               "errors": {}
            }, 
            {
               "name": "supports_repository_search_record_type", 
               "doc": {
                  "headline": "Tests if a given repository search record type is supported.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    repository_search_record_type (osid.type.Type): the\n                repository search type\n", 
               "return_doc": "        return: (boolean) - ``true`` if the repository search record\n                type is supported ``,`` ``false`` otherwise", 
               "error_doc": "        raise:  NullArgument - ``repository_search_record_type`` is\n                ``null``", 
               "sphinx_param_doc": "        :param repository_search_record_type: the repository search type\n        :type repository_search_record_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "        :return: ``true`` if the repository search record type is supported ``,``  ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``repository_search_record_type`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "repository_search_record_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "boolean", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "get_spatial_unit_record_types", 
               "doc": {
                  "headline": "Gets all the spatial unit record types supported.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.type.TypeList) - the list of supported spatial\n                unit record types", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the list of supported spatial unit record types\n        :rtype: ``osid.type.TypeList``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.type.TypeList", 
               "errors": {}
            }, 
            {
               "name": "supports_spatial_unit_record_type", 
               "doc": {
                  "headline": "Tests if a given spatial unit record type is supported.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    spatial_unit_record_type (osid.type.Type): the spatial\n                unit record type\n", 
               "return_doc": "        return: (boolean) - ``true`` if the spatial unit record type is\n                supported ``,``  ``false`` otherwise", 
               "error_doc": "        raise:  NullArgument - ``spatial_unit_record_type`` is ``null``", 
               "sphinx_param_doc": "        :param spatial_unit_record_type: the spatial unit record type\n        :type spatial_unit_record_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "        :return: ``true`` if the spatial unit record type is supported ``,``  ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``spatial_unit_record_type`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "spatial_unit_record_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "boolean", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "get_coordinate_types", 
               "doc": {
                  "headline": "Gets all the coordinate types supported.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.type.TypeList) - the list of supported coordinate\n                types", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the list of supported coordinate types\n        :rtype: ``osid.type.TypeList``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.type.TypeList", 
               "errors": {}
            }, 
            {
               "name": "supports_coordinate_type", 
               "doc": {
                  "headline": "Tests if a given coordinate type is supported.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    coordinate_type (osid.type.Type): the coordinate type\n", 
               "return_doc": "        return: (boolean) - ``true`` if the coordinate type is supported\n                ``,``  ``false`` otherwise", 
               "error_doc": "        raise:  NullArgument - ``coordinate_type`` is ``null``", 
               "sphinx_param_doc": "        :param coordinate_type: the coordinate type\n        :type coordinate_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "        :return: ``true`` if the coordinate type is supported ``,``  ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``coordinate_type`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "coordinate_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "boolean", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.repository.RepositoryManager", 
         "shortname": "RepositoryManager", 
         "category": "managers", 
         "doc": {
            "headline": "The repository manager provides access to asset lookup and creation session and provides interoperability tests for various aspects of this service.", 
            "body": "    The sessions included in this manager are:\n\n      * ``AssetLookupSession:`` a session to retrieve assets\n      * ``AssetQuerySession:`` a session to query assets\n      * ``AssetSearchSession:`` a session to search for assets\n      * ``AssetAdminSession:`` a session to create and delete assets\n      * ``AssetNotificationSession:`` a session to receive notifications\n        pertaining to asset changes\n      * ``AssetRepositorySession:`` a session to look up asset to\n        repository mappings\n      * ``AssetRepositoryAssignmentSession:`` a session to manage asset\n        to repository mappings\n      * ``AssetSmartRepositorySession:`` a session to manage dynamic\n        repositories of assets\n      * ``AssetTemporalSession:`` a session to access the temporal\n        coverage of an asset\n      * ``AssetTemporalAssignmentSession:`` a session to manage the\n        temporal coverage of an asset\n      * ``AssetSpatialSession:`` a session to access the spatial\n        coverage of an asset\n      * ``AssetSpatialAssignmentSession:`` a session to manage the\n        spatial coverage of an asset\n      * ``AssetCompositionSession:`` a session to look up asset\n        composition mappings\n      * ``AssetCompositionDesignSession:`` a session to map assets to\n        compositions\n    \n      * ``CompositionLookupSession: a`` session to retrieve compositions\n      * ``CompositionQuerySession:`` a session to query compositions\n      * ``CompositionSearchSession:`` a session to search for\n        compositions\n      * ``CompositionAdminSession:`` a session to create, update and\n        delete compositions\n      * ``CompositionNotificationSession:`` a session to receive\n        notifications pertaining to changes in compositions\n      * ``CompositionRepositorySession:`` a session to retrieve\n        composition repository mappings\n      * ``CompositionRepositoryAssignmentSession:`` a session to manage\n        composition repository mappings\n      * ``CompositionSmartRepositorySession:`` a session to manage\n        dynamic repositories of compositions\n    \n      * ``RepositoryLookupSession: a`` session to retrieve repositories\n      * ``RepositoryQuerySession:`` a session to query repositories\n      * ``RepositorySearchSession:`` a session to search for\n        repositories\n      * ``RepositoryAdminSession:`` a session to create, update and\n        delete repositories\n      * ``RepositoryNotificationSession:`` a session to receive\n        notifications pertaining to changes in repositories\n      * ``RepositoryHierarchySession:`` a session to traverse repository\n        hierarchies\n      * ``RepositoryHierarchyDesignSession:`` a session to manage\n        repository hierarchies\n"
         }, 
         "inherit_fullnames": [
            "osid.OsidManager", 
            "osid.repository.RepositoryProfile"
         ], 
         "inherit_shortnames": [
            "OsidManager", 
            "RepositoryProfile"
         ], 
         "inherit_pkg_names": [
            "osid", 
            "repository"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidManager"
            }, 
            {
               "pkg_name": "repository", 
               "name": "RepositoryProfile"
            }
         ], 
         "method_names": [
            "get_asset_lookup_session", 
            "get_asset_lookup_session_for_repository", 
            "get_asset_query_session", 
            "get_asset_query_session_for_repository", 
            "get_asset_search_session", 
            "get_asset_search_session_for_repository", 
            "get_asset_admin_session", 
            "get_asset_admin_session_for_repository", 
            "get_asset_notification_session", 
            "get_asset_notification_session_for_repository", 
            "get_asset_repository_session", 
            "get_asset_repository_assignment_session", 
            "get_asset_smart_repository_session", 
            "get_asset_temporal_session", 
            "get_asset_temporal_session_for_repository", 
            "get_asset_temporal_assignment_session", 
            "get_asset_temporal_assignment_session_for_repository", 
            "get_asset_spatial_session", 
            "get_asset_spatial_session_for_repository", 
            "get_asset_spatial_assignment_session", 
            "get_asset_spatial_assignment_session_for_repository", 
            "get_asset_composition_session", 
            "get_asset_composition_design_session", 
            "get_composition_lookup_session", 
            "get_composition_lookup_session_for_repository", 
            "get_composition_query_session", 
            "get_composition_query_session_for_repository", 
            "get_composition_search_session", 
            "get_composition_search_session_for_repository", 
            "get_composition_admin_session", 
            "get_composition_admin_session_for_repository", 
            "get_composition_notification_session", 
            "get_composition_notification_session_for_repository", 
            "get_composition_repository_session", 
            "get_composition_repository_assignment_session", 
            "get_composition_smart_repository_session", 
            "get_repository_lookup_session", 
            "get_repository_query_session", 
            "get_repository_search_session", 
            "get_repository_admin_session", 
            "get_repository_notification_session", 
            "get_repository_hierarchy_session", 
            "get_repository_hierarchy_design_session", 
            "get_repository_batch_manager", 
            "get_repository_rules_manager"
         ], 
         "methods": [
            {
               "name": "get_asset_lookup_session", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` associated with the asset lookup service.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.repository.AssetLookupSession) - the new\n                ``AssetLookupSession``", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_asset_lookup()`` is ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the new ``AssetLookupSession``\n        :rtype: ``osid.repository.AssetLookupSession``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_asset_lookup()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_asset_lookup()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.repository.AssetLookupSession", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_asset_lookup_session_for_repository", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` associated with the asset lookup service for the given repository.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    repository_id (osid.id.Id): the ``Id`` of the repository\n", 
               "return_doc": "        return: (osid.repository.AssetLookupSession) - the new\n                ``AssetLookupSession``", 
               "error_doc": "        raise:  NotFound - ``repository_id`` not found\n        raise:  NullArgument - ``repository_id`` is ``null``\n        raise:  OperationFailed - ``unable to complete request``\n        raise:  Unimplemented - ``supports_asset_lookup()`` or\n                ``supports_visible_federation()`` is ``false``", 
               "sphinx_param_doc": "        :param repository_id: the ``Id`` of the repository\n        :type repository_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: the new ``AssetLookupSession``\n        :rtype: ``osid.repository.AssetLookupSession``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``repository_id`` not found\n        :raise: ``NullArgument`` -- ``repository_id`` is ``null``\n        :raise: ``OperationFailed`` -- ``unable to complete request``\n        :raise: ``Unimplemented`` -- ``supports_asset_lookup()`` or ``supports_visible_federation()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_asset_lookup()`` and ``supports_visible_federation()`` are ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "repository_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "osid.repository.AssetLookupSession", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_asset_query_session", 
               "doc": {
                  "headline": "Gets an asset query session.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.repository.AssetQuerySession) - an\n                ``AssetQuerySession``", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_asset_query()`` is ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: an ``AssetQuerySession``\n        :rtype: ``osid.repository.AssetQuerySession``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_asset_query()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_asset_query()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.repository.AssetQuerySession", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_asset_query_session_for_repository", 
               "doc": {
                  "headline": "Gets an asset query session for the given repository.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    repository_id (osid.id.Id): the ``Id`` of the repository\n", 
               "return_doc": "        return: (osid.repository.AssetQuerySession) - an\n                ``AssetQuerySession``", 
               "error_doc": "        raise:  NotFound - ``repository_id`` not found\n        raise:  NullArgument - ``repository_id`` is ``null``\n        raise:  OperationFailed - ``unable to complete request``\n        raise:  Unimplemented - ``supports_asset_query()`` or\n                ``supports_visible_federation()`` is ``false``", 
               "sphinx_param_doc": "        :param repository_id: the ``Id`` of the repository\n        :type repository_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: an ``AssetQuerySession``\n        :rtype: ``osid.repository.AssetQuerySession``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``repository_id`` not found\n        :raise: ``NullArgument`` -- ``repository_id`` is ``null``\n        :raise: ``OperationFailed`` -- ``unable to complete request``\n        :raise: ``Unimplemented`` -- ``supports_asset_query()`` or ``supports_visible_federation()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_asset_query()`` and ``supports_visible_federation()`` are ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "repository_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "osid.repository.AssetQuerySession", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_asset_search_session", 
               "doc": {
                  "headline": "Gets an asset search session.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.repository.AssetSearchSession) - an\n                ``AssetSearchSession``", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_asset_search()`` is ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: an ``AssetSearchSession``\n        :rtype: ``osid.repository.AssetSearchSession``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_asset_search()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_asset_search()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.repository.AssetSearchSession", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_asset_search_session_for_repository", 
               "doc": {
                  "headline": "Gets an asset search session for the given repository.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    repository_id (osid.id.Id): the ``Id`` of the repository\n", 
               "return_doc": "        return: (osid.repository.AssetSearchSession) - an\n                ``AssetSearchSession``", 
               "error_doc": "        raise:  NotFound - ``repository_id`` not found\n        raise:  NullArgument - ``repository_id`` is ``null``\n        raise:  OperationFailed - ``unable to complete request``\n        raise:  Unimplemented - ``supports_asset_search()`` or\n                ``supports_visible_federation()`` is ``false``", 
               "sphinx_param_doc": "        :param repository_id: the ``Id`` of the repository\n        :type repository_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: an ``AssetSearchSession``\n        :rtype: ``osid.repository.AssetSearchSession``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``repository_id`` not found\n        :raise: ``NullArgument`` -- ``repository_id`` is ``null``\n        :raise: ``OperationFailed`` -- ``unable to complete request``\n        :raise: ``Unimplemented`` -- ``supports_asset_search()`` or ``supports_visible_federation()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_asset_search()`` and ``supports_visible_federation()`` are ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "repository_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "osid.repository.AssetSearchSession", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_asset_admin_session", 
               "doc": {
                  "headline": "Gets an asset administration session for creating, updating and deleting assets.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.repository.AssetAdminSession) - an\n                ``AssetAdminSession``", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_asset_admin()`` is ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: an ``AssetAdminSession``\n        :rtype: ``osid.repository.AssetAdminSession``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_asset_admin()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_asset_admin()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.repository.AssetAdminSession", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_asset_admin_session_for_repository", 
               "doc": {
                  "headline": "Gets an asset administration session for the given repository.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    repository_id (osid.id.Id): the ``Id`` of the repository\n", 
               "return_doc": "        return: (osid.repository.AssetAdminSession) - an\n                ``AssetAdminSession``", 
               "error_doc": "        raise:  NotFound - ``repository_id`` not found\n        raise:  NullArgument - ``repository_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_asset_admin()`` or\n                ``supports_visible_federation()`` is ``false``", 
               "sphinx_param_doc": "        :param repository_id: the ``Id`` of the repository\n        :type repository_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: an ``AssetAdminSession``\n        :rtype: ``osid.repository.AssetAdminSession``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``repository_id`` not found\n        :raise: ``NullArgument`` -- ``repository_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_asset_admin()`` or ``supports_visible_federation()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_asset_admin()`` and ``supports_visible_federation()`` are ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "repository_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "osid.repository.AssetAdminSession", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_asset_notification_session", 
               "doc": {
                  "headline": "Gets the notification session for notifications pertaining to asset changes.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    asset_receiver (osid.repository.AssetReceiver): the\n                notification callback\n", 
               "return_doc": "        return: (osid.repository.AssetNotificationSession) - an\n                ``AssetNotificationSession``", 
               "error_doc": "        raise:  NullArgument - ``asset_receiver`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_asset_notification()`` is\n                ``false``", 
               "sphinx_param_doc": "        :param asset_receiver: the notification callback\n        :type asset_receiver: ``osid.repository.AssetReceiver``\n", 
               "sphinx_return_doc": "        :return: an ``AssetNotificationSession``\n        :rtype: ``osid.repository.AssetNotificationSession``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``asset_receiver`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_asset_notification()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_asset_notification()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.repository.AssetReceiver", 
                     "var_name": "asset_receiver", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.repository.AssetReceiver"
               ], 
               "return_type": "osid.repository.AssetNotificationSession", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_asset_notification_session_for_repository", 
               "doc": {
                  "headline": "Gets the asset notification session for the given repository.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    asset_receiver (osid.repository.AssetReceiver): the\n                notification callback\n        arg:    repository_id (osid.id.Id): the ``Id`` of the repository\n", 
               "return_doc": "        return: (osid.repository.AssetNotificationSession) - an\n                ``AssetNotificationSession``", 
               "error_doc": "        raise:  NotFound - ``repository_id`` not found\n        raise:  NullArgument - ``asset_receiver`` or ``repository_id``\n                is ``null``\n        raise:  OperationFailed - ``unable to complete request``\n        raise:  Unimplemented - ``supports_asset_notification()`` or\n                ``supports_visible_federation()`` is ``false``", 
               "sphinx_param_doc": "        :param asset_receiver: the notification callback\n        :type asset_receiver: ``osid.repository.AssetReceiver``\n        :param repository_id: the ``Id`` of the repository\n        :type repository_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: an ``AssetNotificationSession``\n        :rtype: ``osid.repository.AssetNotificationSession``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``repository_id`` not found\n        :raise: ``NullArgument`` -- ``asset_receiver`` or ``repository_id`` is ``null``\n        :raise: ``OperationFailed`` -- ``unable to complete request``\n        :raise: ``Unimplemented`` -- ``supports_asset_notification()`` or ``supports_visible_federation()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_asset_notfication()`` and ``supports_visible_federation()`` are ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.repository.AssetReceiver", 
                     "var_name": "asset_receiver", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "repository_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.repository.AssetReceiver", 
                  "osid.id.Id"
               ], 
               "return_type": "osid.repository.AssetNotificationSession", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_asset_repository_session", 
               "doc": {
                  "headline": "Gets the session for retrieving asset to repository mappings.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.repository.AssetRepositorySession) - an\n                ``AssetRepositorySession``", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_asset_repository()`` is\n                ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: an ``AssetRepositorySession``\n        :rtype: ``osid.repository.AssetRepositorySession``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_asset_repository()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_asset_repository()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.repository.AssetRepositorySession", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_asset_repository_assignment_session", 
               "doc": {
                  "headline": "Gets the session for assigning asset to repository mappings.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.repository.AssetRepositoryAssignmentSession) - an\n                ``AssetRepositoryAsignmentSession``", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented -\n                ``supports_asset_repository_assignment()`` is ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: an ``AssetRepositoryAsignmentSession``\n        :rtype: ``osid.repository.AssetRepositoryAssignmentSession``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_asset_repository_assignment()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_asset_repository_assignment()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.repository.AssetRepositoryAssignmentSession", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_asset_smart_repository_session", 
               "doc": {
                  "headline": "Gets an asset smart repository session for the given repository.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    repository_id (osid.id.Id): the ``Id`` of the repository\n", 
               "return_doc": "        return: (osid.repository.AssetSmartRepositorySession) - an\n                ``AssetSmartRepositorySession``", 
               "error_doc": "        raise:  NotFound - ``repository_id`` not found\n        raise:  NullArgument - ``repository_id`` is ``null``\n        raise:  OperationFailed - ``unable to complete request``\n        raise:  Unimplemented - ``supports_asset_smart_repository()``\n                ``false``", 
               "sphinx_param_doc": "        :param repository_id: the ``Id`` of the repository\n        :type repository_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: an ``AssetSmartRepositorySession``\n        :rtype: ``osid.repository.AssetSmartRepositorySession``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``repository_id`` not found\n        :raise: ``NullArgument`` -- ``repository_id`` is ``null``\n        :raise: ``OperationFailed`` -- ``unable to complete request``\n        :raise: ``Unimplemented`` -- ``supports_asset_smart_repository()``  ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_asset_smart_repository()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "repository_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "osid.repository.AssetSmartRepositorySession", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_asset_temporal_session", 
               "doc": {
                  "headline": "Gets the session for retrieving temporal coverage of an asset.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.repository.AssetTemporalSession) - an\n                ``AssetTemporalSession``", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_asset_temporal()`` is\n                ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: an ``AssetTemporalSession``\n        :rtype: ``osid.repository.AssetTemporalSession``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_asset_temporal()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_asset_temporal()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.repository.AssetTemporalSession", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_asset_temporal_session_for_repository", 
               "doc": {
                  "headline": "Gets the session for retrieving temporal coverage of an asset for the given repository.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    repository_id (osid.id.Id): the ``Id`` of the repository\n", 
               "return_doc": "        return: (osid.repository.AssetTemporalSession) - an\n                ``AssetTemporalSession``", 
               "error_doc": "        raise:  NotFound - ``repository_id`` not found\n        raise:  NullArgument - ``repository_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_asset_temporal()`` or\n                ``supports_visible_federation()`` is ``false``", 
               "sphinx_param_doc": "        :param repository_id: the ``Id`` of the repository\n        :type repository_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: an ``AssetTemporalSession``\n        :rtype: ``osid.repository.AssetTemporalSession``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``repository_id`` not found\n        :raise: ``NullArgument`` -- ``repository_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_asset_temporal()`` or ``supports_visible_federation()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_asset_temporal()`` and ``supports_visible_federation()`` are ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "repository_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "osid.repository.AssetTemporalSession", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_asset_temporal_assignment_session", 
               "doc": {
                  "headline": "Gets the session for assigning temporal coverage to an asset.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.repository.AssetTemporalAssignmentSession) - an\n                ``AssetTemporalAssignmentSession``", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_asset_temporal_assignment()``\n                is ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: an ``AssetTemporalAssignmentSession``\n        :rtype: ``osid.repository.AssetTemporalAssignmentSession``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_asset_temporal_assignment()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_asset_temporal_assignment()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.repository.AssetTemporalAssignmentSession", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_asset_temporal_assignment_session_for_repository", 
               "doc": {
                  "headline": "Gets the session for assigning temporal coverage of an asset for the given repository.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    repository_id (osid.id.Id): the ``Id`` of the repository\n", 
               "return_doc": "        return: (osid.repository.AssetTemporalAssignmentSession) - an\n                ``AssetTemporalAssignmentSession``", 
               "error_doc": "        raise:  NotFound - ``repository_id`` not found\n        raise:  NullArgument - ``repository_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_asset_temporal_assignment()``\n                or ``supports_visible_federation()`` is ``false``", 
               "sphinx_param_doc": "        :param repository_id: the ``Id`` of the repository\n        :type repository_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: an ``AssetTemporalAssignmentSession``\n        :rtype: ``osid.repository.AssetTemporalAssignmentSession``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``repository_id`` not found\n        :raise: ``NullArgument`` -- ``repository_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_asset_temporal_assignment()`` or ``supports_visible_federation()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_asset_temporal_assignment()`` and ``supports_visible_federation()`` are ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "repository_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "osid.repository.AssetTemporalAssignmentSession", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_asset_spatial_session", 
               "doc": {
                  "headline": "Gets the session for retrieving spatial coverage of an asset.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.repository.AssetSpatialSession) - an\n                ``AssetSpatialSession``", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_spatial_assets()`` is\n                ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: an ``AssetSpatialSession``\n        :rtype: ``osid.repository.AssetSpatialSession``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_spatial_assets()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_spatial_assets()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.repository.AssetSpatialSession", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_asset_spatial_session_for_repository", 
               "doc": {
                  "headline": "Gets the session for retrieving spatial coverage of an asset for the given repository.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    repository_id (osid.id.Id): the ``Id`` of the repository\n", 
               "return_doc": "        return: (osid.repository.AssetSpatialSession) - an\n                ``AssetSpatialSession``", 
               "error_doc": "        raise:  NotFound - ``repository_id`` not found\n        raise:  NullArgument - ``repository_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_asset_spatial()`` or\n                ``supports_visible_federation()`` is ``false``", 
               "sphinx_param_doc": "        :param repository_id: the ``Id`` of the repository\n        :type repository_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: an ``AssetSpatialSession``\n        :rtype: ``osid.repository.AssetSpatialSession``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``repository_id`` not found\n        :raise: ``NullArgument`` -- ``repository_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_asset_spatial()`` or ``supports_visible_federation()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_asset_spatial()`` and ``supports_visible_federation()`` are ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "repository_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "osid.repository.AssetSpatialSession", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_asset_spatial_assignment_session", 
               "doc": {
                  "headline": "Gets the session for assigning spatial coverage to an asset.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.repository.AssetSpatialAssignmentSession) - an\n                ``AssetSpatialAssignmentSession``", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_asset_spatial_assignment()``\n                is ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: an ``AssetSpatialAssignmentSession``\n        :rtype: ``osid.repository.AssetSpatialAssignmentSession``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_asset_spatial_assignment()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_asset_spatial_assignment()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.repository.AssetSpatialAssignmentSession", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_asset_spatial_assignment_session_for_repository", 
               "doc": {
                  "headline": "Gets the session for assigning spatial coverage of an asset for the given repository.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    repository_id (osid.id.Id): the ``Id`` of the repository\n", 
               "return_doc": "        return: (osid.repository.AssetSpatialAssignmentSession) - an\n                ``AssetSpatialAssignmentSession``", 
               "error_doc": "        raise:  NotFound - ``repository_id`` not found\n        raise:  NullArgument - ``repository_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_asset_spatial_assignment()``\n                or ``supports_visible_federation()`` is ``false``", 
               "sphinx_param_doc": "        :param repository_id: the ``Id`` of the repository\n        :type repository_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: an ``AssetSpatialAssignmentSession``\n        :rtype: ``osid.repository.AssetSpatialAssignmentSession``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``repository_id`` not found\n        :raise: ``NullArgument`` -- ``repository_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_asset_spatial_assignment()`` or ``supports_visible_federation()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_asset_spatial_assignment()`` and ``supports_visible_federation()`` are ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "repository_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "osid.repository.AssetSpatialAssignmentSession", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_asset_composition_session", 
               "doc": {
                  "headline": "Gets the session for retrieving asset compositions.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.repository.AssetCompositionSession) - an\n                ``AssetCompositionSession``", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_asset_composition()`` is\n                ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: an ``AssetCompositionSession``\n        :rtype: ``osid.repository.AssetCompositionSession``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_asset_composition()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_asset_composition()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.repository.AssetCompositionSession", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_asset_composition_design_session", 
               "doc": {
                  "headline": "Gets the session for creating asset compositions.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.repository.AssetCompositionDesignSession) - an\n                ``AssetCompositionDesignSession``", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_asset_composition_design()``\n                is ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: an ``AssetCompositionDesignSession``\n        :rtype: ``osid.repository.AssetCompositionDesignSession``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_asset_composition_design()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_asset_composition_design()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.repository.AssetCompositionDesignSession", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_composition_lookup_session", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` associated with the composition lookup service.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.repository.CompositionLookupSession) - the new\n                ``CompositionLookupSession``", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_composition_lookup()`` is\n                ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the new ``CompositionLookupSession``\n        :rtype: ``osid.repository.CompositionLookupSession``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_composition_lookup()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_composition_lookup()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.repository.CompositionLookupSession", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_composition_lookup_session_for_repository", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` associated with the composition lookup service for the given repository.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    repository_id (osid.id.Id): the ``Id`` of the repository\n", 
               "return_doc": "        return: (osid.repository.CompositionLookupSession) - the new\n                ``CompositionLookupSession``", 
               "error_doc": "        raise:  NotFound - ``repository_id`` not found\n        raise:  NullArgument - ``repository_id`` is ``null``\n        raise:  OperationFailed - ``unable to complete request``\n        raise:  Unimplemented - ``supports_composition_lookup()`` or\n                ``supports_visible_federation()`` is ``false``", 
               "sphinx_param_doc": "        :param repository_id: the ``Id`` of the repository\n        :type repository_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: the new ``CompositionLookupSession``\n        :rtype: ``osid.repository.CompositionLookupSession``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``repository_id`` not found\n        :raise: ``NullArgument`` -- ``repository_id`` is ``null``\n        :raise: ``OperationFailed`` -- ``unable to complete request``\n        :raise: ``Unimplemented`` -- ``supports_composition_lookup()`` or ``supports_visible_federation()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_composition_lookup()`` and ``supports_visible_federation()`` are ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "repository_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "osid.repository.CompositionLookupSession", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_composition_query_session", 
               "doc": {
                  "headline": "Gets a composition query session.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.repository.CompositionQuerySession) - a\n                ``CompositionQuerySession``", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_composition_query()`` is\n                ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: a ``CompositionQuerySession``\n        :rtype: ``osid.repository.CompositionQuerySession``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_composition_query()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_composition_query()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.repository.CompositionQuerySession", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_composition_query_session_for_repository", 
               "doc": {
                  "headline": "Gets a composition query session for the given repository.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    repository_id (osid.id.Id): the ``Id`` of the repository\n", 
               "return_doc": "        return: (osid.repository.CompositionQuerySession) - a\n                ``CompositionQuerySession``", 
               "error_doc": "        raise:  NotFound - ``repository_id`` not found\n        raise:  NullArgument - ``repository_id`` is ``null``\n        raise:  OperationFailed - ``unable to complete request``\n        raise:  Unimplemented - ``supports_composition_query()`` or\n                ``supports_visible_federation()`` is ``false``", 
               "sphinx_param_doc": "        :param repository_id: the ``Id`` of the repository\n        :type repository_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: a ``CompositionQuerySession``\n        :rtype: ``osid.repository.CompositionQuerySession``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``repository_id`` not found\n        :raise: ``NullArgument`` -- ``repository_id`` is ``null``\n        :raise: ``OperationFailed`` -- ``unable to complete request``\n        :raise: ``Unimplemented`` -- ``supports_composition_query()`` or ``supports_visible_federation()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_composition_query()`` and ``supports_visible_federation()`` are ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "repository_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "osid.repository.CompositionQuerySession", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_composition_search_session", 
               "doc": {
                  "headline": "Gets a composition search session.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.repository.CompositionSearchSession) - a\n                ``CompositionSearchSession``", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_composition_search()`` is\n                ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: a ``CompositionSearchSession``\n        :rtype: ``osid.repository.CompositionSearchSession``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_composition_search()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_composition_search()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.repository.CompositionSearchSession", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_composition_search_session_for_repository", 
               "doc": {
                  "headline": "Gets a composition search session for the given repository.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    repository_id (osid.id.Id): the ``Id`` of the repository\n", 
               "return_doc": "        return: (osid.repository.CompositionSearchSession) - a\n                ``CompositionSearchSession``", 
               "error_doc": "        raise:  NotFound - ``repository_id`` not found\n        raise:  NullArgument - ``repository_id`` is ``null``\n        raise:  OperationFailed - ``unable to complete request``\n        raise:  Unimplemented - ``supports_composition_search()`` or\n                ``supports_visible_federation()`` is ``false``", 
               "sphinx_param_doc": "        :param repository_id: the ``Id`` of the repository\n        :type repository_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: a ``CompositionSearchSession``\n        :rtype: ``osid.repository.CompositionSearchSession``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``repository_id`` not found\n        :raise: ``NullArgument`` -- ``repository_id`` is ``null``\n        :raise: ``OperationFailed`` -- ``unable to complete request``\n        :raise: ``Unimplemented`` -- ``supports_composition_search()`` or ``supports_visible_federation()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_composition_search()`` and ``supports_visible_federation()`` are ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "repository_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "osid.repository.CompositionSearchSession", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_composition_admin_session", 
               "doc": {
                  "headline": "Gets a composition administration session for creating, updating and deleting compositions.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.repository.CompositionAdminSession) - a\n                ``CompositionAdminSession``", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_composition_admin()`` is\n                ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: a ``CompositionAdminSession``\n        :rtype: ``osid.repository.CompositionAdminSession``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_composition_admin()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_composition_admin()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.repository.CompositionAdminSession", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_composition_admin_session_for_repository", 
               "doc": {
                  "headline": "Gets a composiiton administrative session for the given repository.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    repository_id (osid.id.Id): the ``Id`` of the repository\n", 
               "return_doc": "        return: (osid.repository.CompositionAdminSession) - a\n                ``CompositionAdminSession``", 
               "error_doc": "        raise:  NotFound - ``repository_id`` not found\n        raise:  NullArgument - ``repository_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_composition_admin()`` or\n                ``supports_visible_federation()`` is ``false``", 
               "sphinx_param_doc": "        :param repository_id: the ``Id`` of the repository\n        :type repository_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: a ``CompositionAdminSession``\n        :rtype: ``osid.repository.CompositionAdminSession``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``repository_id`` not found\n        :raise: ``NullArgument`` -- ``repository_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_composition_admin()`` or ``supports_visible_federation()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_composition_admin()`` and ``supports_visible_federation()`` are ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "repository_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "osid.repository.CompositionAdminSession", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_composition_notification_session", 
               "doc": {
                  "headline": "Gets the notification session for notifications pertaining to composition changes.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    composition_receiver\n                (osid.repository.CompositionReceiver): the notification\n                callback\n", 
               "return_doc": "        return: (osid.repository.CompositionNotificationSession) - a\n                ``CompositionNotificationSession``", 
               "error_doc": "        raise:  NullArgument - ``composition_receiver`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_composition_notification()``\n                is ``false``", 
               "sphinx_param_doc": "        :param composition_receiver: the notification callback\n        :type composition_receiver: ``osid.repository.CompositionReceiver``\n", 
               "sphinx_return_doc": "        :return: a ``CompositionNotificationSession``\n        :rtype: ``osid.repository.CompositionNotificationSession``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``composition_receiver`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_composition_notification()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_composition_notification()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.repository.CompositionReceiver", 
                     "var_name": "composition_receiver", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.repository.CompositionReceiver"
               ], 
               "return_type": "osid.repository.CompositionNotificationSession", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_composition_notification_session_for_repository", 
               "doc": {
                  "headline": "Gets the composition notification session for the given repository.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    composition_receiver\n                (osid.repository.CompositionReceiver): the notification\n                callback\n        arg:    repository_id (osid.id.Id): the ``Id`` of the repository\n", 
               "return_doc": "        return: (osid.repository.CompositionNotificationSession) - a\n                ``CompositionNotificationSession``", 
               "error_doc": "        raise:  NotFound - ``repository_id`` not found\n        raise:  NullArgument - ``composition_receiver`` or\n                ``repository_id`` is ``null``\n        raise:  OperationFailed - ``unable to complete request``\n        raise:  Unimplemented - ``supports_composition_notification()``\n                or ``supports_visible_federation()`` is ``false``", 
               "sphinx_param_doc": "        :param composition_receiver: the notification callback\n        :type composition_receiver: ``osid.repository.CompositionReceiver``\n        :param repository_id: the ``Id`` of the repository\n        :type repository_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: a ``CompositionNotificationSession``\n        :rtype: ``osid.repository.CompositionNotificationSession``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``repository_id`` not found\n        :raise: ``NullArgument`` -- ``composition_receiver`` or ``repository_id`` is ``null``\n        :raise: ``OperationFailed`` -- ``unable to complete request``\n        :raise: ``Unimplemented`` -- ``supports_composition_notification()`` or ``supports_visible_federation()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_composition_notfication()`` and ``supports_visible_federation()`` are ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.repository.CompositionReceiver", 
                     "var_name": "composition_receiver", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "repository_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.repository.CompositionReceiver", 
                  "osid.id.Id"
               ], 
               "return_type": "osid.repository.CompositionNotificationSession", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_composition_repository_session", 
               "doc": {
                  "headline": "Gets the session for retrieving composition to repository mappings.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.repository.CompositionRepositorySession) - a\n                ``CompositionRepositorySession``", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_composition_repository()`` is\n                ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: a ``CompositionRepositorySession``\n        :rtype: ``osid.repository.CompositionRepositorySession``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_composition_repository()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_composition_repository()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.repository.CompositionRepositorySession", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_composition_repository_assignment_session", 
               "doc": {
                  "headline": "Gets the session for assigning composition to repository mappings.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.repository.CompositionRepositoryAssignmentSession)\n                - a ``CompositionRepositoryAssignmentSession``", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented -\n                ``supports_composition_repository_assignment()`` is\n                ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: a ``CompositionRepositoryAssignmentSession``\n        :rtype: ``osid.repository.CompositionRepositoryAssignmentSession``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_composition_repository_assignment()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_composition_repository_assignment()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.repository.CompositionRepositoryAssignmentSession", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_composition_smart_repository_session", 
               "doc": {
                  "headline": "Gets a composition smart repository session for the given repository.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    repository_id (osid.id.Id): the ``Id`` of the repository\n", 
               "return_doc": "        return: (osid.repository.CompositionSmartRepositorySession) - a\n                ``CompositionSmartRepositorySession``", 
               "error_doc": "        raise:  NotFound - ``repository_id`` not found\n        raise:  NullArgument - ``repository_id`` is ``null``\n        raise:  OperationFailed - ``unable to complete request``\n        raise:  Unimplemented -\n                ``supports_composition_smart_repository()``  ``false``", 
               "sphinx_param_doc": "        :param repository_id: the ``Id`` of the repository\n        :type repository_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: a ``CompositionSmartRepositorySession``\n        :rtype: ``osid.repository.CompositionSmartRepositorySession``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``repository_id`` not found\n        :raise: ``NullArgument`` -- ``repository_id`` is ``null``\n        :raise: ``OperationFailed`` -- ``unable to complete request``\n        :raise: ``Unimplemented`` -- ``supports_composition_smart_repository()``  ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_composition_smart_repository()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "repository_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "osid.repository.CompositionSmartRepositorySession", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_repository_lookup_session", 
               "doc": {
                  "headline": "Gets the repository lookup session.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.repository.RepositoryLookupSession) - a\n                ``RepositoryLookupSession``", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_repository_lookup()`` is\n                ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: a ``RepositoryLookupSession``\n        :rtype: ``osid.repository.RepositoryLookupSession``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_repository_lookup()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_repository_lookup()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.repository.RepositoryLookupSession", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_repository_query_session", 
               "doc": {
                  "headline": "Gets the repository query session.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.repository.RepositoryQuerySession) - a\n                ``RepositoryQuerySession``", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_repository_query()`` is\n                ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: a ``RepositoryQuerySession``\n        :rtype: ``osid.repository.RepositoryQuerySession``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_repository_query()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_repository_query()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.repository.RepositoryQuerySession", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_repository_search_session", 
               "doc": {
                  "headline": "Gets the repository search session.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.repository.RepositorySearchSession) - a\n                ``RepositorySearchSession``", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_repository_search()`` is\n                ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: a ``RepositorySearchSession``\n        :rtype: ``osid.repository.RepositorySearchSession``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_repository_search()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_repository_search()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.repository.RepositorySearchSession", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_repository_admin_session", 
               "doc": {
                  "headline": "Gets the repository administrative session for creating, updating and deleteing repositories.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.repository.RepositoryAdminSession) - a\n                ``RepositoryAdminSession``", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_repository_admin()`` is\n                ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: a ``RepositoryAdminSession``\n        :rtype: ``osid.repository.RepositoryAdminSession``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_repository_admin()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_repository_admin()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.repository.RepositoryAdminSession", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_repository_notification_session", 
               "doc": {
                  "headline": "Gets the notification session for subscribing to changes to a repository.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    repository_receiver\n                (osid.repository.RepositoryReceiver): the notification\n                callback\n", 
               "return_doc": "        return: (osid.repository.RepositoryNotificationSession) - a\n                ``RepositoryNotificationSession``", 
               "error_doc": "        raise:  NullArgument - ``repository_receiver`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_repository_notification()``\n                is ``false``", 
               "sphinx_param_doc": "        :param repository_receiver: the notification callback\n        :type repository_receiver: ``osid.repository.RepositoryReceiver``\n", 
               "sphinx_return_doc": "        :return: a ``RepositoryNotificationSession``\n        :rtype: ``osid.repository.RepositoryNotificationSession``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``repository_receiver`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_repository_notification()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_repository_notification()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.repository.RepositoryReceiver", 
                     "var_name": "repository_receiver", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.repository.RepositoryReceiver"
               ], 
               "return_type": "osid.repository.RepositoryNotificationSession", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_repository_hierarchy_session", 
               "doc": {
                  "headline": "Gets the repository hierarchy traversal session.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.repository.RepositoryHierarchySession) - ``a\n                RepositoryHierarchySession``", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_repository_hierarchy()`` is\n                ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``a RepositoryHierarchySession``\n        :rtype: ``osid.repository.RepositoryHierarchySession``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_repository_hierarchy()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_repository_hierarchy()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.repository.RepositoryHierarchySession", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_repository_hierarchy_design_session", 
               "doc": {
                  "headline": "Gets the repository hierarchy design session.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.repository.RepositoryHierarchyDesignSession) - a\n                ``RepostoryHierarchyDesignSession``", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented -\n                ``supports_repository_hierarchy_design()`` is ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: a ``RepostoryHierarchyDesignSession``\n        :rtype: ``osid.repository.RepositoryHierarchyDesignSession``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_repository_hierarchy_design()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_repository_hierarchy_design()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.repository.RepositoryHierarchyDesignSession", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_repository_batch_manager", 
               "doc": {
                  "headline": "Gets a ``RepositoryBatchManager``.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.repository.batch.RepositoryBatchManager) - a\n                ``RepostoryBatchManager``", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_repository_batch()`` is\n                ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: a ``RepostoryBatchManager``\n        :rtype: ``osid.repository.batch.RepositoryBatchManager``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_repository_batch()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_repository_batch()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.repository.batch.RepositoryBatchManager", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_repository_rules_manager", 
               "doc": {
                  "headline": "Gets a ``RepositoryRulesManager``.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.repository.rules.RepositoryRulesManager) - a\n                ``RepostoryRulesManager``", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_repository_rules()`` is\n                ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: a ``RepostoryRulesManager``\n        :rtype: ``osid.repository.rules.RepositoryRulesManager``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_repository_rules()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_repository_rules()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.repository.rules.RepositoryRulesManager", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.repository.RepositoryProxyManager", 
         "shortname": "RepositoryProxyManager", 
         "category": "managers", 
         "doc": {
            "headline": "The repository manager provides access to asset lookup and creation session and provides interoperability tests for various aspects of this service.", 
            "body": "    Methods in this manager support the passing of a ``Proxy`` for the\n    purposes of passing information from a server environment. The\n    sessions included in this manager are:\n\n      * ``AssetLookupSession:`` a session to retrieve assets\n      * ``AssetQuerySession:`` a session to query assets\n      * ``AssetSearchSession:`` a session to search for assets\n      * ``AssetAdminSession:`` a session to create and delete assets\n      * ``AssetNotificationSession:`` a session to receive notifications\n        pertaining to asset changes\n      * ``AssetRepositorySession:`` a session to look up asset to\n        repository mappings\n      * ``AssetRepositoryAssignmentSession:`` a session to manage asset\n        to repository mappings\n      * ``AssetSmartRepositorySession:`` a session to manage dynamic\n        repositories of assets\n      * ``AssetTemporalSession:`` a session to access the temporal\n        coverage of an asset\n      * ``AssetTemporalAssignmentSession:`` a session to manage the\n        temporal coverage of an asset\n      * ``AssetSpatialSession:`` a session to access the spatial\n        coverage of an asset\n      * ``AssetSpatialAssignmentSession:`` a session to manage the\n        spatial coverage of an asset\n      * ``AssetCompositionSession:`` a session to look up asset\n        composition mappings\n      * ``AssetCompositionDesignSession:`` a session to map assets to\n        compositions\n    \n      * ``CompositionLookupSession: a`` session to retrieve compositions\n      * ``CompositionQuerySession:`` a session to query compositions\n      * ``CompositionSearchSession:`` a session to search for\n        compositions\n      * ``CompositionAdminSession:`` a session to create, update and\n        delete compositions\n      * ``CompositionNotificationSession:`` a session to receive\n        notifications pertaining to changes in compositions\n      * ``CompositionRepositorySession:`` a session to retrieve\n        composition repository mappings\n      * ``CompositionRepositoryAssignmentSession:`` a session to manage\n        composition repository mappings\n      * ``CompositionSmartRepositorySession:`` a session to manage\n        dynamic repositories of compositions\n    \n      * ``RepositoryLookupSession: a`` session to retrieve repositories\n      * ``RepositoryQuerySession:`` a session to query repositories\n      * ``RepositorySearchSession:`` a session to search for\n        repositories\n      * ``RepositoryAdminSession:`` a session to create, update and\n        delete repositories\n      * ``RepositoryNotificationSession:`` a session to receive\n        notifications pertaining to changes in repositories\n      * ``RepositoryHierarchySession:`` a session to traverse repository\n        hierarchies\n      * ``RepositoryHierarchyDesignSession:`` a session to manage\n        repository hierarchies\n"
         }, 
         "inherit_fullnames": [
            "osid.OsidProxyManager", 
            "osid.repository.RepositoryProfile"
         ], 
         "inherit_shortnames": [
            "OsidProxyManager", 
            "RepositoryProfile"
         ], 
         "inherit_pkg_names": [
            "osid", 
            "repository"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidProxyManager"
            }, 
            {
               "pkg_name": "repository", 
               "name": "RepositoryProfile"
            }
         ], 
         "method_names": [
            "get_asset_lookup_session", 
            "get_asset_lookup_session_for_repository", 
            "get_asset_query_session", 
            "get_asset_query_session_for_repository", 
            "get_asset_search_session", 
            "get_asset_search_session_for_repository", 
            "get_asset_admin_session", 
            "get_asset_admin_session_for_repository", 
            "get_asset_notification_session", 
            "get_asset_notification_session_for_repository", 
            "get_asset_repository_session", 
            "get_asset_repository_assignment_session", 
            "get_asset_smart_repository_session", 
            "get_asset_temporal_session", 
            "get_asset_temporal_session_for_repository", 
            "get_asset_temporal_assignment_session", 
            "get_asset_temporal_assignment_session_for_repository", 
            "get_asset_spatial_session", 
            "get_asset_spatial_session_for_repository", 
            "get_asset_spatial_assignment_session", 
            "get_asset_spatial_assignment_session_for_repository", 
            "get_asset_composition_session", 
            "get_asset_composition_design_session", 
            "get_composition_lookup_session", 
            "get_composition_lookup_session_for_repository", 
            "get_composition_query_session", 
            "get_composition_query_session_for_repository", 
            "get_composition_search_session", 
            "get_composition_search_session_for_repository", 
            "get_composition_admin_session", 
            "get_composition_admin_session_for_repository", 
            "get_composition_notification_session", 
            "get_composition_notification_session_for_repository", 
            "get_composition_repository_session", 
            "get_composition_repository_assignment_session", 
            "get_composition_smart_repository_session", 
            "get_repository_lookup_session", 
            "get_repository_query_session", 
            "get_repository_search_session", 
            "get_repository_admin_session", 
            "get_repository_notification_session", 
            "get_repository_hierarchy_session", 
            "get_repository_hierarchy_design_session", 
            "get_repository_batch_proxy_manager", 
            "get_repository_rules_proxy_manager"
         ], 
         "methods": [
            {
               "name": "get_asset_lookup_session", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` associated with the asset lookup service.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    proxy (osid.proxy.Proxy): a proxy\n", 
               "return_doc": "        return: (osid.repository.AssetLookupSession) - an\n                ``AssetLookupSession``", 
               "error_doc": "        raise:  NullArgument - ``proxy`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_asset_lookup()`` is ``false``", 
               "sphinx_param_doc": "        :param proxy: a proxy\n        :type proxy: ``osid.proxy.Proxy``\n", 
               "sphinx_return_doc": "        :return: an ``AssetLookupSession``\n        :rtype: ``osid.repository.AssetLookupSession``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``proxy`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_asset_lookup()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_asset_lookup()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.proxy.Proxy", 
                     "var_name": "proxy", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.proxy.Proxy"
               ], 
               "return_type": "osid.repository.AssetLookupSession", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_asset_lookup_session_for_repository", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` associated with the asset lookup service for the given repository.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    repository_id (osid.id.Id): the ``Id`` of the repository\n        arg:    proxy (osid.proxy.Proxy): a proxy\n", 
               "return_doc": "        return: (osid.repository.AssetLookupSession) - an\n                ``AssetLookupSession``", 
               "error_doc": "        raise:  NotFound - ``repository_id`` not found\n        raise:  NullArgument - ``repository_id`` or ``proxy`` is\n                ``null``\n        raise:  OperationFailed - ``unable to complete request``\n        raise:  Unimplemented - ``supports_asset_lookup()`` or\n                ``supports_visible_federation()`` is ``false``", 
               "sphinx_param_doc": "        :param repository_id: the ``Id`` of the repository\n        :type repository_id: ``osid.id.Id``\n        :param proxy: a proxy\n        :type proxy: ``osid.proxy.Proxy``\n", 
               "sphinx_return_doc": "        :return: an ``AssetLookupSession``\n        :rtype: ``osid.repository.AssetLookupSession``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``repository_id`` not found\n        :raise: ``NullArgument`` -- ``repository_id`` or ``proxy`` is ``null``\n        :raise: ``OperationFailed`` -- ``unable to complete request``\n        :raise: ``Unimplemented`` -- ``supports_asset_lookup()`` or ``supports_visible_federation()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_asset_lookup()`` and ``supports_visible_federation()`` are ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "repository_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.proxy.Proxy", 
                     "var_name": "proxy", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "osid.proxy.Proxy"
               ], 
               "return_type": "osid.repository.AssetLookupSession", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_asset_query_session", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` associated with the asset query service.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    proxy (osid.proxy.Proxy): a proxy\n", 
               "return_doc": "        return: (osid.repository.AssetQuerySession) - an\n                ``AssetQuerySession``", 
               "error_doc": "        raise:  NullArgument - ``proxy`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_asset_query()`` is ``false``", 
               "sphinx_param_doc": "        :param proxy: a proxy\n        :type proxy: ``osid.proxy.Proxy``\n", 
               "sphinx_return_doc": "        :return: an ``AssetQuerySession``\n        :rtype: ``osid.repository.AssetQuerySession``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``proxy`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_asset_query()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_asset_query()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.proxy.Proxy", 
                     "var_name": "proxy", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.proxy.Proxy"
               ], 
               "return_type": "osid.repository.AssetQuerySession", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_asset_query_session_for_repository", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` associated with the asset query service for the given repository.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    repository_id (osid.id.Id): the ``Id`` of the repository\n        arg:    proxy (osid.proxy.Proxy): a proxy\n", 
               "return_doc": "        return: (osid.repository.AssetQuerySession) - an\n                ``AssetQuerySession``", 
               "error_doc": "        raise:  NotFound - ``repository_id`` not found\n        raise:  NullArgument - ``repository_id`` or ``proxy`` is\n                ``null``\n        raise:  OperationFailed - ``unable to complete request``\n        raise:  Unimplemented - ``supports_asset_query()`` or\n                ``supports_visible_federation()`` is ``false``", 
               "sphinx_param_doc": "        :param repository_id: the ``Id`` of the repository\n        :type repository_id: ``osid.id.Id``\n        :param proxy: a proxy\n        :type proxy: ``osid.proxy.Proxy``\n", 
               "sphinx_return_doc": "        :return: an ``AssetQuerySession``\n        :rtype: ``osid.repository.AssetQuerySession``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``repository_id`` not found\n        :raise: ``NullArgument`` -- ``repository_id`` or ``proxy`` is ``null``\n        :raise: ``OperationFailed`` -- ``unable to complete request``\n        :raise: ``Unimplemented`` -- ``supports_asset_query()`` or ``supports_visible_federation()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_asset_query()`` and ``supports_visible_federation()`` are ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "repository_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.proxy.Proxy", 
                     "var_name": "proxy", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "osid.proxy.Proxy"
               ], 
               "return_type": "osid.repository.AssetQuerySession", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_asset_search_session", 
               "doc": {
                  "headline": "Gets an asset search session.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    proxy (osid.proxy.Proxy): a proxy\n", 
               "return_doc": "        return: (osid.repository.AssetSearchSession) - an\n                ``AssetSearchSession``", 
               "error_doc": "        raise:  NullArgument - ``proxy`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_asset_search()`` is ``false``", 
               "sphinx_param_doc": "        :param proxy: a proxy\n        :type proxy: ``osid.proxy.Proxy``\n", 
               "sphinx_return_doc": "        :return: an ``AssetSearchSession``\n        :rtype: ``osid.repository.AssetSearchSession``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``proxy`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_asset_search()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_asset_search()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.proxy.Proxy", 
                     "var_name": "proxy", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.proxy.Proxy"
               ], 
               "return_type": "osid.repository.AssetSearchSession", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_asset_search_session_for_repository", 
               "doc": {
                  "headline": "Gets an asset search session for the given repository.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    repository_id (osid.id.Id): the ``Id`` of the repository\n        arg:    proxy (osid.proxy.Proxy): a proxy\n", 
               "return_doc": "        return: (osid.repository.AssetSearchSession) - an\n                ``AssetSearchSession``", 
               "error_doc": "        raise:  NotFound - ``repository_id`` not found\n        raise:  NullArgument - ``repository_id`` or ``proxy`` is\n                ``null``\n        raise:  OperationFailed - ``unable to complete request``\n        raise:  Unimplemented - ``supports_asset_search()`` or\n                ``supports_visible_federation()`` is ``false``", 
               "sphinx_param_doc": "        :param repository_id: the ``Id`` of the repository\n        :type repository_id: ``osid.id.Id``\n        :param proxy: a proxy\n        :type proxy: ``osid.proxy.Proxy``\n", 
               "sphinx_return_doc": "        :return: an ``AssetSearchSession``\n        :rtype: ``osid.repository.AssetSearchSession``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``repository_id`` not found\n        :raise: ``NullArgument`` -- ``repository_id`` or ``proxy`` is ``null``\n        :raise: ``OperationFailed`` -- ``unable to complete request``\n        :raise: ``Unimplemented`` -- ``supports_asset_search()`` or ``supports_visible_federation()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_asset_search()`` and ``supports_visible_federation()`` are ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "repository_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.proxy.Proxy", 
                     "var_name": "proxy", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "osid.proxy.Proxy"
               ], 
               "return_type": "osid.repository.AssetSearchSession", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_asset_admin_session", 
               "doc": {
                  "headline": "Gets an asset administration session for creating, updating and deleting assets.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    proxy (osid.proxy.Proxy): a proxy\n", 
               "return_doc": "        return: (osid.repository.AssetAdminSession) - an\n                ``AssetAdminSession``", 
               "error_doc": "        raise:  NullArgument - ``proxy`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_asset_admin()`` is ``false``", 
               "sphinx_param_doc": "        :param proxy: a proxy\n        :type proxy: ``osid.proxy.Proxy``\n", 
               "sphinx_return_doc": "        :return: an ``AssetAdminSession``\n        :rtype: ``osid.repository.AssetAdminSession``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``proxy`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_asset_admin()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_asset_admin()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.proxy.Proxy", 
                     "var_name": "proxy", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.proxy.Proxy"
               ], 
               "return_type": "osid.repository.AssetAdminSession", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_asset_admin_session_for_repository", 
               "doc": {
                  "headline": "Gets an asset administration session for the given repository.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    repository_id (osid.id.Id): the ``Id`` of the repository\n        arg:    proxy (osid.proxy.Proxy): a proxy\n", 
               "return_doc": "        return: (osid.repository.AssetAdminSession) - an\n                ``AssetAdminSession``", 
               "error_doc": "        raise:  NotFound - ``repository_id`` not found\n        raise:  NullArgument - ``repository_id`` or ``proxy`` is\n                ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_asset_admin()`` or\n                ``supports_visible_federation()`` is ``false``", 
               "sphinx_param_doc": "        :param repository_id: the ``Id`` of the repository\n        :type repository_id: ``osid.id.Id``\n        :param proxy: a proxy\n        :type proxy: ``osid.proxy.Proxy``\n", 
               "sphinx_return_doc": "        :return: an ``AssetAdminSession``\n        :rtype: ``osid.repository.AssetAdminSession``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``repository_id`` not found\n        :raise: ``NullArgument`` -- ``repository_id`` or ``proxy`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_asset_admin()`` or ``supports_visible_federation()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_asset_admin()`` and ``supports_visible_federation()`` are ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "repository_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.proxy.Proxy", 
                     "var_name": "proxy", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "osid.proxy.Proxy"
               ], 
               "return_type": "osid.repository.AssetAdminSession", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_asset_notification_session", 
               "doc": {
                  "headline": "Gets the notification session for notifications pertaining to asset changes.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    asset_receiver (osid.repository.AssetReceiver): the\n                notification callback\n        arg:    proxy (osid.proxy.Proxy): a proxy\n", 
               "return_doc": "        return: (osid.repository.AssetNotificationSession) - an\n                ``AssetNotificationSession``", 
               "error_doc": "        raise:  NullArgument - ``asset_receiver`` or ``proxy`` is\n                ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_asset_notification()`` is\n                ``false``", 
               "sphinx_param_doc": "        :param asset_receiver: the notification callback\n        :type asset_receiver: ``osid.repository.AssetReceiver``\n        :param proxy: a proxy\n        :type proxy: ``osid.proxy.Proxy``\n", 
               "sphinx_return_doc": "        :return: an ``AssetNotificationSession``\n        :rtype: ``osid.repository.AssetNotificationSession``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``asset_receiver`` or ``proxy`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_asset_notification()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_asset_notification()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.repository.AssetReceiver", 
                     "var_name": "asset_receiver", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.proxy.Proxy", 
                     "var_name": "proxy", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.repository.AssetReceiver", 
                  "osid.proxy.Proxy"
               ], 
               "return_type": "osid.repository.AssetNotificationSession", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_asset_notification_session_for_repository", 
               "doc": {
                  "headline": "Gets the asset notification session for the given repository.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    asset_receiver (osid.repository.AssetReceiver): the\n                notification callback\n        arg:    repository_id (osid.id.Id): the ``Id`` of the repository\n        arg:    proxy (osid.proxy.Proxy): a proxy\n", 
               "return_doc": "        return: (osid.repository.AssetNotificationSession) - an\n                ``AssetNotificationSession``", 
               "error_doc": "        raise:  NotFound - ``repository_id`` not found\n        raise:  NullArgument - ``asset_receiver, repository_id`` or\n                ``proxy`` is ``null``\n        raise:  OperationFailed - ``unable to complete request``\n        raise:  Unimplemented - ``supports_asset_notification()`` or\n                ``supports_visible_federation()`` is ``false``", 
               "sphinx_param_doc": "        :param asset_receiver: the notification callback\n        :type asset_receiver: ``osid.repository.AssetReceiver``\n        :param repository_id: the ``Id`` of the repository\n        :type repository_id: ``osid.id.Id``\n        :param proxy: a proxy\n        :type proxy: ``osid.proxy.Proxy``\n", 
               "sphinx_return_doc": "        :return: an ``AssetNotificationSession``\n        :rtype: ``osid.repository.AssetNotificationSession``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``repository_id`` not found\n        :raise: ``NullArgument`` -- ``asset_receiver, repository_id`` or ``proxy`` is ``null``\n        :raise: ``OperationFailed`` -- ``unable to complete request``\n        :raise: ``Unimplemented`` -- ``supports_asset_notification()`` or ``supports_visible_federation()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_asset_notfication()`` and ``supports_visible_federation()`` are ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.repository.AssetReceiver", 
                     "var_name": "asset_receiver", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "repository_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.proxy.Proxy", 
                     "var_name": "proxy", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.repository.AssetReceiver", 
                  "osid.id.Id", 
                  "osid.proxy.Proxy"
               ], 
               "return_type": "osid.repository.AssetNotificationSession", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_asset_repository_session", 
               "doc": {
                  "headline": "Gets the session for retrieving asset to repository mappings.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    proxy (osid.proxy.Proxy): a proxy\n", 
               "return_doc": "        return: (osid.repository.AssetRepositorySession) - an\n                ``AssetRepositorySession``", 
               "error_doc": "        raise:  NullArgument - ``proxy`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_asset_repository()`` is\n                ``false``", 
               "sphinx_param_doc": "        :param proxy: a proxy\n        :type proxy: ``osid.proxy.Proxy``\n", 
               "sphinx_return_doc": "        :return: an ``AssetRepositorySession``\n        :rtype: ``osid.repository.AssetRepositorySession``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``proxy`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_asset_repository()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_asset_repository()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.proxy.Proxy", 
                     "var_name": "proxy", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.proxy.Proxy"
               ], 
               "return_type": "osid.repository.AssetRepositorySession", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_asset_repository_assignment_session", 
               "doc": {
                  "headline": "Gets the session for assigning asset to repository mappings.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    proxy (osid.proxy.Proxy): a proxy\n", 
               "return_doc": "        return: (osid.repository.AssetRepositoryAssignmentSession) - an\n                ``AssetRepositoryAsignmentSession``", 
               "error_doc": "        raise:  NullArgument - ``proxy`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented -\n                ``supports_asset_repository_assignment()`` is ``false``", 
               "sphinx_param_doc": "        :param proxy: a proxy\n        :type proxy: ``osid.proxy.Proxy``\n", 
               "sphinx_return_doc": "        :return: an ``AssetRepositoryAsignmentSession``\n        :rtype: ``osid.repository.AssetRepositoryAssignmentSession``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``proxy`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_asset_repository_assignment()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_asset_repository_assignment()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.proxy.Proxy", 
                     "var_name": "proxy", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.proxy.Proxy"
               ], 
               "return_type": "osid.repository.AssetRepositoryAssignmentSession", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_asset_smart_repository_session", 
               "doc": {
                  "headline": "Gets an asset smart repository session for the given repository.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    repository_id (osid.id.Id): the ``Id`` of the repository\n        arg:    proxy (osid.proxy.Proxy): a proxy\n", 
               "return_doc": "        return: (osid.repository.AssetSmartRepositorySession) - an\n                ``AssetSmartRepositorySession``", 
               "error_doc": "        raise:  NotFound - ``repository_id`` not found\n        raise:  NullArgument - ``repository_id`` or ``proxy`` is\n                ``null``\n        raise:  OperationFailed - ``unable to complete request``\n        raise:  Unimplemented - ``supports_asset_smart_repository()``\n                ``false``", 
               "sphinx_param_doc": "        :param repository_id: the ``Id`` of the repository\n        :type repository_id: ``osid.id.Id``\n        :param proxy: a proxy\n        :type proxy: ``osid.proxy.Proxy``\n", 
               "sphinx_return_doc": "        :return: an ``AssetSmartRepositorySession``\n        :rtype: ``osid.repository.AssetSmartRepositorySession``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``repository_id`` not found\n        :raise: ``NullArgument`` -- ``repository_id`` or ``proxy`` is ``null``\n        :raise: ``OperationFailed`` -- ``unable to complete request``\n        :raise: ``Unimplemented`` -- ``supports_asset_smart_repository()``  ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_asset_smart_repository()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "repository_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.proxy.Proxy", 
                     "var_name": "proxy", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "osid.proxy.Proxy"
               ], 
               "return_type": "osid.repository.AssetSmartRepositorySession", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_asset_temporal_session", 
               "doc": {
                  "headline": "Gets the session for retrieving temporal coverage of an asset.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    proxy (osid.proxy.Proxy): a proxy\n", 
               "return_doc": "        return: (osid.repository.AssetTemporalSession) - an\n                ``AssetTemporalSession``", 
               "error_doc": "        raise:  NullArgument - ``proxy`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_asset_temporal()`` is\n                ``false``", 
               "sphinx_param_doc": "        :param proxy: a proxy\n        :type proxy: ``osid.proxy.Proxy``\n", 
               "sphinx_return_doc": "        :return: an ``AssetTemporalSession``\n        :rtype: ``osid.repository.AssetTemporalSession``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``proxy`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_asset_temporal()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_asset_temporal()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.proxy.Proxy", 
                     "var_name": "proxy", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.proxy.Proxy"
               ], 
               "return_type": "osid.repository.AssetTemporalSession", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_asset_temporal_session_for_repository", 
               "doc": {
                  "headline": "Gets the session for retrieving temporal coverage of an asset for the given repository.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    repository_id (osid.id.Id): the ``Id`` of the repository\n        arg:    proxy (osid.proxy.Proxy): a proxy\n", 
               "return_doc": "        return: (osid.repository.AssetTemporalSession) - an\n                ``AssetTemporalSession``", 
               "error_doc": "        raise:  NotFound - ``repository_id`` not found\n        raise:  NullArgument - ``repository_id`` or ``proxy`` is\n                ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_asset_temporal()`` or\n                ``supports_visible_federation()`` is ``false``", 
               "sphinx_param_doc": "        :param repository_id: the ``Id`` of the repository\n        :type repository_id: ``osid.id.Id``\n        :param proxy: a proxy\n        :type proxy: ``osid.proxy.Proxy``\n", 
               "sphinx_return_doc": "        :return: an ``AssetTemporalSession``\n        :rtype: ``osid.repository.AssetTemporalSession``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``repository_id`` not found\n        :raise: ``NullArgument`` -- ``repository_id`` or ``proxy`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_asset_temporal()`` or ``supports_visible_federation()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_asset_temporal()`` and ``supports_visible_federation()`` are ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "repository_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.proxy.Proxy", 
                     "var_name": "proxy", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "osid.proxy.Proxy"
               ], 
               "return_type": "osid.repository.AssetTemporalSession", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_asset_temporal_assignment_session", 
               "doc": {
                  "headline": "Gets the session for assigning temporal coverage to an asset.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    proxy (osid.proxy.Proxy): a proxy\n", 
               "return_doc": "        return: (osid.repository.AssetTemporalAssignmentSession) - an\n                ``AssetTemporalAssignmentSession``", 
               "error_doc": "        raise:  NullArgument - ``proxy`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_asset_temporal_assignment()``\n                is ``false``", 
               "sphinx_param_doc": "        :param proxy: a proxy\n        :type proxy: ``osid.proxy.Proxy``\n", 
               "sphinx_return_doc": "        :return: an ``AssetTemporalAssignmentSession``\n        :rtype: ``osid.repository.AssetTemporalAssignmentSession``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``proxy`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_asset_temporal_assignment()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_asset_temporal_assignment()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.proxy.Proxy", 
                     "var_name": "proxy", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.proxy.Proxy"
               ], 
               "return_type": "osid.repository.AssetTemporalAssignmentSession", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_asset_temporal_assignment_session_for_repository", 
               "doc": {
                  "headline": "Gets the session for assigning temporal coverage of an asset for the given repository.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    repository_id (osid.id.Id): the ``Id`` of the repository\n        arg:    proxy (osid.proxy.Proxy): a proxy\n", 
               "return_doc": "        return: (osid.repository.AssetTemporalAssignmentSession) - an\n                ``AssetTemporalAssignmentSession``", 
               "error_doc": "        raise:  NotFound - ``repository_id`` not found\n        raise:  NullArgument - ``repository_id`` or ``proxy`` is\n                ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_asset_temporal_assignment()``\n                or ``supports_visible_federation()`` is ``false``", 
               "sphinx_param_doc": "        :param repository_id: the ``Id`` of the repository\n        :type repository_id: ``osid.id.Id``\n        :param proxy: a proxy\n        :type proxy: ``osid.proxy.Proxy``\n", 
               "sphinx_return_doc": "        :return: an ``AssetTemporalAssignmentSession``\n        :rtype: ``osid.repository.AssetTemporalAssignmentSession``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``repository_id`` not found\n        :raise: ``NullArgument`` -- ``repository_id`` or ``proxy`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_asset_temporal_assignment()`` or ``supports_visible_federation()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_asset_temporal_assignment()`` and ``supports_visible_federation()`` are ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "repository_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.proxy.Proxy", 
                     "var_name": "proxy", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "osid.proxy.Proxy"
               ], 
               "return_type": "osid.repository.AssetTemporalAssignmentSession", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_asset_spatial_session", 
               "doc": {
                  "headline": "Gets the session for retrieving spatial coverage of an asset.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    proxy (osid.proxy.Proxy): a proxy\n", 
               "return_doc": "        return: (osid.repository.AssetSpatialSession) - an\n                ``AssetSpatialSession``", 
               "error_doc": "        raise:  NullArgument - ``proxy`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_spatial_assets()`` is\n                ``false``", 
               "sphinx_param_doc": "        :param proxy: a proxy\n        :type proxy: ``osid.proxy.Proxy``\n", 
               "sphinx_return_doc": "        :return: an ``AssetSpatialSession``\n        :rtype: ``osid.repository.AssetSpatialSession``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``proxy`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_spatial_assets()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_spatial_assets()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.proxy.Proxy", 
                     "var_name": "proxy", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.proxy.Proxy"
               ], 
               "return_type": "osid.repository.AssetSpatialSession", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_asset_spatial_session_for_repository", 
               "doc": {
                  "headline": "Gets the session for retrieving spatial coverage of an asset for the given repository.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    repository_id (osid.id.Id): the ``Id`` of the repository\n        arg:    proxy (osid.proxy.Proxy): a proxy\n", 
               "return_doc": "        return: (osid.repository.AssetSpatialSession) - an\n                ``AssetSpatialSession``", 
               "error_doc": "        raise:  NotFound - ``repository_id`` not found\n        raise:  NullArgument - ``repository_id`` or ``proxy`` is\n                ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_asset_spatial()`` or\n                ``supports_visible_federation()`` is ``false``", 
               "sphinx_param_doc": "        :param repository_id: the ``Id`` of the repository\n        :type repository_id: ``osid.id.Id``\n        :param proxy: a proxy\n        :type proxy: ``osid.proxy.Proxy``\n", 
               "sphinx_return_doc": "        :return: an ``AssetSpatialSession``\n        :rtype: ``osid.repository.AssetSpatialSession``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``repository_id`` not found\n        :raise: ``NullArgument`` -- ``repository_id`` or ``proxy`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_asset_spatial()`` or ``supports_visible_federation()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_asset_spatial()`` and ``supports_visible_federation()`` are ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "repository_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.proxy.Proxy", 
                     "var_name": "proxy", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "osid.proxy.Proxy"
               ], 
               "return_type": "osid.repository.AssetSpatialSession", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_asset_spatial_assignment_session", 
               "doc": {
                  "headline": "Gets the session for assigning spatial coverage to an asset.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    proxy (osid.proxy.Proxy): a proxy\n", 
               "return_doc": "        return: (osid.repository.AssetSpatialAssignmentSession) - an\n                ``AssetSpatialAssignmentSession``", 
               "error_doc": "        raise:  NullArgument - ``proxy`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_asset_spatial_assignment()``\n                is ``false``", 
               "sphinx_param_doc": "        :param proxy: a proxy\n        :type proxy: ``osid.proxy.Proxy``\n", 
               "sphinx_return_doc": "        :return: an ``AssetSpatialAssignmentSession``\n        :rtype: ``osid.repository.AssetSpatialAssignmentSession``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``proxy`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_asset_spatial_assignment()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_asset_spatial_assignment()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.proxy.Proxy", 
                     "var_name": "proxy", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.proxy.Proxy"
               ], 
               "return_type": "osid.repository.AssetSpatialAssignmentSession", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_asset_spatial_assignment_session_for_repository", 
               "doc": {
                  "headline": "Gets the session for assigning spatial coverage of an asset for the given repository.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    repository_id (osid.id.Id): the ``Id`` of the repository\n        arg:    proxy (osid.proxy.Proxy): a proxy\n", 
               "return_doc": "        return: (osid.repository.AssetSpatialAssignmentSession) - an\n                ``AssetSpatialAssignmentSession``", 
               "error_doc": "        raise:  NotFound - ``repository_id`` not found\n        raise:  NullArgument - ``repository_id`` or ``proxy`` is\n                ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_asset_spatial_assignment()``\n                or ``supports_visible_federation()`` is ``false``", 
               "sphinx_param_doc": "        :param repository_id: the ``Id`` of the repository\n        :type repository_id: ``osid.id.Id``\n        :param proxy: a proxy\n        :type proxy: ``osid.proxy.Proxy``\n", 
               "sphinx_return_doc": "        :return: an ``AssetSpatialAssignmentSession``\n        :rtype: ``osid.repository.AssetSpatialAssignmentSession``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``repository_id`` not found\n        :raise: ``NullArgument`` -- ``repository_id`` or ``proxy`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_asset_spatial_assignment()`` or ``supports_visible_federation()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_asset_spatial_assignment()`` and ``supports_visible_federation()`` are ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "repository_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.proxy.Proxy", 
                     "var_name": "proxy", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "osid.proxy.Proxy"
               ], 
               "return_type": "osid.repository.AssetSpatialAssignmentSession", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_asset_composition_session", 
               "doc": {
                  "headline": "Gets the session for retrieving asset compositions.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    proxy (osid.proxy.Proxy): a proxy\n", 
               "return_doc": "        return: (osid.repository.AssetCompositionSession) - an\n                ``AssetCompositionSession``", 
               "error_doc": "        raise:  NullArgument - ``proxy`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_asset_composition()`` is\n                ``false``", 
               "sphinx_param_doc": "        :param proxy: a proxy\n        :type proxy: ``osid.proxy.Proxy``\n", 
               "sphinx_return_doc": "        :return: an ``AssetCompositionSession``\n        :rtype: ``osid.repository.AssetCompositionSession``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``proxy`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_asset_composition()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_asset_composition()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.proxy.Proxy", 
                     "var_name": "proxy", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.proxy.Proxy"
               ], 
               "return_type": "osid.repository.AssetCompositionSession", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_asset_composition_design_session", 
               "doc": {
                  "headline": "Gets the session for creating asset compositions.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    proxy (osid.proxy.Proxy): a proxy\n", 
               "return_doc": "        return: (osid.repository.AssetCompositionDesignSession) - an\n                ``AssetCompositionDesignSession``", 
               "error_doc": "        raise:  NullArgument - ``proxy`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_asset_composition_design()``\n                is ``false``", 
               "sphinx_param_doc": "        :param proxy: a proxy\n        :type proxy: ``osid.proxy.Proxy``\n", 
               "sphinx_return_doc": "        :return: an ``AssetCompositionDesignSession``\n        :rtype: ``osid.repository.AssetCompositionDesignSession``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``proxy`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_asset_composition_design()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_asset_composition_design()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.proxy.Proxy", 
                     "var_name": "proxy", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.proxy.Proxy"
               ], 
               "return_type": "osid.repository.AssetCompositionDesignSession", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_composition_lookup_session", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` associated with the composition lookup service.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    proxy (osid.proxy.Proxy): a proxy\n", 
               "return_doc": "        return: (osid.repository.CompositionLookupSession) - the new\n                ``CompositionLookupSession``", 
               "error_doc": "        raise:  NullArgument - ``proxy`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_composition_lookup()`` is\n                ``false``", 
               "sphinx_param_doc": "        :param proxy: a proxy\n        :type proxy: ``osid.proxy.Proxy``\n", 
               "sphinx_return_doc": "        :return: the new ``CompositionLookupSession``\n        :rtype: ``osid.repository.CompositionLookupSession``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``proxy`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_composition_lookup()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_composition_lookup()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.proxy.Proxy", 
                     "var_name": "proxy", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.proxy.Proxy"
               ], 
               "return_type": "osid.repository.CompositionLookupSession", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_composition_lookup_session_for_repository", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` associated with the composition lookup service for the given repository.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    repository_id (osid.id.Id): the ``Id`` of the repository\n        arg:    proxy (osid.proxy.Proxy): a proxy\n", 
               "return_doc": "        return: (osid.repository.CompositionLookupSession) - the new\n                ``CompositionLookupSession``", 
               "error_doc": "        raise:  NotFound - ``repository_id`` not found\n        raise:  NullArgument - ``repository_id`` or ``proxy`` is\n                ``null``\n        raise:  OperationFailed - ``unable to complete request``\n        raise:  Unimplemented - ``supports_composition_lookup()`` or\n                ``supports_visible_federation()`` is ``false``", 
               "sphinx_param_doc": "        :param repository_id: the ``Id`` of the repository\n        :type repository_id: ``osid.id.Id``\n        :param proxy: a proxy\n        :type proxy: ``osid.proxy.Proxy``\n", 
               "sphinx_return_doc": "        :return: the new ``CompositionLookupSession``\n        :rtype: ``osid.repository.CompositionLookupSession``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``repository_id`` not found\n        :raise: ``NullArgument`` -- ``repository_id`` or ``proxy`` is ``null``\n        :raise: ``OperationFailed`` -- ``unable to complete request``\n        :raise: ``Unimplemented`` -- ``supports_composition_lookup()`` or ``supports_visible_federation()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_composition_lookup()`` and ``supports_visible_federation()`` are ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "repository_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.proxy.Proxy", 
                     "var_name": "proxy", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "osid.proxy.Proxy"
               ], 
               "return_type": "osid.repository.CompositionLookupSession", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_composition_query_session", 
               "doc": {
                  "headline": "Gets a composition query session.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    proxy (osid.proxy.Proxy): a proxy\n", 
               "return_doc": "        return: (osid.repository.CompositionSearchSession) - a\n                ``CompositionQuerySession``", 
               "error_doc": "        raise:  NullArgument - ``proxy`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_composition_query()`` is\n                ``false``", 
               "sphinx_param_doc": "        :param proxy: a proxy\n        :type proxy: ``osid.proxy.Proxy``\n", 
               "sphinx_return_doc": "        :return: a ``CompositionQuerySession``\n        :rtype: ``osid.repository.CompositionSearchSession``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``proxy`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_composition_query()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_composition_query()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.proxy.Proxy", 
                     "var_name": "proxy", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.proxy.Proxy"
               ], 
               "return_type": "osid.repository.CompositionSearchSession", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_composition_query_session_for_repository", 
               "doc": {
                  "headline": "Gets a composition query session for the given repository.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    repository_id (osid.id.Id): the ``Id`` of the repository\n        arg:    proxy (osid.proxy.Proxy): a proxy\n", 
               "return_doc": "        return: (osid.repository.CompositionQuerySession) - a\n                ``CompositionQuerySession``", 
               "error_doc": "        raise:  NotFound - ``repository_id`` not found\n        raise:  NullArgument - ``repository_id`` or ``proxy`` is\n                ``null``\n        raise:  OperationFailed - ``unable to complete request``\n        raise:  Unimplemented - ``supports_composition_query()`` or\n                ``supports_visible_federation()`` is ``false``", 
               "sphinx_param_doc": "        :param repository_id: the ``Id`` of the repository\n        :type repository_id: ``osid.id.Id``\n        :param proxy: a proxy\n        :type proxy: ``osid.proxy.Proxy``\n", 
               "sphinx_return_doc": "        :return: a ``CompositionQuerySession``\n        :rtype: ``osid.repository.CompositionQuerySession``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``repository_id`` not found\n        :raise: ``NullArgument`` -- ``repository_id`` or ``proxy`` is ``null``\n        :raise: ``OperationFailed`` -- ``unable to complete request``\n        :raise: ``Unimplemented`` -- ``supports_composition_query()`` or ``supports_visible_federation()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_composition_query()`` and ``supports_visible_federation()`` are ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "repository_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.proxy.Proxy", 
                     "var_name": "proxy", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "osid.proxy.Proxy"
               ], 
               "return_type": "osid.repository.CompositionQuerySession", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_composition_search_session", 
               "doc": {
                  "headline": "Gets a composition search session.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    proxy (osid.proxy.Proxy): a proxy\n", 
               "return_doc": "        return: (osid.repository.CompositionSearchSession) - a\n                ``CompositionSearchSession``", 
               "error_doc": "        raise:  NullArgument - ``proxy`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_composition_search()`` is\n                ``false``", 
               "sphinx_param_doc": "        :param proxy: a proxy\n        :type proxy: ``osid.proxy.Proxy``\n", 
               "sphinx_return_doc": "        :return: a ``CompositionSearchSession``\n        :rtype: ``osid.repository.CompositionSearchSession``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``proxy`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_composition_search()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_composition_search()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.proxy.Proxy", 
                     "var_name": "proxy", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.proxy.Proxy"
               ], 
               "return_type": "osid.repository.CompositionSearchSession", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_composition_search_session_for_repository", 
               "doc": {
                  "headline": "Gets a composition search session for the given repository.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    repository_id (osid.id.Id): the ``Id`` of the repository\n        arg:    proxy (osid.proxy.Proxy): a proxy\n", 
               "return_doc": "        return: (osid.repository.CompositionSearchSession) - a\n                ``CompositionSearchSession``", 
               "error_doc": "        raise:  NotFound - ``repository_id`` not found\n        raise:  NullArgument - ``repository_id`` or ``proxy`` is\n                ``null``\n        raise:  OperationFailed - ``unable to complete request``\n        raise:  Unimplemented - ``supports_composition_search()`` or\n                ``supports_visible_federation()`` is ``false``", 
               "sphinx_param_doc": "        :param repository_id: the ``Id`` of the repository\n        :type repository_id: ``osid.id.Id``\n        :param proxy: a proxy\n        :type proxy: ``osid.proxy.Proxy``\n", 
               "sphinx_return_doc": "        :return: a ``CompositionSearchSession``\n        :rtype: ``osid.repository.CompositionSearchSession``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``repository_id`` not found\n        :raise: ``NullArgument`` -- ``repository_id`` or ``proxy`` is ``null``\n        :raise: ``OperationFailed`` -- ``unable to complete request``\n        :raise: ``Unimplemented`` -- ``supports_composition_search()`` or ``supports_visible_federation()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_composition_search()`` and ``supports_visible_federation()`` are ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "repository_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.proxy.Proxy", 
                     "var_name": "proxy", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "osid.proxy.Proxy"
               ], 
               "return_type": "osid.repository.CompositionSearchSession", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_composition_admin_session", 
               "doc": {
                  "headline": "Gets a composition administration session for creating, updating and deleting compositions.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    proxy (osid.proxy.Proxy): a proxy\n", 
               "return_doc": "        return: (osid.repository.CompositionAdminSession) - a\n                ``CompositionAdminSession``", 
               "error_doc": "        raise:  NullArgument - ``proxy`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_composition_admin()`` is\n                ``false``", 
               "sphinx_param_doc": "        :param proxy: a proxy\n        :type proxy: ``osid.proxy.Proxy``\n", 
               "sphinx_return_doc": "        :return: a ``CompositionAdminSession``\n        :rtype: ``osid.repository.CompositionAdminSession``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``proxy`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_composition_admin()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_composition_admin()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.proxy.Proxy", 
                     "var_name": "proxy", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.proxy.Proxy"
               ], 
               "return_type": "osid.repository.CompositionAdminSession", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_composition_admin_session_for_repository", 
               "doc": {
                  "headline": "Gets a composiiton administrative session for the given repository.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    repository_id (osid.id.Id): the ``Id`` of the repository\n        arg:    proxy (osid.proxy.Proxy): a proxy\n", 
               "return_doc": "        return: (osid.repository.CompositionAdminSession) - a\n                ``CompositionAdminSession``", 
               "error_doc": "        raise:  NotFound - ``repository_id`` not found\n        raise:  NullArgument - ``repository_id`` or ``proxy`` is\n                ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_composition_admin()`` or\n                ``supports_visible_federation()`` is ``false``", 
               "sphinx_param_doc": "        :param repository_id: the ``Id`` of the repository\n        :type repository_id: ``osid.id.Id``\n        :param proxy: a proxy\n        :type proxy: ``osid.proxy.Proxy``\n", 
               "sphinx_return_doc": "        :return: a ``CompositionAdminSession``\n        :rtype: ``osid.repository.CompositionAdminSession``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``repository_id`` not found\n        :raise: ``NullArgument`` -- ``repository_id`` or ``proxy`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_composition_admin()`` or ``supports_visible_federation()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_composition_admin()`` and ``supports_visible_federation()`` are ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "repository_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.proxy.Proxy", 
                     "var_name": "proxy", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "osid.proxy.Proxy"
               ], 
               "return_type": "osid.repository.CompositionAdminSession", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_composition_notification_session", 
               "doc": {
                  "headline": "Gets the notification session for notifications pertaining to composition changes.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    composition_receiver\n                (osid.repository.CompositionReceiver): the notification\n                callback\n        arg:    proxy (osid.proxy.Proxy): a proxy\n", 
               "return_doc": "        return: (osid.repository.CompositionNotificationSession) - a\n                ``CompositionNotificationSession``", 
               "error_doc": "        raise:  NullArgument - ``composition_receiver`` or ``proxy`` is\n                ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_composition_notification()``\n                is ``false``", 
               "sphinx_param_doc": "        :param composition_receiver: the notification callback\n        :type composition_receiver: ``osid.repository.CompositionReceiver``\n        :param proxy: a proxy\n        :type proxy: ``osid.proxy.Proxy``\n", 
               "sphinx_return_doc": "        :return: a ``CompositionNotificationSession``\n        :rtype: ``osid.repository.CompositionNotificationSession``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``composition_receiver`` or ``proxy`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_composition_notification()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_composition_notification()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.repository.CompositionReceiver", 
                     "var_name": "composition_receiver", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.proxy.Proxy", 
                     "var_name": "proxy", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.repository.CompositionReceiver", 
                  "osid.proxy.Proxy"
               ], 
               "return_type": "osid.repository.CompositionNotificationSession", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_composition_notification_session_for_repository", 
               "doc": {
                  "headline": "Gets the composition notification session for the given repository.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    composition_receiver\n                (osid.repository.CompositionReceiver): the notification\n                callback\n        arg:    repository_id (osid.id.Id): the ``Id`` of the repository\n        arg:    proxy (osid.proxy.Proxy): a proxy\n", 
               "return_doc": "        return: (osid.repository.CompositionNotificationSession) - a\n                ``CompositionNotificationSession``", 
               "error_doc": "        raise:  NotFound - ``repository_id`` not found\n        raise:  NullArgument - ``composition_receiver, repository_id``\n                or ``proxy`` is ``null``\n        raise:  OperationFailed - ``unable to complete request``\n        raise:  Unimplemented - ``supports_composition_notification()``\n                or ``supports_visible_federation()`` is ``false``", 
               "sphinx_param_doc": "        :param composition_receiver: the notification callback\n        :type composition_receiver: ``osid.repository.CompositionReceiver``\n        :param repository_id: the ``Id`` of the repository\n        :type repository_id: ``osid.id.Id``\n        :param proxy: a proxy\n        :type proxy: ``osid.proxy.Proxy``\n", 
               "sphinx_return_doc": "        :return: a ``CompositionNotificationSession``\n        :rtype: ``osid.repository.CompositionNotificationSession``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``repository_id`` not found\n        :raise: ``NullArgument`` -- ``composition_receiver, repository_id`` or ``proxy`` is ``null``\n        :raise: ``OperationFailed`` -- ``unable to complete request``\n        :raise: ``Unimplemented`` -- ``supports_composition_notification()`` or ``supports_visible_federation()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_composition_notfication()`` and ``supports_visible_federation()`` are ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.repository.CompositionReceiver", 
                     "var_name": "composition_receiver", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "repository_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.proxy.Proxy", 
                     "var_name": "proxy", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.repository.CompositionReceiver", 
                  "osid.id.Id", 
                  "osid.proxy.Proxy"
               ], 
               "return_type": "osid.repository.CompositionNotificationSession", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_composition_repository_session", 
               "doc": {
                  "headline": "Gets the session for retrieving composition to repository mappings.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    proxy (osid.proxy.Proxy): a proxy\n", 
               "return_doc": "        return: (osid.repository.CompositionRepositorySession) - a\n                ``CompositionRepositorySession``", 
               "error_doc": "        raise:  NullArgument - ``proxy`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_composition_repository()`` is\n                ``false``", 
               "sphinx_param_doc": "        :param proxy: a proxy\n        :type proxy: ``osid.proxy.Proxy``\n", 
               "sphinx_return_doc": "        :return: a ``CompositionRepositorySession``\n        :rtype: ``osid.repository.CompositionRepositorySession``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``proxy`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_composition_repository()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_composition_repository()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.proxy.Proxy", 
                     "var_name": "proxy", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.proxy.Proxy"
               ], 
               "return_type": "osid.repository.CompositionRepositorySession", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_composition_repository_assignment_session", 
               "doc": {
                  "headline": "Gets the session for assigning composition to repository mappings.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    proxy (osid.proxy.Proxy): a proxy\n", 
               "return_doc": "        return: (osid.repository.CompositionRepositoryAssignmentSession)\n                - a ``CompositionRepositoryAssignmentSession``", 
               "error_doc": "        raise:  NullArgument - ``proxy`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented -\n                ``supports_composition_repository_assignment()`` is\n                ``false``", 
               "sphinx_param_doc": "        :param proxy: a proxy\n        :type proxy: ``osid.proxy.Proxy``\n", 
               "sphinx_return_doc": "        :return: a ``CompositionRepositoryAssignmentSession``\n        :rtype: ``osid.repository.CompositionRepositoryAssignmentSession``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``proxy`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_composition_repository_assignment()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_composition_repository_assignment()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.proxy.Proxy", 
                     "var_name": "proxy", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.proxy.Proxy"
               ], 
               "return_type": "osid.repository.CompositionRepositoryAssignmentSession", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_composition_smart_repository_session", 
               "doc": {
                  "headline": "Gets a composition smart repository session for the given repository.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    repository_id (osid.id.Id): the ``Id`` of the repository\n        arg:    proxy (osid.proxy.Proxy): a proxy\n", 
               "return_doc": "        return: (osid.repository.CompositionSmartRepositorySession) - a\n                ``CompositionSmartRepositorySession``", 
               "error_doc": "        raise:  NotFound - ``repository_id`` not found\n        raise:  NullArgument - ``repository_id`` or ``proxy`` is\n                ``null``\n        raise:  OperationFailed - ``unable to complete request``\n        raise:  Unimplemented -\n                ``supports_composition_smart_repository()``  ``false``", 
               "sphinx_param_doc": "        :param repository_id: the ``Id`` of the repository\n        :type repository_id: ``osid.id.Id``\n        :param proxy: a proxy\n        :type proxy: ``osid.proxy.Proxy``\n", 
               "sphinx_return_doc": "        :return: a ``CompositionSmartRepositorySession``\n        :rtype: ``osid.repository.CompositionSmartRepositorySession``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``repository_id`` not found\n        :raise: ``NullArgument`` -- ``repository_id`` or ``proxy`` is ``null``\n        :raise: ``OperationFailed`` -- ``unable to complete request``\n        :raise: ``Unimplemented`` -- ``supports_composition_smart_repository()``  ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_composition_smart_repository()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "repository_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.proxy.Proxy", 
                     "var_name": "proxy", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "osid.proxy.Proxy"
               ], 
               "return_type": "osid.repository.CompositionSmartRepositorySession", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_repository_lookup_session", 
               "doc": {
                  "headline": "Gets the repository lookup session.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    proxy (osid.proxy.Proxy): a proxy\n", 
               "return_doc": "        return: (osid.repository.RepositoryLookupSession) - a\n                ``RepositoryLookupSession``", 
               "error_doc": "        raise:  NullArgument - ``proxy`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_repository_lookup()`` is\n                ``false``", 
               "sphinx_param_doc": "        :param proxy: a proxy\n        :type proxy: ``osid.proxy.Proxy``\n", 
               "sphinx_return_doc": "        :return: a ``RepositoryLookupSession``\n        :rtype: ``osid.repository.RepositoryLookupSession``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``proxy`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_repository_lookup()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_repository_lookup()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.proxy.Proxy", 
                     "var_name": "proxy", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.proxy.Proxy"
               ], 
               "return_type": "osid.repository.RepositoryLookupSession", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_repository_query_session", 
               "doc": {
                  "headline": "Gets the repository query session.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    proxy (osid.proxy.Proxy): a proxy\n", 
               "return_doc": "        return: (osid.repository.RepositoryQuerySession) - a\n                ``RepositoryQuerySession``", 
               "error_doc": "        raise:  NullArgument - ``proxy`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_repository_query()`` is\n                ``false``", 
               "sphinx_param_doc": "        :param proxy: a proxy\n        :type proxy: ``osid.proxy.Proxy``\n", 
               "sphinx_return_doc": "        :return: a ``RepositoryQuerySession``\n        :rtype: ``osid.repository.RepositoryQuerySession``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``proxy`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_repository_query()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_repository_query()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.proxy.Proxy", 
                     "var_name": "proxy", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.proxy.Proxy"
               ], 
               "return_type": "osid.repository.RepositoryQuerySession", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_repository_search_session", 
               "doc": {
                  "headline": "Gets the repository search session.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    proxy (osid.proxy.Proxy): a proxy\n", 
               "return_doc": "        return: (osid.repository.RepositorySearchSession) - a\n                ``RepositorySearchSession``", 
               "error_doc": "        raise:  NullArgument - ``proxy`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_repository_search()`` is\n                ``false``", 
               "sphinx_param_doc": "        :param proxy: a proxy\n        :type proxy: ``osid.proxy.Proxy``\n", 
               "sphinx_return_doc": "        :return: a ``RepositorySearchSession``\n        :rtype: ``osid.repository.RepositorySearchSession``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``proxy`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_repository_search()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_repository_search()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.proxy.Proxy", 
                     "var_name": "proxy", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.proxy.Proxy"
               ], 
               "return_type": "osid.repository.RepositorySearchSession", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_repository_admin_session", 
               "doc": {
                  "headline": "Gets the repository administrative session for creating, updating and deleteing repositories.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    proxy (osid.proxy.Proxy): a proxy\n", 
               "return_doc": "        return: (osid.repository.RepositoryAdminSession) - a\n                ``RepositoryAdminSession``", 
               "error_doc": "        raise:  NullArgument - ``proxy`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_repository_admin()`` is\n                ``false``", 
               "sphinx_param_doc": "        :param proxy: a proxy\n        :type proxy: ``osid.proxy.Proxy``\n", 
               "sphinx_return_doc": "        :return: a ``RepositoryAdminSession``\n        :rtype: ``osid.repository.RepositoryAdminSession``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``proxy`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_repository_admin()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_repository_admin()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.proxy.Proxy", 
                     "var_name": "proxy", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.proxy.Proxy"
               ], 
               "return_type": "osid.repository.RepositoryAdminSession", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_repository_notification_session", 
               "doc": {
                  "headline": "Gets the notification session for subscribing to changes to a repository.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    repository_receiver\n                (osid.repository.RepositoryReceiver): the notification\n                callback\n        arg:    proxy (osid.proxy.Proxy): a proxy\n", 
               "return_doc": "        return: (osid.repository.RepositoryNotificationSession) - a\n                ``RepositoryNotificationSession``", 
               "error_doc": "        raise:  NullArgument - ``repository_receiver`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_repository_notification()``\n                is ``false``", 
               "sphinx_param_doc": "        :param repository_receiver: the notification callback\n        :type repository_receiver: ``osid.repository.RepositoryReceiver``\n        :param proxy: a proxy\n        :type proxy: ``osid.proxy.Proxy``\n", 
               "sphinx_return_doc": "        :return: a ``RepositoryNotificationSession``\n        :rtype: ``osid.repository.RepositoryNotificationSession``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``repository_receiver`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_repository_notification()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_repository_notification()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.repository.RepositoryReceiver", 
                     "var_name": "repository_receiver", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.proxy.Proxy", 
                     "var_name": "proxy", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.repository.RepositoryReceiver", 
                  "osid.proxy.Proxy"
               ], 
               "return_type": "osid.repository.RepositoryNotificationSession", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_repository_hierarchy_session", 
               "doc": {
                  "headline": "Gets the repository hierarchy traversal session.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    proxy (osid.proxy.Proxy): a proxy\n", 
               "return_doc": "        return: (osid.repository.RepositoryHierarchySession) - ``a\n                RepositoryHierarchySession``", 
               "error_doc": "        raise:  NullArgument - ``proxy`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_repository_hierarchy()`` is\n                ``false``", 
               "sphinx_param_doc": "        :param proxy: a proxy\n        :type proxy: ``osid.proxy.Proxy``\n", 
               "sphinx_return_doc": "        :return: ``a RepositoryHierarchySession``\n        :rtype: ``osid.repository.RepositoryHierarchySession``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``proxy`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_repository_hierarchy()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_repository_hierarchy()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.proxy.Proxy", 
                     "var_name": "proxy", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.proxy.Proxy"
               ], 
               "return_type": "osid.repository.RepositoryHierarchySession", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_repository_hierarchy_design_session", 
               "doc": {
                  "headline": "Gets the repository hierarchy design session.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    proxy (osid.proxy.Proxy): a proxy\n", 
               "return_doc": "        return: (osid.repository.RepositoryHierarchyDesignSession) - a\n                ``RepostoryHierarchyDesignSession``", 
               "error_doc": "        raise:  NullArgument - ``proxy`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented -\n                ``supports_repository_hierarchy_design()`` is ``false``", 
               "sphinx_param_doc": "        :param proxy: a proxy\n        :type proxy: ``osid.proxy.Proxy``\n", 
               "sphinx_return_doc": "        :return: a ``RepostoryHierarchyDesignSession``\n        :rtype: ``osid.repository.RepositoryHierarchyDesignSession``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``proxy`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_repository_hierarchy_design()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_repository_hierarchy_design()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.proxy.Proxy", 
                     "var_name": "proxy", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.proxy.Proxy"
               ], 
               "return_type": "osid.repository.RepositoryHierarchyDesignSession", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_repository_batch_proxy_manager", 
               "doc": {
                  "headline": "Gets a ``RepositoryBatchProxyManager``.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.repository.batch.RepositoryBatchProxyManager) - a\n                ``RepostoryBatchProxyManager``", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_repository_batch()`` is\n                ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: a ``RepostoryBatchProxyManager``\n        :rtype: ``osid.repository.batch.RepositoryBatchProxyManager``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_repository_batch()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_repository_batch()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.repository.batch.RepositoryBatchProxyManager", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_repository_rules_proxy_manager", 
               "doc": {
                  "headline": "Gets a ``RepositoryRulesProxyManager``.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.repository.rules.RepositoryRulesProxyManager) - a\n                ``RepostoryRulesProxyManager``", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_repository_rules()`` is\n                ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: a ``RepostoryRulesProxyManager``\n        :rtype: ``osid.repository.rules.RepositoryRulesProxyManager``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_repository_rules()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_repository_rules()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.repository.rules.RepositoryRulesProxyManager", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.repository.AssetLookupSession", 
         "shortname": "AssetLookupSession", 
         "category": "sessions", 
         "doc": {
            "headline": "This session defines methods for retrieving assets.", 
            "body": "    An ``Asset`` represents an element of content stored in a\n    Repository.\n\n    This lookup session defines several views:\n    \n      * comparative view: elements may be silently omitted or re-ordered\n      * plenary view: provides a complete result set or is an error\n        condition\n      * isolated repository view: All asset methods in this session\n        operate, retrieve and pertain to assets defined explicitly in\n        the current repository. Using an isolated view is useful for\n        managing ``Assets`` with the ``AssetAdminSession.``\n      * federated repository view: All asset methods in this session\n        operate, retrieve and pertain to all assets defined in this\n        repository and any other assets implicitly available in this\n        repository through repository inheritence.\n\n    \n    The methods ``use_federated_repository_view()`` and\n    ``use_isolated_repository_view()`` behave as a radio group and one\n    should be selected before invoking any lookup methods.\n    \n    Assets may have an additional records indicated by their respective\n    record types. The record may not be accessed through a cast of the\n    ``Asset``."
         }, 
         "inherit_fullnames": [
            "osid.OsidSession"
         ], 
         "inherit_shortnames": [
            "OsidSession"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidSession"
            }
         ], 
         "method_names": [
            "get_repository_id", 
            "get_repository", 
            "can_lookup_assets", 
            "use_comparative_asset_view", 
            "use_plenary_asset_view", 
            "use_federated_repository_view", 
            "use_isolated_repository_view", 
            "get_asset", 
            "get_assets_by_ids", 
            "get_assets_by_genus_type", 
            "get_assets_by_parent_genus_type", 
            "get_assets_by_record_type", 
            "get_assets_by_provider", 
            "get_assets"
         ], 
         "methods": [
            {
               "name": "get_repository_id", 
               "doc": {
                  "headline": "Gets the ``Repository``  ``Id`` associated with this session.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.id.Id) - the ``Repository Id`` associated with\n                this session", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the ``Repository Id`` associated with this session\n        :rtype: ``osid.id.Id``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.id.Id", 
               "errors": {}
            }, 
            {
               "name": "get_repository", 
               "doc": {
                  "headline": "Gets the ``Repository`` associated with this session.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.repository.Repository) - the ``Repository``\n                associated with this session", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the ``Repository`` associated with this session\n        :rtype: ``osid.repository.Repository``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.repository.Repository", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "can_lookup_assets", 
               "doc": {
                  "headline": "Tests if this user can perform ``Asset`` lookups.", 
                  "body": "        A return of true does not guarantee successful authorization. A\n        return of false indicates that it is known all methods in this\n        session will result in a ``PermissionDenied``. This is intended\n        as a hint to an application that may opt not to offer lookup\n        operations."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``false`` if lookup methods are not\n                authorized, ``true`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``false`` if lookup methods are not authorized, ``true`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "use_comparative_asset_view", 
               "doc": {
                  "headline": "The returns from the lookup methods may omit or translate elements based on this session, such as authorization, and not result in an error.", 
                  "body": "        This view is used when greater interoperability is desired at\n        the expense of precision."
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "use_plenary_asset_view", 
               "doc": {
                  "headline": "A complete view of the ``Asset`` returns is desired.", 
                  "body": "        Methods will return what is requested or result in an error.\n        This view is used when greater precision is desired at the\n        expense of interoperability."
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "use_federated_repository_view", 
               "doc": {
                  "headline": "Federates the view for methods in this session.", 
                  "body": "        A federated view will include assets in repositories which are\n        children of this repository in the repository hierarchy."
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "use_isolated_repository_view", 
               "doc": {
                  "headline": "Isolates the view for methods in this session.", 
                  "body": "        An isolated view restricts lookups to this repository only."
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "get_asset", 
               "doc": {
                  "headline": "Gets the ``Asset`` specified by its ``Id``.", 
                  "body": "        In plenary mode, the exact ``Id`` is found or a ``NotFound``\n        results. Otherwise, the returned ``Asset`` may have a different\n        ``Id`` than requested, such as the case where a duplicate ``Id``\n        was assigned to an ``Asset`` and retained for compatibility."
               }, 
               "arg_doc": "        arg:    asset_id (osid.id.Id): the ``Id`` of the ``Asset`` to\n                retrieve\n", 
               "return_doc": "        return: (osid.repository.Asset) - the returned ``Asset``", 
               "error_doc": "        raise:  NotFound - no ``Asset`` found with the given ``Id``\n        raise:  NullArgument - ``asset_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param asset_id: the ``Id`` of the ``Asset`` to retrieve\n        :type asset_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: the returned ``Asset``\n        :rtype: ``osid.repository.Asset``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- no ``Asset`` found with the given ``Id``\n        :raise: ``NullArgument`` -- ``asset_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "asset_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "osid.repository.Asset", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_assets_by_ids", 
               "doc": {
                  "headline": "Gets an ``AssetList`` corresponding to the given ``IdList``.", 
                  "body": "        In plenary mode, the returned list contains all of the assets\n        specified in the ``Id`` list, in the order of the list,\n        including duplicates, or an error results if an ``Id`` in the\n        supplied list is not found or inaccessible. Otherwise,\n        inaccessible ``Assets`` may be omitted from the list and may\n        present the elements in any order including returning a unique\n        set."
               }, 
               "arg_doc": "        arg:    asset_ids (osid.id.IdList): the list of ``Ids`` to\n                retrieve\n", 
               "return_doc": "        return: (osid.repository.AssetList) - the returned ``Asset\n                list``", 
               "error_doc": "        raise:  NotFound - an ``Id`` was not found\n        raise:  NullArgument - ``asset_ids`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param asset_ids: the list of ``Ids`` to retrieve\n        :type asset_ids: ``osid.id.IdList``\n", 
               "sphinx_return_doc": "        :return: the returned ``Asset list``\n        :rtype: ``osid.repository.AssetList``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- an ``Id`` was not found\n        :raise: ``NullArgument`` -- ``asset_ids`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.IdList", 
                     "var_name": "asset_ids", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.IdList"
               ], 
               "return_type": "osid.repository.AssetList", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_assets_by_genus_type", 
               "doc": {
                  "headline": "Gets an ``AssetList`` corresponding to the given asset genus ``Type`` which does not include assets of types derived from the specified ``Type``.", 
                  "body": "        In plenary mode, the returned list contains all known assets or\n        an error results. Otherwise, the returned list may contain only\n        those assets that are accessible through this session."
               }, 
               "arg_doc": "        arg:    asset_genus_type (osid.type.Type): an asset genus type\n", 
               "return_doc": "        return: (osid.repository.AssetList) - the returned ``Asset\n                list``", 
               "error_doc": "        raise:  NullArgument - ``asset_genus_type`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param asset_genus_type: an asset genus type\n        :type asset_genus_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "        :return: the returned ``Asset list``\n        :rtype: ``osid.repository.AssetList``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``asset_genus_type`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "asset_genus_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "osid.repository.AssetList", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_assets_by_parent_genus_type", 
               "doc": {
                  "headline": "Gets an ``AssetList`` corresponding to the given asset genus ``Type`` and include any additional assets with genus types derived from the specified ``Type``.", 
                  "body": "        In plenary mode, the returned list contains all known assets or\n        an error results. Otherwise, the returned list may contain only\n        those assets that are accessible through this session."
               }, 
               "arg_doc": "        arg:    asset_genus_type (osid.type.Type): an asset genus type\n", 
               "return_doc": "        return: (osid.repository.AssetList) - the returned ``Asset\n                list``", 
               "error_doc": "        raise:  NullArgument - ``asset_genus_type`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param asset_genus_type: an asset genus type\n        :type asset_genus_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "        :return: the returned ``Asset list``\n        :rtype: ``osid.repository.AssetList``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``asset_genus_type`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "asset_genus_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "osid.repository.AssetList", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_assets_by_record_type", 
               "doc": {
                  "headline": "Gets an ``AssetList`` containing the given asset record ``Type``.", 
                  "body": "        In plenary mode, the returned list contains all known assets or\n        an error results. Otherwise, the returned list may contain only\n        those assets that are accessible through this session."
               }, 
               "arg_doc": "        arg:    asset_record_type (osid.type.Type): an asset record type\n", 
               "return_doc": "        return: (osid.repository.AssetList) - the returned ``Asset\n                list``", 
               "error_doc": "        raise:  NullArgument - ``asset_record_type`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param asset_record_type: an asset record type\n        :type asset_record_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "        :return: the returned ``Asset list``\n        :rtype: ``osid.repository.AssetList``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``asset_record_type`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "asset_record_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "osid.repository.AssetList", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_assets_by_provider", 
               "doc": {
                  "headline": "Gets an ``AssetList`` from the given provider.", 
                  "body": "        In plenary mode, the returned list contains all known assets or\n        an error results. Otherwise, the returned list may contain only\n        those assets that are accessible through this session."
               }, 
               "arg_doc": "        arg:    resource_id (osid.id.Id): a resource ``Id``\n", 
               "return_doc": "        return: (osid.repository.AssetList) - the returned ``Asset\n                list``", 
               "error_doc": "        raise:  NullArgument - ``resource_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param resource_id: a resource ``Id``\n        :type resource_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: the returned ``Asset list``\n        :rtype: ``osid.repository.AssetList``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``resource_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "resource_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "osid.repository.AssetList", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_assets", 
               "doc": {
                  "headline": "Gets all ``Assets``.", 
                  "body": "        In plenary mode, the returned list contains all known assets or\n        an error results. Otherwise, the returned list may contain only\n        those assets that are accessible through this session."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.repository.AssetList) - a list of ``Assets``", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: a list of ``Assets``\n        :rtype: ``osid.repository.AssetList``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.repository.AssetList", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.repository.AssetQuerySession", 
         "shortname": "AssetQuerySession", 
         "category": "sessions", 
         "doc": {
            "headline": "This session provides methods for searching among ``Asset`` objects.", 
            "body": "    The search query is constructed using the ``AssetQuery``.\n\n    This session defines views that offer differing behaviors for\n    searching.\n    \n      * federated repository view: searches include assets in\n        repositories of which this repository is a ancestor in the\n        repository hierarchy\n      * isolated repository view: searches are restricted to assets in\n        this repository\n\n    \n    Assets may have a query record indicated by their respective record\n    types. The query record is accessed via the ``AssetQuery``."
         }, 
         "inherit_fullnames": [
            "osid.OsidSession"
         ], 
         "inherit_shortnames": [
            "OsidSession"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidSession"
            }
         ], 
         "method_names": [
            "get_repository_id", 
            "get_repository", 
            "can_search_assets", 
            "use_federated_repository_view", 
            "use_isolated_repository_view", 
            "get_asset_query", 
            "get_assets_by_query"
         ], 
         "methods": [
            {
               "name": "get_repository_id", 
               "doc": {
                  "headline": "Gets the ``Repository``  ``Id`` associated with this session.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.id.Id) - the ``Repository Id`` associated with\n                this session", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the ``Repository Id`` associated with this session\n        :rtype: ``osid.id.Id``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.id.Id", 
               "errors": {}
            }, 
            {
               "name": "get_repository", 
               "doc": {
                  "headline": "Gets the ``Repository`` associated with this session.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.repository.Repository) - the ``Repository``\n                associated with this session", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the ``Repository`` associated with this session\n        :rtype: ``osid.repository.Repository``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.repository.Repository", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "can_search_assets", 
               "doc": {
                  "headline": "Tests if this user can perform ``Asset`` searches.", 
                  "body": "        A return of true does not guarantee successful authorization. A\n        return of false indicates that it is known all methods in this\n        session will result in a ``PermissionDenied``. This is intended\n        as a hint to an application that may opt not to offer search\n        operations to unauthorized users."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``false`` if search methods are not\n                authorized, ``true`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``false`` if search methods are not authorized, ``true`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "use_federated_repository_view", 
               "doc": {
                  "headline": "Federates the view for methods in this session.", 
                  "body": "        A federated view will include assets in repositories which are\n        children of this repository in the repository hierarchy."
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "use_isolated_repository_view", 
               "doc": {
                  "headline": "Isolates the view for methods in this session.", 
                  "body": "        An isolated view restricts lookups to this repository only."
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "get_asset_query", 
               "doc": {
                  "headline": "Gets an asset query.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.repository.AssetQuery) - the asset query", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the asset query\n        :rtype: ``osid.repository.AssetQuery``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.repository.AssetQuery", 
               "errors": {}
            }, 
            {
               "name": "get_assets_by_query", 
               "doc": {
                  "headline": "Gets a list of ``Assets`` matching the given asset query.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    asset_query (osid.repository.AssetQuery): the asset\n                query\n", 
               "return_doc": "        return: (osid.repository.AssetList) - the returned ``AssetList``", 
               "error_doc": "        raise:  NullArgument - ``asset_query`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        raise:  Unsupported - the ``asset_query`` is not of this service", 
               "sphinx_param_doc": "        :param asset_query: the asset query\n        :type asset_query: ``osid.repository.AssetQuery``\n", 
               "sphinx_return_doc": "        :return: the returned ``AssetList``\n        :rtype: ``osid.repository.AssetList``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``asset_query`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure\n        :raise: ``Unsupported`` -- the ``asset_query`` is not of this service", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.repository.AssetQuery", 
                     "var_name": "asset_query", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.repository.AssetQuery"
               ], 
               "return_type": "osid.repository.AssetList", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.repository.AssetSearchSession", 
         "shortname": "AssetSearchSession", 
         "category": "sessions", 
         "doc": {
            "headline": "This session provides methods for searching among ``Asset`` objects.", 
            "body": "    The search query is constructed using the ``AssetQuery``.\n\n    ``get_assets_by_query()`` is the basic search method and returns a\n    list of ``Assets``. A more advanced search may be performed with\n    ``getAssetsBySearch()``. It accepts an ``AssetSearch`` in addition\n    to the query for the purpose of specifying additional options\n    affecting the entire search, such as ordering.\n    ``get_assets_by_search()`` returns an ``AssetSearchResults`` that\n    can be used to access the resulting ``AssetList`` or be used to\n    perform a search within the result set through ``AssetList``.\n    \n    This session defines views that offer differing behaviors for\n    searching.\n    \n      * federated repository view: searches include assets in\n        repositories of which this repository is a ancestor in the\n        repository hierarchy\n      * isolated repository view: searches are restricted to assets in\n        this repository\n\n    \n    Assets may have a query record indicated by their respective record\n    types. The query record is accessed via the ``AssetQuery``."
         }, 
         "inherit_fullnames": [
            "osid.repository.AssetQuerySession"
         ], 
         "inherit_shortnames": [
            "AssetQuerySession"
         ], 
         "inherit_pkg_names": [
            "repository"
         ], 
         "inheritance": [
            {
               "pkg_name": "repository", 
               "name": "AssetQuerySession"
            }
         ], 
         "method_names": [
            "get_asset_search", 
            "get_asset_search_order", 
            "get_assets_by_search", 
            "get_asset_query_from_inspector"
         ], 
         "methods": [
            {
               "name": "get_asset_search", 
               "doc": {
                  "headline": "Gets an asset search.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.repository.AssetSearch) - the asset search", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the asset search\n        :rtype: ``osid.repository.AssetSearch``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.repository.AssetSearch", 
               "errors": {}
            }, 
            {
               "name": "get_asset_search_order", 
               "doc": {
                  "headline": "Gets an asset search order.", 
                  "body": "        The ``AssetSearchOrder`` is supplied to an ``AssetSearch`` to\n        specify the ordering of results."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.repository.AssetSearchOrder) - the asset search\n                order", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the asset search order\n        :rtype: ``osid.repository.AssetSearchOrder``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.repository.AssetSearchOrder", 
               "errors": {}
            }, 
            {
               "name": "get_assets_by_search", 
               "doc": {
                  "headline": "Gets the search results matching the given search query using the given search.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    asset_query (osid.repository.AssetQuery): the asset\n                query\n        arg:    asset_search (osid.repository.AssetSearch): the asset\n                search\n", 
               "return_doc": "        return: (osid.repository.AssetSearchResults) - the asset search\n                results", 
               "error_doc": "        raise:  NullArgument - ``asset_query`` or ``asset_search`` is\n                ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        raise:  Unsupported - ``asset_query`` or ``asset_search`` is not\n                of this service", 
               "sphinx_param_doc": "        :param asset_query: the asset query\n        :type asset_query: ``osid.repository.AssetQuery``\n        :param asset_search: the asset search\n        :type asset_search: ``osid.repository.AssetSearch``\n", 
               "sphinx_return_doc": "        :return: the asset search results\n        :rtype: ``osid.repository.AssetSearchResults``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``asset_query`` or ``asset_search`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure\n        :raise: ``Unsupported`` -- ``asset_query`` or ``asset_search`` is not of this service", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.repository.AssetQuery", 
                     "var_name": "asset_query", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.repository.AssetSearch", 
                     "var_name": "asset_search", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.repository.AssetQuery", 
                  "osid.repository.AssetSearch"
               ], 
               "return_type": "osid.repository.AssetSearchResults", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_asset_query_from_inspector", 
               "doc": {
                  "headline": "Gets an asset query from an inspector.", 
                  "body": "        The inspector is available from a ``AssetSearchResults``."
               }, 
               "arg_doc": "        arg:    asset_query_inspector\n                (osid.repository.AssetQueryInspector): an asset query\n                inspector\n", 
               "return_doc": "        return: (osid.repository.AssetQuery) - the asset query", 
               "error_doc": "        raise:  NullArgument - ``asset_query_inspector`` is ``null``\n        raise:  Unsupported - ``asset_query_inspector`` is not of this\n                service", 
               "sphinx_param_doc": "        :param asset_query_inspector: an asset query inspector\n        :type asset_query_inspector: ``osid.repository.AssetQueryInspector``\n", 
               "sphinx_return_doc": "        :return: the asset query\n        :rtype: ``osid.repository.AssetQuery``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``asset_query_inspector`` is ``null``\n        :raise: ``Unsupported`` -- ``asset_query_inspector`` is not of this service", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.repository.AssetQueryInspector", 
                     "var_name": "asset_query_inspector", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.repository.AssetQueryInspector"
               ], 
               "return_type": "osid.repository.AssetQuery", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.repository.AssetAdminSession", 
         "shortname": "AssetAdminSession", 
         "category": "sessions", 
         "doc": {
            "headline": "This session creates, updates, and deletes ``Assets``.", 
            "body": "    The data for create and update is provided by the consumer via the\n    form object. ``OsidForms`` are requested for each create or update\n    and may not be reused.\n\n    Create and update operations differ in their usage. To create an\n    ``Asset,`` an ``AssetForm`` is requested using\n    ``get_asset_form_for_create()`` specifying the desired record\n    ``Types`` or none if no record ``Types`` are needed. The returned\n    ``AssetyForm`` will indicate that it is to be used with a create\n    operation and can be used to examine metdata or validate data prior\n    to creation. Once the ``AssetForm`` is submiited to a create\n    operation, it cannot be reused with another create operation unless\n    the first operation was unsuccessful. Each ``AssetForm`` corresponds\n    to an attempted transaction.\n    \n    For updates, ``AssetForms`` are requested to the ``Asset``  ``Id``\n    that is to be updated using ``getAssetFormForUpdate()``. Similarly,\n    the ``AssetForm`` has metadata about the data that can be updated\n    and it can perform validation before submitting the update. The\n    ``AssetForm`` can only be used once for a successful update and\n    cannot be reused.\n    \n    The delete operations delete ``Assets``. To unmap an ``Asset`` from\n    the current ``Repository,`` the ``AssetRepositoryAssignmentSession``\n    should be used. These delete operations attempt to remove the\n    ``Bid`` itself thus removing it from all known ``Repository``\n    catalogs.\n    \n    This session includes an ``Id`` aliasing mechanism to assign an\n    external ``Id`` to an internally assigned Id.\n    \n    The view of the administrative methods defined in this session is\n    determined by the provider. For an instance of this session where no\n    repository has been specified, it may not be parallel to the\n    ``AssetLookupSession``. For example, a default\n    ``AssetLookupSession`` may view the entire repository hierarchy\n    while the default ``AssetAdminSession`` uses an isolated\n    ``Repository`` to create new ``Assets`` ora specific repository to\n    operate on a predetermined set of ``Assets``. Another scenario is a\n    federated provider who does not wish to permit administrative\n    operations for the federation unaware.\n    \n    Example create:\n      if (!session.canCreateAssets()) {\n          return \"asset creation not permitted\";\n      }\n      \n      Type types[1];\n      types[0] = assetPhotographType; \n      if (!session.canCreateAssetWithRecordTypes(types)) {\n          return \"creating an asset with a photograph type is not supported\";\n      }\n      \n      AssetForm form = session.getAssetFormForCreate();\n      Metadata metadata = form.getDisplayNameMetadata();\n      if (metadata.isReadOnly()) {\n          return \"cannot set display name\";\n      }\n      \n      form.setDisplayName(\"my photo\");\n      \n      PhotographRecordForm photoForm = (PhotographRecordForn) form.getRecordForm(assetPhotogaphType);\n      Metadata metadata = form.getApertureMetadata();\n      if (metadata.isReadOnly()) {\n          return (\"cannot set aperture\");\n      }\n      \n      photoForm.setAperture(\"5.6\");\n      if (!form.isValid()) {\n          return form.getValidationMessage();\n      }\n      \n      Asset newAsset = session.createAsset(form);\n    \n"
         }, 
         "inherit_fullnames": [
            "osid.OsidSession"
         ], 
         "inherit_shortnames": [
            "OsidSession"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidSession"
            }
         ], 
         "method_names": [
            "get_repository_id", 
            "get_repository", 
            "can_create_assets", 
            "can_create_asset_with_record_types", 
            "get_asset_form_for_create", 
            "create_asset", 
            "can_update_assets", 
            "get_asset_form_for_update", 
            "update_asset", 
            "can_delete_assets", 
            "delete_asset", 
            "can_manage_asset_aliases", 
            "alias_asset", 
            "can_create_asset_content", 
            "can_create_asset_content_with_record_types", 
            "get_asset_content_form_for_create", 
            "create_asset_content", 
            "can_update_asset_contents", 
            "get_asset_content_form_for_update", 
            "update_asset_content", 
            "can_delete_asset_contents", 
            "delete_asset_content"
         ], 
         "methods": [
            {
               "name": "get_repository_id", 
               "doc": {
                  "headline": "Gets the ``Repository``  ``Id`` associated with this session.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.id.Id) - the ``Repository Id`` associated with\n                this session", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the ``Repository Id`` associated with this session\n        :rtype: ``osid.id.Id``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.id.Id", 
               "errors": {}
            }, 
            {
               "name": "get_repository", 
               "doc": {
                  "headline": "Gets the ``Repository`` associated with this session.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.repository.Repository) - the ``Repository``\n                associated with this session", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the ``Repository`` associated with this session\n        :rtype: ``osid.repository.Repository``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.repository.Repository", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "can_create_assets", 
               "doc": {
                  "headline": "Tests if this user can create ``Assets``.", 
                  "body": "        A return of true does not guarantee successful authorization. A\n        return of false indicates that it is known creating an ``Asset``\n        will result in a ``PermissionDenied``. This is intended as a\n        hint to an application that may opt not to offer create\n        operations to an unauthorized user."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``false`` if ``Asset`` creation is not\n                authorized, ``true`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``false`` if ``Asset`` creation is not authorized, ``true`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "can_create_asset_with_record_types", 
               "doc": {
                  "headline": "Tests if this user can create a single ``Asset`` using the desired record types.", 
                  "body": "        While ``RepositoryManager.getAssetRecordTypes()`` can be used to\n        examine which records are supported, this method tests which\n        record(s) are required for creating a specific ``Asset``.\n        Providing an empty array tests if an ``Asset`` can be created\n        with no records."
               }, 
               "arg_doc": "        arg:    asset_record_types (osid.type.Type[]): array of asset\n                record types\n", 
               "return_doc": "        return: (boolean) - ``true`` if ``Asset`` creation using the\n                specified record ``Types`` is supported, ``false``\n                otherwise", 
               "error_doc": "        raise:  NullArgument - ``asset_record_types`` is ``null``", 
               "sphinx_param_doc": "        :param asset_record_types: array of asset record types\n        :type asset_record_types: ``osid.type.Type[]``\n", 
               "sphinx_return_doc": "        :return: ``true`` if ``Asset`` creation using the specified record ``Types`` is supported, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``asset_record_types`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type[]", 
                     "var_name": "asset_record_types", 
                     "array": true
                  }
               ], 
               "arg_types": [
                  "osid.type.Type[]"
               ], 
               "return_type": "boolean", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "get_asset_form_for_create", 
               "doc": {
                  "headline": "Gets the asset form for creating new assets.", 
                  "body": "        A new form should be requested for each create transaction."
               }, 
               "arg_doc": "        arg:    asset_record_types (osid.type.Type[]): array of asset\n                record types\n", 
               "return_doc": "        return: (osid.repository.AssetForm) - the asset form", 
               "error_doc": "        raise:  NullArgument - ``asset_record_types`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        raise:  Unsupported - unable to get form for requested record\n                types", 
               "sphinx_param_doc": "        :param asset_record_types: array of asset record types\n        :type asset_record_types: ``osid.type.Type[]``\n", 
               "sphinx_return_doc": "        :return: the asset form\n        :rtype: ``osid.repository.AssetForm``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``asset_record_types`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure\n        :raise: ``Unsupported`` -- unable to get form for requested record types", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type[]", 
                     "var_name": "asset_record_types", 
                     "array": true
                  }
               ], 
               "arg_types": [
                  "osid.type.Type[]"
               ], 
               "return_type": "osid.repository.AssetForm", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }, 
            {
               "name": "create_asset", 
               "doc": {
                  "headline": "Creates a new ``Asset``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    asset_form (osid.repository.AssetForm): the form for\n                this ``Asset``\n", 
               "return_doc": "        return: (osid.repository.Asset) - the new ``Asset``", 
               "error_doc": "        raise:  IllegalState - ``asset_form`` already used in a create\n                transaction\n        raise:  InvalidArgument - one or more of the form elements is\n                invalid\n        raise:  NullArgument - ``asset_form`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        raise:  Unsupported - ``asset_form`` did not originate from\n                ``get_asset_form_for_create()``", 
               "sphinx_param_doc": "        :param asset_form: the form for this ``Asset``\n        :type asset_form: ``osid.repository.AssetForm``\n", 
               "sphinx_return_doc": "        :return: the new ``Asset``\n        :rtype: ``osid.repository.Asset``", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- ``asset_form`` already used in a create transaction\n        :raise: ``InvalidArgument`` -- one or more of the form elements is invalid\n        :raise: ``NullArgument`` -- ``asset_form`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure\n        :raise: ``Unsupported`` -- ``asset_form`` did not originate from ``get_asset_form_for_create()``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.repository.AssetForm", 
                     "var_name": "asset_form", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.repository.AssetForm"
               ], 
               "return_type": "osid.repository.Asset", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract", 
                  "INVALID_ARGUMENT": "ConsumerContract", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }, 
            {
               "name": "can_update_assets", 
               "doc": {
                  "headline": "Tests if this user can update ``Assets``.", 
                  "body": "        A return of true does not guarantee successful authorization. A\n        return of false indicates that it is known updating an ``Asset``\n        will result in a ``PermissionDenied``. This is intended as a\n        hint to an application that may opt not to offer update\n        operations to an unauthorized user."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``false`` if ``Asset`` modification is not\n                authorized, ``true`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``false`` if ``Asset`` modification is not authorized, ``true`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "get_asset_form_for_update", 
               "doc": {
                  "headline": "Gets the asset form for updating an existing asset.", 
                  "body": "        A new asset form should be requested for each update\n        transaction."
               }, 
               "arg_doc": "        arg:    asset_id (osid.id.Id): the ``Id`` of the ``Asset``\n", 
               "return_doc": "        return: (osid.repository.AssetForm) - the asset form", 
               "error_doc": "        raise:  NotFound - ``asset_id`` is not found\n        raise:  NullArgument - ``asset_id`` is null\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param asset_id: the ``Id`` of the ``Asset``\n        :type asset_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: the asset form\n        :rtype: ``osid.repository.AssetForm``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``asset_id`` is not found\n        :raise: ``NullArgument`` -- ``asset_id`` is null\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "asset_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "osid.repository.AssetForm", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "update_asset", 
               "doc": {
                  "headline": "Updates an existing asset.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    asset_form (osid.repository.AssetForm): the form\n                containing the elements to be updated\n", 
               "return_doc": "", 
               "error_doc": "        raise:  IllegalState - ``asset_form`` already used in anupdate\n                transaction\n        raise:  InvalidArgument - the form contains an invalid value\n        raise:  NullArgument - ``asset_form`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        raise:  Unsupported - ``asset_form`` did not originate from\n                ``get_asset_form_for_update()``", 
               "sphinx_param_doc": "        :param asset_form: the form containing the elements to be updated\n        :type asset_form: ``osid.repository.AssetForm``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- ``asset_form`` already used in anupdate transaction\n        :raise: ``InvalidArgument`` -- the form contains an invalid value\n        :raise: ``NullArgument`` -- ``asset_form`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure\n        :raise: ``Unsupported`` -- ``asset_form`` did not originate from ``get_asset_form_for_update()``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.repository.AssetForm", 
                     "var_name": "asset_form", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.repository.AssetForm"
               ], 
               "return_type": "", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract", 
                  "INVALID_ARGUMENT": "ConsumerContract", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }, 
            {
               "name": "can_delete_assets", 
               "doc": {
                  "headline": "Tests if this user can delete ``Assets``.", 
                  "body": "        A return of true does not guarantee successful authorization. A\n        return of false indicates that it is known deleting an ``Asset``\n        will result in a ``PermissionDenied``. This is intended as a\n        hint to an application that may opt not to offer delete\n        operations to an unauthorized user."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``false`` if ``Asset`` deletion is not\n                authorized, ``true`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``false`` if ``Asset`` deletion is not authorized, ``true`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "delete_asset", 
               "doc": {
                  "headline": "Deletes an ``Asset``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    asset_id (osid.id.Id): the ``Id`` of the ``Asset`` to\n                remove\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NotFound - ``asset_id`` not found\n        raise:  NullArgument - ``asset_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param asset_id: the ``Id`` of the ``Asset`` to remove\n        :type asset_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``asset_id`` not found\n        :raise: ``NullArgument`` -- ``asset_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "asset_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "can_manage_asset_aliases", 
               "doc": {
                  "headline": "Tests if this user can manage ``Id`` aliases for ``Assets``.", 
                  "body": "        A return of true does not guarantee successful authorization. A\n        return of false indicates that it is known changing an alias\n        will result in a ``PermissionDenied``. This is intended as a\n        hint to an application that may opt not to offer alias\n        operations to an unauthorized user."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``false`` if ``Asset`` aliasing is not\n                authorized, ``true`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``false`` if ``Asset`` aliasing is not authorized, ``true`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "alias_asset", 
               "doc": {
                  "headline": "Adds an ``Id`` to an ``Asset`` for the purpose of creating compatibility.", 
                  "body": "        The primary ``Id`` of the ``Asset`` is determined by the\n        provider. The new ``Id`` performs as an alias to the primary\n        ``Id``. If the alias is a pointer to another asset, it is\n        reassigned to the given asset ``Id``."
               }, 
               "arg_doc": "        arg:    asset_id (osid.id.Id): the ``Id`` of an ``Asset``\n        arg:    alias_id (osid.id.Id): the alias ``Id``\n", 
               "return_doc": "", 
               "error_doc": "        raise:  AlreadyExists - ``alias_id`` is already assigned\n        raise:  NotFound - ``asset_id`` not found\n        raise:  NullArgument - ``asset_id`` or ``alias_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param asset_id: the ``Id`` of an ``Asset``\n        :type asset_id: ``osid.id.Id``\n        :param alias_id: the alias ``Id``\n        :type alias_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``AlreadyExists`` -- ``alias_id`` is already assigned\n        :raise: ``NotFound`` -- ``asset_id`` not found\n        :raise: ``NullArgument`` -- ``asset_id`` or ``alias_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "asset_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "alias_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {
                  "ALREADY_EXISTS": "User", 
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "can_create_asset_content", 
               "doc": {
                  "headline": "Tests if this user can create content for ``Assets``.", 
                  "body": "        A return of true does not guarantee successful authorization. A\n        return of false indicates that it is known creating an\n        ``AssetContent`` will result in a ``PermissionDenied``. This is\n        intended as a hint to an application that may opt not to offer\n        create operations to an unauthorized user."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``false`` if ``Asset`` content creation is\n                not authorized, ``true`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``false`` if ``Asset`` content creation is not authorized, ``true`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "can_create_asset_content_with_record_types", 
               "doc": {
                  "headline": "Tests if this user can create an ``AssetContent`` using the desired record types.", 
                  "body": "        While ``RepositoryManager.getAssetContentRecordTypes()`` can be\n        used to test which records are supported, this method tests\n        which records are required for creating a specific\n        ``AssetContent``. Providing an empty array tests if an\n        ``AssetContent`` can be created with no records."
               }, 
               "arg_doc": "        arg:    asset_content_record_types (osid.type.Type[]): array of\n                asset content record types\n", 
               "return_doc": "        return: (boolean) - ``true`` if ``AssetContent`` creation using\n                the specified ``Types`` is supported, ``false``\n                otherwise", 
               "error_doc": "        raise:  NullArgument - ``asset_content_record_types`` is\n                ``null``", 
               "sphinx_param_doc": "        :param asset_content_record_types: array of asset content record types\n        :type asset_content_record_types: ``osid.type.Type[]``\n", 
               "sphinx_return_doc": "        :return: ``true`` if ``AssetContent`` creation using the specified ``Types`` is supported, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``asset_content_record_types`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type[]", 
                     "var_name": "asset_content_record_types", 
                     "array": true
                  }
               ], 
               "arg_types": [
                  "osid.type.Type[]"
               ], 
               "return_type": "boolean", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "get_asset_content_form_for_create", 
               "doc": {
                  "headline": "Gets an asset content form for creating new assets.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    asset_id (osid.id.Id): the ``Id`` of an ``Asset``\n        arg:    asset_content_record_types (osid.type.Type[]): array of\n                asset content record types\n", 
               "return_doc": "        return: (osid.repository.AssetContentForm) - the asset content\n                form", 
               "error_doc": "        raise:  NotFound - ``asset_id`` is not found\n        raise:  NullArgument - ``asset_id`` or\n                ``asset_content_record_types`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        raise:  Unsupported - unable to get form for requested record\n                types", 
               "sphinx_param_doc": "        :param asset_id: the ``Id`` of an ``Asset``\n        :type asset_id: ``osid.id.Id``\n        :param asset_content_record_types: array of asset content record types\n        :type asset_content_record_types: ``osid.type.Type[]``\n", 
               "sphinx_return_doc": "        :return: the asset content form\n        :rtype: ``osid.repository.AssetContentForm``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``asset_id`` is not found\n        :raise: ``NullArgument`` -- ``asset_id`` or ``asset_content_record_types`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure\n        :raise: ``Unsupported`` -- unable to get form for requested record types", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "asset_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.type.Type[]", 
                     "var_name": "asset_content_record_types", 
                     "array": true
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "osid.type.Type[]"
               ], 
               "return_type": "osid.repository.AssetContentForm", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }, 
            {
               "name": "create_asset_content", 
               "doc": {
                  "headline": "Creates new ``AssetContent`` for a given asset.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    asset_content_form (osid.repository.AssetContentForm):\n                the form for this ``AssetContent``\n", 
               "return_doc": "        return: (osid.repository.AssetContent) - the new\n                ``AssetContent``", 
               "error_doc": "        raise:  IllegalState - ``asset_content_form`` already used in a\n                create transaction\n        raise:  InvalidArgument - one or more of the form elements is\n                invalid\n        raise:  NullArgument - ``asset_content_form`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        raise:  Unsupported - ``asset_content_form`` did not originate\n                from ``get_asset_content_form_for_create()``", 
               "sphinx_param_doc": "        :param asset_content_form: the form for this ``AssetContent``\n        :type asset_content_form: ``osid.repository.AssetContentForm``\n", 
               "sphinx_return_doc": "        :return: the new ``AssetContent``\n        :rtype: ``osid.repository.AssetContent``", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- ``asset_content_form`` already used in a create transaction\n        :raise: ``InvalidArgument`` -- one or more of the form elements is invalid\n        :raise: ``NullArgument`` -- ``asset_content_form`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure\n        :raise: ``Unsupported`` -- ``asset_content_form`` did not originate from ``get_asset_content_form_for_create()``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.repository.AssetContentForm", 
                     "var_name": "asset_content_form", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.repository.AssetContentForm"
               ], 
               "return_type": "osid.repository.AssetContent", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract", 
                  "INVALID_ARGUMENT": "ConsumerContract", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }, 
            {
               "name": "can_update_asset_contents", 
               "doc": {
                  "headline": "Tests if this user can update ``AssetContent``.", 
                  "body": "        A return of true does not guarantee successful authorization. A\n        return of false indicates that it is known updating an\n        ``AssetContent`` will result in a ``PermissionDenied``. This is\n        intended as a hint to an application that may opt not to offer\n        update operations to an unauthorized user."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``false`` if ``AssetContent`` modification\n                is not authorized, ``true`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``false`` if ``AssetContent`` modification is not authorized, ``true`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "get_asset_content_form_for_update", 
               "doc": {
                  "headline": "Gets the asset content form for updating an existing asset content.", 
                  "body": "        A new asset content form should be requested for each update\n        transaction."
               }, 
               "arg_doc": "        arg:    asset_content_id (osid.id.Id): the ``Id`` of the\n                ``AssetContent``\n", 
               "return_doc": "        return: (osid.repository.AssetContentForm) - the asset content\n                form", 
               "error_doc": "        raise:  NotFound - ``asset_content_id`` is not found\n        raise:  NullArgument - ``asset_content_id`` is ``null``\n        raise:  OperationFailed - unable to complete request", 
               "sphinx_param_doc": "        :param asset_content_id: the ``Id`` of the ``AssetContent``\n        :type asset_content_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: the asset content form\n        :rtype: ``osid.repository.AssetContentForm``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``asset_content_id`` is not found\n        :raise: ``NullArgument`` -- ``asset_content_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "asset_content_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "osid.repository.AssetContentForm", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational"
               }
            }, 
            {
               "name": "update_asset_content", 
               "doc": {
                  "headline": "Updates an existing asset content.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    asset_content_form (osid.repository.AssetContentForm):\n                the form containing the elements to be updated\n", 
               "return_doc": "", 
               "error_doc": "        raise:  IllegalState - ``asset_content_form`` already used in an\n                update transaction\n        raise:  InvalidArgument - the form contains an invalid value\n        raise:  NullArgument - ``asset_form`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        raise:  Unsupported - ``asset_content_form`` did not originate\n                from ``get_asset_content_form_for_update()``", 
               "sphinx_param_doc": "        :param asset_content_form: the form containing the elements to be updated\n        :type asset_content_form: ``osid.repository.AssetContentForm``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- ``asset_content_form`` already used in an update transaction\n        :raise: ``InvalidArgument`` -- the form contains an invalid value\n        :raise: ``NullArgument`` -- ``asset_form`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure\n        :raise: ``Unsupported`` -- ``asset_content_form`` did not originate from ``get_asset_content_form_for_update()``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.repository.AssetContentForm", 
                     "var_name": "asset_content_form", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.repository.AssetContentForm"
               ], 
               "return_type": "", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract", 
                  "INVALID_ARGUMENT": "ConsumerContract", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }, 
            {
               "name": "can_delete_asset_contents", 
               "doc": {
                  "headline": "Tests if this user can delete ``AssetsContents``.", 
                  "body": "        A return of true does not guarantee successful authorization. A\n        return of false indicates that it is known deleting an\n        ``AssetContent`` will result in a ``PermissionDenied``. This is\n        intended as a hint to an application that may opt not to offer\n        delete operations to an unauthorized user."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``false`` if ``AssetContent`` deletion is\n                not authorized, ``true`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``false`` if ``AssetContent`` deletion is not authorized, ``true`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "delete_asset_content", 
               "doc": {
                  "headline": "Deletes content from an ``Asset``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    asset_content_id (osid.id.Id): the ``Id`` of the\n                ``AssetContent``\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NotFound - ``asset_content_id`` is not found\n        raise:  NullArgument - ``asset_content_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param asset_content_id: the ``Id`` of the ``AssetContent``\n        :type asset_content_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``asset_content_id`` is not found\n        :raise: ``NullArgument`` -- ``asset_content_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "asset_content_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.repository.AssetNotificationSession", 
         "shortname": "AssetNotificationSession", 
         "category": "sessions", 
         "doc": {
            "headline": "This session defines methods to receive notifications on adds/changes to ``Asset`` objects in this ``Repository``.", 
            "body": "    This also includes existing assets that may appear or disappear due\n    to changes in the ``Repository`` hierarchy, This session is intended\n    for consumers needing to synchronize their state with this service\n    without the use of polling. Notifications are cancelled when this\n    session is closed.\n\n    The two views defined in this session correspond to the views in the\n    ``AssetLookupSession``."
         }, 
         "inherit_fullnames": [
            "osid.OsidSession"
         ], 
         "inherit_shortnames": [
            "OsidSession"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidSession"
            }
         ], 
         "method_names": [
            "get_repository_id", 
            "get_repository", 
            "can_register_for_asset_notifications", 
            "use_federated_repository_view", 
            "use_isolated_repository_view", 
            "register_for_new_assets", 
            "register_for_new_assets_by_genus_type", 
            "register_for_changed_assets", 
            "register_for_changed_assets_by_genus_type", 
            "register_for_changed_asset", 
            "register_for_deleted_assets", 
            "register_for_deleted_assets_by_genus_type", 
            "register_for_deleted_asset"
         ], 
         "methods": [
            {
               "name": "get_repository_id", 
               "doc": {
                  "headline": "Gets the ``Repository``  ``Id`` associated with this session.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.id.Id) - the ``Repository Id`` associated with\n                this session", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the ``Repository Id`` associated with this session\n        :rtype: ``osid.id.Id``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.id.Id", 
               "errors": {}
            }, 
            {
               "name": "get_repository", 
               "doc": {
                  "headline": "Gets the ``Repository`` associated with this session.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.repository.Repository) - the ``Repository``\n                associated with this session", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the ``Repository`` associated with this session\n        :rtype: ``osid.repository.Repository``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.repository.Repository", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "can_register_for_asset_notifications", 
               "doc": {
                  "headline": "Tests if this user can register for ``Asset`` notifications.", 
                  "body": "        A return of true does not guarantee successful authorization. A\n        return of false indicates that it is known all methods in this\n        session will result in a ``PermissionDenied``. This is intended\n        as a hint to an application that may opt not to offer\n        notification operations."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``false`` if notification methods are not\n                authorized, ``true`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``false`` if notification methods are not authorized, ``true`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "use_federated_repository_view", 
               "doc": {
                  "headline": "Federates the view for methods in this session.", 
                  "body": "        A federated view will include assets in repositories which are\n        children of this repository in the repository hierarchy."
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "use_isolated_repository_view", 
               "doc": {
                  "headline": "Isolates the view for methods in this session.", 
                  "body": "        An isolated view restricts notifications to this repository\n        only."
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "register_for_new_assets", 
               "doc": {
                  "headline": "Register for notifications of new assets.", 
                  "body": "        ``AssetReceiver.newAsset()`` is invoked when a new ``Asset``\n        appears in this repository."
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "register_for_new_assets_by_genus_type", 
               "doc": {
                  "headline": "Registers for notification of new assets of the given asset genus type.", 
                  "body": "        ``AssetReceiver.newAsset()`` is invoked when an asset is appears\n        in this repository."
               }, 
               "arg_doc": "        arg:    asset_genus_type (osid.type.Type): the genus type of the\n                ``Asset`` to monitor\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``asset_genus_type`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param asset_genus_type: the genus type of the ``Asset`` to monitor\n        :type asset_genus_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``asset_genus_type`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "asset_genus_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "register_for_changed_assets", 
               "doc": {
                  "headline": "Registers for notification of updated assets.", 
                  "body": "        ``AssetReceiver.changedAsset()`` is invoked when an asset in\n        this repository is changed."
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "register_for_changed_assets_by_genus_type", 
               "doc": {
                  "headline": "Registers for notification of updated assets of the given asset genus type.", 
                  "body": "        ``AssetReceiver.changedAsset()`` is invoked when an asset in\n        this repository is changed."
               }, 
               "arg_doc": "        arg:    asset_genus_type (osid.type.Type): the genus type of the\n                ``Asset`` to monitor\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``asset_genus_type`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param asset_genus_type: the genus type of the ``Asset`` to monitor\n        :type asset_genus_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``asset_genus_type`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "asset_genus_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "register_for_changed_asset", 
               "doc": {
                  "headline": "Registers for notification of an updated asset.", 
                  "body": "        ``AssetReceiver.changedAsset()`` is invoked when the specified\n        asset in this repository is changed."
               }, 
               "arg_doc": "        arg:    asset_id (osid.id.Id): the ``Id`` of the ``Asset`` to\n                monitor\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``asset_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param asset_id: the ``Id`` of the ``Asset`` to monitor\n        :type asset_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``asset_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "asset_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "register_for_deleted_assets", 
               "doc": {
                  "headline": "Registers for notification of deleted assets.", 
                  "body": "        ``AssetReceiver.deletedAsset()`` is invoked when an asset is\n        deleted or removed from this repository."
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "register_for_deleted_assets_by_genus_type", 
               "doc": {
                  "headline": "Registers for notification of deleted assets of the given asset genus type.", 
                  "body": "        ``AssetReceiver.deletedAsset()`` is invoked when an asset is\n        deleted or removed from this repository."
               }, 
               "arg_doc": "        arg:    asset_genus_type (osid.type.Type): the genus type of the\n                ``Asset`` to monitor\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``asset_genus_type`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param asset_genus_type: the genus type of the ``Asset`` to monitor\n        :type asset_genus_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``asset_genus_type`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "asset_genus_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "register_for_deleted_asset", 
               "doc": {
                  "headline": "Registers for notification of a deleted asset.", 
                  "body": "        ``AssetReceiver.deletedAsset()`` is invoked when the specified\n        asset is deleted or removed from this repository."
               }, 
               "arg_doc": "        arg:    asset_id (osid.id.Id): the ``Id`` of the ``Asset`` to\n                monitor\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``asset_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param asset_id: the ``Id`` of the ``Asset`` to monitor\n        :type asset_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``asset_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "asset_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.repository.AssetRepositorySession", 
         "shortname": "AssetRepositorySession", 
         "category": "sessions", 
         "doc": {
            "headline": "This session provides methods to retrieve ``Assets`` to ``Repository`` mappings.", 
            "body": "    An ``Asset`` may appear in multiple ``Repository`` objects. Each\n    Repository may have its own authorizations governing who is allowed\n    to look at it.\n\n    This lookup session defines two views:\n    \n      * comparative view: elements may be silently omitted or re-ordered\n      * plenary view: provides a complete result set or is an error\n        condition\n"
         }, 
         "inherit_fullnames": [
            "osid.OsidSession"
         ], 
         "inherit_shortnames": [
            "OsidSession"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidSession"
            }
         ], 
         "method_names": [
            "can_lookup_asset_repository_mappings", 
            "use_comparative_repository_view", 
            "use_plenary_repository_view", 
            "get_asset_ids_by_repository", 
            "get_assets_by_repository", 
            "get_asset_ids_by_repositories", 
            "get_assets_by_repositories", 
            "get_repository_ids_by_asset", 
            "get_repositories_by_asset"
         ], 
         "methods": [
            {
               "name": "can_lookup_asset_repository_mappings", 
               "doc": {
                  "headline": "Tests if this user can perform lookups of asset/repository mappings.", 
                  "body": "        A return of true does not guarantee successful authorization. A\n        return of false indicates that it is known lookup methods in\n        this session will result in a ``PermissionDenied``. This is\n        intended as a hint to an application that may opt not to offer\n        lookup operations to unauthorized users."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``false`` if looking up mappings is not\n                authorized, ``true`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``false`` if looking up mappings is not authorized, ``true`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "use_comparative_repository_view", 
               "doc": {
                  "headline": "The returns from the lookup methods may omit or translate elements based on this session, such as authorization, and not result in an error.", 
                  "body": "        This view is used when greater interoperability is desired at\n        the expense of precision."
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "use_plenary_repository_view", 
               "doc": {
                  "headline": "A complete view of the ``Asset`` and ``Repository`` returns is desired.", 
                  "body": "        Methods will return what is requested or result in an error.\n        This view is used when greater precision is desired at the\n        expense of interoperability."
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "get_asset_ids_by_repository", 
               "doc": {
                  "headline": "Gets the list of ``Asset``  ``Ids`` associated with a ``Repository``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    repository_id (osid.id.Id): ``Id`` of the ``Repository``\n", 
               "return_doc": "        return: (osid.id.IdList) - list of related asset ``Ids``", 
               "error_doc": "        raise:  NotFound - ``repository_id`` is not found\n        raise:  NullArgument - ``repository_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param repository_id: ``Id`` of the ``Repository``\n        :type repository_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: list of related asset ``Ids``\n        :rtype: ``osid.id.IdList``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``repository_id`` is not found\n        :raise: ``NullArgument`` -- ``repository_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "repository_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "osid.id.IdList", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_assets_by_repository", 
               "doc": {
                  "headline": "Gets the list of ``Assets`` associated with a ``Repository``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    repository_id (osid.id.Id): ``Id`` of the ``Repository``\n", 
               "return_doc": "        return: (osid.repository.AssetList) - list of related assets", 
               "error_doc": "        raise:  NotFound - ``repository_id`` is not found\n        raise:  NullArgument - ``repository_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param repository_id: ``Id`` of the ``Repository``\n        :type repository_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: list of related assets\n        :rtype: ``osid.repository.AssetList``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``repository_id`` is not found\n        :raise: ``NullArgument`` -- ``repository_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "repository_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "osid.repository.AssetList", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_asset_ids_by_repositories", 
               "doc": {
                  "headline": "Gets the list of ``Asset Ids`` corresponding to a list of ``Repository`` objects.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    repository_ids (osid.id.IdList): list of repository\n                ``Ids``\n", 
               "return_doc": "        return: (osid.id.IdList) - list of asset ``Ids``", 
               "error_doc": "        raise:  NullArgument - ``repository_ids`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param repository_ids: list of repository ``Ids``\n        :type repository_ids: ``osid.id.IdList``\n", 
               "sphinx_return_doc": "        :return: list of asset ``Ids``\n        :rtype: ``osid.id.IdList``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``repository_ids`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.IdList", 
                     "var_name": "repository_ids", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.IdList"
               ], 
               "return_type": "osid.id.IdList", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_assets_by_repositories", 
               "doc": {
                  "headline": "Gets the list of ``Assets`` corresponding to a list of ``Repository`` objects.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    repository_ids (osid.id.IdList): list of repository\n                ``Ids``\n", 
               "return_doc": "        return: (osid.repository.AssetList) - list of assets", 
               "error_doc": "        raise:  NullArgument - ``repository_ids`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param repository_ids: list of repository ``Ids``\n        :type repository_ids: ``osid.id.IdList``\n", 
               "sphinx_return_doc": "        :return: list of assets\n        :rtype: ``osid.repository.AssetList``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``repository_ids`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.IdList", 
                     "var_name": "repository_ids", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.IdList"
               ], 
               "return_type": "osid.repository.AssetList", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_repository_ids_by_asset", 
               "doc": {
                  "headline": "Gets the list of ``Repository``  ``Ids`` mapped to an ``Asset``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    asset_id (osid.id.Id): ``Id`` of an ``Asset``\n", 
               "return_doc": "        return: (osid.id.IdList) - list of repository ``Ids``", 
               "error_doc": "        raise:  NotFound - ``asset_id`` is not found\n        raise:  NullArgument - ``asset_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param asset_id: ``Id`` of an ``Asset``\n        :type asset_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: list of repository ``Ids``\n        :rtype: ``osid.id.IdList``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``asset_id`` is not found\n        :raise: ``NullArgument`` -- ``asset_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "asset_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "osid.id.IdList", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_repositories_by_asset", 
               "doc": {
                  "headline": "Gets the list of ``Repository`` objects mapped to an ``Asset``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    asset_id (osid.id.Id): ``Id`` of an ``Asset``\n", 
               "return_doc": "        return: (osid.repository.RepositoryList) - list of repositories", 
               "error_doc": "        raise:  NotFound - ``asset_id`` is not found\n        raise:  NullArgument - ``asset_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param asset_id: ``Id`` of an ``Asset``\n        :type asset_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: list of repositories\n        :rtype: ``osid.repository.RepositoryList``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``asset_id`` is not found\n        :raise: ``NullArgument`` -- ``asset_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "asset_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "osid.repository.RepositoryList", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.repository.AssetRepositoryAssignmentSession", 
         "shortname": "AssetRepositoryAssignmentSession", 
         "category": "sessions", 
         "doc": {
            "headline": "This session provides methods to re-assign ``Assets`` to ``Repositories``.", 
            "body": "    An ``Asset`` may map to multiple ``Repository`` objects and removing\n    the last reference to an ``Asset`` is the equivalent of deleting it.\n    Each ``Repository`` may have its own authorizations governing who is\n    allowed to operate on it.\n\n    Moving or adding a reference of an ``Asset`` to another\n    ``Repository`` is not a copy operation (eg: does not change its\n    ``Id`` )."
         }, 
         "inherit_fullnames": [
            "osid.OsidSession"
         ], 
         "inherit_shortnames": [
            "OsidSession"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidSession"
            }
         ], 
         "method_names": [
            "can_assign_assets", 
            "can_assign_assets_to_repository", 
            "get_assignable_repository_ids", 
            "get_assignable_repository_ids_for_asset", 
            "assign_asset_to_repository", 
            "unassign_asset_from_repository"
         ], 
         "methods": [
            {
               "name": "can_assign_assets", 
               "doc": {
                  "headline": "Tests if this user can alter asset/repository mappings.", 
                  "body": "        A return of true does not guarantee successful authorization. A\n        return of false indicates that it is known mapping methods in\n        this session will result in a ``PermissionDenied``. This is\n        intended as a hint to an application that may opt not to offer\n        assignment operations to unauthorized users."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``false`` if mapping is not authorized,\n                ``true`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``false`` if mapping is not authorized, ``true`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "can_assign_assets_to_repository", 
               "doc": {
                  "headline": "Tests if this user can alter asset/repository mappings.", 
                  "body": "        A return of true does not guarantee successful authorization. A\n        return of false indicates that it is known mapping methods in\n        this session will result in a ``PermissionDenied``. This is\n        intended as a hint to an application that may opt not to offer\n        assignment operations to unauthorized users."
               }, 
               "arg_doc": "        arg:    repository_id (osid.id.Id): the ``Id`` of the\n                ``Repository``\n", 
               "return_doc": "        return: (boolean) - ``false`` if mapping is not authorized,\n                ``true`` otherwise", 
               "error_doc": "        raise:  NullArgument - ``repository_id`` is ``null``", 
               "sphinx_param_doc": "        :param repository_id: the ``Id`` of the ``Repository``\n        :type repository_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: ``false`` if mapping is not authorized, ``true`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``repository_id`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "repository_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "boolean", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "get_assignable_repository_ids", 
               "doc": {
                  "headline": "Gets a list of repositories including and under the given repository node in which any asset can be assigned.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    repository_id (osid.id.Id): the ``Id`` of the\n                ``Repository``\n", 
               "return_doc": "        return: (osid.id.IdList) - list of assignable repository ``Ids``", 
               "error_doc": "        raise:  NullArgument - ``repository_id`` is ``null``\n        raise:  OperationFailed - unable to complete request", 
               "sphinx_param_doc": "        :param repository_id: the ``Id`` of the ``Repository``\n        :type repository_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: list of assignable repository ``Ids``\n        :rtype: ``osid.id.IdList``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``repository_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "repository_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "osid.id.IdList", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational"
               }
            }, 
            {
               "name": "get_assignable_repository_ids_for_asset", 
               "doc": {
                  "headline": "Gets a list of repositories including and under the given repository node in which a specific asset can be assigned.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    repository_id (osid.id.Id): the ``Id`` of the\n                ``Repository``\n        arg:    asset_id (osid.id.Id): the ``Id`` of the ``Asset``\n", 
               "return_doc": "        return: (osid.id.IdList) - list of assignable repository ``Ids``", 
               "error_doc": "        raise:  NullArgument - ``repository_id`` or ``asset_id`` is\n                ``null``\n        raise:  OperationFailed - unable to complete request", 
               "sphinx_param_doc": "        :param repository_id: the ``Id`` of the ``Repository``\n        :type repository_id: ``osid.id.Id``\n        :param asset_id: the ``Id`` of the ``Asset``\n        :type asset_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: list of assignable repository ``Ids``\n        :rtype: ``osid.id.IdList``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``repository_id`` or ``asset_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "repository_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "asset_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "osid.id.Id"
               ], 
               "return_type": "osid.id.IdList", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational"
               }
            }, 
            {
               "name": "assign_asset_to_repository", 
               "doc": {
                  "headline": "Adds an existing ``Asset`` to a ``Repository``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    asset_id (osid.id.Id): the ``Id`` of the ``Asset``\n        arg:    repository_id (osid.id.Id): the ``Id`` of the\n                ``Repository``\n", 
               "return_doc": "", 
               "error_doc": "        raise:  AlreadyExists - ``asset_id`` already assigned to\n                ``repository_id``\n        raise:  NotFound - ``asset_id`` or ``repository_id`` not found\n        raise:  NullArgument - ``asset_id`` or ``repository_id`` is\n                ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param asset_id: the ``Id`` of the ``Asset``\n        :type asset_id: ``osid.id.Id``\n        :param repository_id: the ``Id`` of the ``Repository``\n        :type repository_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``AlreadyExists`` -- ``asset_id`` already assigned to ``repository_id``\n        :raise: ``NotFound`` -- ``asset_id`` or ``repository_id`` not found\n        :raise: ``NullArgument`` -- ``asset_id`` or ``repository_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "asset_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "repository_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {
                  "ALREADY_EXISTS": "User", 
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "unassign_asset_from_repository", 
               "doc": {
                  "headline": "Removes an ``Asset`` from a ``Repository``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    asset_id (osid.id.Id): the ``Id`` of the ``Asset``\n        arg:    repository_id (osid.id.Id): the ``Id`` of the\n                ``Repository``\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NotFound - ``asset_id`` or ``repository_id`` not found\n                or ``asset_id`` not assigned to ``repository_id``\n        raise:  NullArgument - ``asset_id`` or ``repository_id`` is\n                ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param asset_id: the ``Id`` of the ``Asset``\n        :type asset_id: ``osid.id.Id``\n        :param repository_id: the ``Id`` of the ``Repository``\n        :type repository_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``asset_id`` or ``repository_id`` not found or ``asset_id`` not assigned to ``repository_id``\n        :raise: ``NullArgument`` -- ``asset_id`` or ``repository_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "asset_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "repository_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.repository.AssetSmartRepositorySession", 
         "shortname": "AssetSmartRepositorySession", 
         "category": "sessions", 
         "doc": {
            "headline": "This session manages queries and sequencing to create \"smart\" dynamic catalogs.", 
            "body": "    An ``AssetQuery`` can be retrieved from this session and mapped to\n    this ``Repository`` to create a virtual collection of ``Assets``.\n    The assets may be sequenced using the ``AssetSearchOrder`` from this\n    session.\n\n    This ``Repository`` has a default query that matches any asset and a\n    default search order that specifies no sequencing. The queries may\n    be examined using an ``AssetQueryInspector``. The query may be\n    modified by converting the inspector back to an ``AssetQuery``."
         }, 
         "inherit_fullnames": [
            "osid.OsidSession"
         ], 
         "inherit_shortnames": [
            "OsidSession"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidSession"
            }
         ], 
         "method_names": [
            "get_repository_id", 
            "get_repository", 
            "can_manage_smart_repository", 
            "get_asset_query", 
            "get_asset_search_order", 
            "apply_asset_query", 
            "inspect_asset_query", 
            "apply_asset_sequencing", 
            "get_asset_query_from_inspector"
         ], 
         "methods": [
            {
               "name": "get_repository_id", 
               "doc": {
                  "headline": "Gets the ``Repository``  ``Id`` associated with this session.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.id.Id) - the ``Repository Id`` associated with\n                this session", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the ``Repository Id`` associated with this session\n        :rtype: ``osid.id.Id``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.id.Id", 
               "errors": {}
            }, 
            {
               "name": "get_repository", 
               "doc": {
                  "headline": "Gets the ``Repository`` associated with this session.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.repository.Repository) - the ``Repository``\n                associated with this session", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the ``Repository`` associated with this session\n        :rtype: ``osid.repository.Repository``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.repository.Repository", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "can_manage_smart_repository", 
               "doc": {
                  "headline": "Tests if this user can manage smart repository.", 
                  "body": "        A return of true does not guarantee successful authorization. A\n        return of false indicates that it is known methods in this\n        session will result in a ``PermissionDenied``. This is intended\n        as a hint to an application that may opt not to offer operations\n        to unauthorized users."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``false`` if smart repository management is\n                not authorized, ``true`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``false`` if smart repository management is not authorized, ``true`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "get_asset_query", 
               "doc": {
                  "headline": "Gets na asset query.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.repository.AssetQuery) - the asset query", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the asset query\n        :rtype: ``osid.repository.AssetQuery``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.repository.AssetQuery", 
               "errors": {}
            }, 
            {
               "name": "get_asset_search_order", 
               "doc": {
                  "headline": "Gets an asset search order.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.repository.AssetSearchOrder) - the asset search\n                order", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the asset search order\n        :rtype: ``osid.repository.AssetSearchOrder``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.repository.AssetSearchOrder", 
               "errors": {}
            }, 
            {
               "name": "apply_asset_query", 
               "doc": {
                  "headline": "Applies an asset query to this repository.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    asset_query (osid.repository.AssetQuery): the asset\n                query\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``asset_query`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure occurred\n        raise:  Unsupported - ``asset_query`` not of this service", 
               "sphinx_param_doc": "        :param asset_query: the asset query\n        :type asset_query: ``osid.repository.AssetQuery``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``asset_query`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure occurred\n        :raise: ``Unsupported`` -- ``asset_query`` not of this service", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.repository.AssetQuery", 
                     "var_name": "asset_query", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.repository.AssetQuery"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }, 
            {
               "name": "inspect_asset_query", 
               "doc": {
                  "headline": "Gets an asset query inspector for this repository.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.repository.AssetQueryInspector) - the asset query\n                inspector", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure occurred", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the asset query inspector\n        :rtype: ``osid.repository.AssetQueryInspector``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure occurred", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.repository.AssetQueryInspector", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "apply_asset_sequencing", 
               "doc": {
                  "headline": "Applies an asset search order to this repository.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    asset_search_order (osid.repository.AssetSearchOrder):\n                the asset search order\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``asset_search_order`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure occurred\n        raise:  Unsupported - ``asset_search_order`` not of this service", 
               "sphinx_param_doc": "        :param asset_search_order: the asset search order\n        :type asset_search_order: ``osid.repository.AssetSearchOrder``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``asset_search_order`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure occurred\n        :raise: ``Unsupported`` -- ``asset_search_order`` not of this service", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.repository.AssetSearchOrder", 
                     "var_name": "asset_search_order", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.repository.AssetSearchOrder"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_asset_query_from_inspector", 
               "doc": {
                  "headline": "Gets an asset query from an inspector.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    asset_query_inspector\n                (osid.repository.AssetQueryInspector): a resorce\n                relationship query inspector\n", 
               "return_doc": "        return: (osid.repository.AssetQuery) - the asset query", 
               "error_doc": "        raise:  NullArgument - ``asset_query_inspector`` is ``null``\n        raise:  Unsupported - ``asset_query_inspector`` is not of this\n                service", 
               "sphinx_param_doc": "        :param asset_query_inspector: a resorce relationship query inspector\n        :type asset_query_inspector: ``osid.repository.AssetQueryInspector``\n", 
               "sphinx_return_doc": "        :return: the asset query\n        :rtype: ``osid.repository.AssetQuery``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``asset_query_inspector`` is ``null``\n        :raise: ``Unsupported`` -- ``asset_query_inspector`` is not of this service", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.repository.AssetQueryInspector", 
                     "var_name": "asset_query_inspector", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.repository.AssetQueryInspector"
               ], 
               "return_type": "osid.repository.AssetQuery", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.repository.AssetTemporalSession", 
         "shortname": "AssetTemporalSession", 
         "category": "sessions", 
         "doc": {
            "headline": "This session defines a means for accessing temporal coverage of an asset.", 
            "body": "    The views sorrespond to the view defined in the\n    ``AssetLookupSession``."
         }, 
         "inherit_fullnames": [
            "osid.OsidSession"
         ], 
         "inherit_shortnames": [
            "OsidSession"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidSession"
            }
         ], 
         "method_names": [
            "get_repository_id", 
            "get_repository", 
            "can_lookup_temporal_coverage", 
            "use_comparative_asset_view", 
            "use_plenary_asset_view", 
            "use_federated_repository_view", 
            "use_isolated_repository_view", 
            "get_temporal_coverage", 
            "get_asset_ids_by_temporal_coverage", 
            "get_assets_by_temporal_coverage"
         ], 
         "methods": [
            {
               "name": "get_repository_id", 
               "doc": {
                  "headline": "Gets the ``Repository``  ``Id`` associated with this session.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.id.Id) - the ``Repository Id`` associated with\n                this session", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the ``Repository Id`` associated with this session\n        :rtype: ``osid.id.Id``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.id.Id", 
               "errors": {}
            }, 
            {
               "name": "get_repository", 
               "doc": {
                  "headline": "Gets the ``Repository`` associated with this session.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.repository.Repository) - the ``Repository``\n                associated with this session", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the ``Repository`` associated with this session\n        :rtype: ``osid.repository.Repository``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.repository.Repository", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "can_lookup_temporal_coverage", 
               "doc": {
                  "headline": "Tests if this user can perform temporal lookups.", 
                  "body": "        A return of true does not guarantee successful authorization. A\n        return of false indicates that it is known all methods in this\n        session will result in a ``PermissionDenied``. This is intended\n        as a hint to an application that may opt not to offer lookup\n        operations."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``false`` if lookups are not authorized,\n                ``true`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``false`` if lookups are not authorized, ``true`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "use_comparative_asset_view", 
               "doc": {
                  "headline": "The returns from the lookup methods may omit or translate elements based on this session, such as authorization, and not result in an error.", 
                  "body": "        This view is used when greater interoperability is desired at\n        the expense of precision."
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "use_plenary_asset_view", 
               "doc": {
                  "headline": "A complete view of the ``Asset`` returns is desired.", 
                  "body": "        Methods will return what is requested or result in an error.\n        This view is used when greater precision is desired at the\n        expense of interoperability."
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "use_federated_repository_view", 
               "doc": {
                  "headline": "Federates the view for methods in this session.", 
                  "body": "        A federated view will include assets in repositories which are\n        children of this repository in the repository hierarchy."
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "use_isolated_repository_view", 
               "doc": {
                  "headline": "Isolates the view for methods in this session.", 
                  "body": "        An isolated view restricts lookups to this repository only."
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "get_temporal_coverage", 
               "doc": {
                  "headline": "Gets the temporal coverage related to the subject of this asset.", 
                  "body": "        Each element of the returned list describes a range of 2 times\n        each described by a point in time with specified granularity and\n        uncertainty. If the list contains more than one element, each\n        element indicates a relevant time or period for the subject of\n        this asset."
               }, 
               "arg_doc": "        arg:    asset_id (osid.id.Id): ``Id`` of the ``Asset`` to query\n", 
               "return_doc": "        return: (osid.calendaring.DateTimeIntervalList) - a list of\n                times relevant to the subject of this asset", 
               "error_doc": "        raise:  NotFound - ``asset_id`` is not found\n        raise:  NullArgument - ``asset_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param asset_id: ``Id`` of the ``Asset`` to query\n        :type asset_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: a list of times relevant to the subject of this asset\n        :rtype: ``osid.calendaring.DateTimeIntervalList``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``asset_id`` is not found\n        :raise: ``NullArgument`` -- ``asset_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "asset_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "osid.calendaring.DateTimeIntervalList", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_asset_ids_by_temporal_coverage", 
               "doc": {
                  "headline": "Gets asset ``Ids`` with temporal coverege within the specified dates inclusive.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    from (osid.calendaring.DateTime): starting range\n        arg:    to (osid.calendaring.DateTime): ending range\n", 
               "return_doc": "        return: (osid.id.IdList) - list of asset ``Ids``", 
               "error_doc": "        raise:  InvalidArgument - ``to`` is less than ``from``\n        raise:  NullArgument - ``from`` or ``to`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param from: starting range\n        :type from: ``osid.calendaring.DateTime``\n        :param to: ending range\n        :type to: ``osid.calendaring.DateTime``\n", 
               "sphinx_return_doc": "        :return: list of asset ``Ids``\n        :rtype: ``osid.id.IdList``", 
               "sphinx_error_doc": "        :raise: ``InvalidArgument`` -- ``to`` is less than ``from``\n        :raise: ``NullArgument`` -- ``from`` or ``to`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.calendaring.DateTime", 
                     "var_name": "from_", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.calendaring.DateTime", 
                     "var_name": "to", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.calendaring.DateTime", 
                  "osid.calendaring.DateTime"
               ], 
               "return_type": "osid.id.IdList", 
               "errors": {
                  "INVALID_ARGUMENT": "ConsumerContract", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_assets_by_temporal_coverage", 
               "doc": {
                  "headline": "Gets assets with temporal coverege within the specified dates inclusive.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    from (osid.calendaring.DateTime): starting range\n        arg:    to (osid.calendaring.DateTime): ending range\n", 
               "return_doc": "        return: (osid.repository.RepositoryList) - list of assets", 
               "error_doc": "        raise:  InvalidArgument - ``to`` is less than ``from``\n        raise:  NullArgument - ``from`` or ``to`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param from: starting range\n        :type from: ``osid.calendaring.DateTime``\n        :param to: ending range\n        :type to: ``osid.calendaring.DateTime``\n", 
               "sphinx_return_doc": "        :return: list of assets\n        :rtype: ``osid.repository.RepositoryList``", 
               "sphinx_error_doc": "        :raise: ``InvalidArgument`` -- ``to`` is less than ``from``\n        :raise: ``NullArgument`` -- ``from`` or ``to`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.calendaring.DateTime", 
                     "var_name": "from_", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.calendaring.DateTime", 
                     "var_name": "to", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.calendaring.DateTime", 
                  "osid.calendaring.DateTime"
               ], 
               "return_type": "osid.repository.RepositoryList", 
               "errors": {
                  "INVALID_ARGUMENT": "ConsumerContract", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.repository.AssetTemporalAssignmentSession", 
         "shortname": "AssetTemporalAssignmentSession", 
         "category": "sessions", 
         "doc": {
            "headline": "This session defines methods to manage temporal coverage of an asset.", 
            "body": ""
         }, 
         "inherit_fullnames": [
            "osid.OsidSession"
         ], 
         "inherit_shortnames": [
            "OsidSession"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidSession"
            }
         ], 
         "method_names": [
            "get_repository_id", 
            "get_repository", 
            "can_assign_temporal_coverage", 
            "add_temporal_coverage", 
            "remove_temporal_coverage"
         ], 
         "methods": [
            {
               "name": "get_repository_id", 
               "doc": {
                  "headline": "Gets the ``Repository``  ``Id`` associated with this session.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.id.Id) - the ``Repository Id`` associated with\n                this session", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the ``Repository Id`` associated with this session\n        :rtype: ``osid.id.Id``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.id.Id", 
               "errors": {}
            }, 
            {
               "name": "get_repository", 
               "doc": {
                  "headline": "Gets the ``Repository`` associated with this session.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.repository.Repository) - the ``Repository``\n                associated with this session", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the ``Repository`` associated with this session\n        :rtype: ``osid.repository.Repository``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.repository.Repository", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "can_assign_temporal_coverage", 
               "doc": {
                  "headline": "Tests if this user can manage temporal lookups.", 
                  "body": "        A return of true does not guarantee successful authorization. A\n        return of false indicates that it is known all methods in this\n        session will result in a ``PermissionDenied``. This is intended\n        as a hint to an application that may opt not to offer assignment\n        operations."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``false`` if temporal management is not\n                authorized, ``true`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``false`` if temporal management is not authorized, ``true`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "add_temporal_coverage", 
               "doc": {
                  "headline": "Adds a temporal coverage to this asset expressed as a range between two date/times.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    asset_id (osid.id.Id): ``Id`` of the ``Asset``\n        arg:    begin (osid.calendaring.DateTime): start date/time\n        arg:    end (osid.calendaring.DateTime): end date/time\n", 
               "return_doc": "", 
               "error_doc": "        raise:  AlreadyExists - interval already exists\n        raise:  InvalidArgument - ``begin`` is greater than ``end``\n        raise:  NotFound - ``asset_id`` not ``found``\n        raise:  NullArgument - ``asset_id, begin`` or ``end`` is\n                ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization fauilure", 
               "sphinx_param_doc": "        :param asset_id: ``Id`` of the ``Asset``\n        :type asset_id: ``osid.id.Id``\n        :param begin: start date/time\n        :type begin: ``osid.calendaring.DateTime``\n        :param end: end date/time\n        :type end: ``osid.calendaring.DateTime``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``AlreadyExists`` -- interval already exists\n        :raise: ``InvalidArgument`` -- ``begin`` is greater than ``end``\n        :raise: ``NotFound`` -- ``asset_id`` not ``found``\n        :raise: ``NullArgument`` -- ``asset_id, begin`` or ``end`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization fauilure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "asset_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.calendaring.DateTime", 
                     "var_name": "begin", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.calendaring.DateTime", 
                     "var_name": "end", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "osid.calendaring.DateTime", 
                  "osid.calendaring.DateTime"
               ], 
               "return_type": "", 
               "errors": {
                  "ALREADY_EXISTS": "User", 
                  "INVALID_ARGUMENT": "ConsumerContract", 
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "remove_temporal_coverage", 
               "doc": {
                  "headline": "Removes a temporal range from an asset.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    asset_id (osid.id.Id): ``Id`` of the ``Asset``\n        arg:    begin (osid.calendaring.DateTime): start date/time\n        arg:    end (osid.calendaring.DateTime): end date/time\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NotFound - ``asset_id`` with ``begin`` and ``end`` not\n                ``found``\n        raise:  NullArgument - ``asset_id, begin`` or ``end`` is\n                ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization fauilure", 
               "sphinx_param_doc": "        :param asset_id: ``Id`` of the ``Asset``\n        :type asset_id: ``osid.id.Id``\n        :param begin: start date/time\n        :type begin: ``osid.calendaring.DateTime``\n        :param end: end date/time\n        :type end: ``osid.calendaring.DateTime``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``asset_id`` with ``begin`` and ``end`` not ``found``\n        :raise: ``NullArgument`` -- ``asset_id, begin`` or ``end`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization fauilure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "asset_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.calendaring.DateTime", 
                     "var_name": "begin", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.calendaring.DateTime", 
                     "var_name": "end", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "osid.calendaring.DateTime", 
                  "osid.calendaring.DateTime"
               ], 
               "return_type": "", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.repository.AssetSpatialSession", 
         "shortname": "AssetSpatialSession", 
         "category": "sessions", 
         "doc": {
            "headline": "This session defines methods to access spatial mappings of an asset.", 
            "body": "    The views correspond to those defined in the ``AssetLookupSession``.\n    The locations are defined in the Mapping OSID."
         }, 
         "inherit_fullnames": [
            "osid.OsidSession"
         ], 
         "inherit_shortnames": [
            "OsidSession"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidSession"
            }
         ], 
         "method_names": [
            "get_repository_id", 
            "get_repository", 
            "can_lookup_spatial_coverage", 
            "use_comparative_asset_view", 
            "use_plenary_asset_view", 
            "use_federated_repository_view", 
            "use_isolated_repository_view", 
            "get_asset_location_ids", 
            "get_asset_locations", 
            "get_asset_spatial_coverage", 
            "get_asset_ids_by_location", 
            "get_assets_by_location", 
            "get_asset_ids_by_spatial_coverage", 
            "get_assets_by_spatial_coverage"
         ], 
         "methods": [
            {
               "name": "get_repository_id", 
               "doc": {
                  "headline": "Gets the ``Repository``  ``Id`` associated with this session.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.id.Id) - the ``Repository Id`` associated with\n                this session", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the ``Repository Id`` associated with this session\n        :rtype: ``osid.id.Id``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.id.Id", 
               "errors": {}
            }, 
            {
               "name": "get_repository", 
               "doc": {
                  "headline": "Gets the ``Repository`` associated with this session.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.repository.Repository) - the ``Repository``\n                associated with this session", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the ``Repository`` associated with this session\n        :rtype: ``osid.repository.Repository``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.repository.Repository", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "can_lookup_spatial_coverage", 
               "doc": {
                  "headline": "Tests if this user can perform spatial lookups.", 
                  "body": "        A return of true does not guarantee successful authorization. A\n        return of false indicates that it is known all methods in this\n        session will result in a ``PermissionDenied``. This is intended\n        as a hint to an application that may opt not to offer lookup\n        operations."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``false`` if spatial lookups are not\n                authorized, ``true`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``false`` if spatial lookups are not authorized, ``true`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "use_comparative_asset_view", 
               "doc": {
                  "headline": "The returns from the lookup methods may omit or translate elements based on this session, such as authorization, and not result in an error.", 
                  "body": "        This view is used when greater interoperability is desired at\n        the expense of precision."
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "use_plenary_asset_view", 
               "doc": {
                  "headline": "A complete view of the ``Asset`` returns is desired.", 
                  "body": "        Methods will return what is requested or result in an error.\n        This view is used when greater precision is desired at the\n        expense of interoperability."
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "use_federated_repository_view", 
               "doc": {
                  "headline": "Federates the view for methods in this session.", 
                  "body": "        A federated view will include assets in repositories which are\n        children of this repository in the repository hierarchy."
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "use_isolated_repository_view", 
               "doc": {
                  "headline": "Isolates the view for methods in this session.", 
                  "body": "        An isolated view restricts lookups to this repository only."
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "get_asset_location_ids", 
               "doc": {
                  "headline": "Gets the locations related to the subject of this asset.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    asset_id (osid.id.Id): ``Id`` of the ``Asset`` to query\n", 
               "return_doc": "        return: (osid.id.IdList) - a list of locations relevant to the\n                subject of this asset", 
               "error_doc": "        raise:  NotFound - ``asset_id`` is not found\n        raise:  NullArgument - ``asset_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param asset_id: ``Id`` of the ``Asset`` to query\n        :type asset_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: a list of locations relevant to the subject of this asset\n        :rtype: ``osid.id.IdList``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``asset_id`` is not found\n        :raise: ``NullArgument`` -- ``asset_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "asset_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "osid.id.IdList", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_asset_locations", 
               "doc": {
                  "headline": "Gets the locations related to the subject of this asset.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    asset_id (osid.id.Id): ``Id`` of the ``Asset`` to query\n", 
               "return_doc": "        return: (osid.mapping.LocationList) - a list of locations\n                relevant to the subject of this asset", 
               "error_doc": "        raise:  NotFound - ``asset_id`` is not found\n        raise:  NullArgument - ``asset_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param asset_id: ``Id`` of the ``Asset`` to query\n        :type asset_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: a list of locations relevant to the subject of this asset\n        :rtype: ``osid.mapping.LocationList``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``asset_id`` is not found\n        :raise: ``NullArgument`` -- ``asset_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "asset_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "osid.mapping.LocationList", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_asset_spatial_coverage", 
               "doc": {
                  "headline": "Gets the spacial coverage related to the subject of this asset.", 
                  "body": "        Each element of the returned list indicates a point in space\n        with specified granularity and uncertainty, or a spatial area.\n        If the list contains more than one element, each element\n        indicates a relevant time or period for the subject of this\n        asset."
               }, 
               "arg_doc": "        arg:    asset_id (osid.id.Id): ``Id`` of the ``Asset`` to query\n", 
               "return_doc": "        return: (osid.mapping.SpatialUnitList) - a list of locations\n                relevant to the subject of this asset", 
               "error_doc": "        raise:  NotFound - ``asset_id`` is not found\n        raise:  NullArgument - ``asset_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param asset_id: ``Id`` of the ``Asset`` to query\n        :type asset_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: a list of locations relevant to the subject of this asset\n        :rtype: ``osid.mapping.SpatialUnitList``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``asset_id`` is not found\n        :raise: ``NullArgument`` -- ``asset_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "asset_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "osid.mapping.SpatialUnitList", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_asset_ids_by_location", 
               "doc": {
                  "headline": "Gets a list of asset ``Ids`` included within the location.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    location_id (osid.id.Id): a location ``Id``\n", 
               "return_doc": "        return: (osid.id.IdList) - a list of asset ``Ids``", 
               "error_doc": "        raise:  NullArgument - ``location_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param location_id: a location ``Id``\n        :type location_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: a list of asset ``Ids``\n        :rtype: ``osid.id.IdList``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``location_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "location_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "osid.id.IdList", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_assets_by_location", 
               "doc": {
                  "headline": "Gets a list of assets included within the given spatial coverage.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    location_id (osid.id.Id): a location ``Id``\n", 
               "return_doc": "        return: (osid.repository.AssetList) - a list of assets", 
               "error_doc": "        raise:  NullArgument - ``location_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param location_id: a location ``Id``\n        :type location_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: a list of assets\n        :rtype: ``osid.repository.AssetList``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``location_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "location_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "osid.repository.AssetList", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_asset_ids_by_spatial_coverage", 
               "doc": {
                  "headline": "Gets a list of asset ``Ids`` included within the given spatial coverage.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    spatial_unit (osid.mapping.SpatialUnit): a spatial unit\n", 
               "return_doc": "        return: (osid.id.IdList) - a list of asset ``Ids``", 
               "error_doc": "        raise:  NullArgument - ``spatial_unit`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param spatial_unit: a spatial unit\n        :type spatial_unit: ``osid.mapping.SpatialUnit``\n", 
               "sphinx_return_doc": "        :return: a list of asset ``Ids``\n        :rtype: ``osid.id.IdList``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``spatial_unit`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.mapping.SpatialUnit", 
                     "var_name": "spatial_unit", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.mapping.SpatialUnit"
               ], 
               "return_type": "osid.id.IdList", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_assets_by_spatial_coverage", 
               "doc": {
                  "headline": "Gets a list of assets included within the given spatial coverage.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    spatial_unit (osid.mapping.SpatialUnit): a spatial unit\n", 
               "return_doc": "        return: (osid.repository.AssetList) - a list of assets", 
               "error_doc": "        raise:  NullArgument - ``spatial_unit`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param spatial_unit: a spatial unit\n        :type spatial_unit: ``osid.mapping.SpatialUnit``\n", 
               "sphinx_return_doc": "        :return: a list of assets\n        :rtype: ``osid.repository.AssetList``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``spatial_unit`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.mapping.SpatialUnit", 
                     "var_name": "spatial_unit", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.mapping.SpatialUnit"
               ], 
               "return_type": "osid.repository.AssetList", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.repository.AssetSpatialAssignmentSession", 
         "shortname": "AssetSpatialAssignmentSession", 
         "category": "sessions", 
         "doc": {
            "headline": "This session defines methods to manage the spatial coverage of an asset.", 
            "body": ""
         }, 
         "inherit_fullnames": [
            "osid.OsidSession"
         ], 
         "inherit_shortnames": [
            "OsidSession"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidSession"
            }
         ], 
         "method_names": [
            "get_repository_id", 
            "get_repository", 
            "can_assign_spatial_coverage", 
            "add_asset_location", 
            "add_asset_spatial_coverage", 
            "remove_asset_location", 
            "remove_asset_spatial_coverage"
         ], 
         "methods": [
            {
               "name": "get_repository_id", 
               "doc": {
                  "headline": "Gets the ``Repository``  ``Id`` associated with this session.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.id.Id) - the ``Repository Id`` associated with\n                this session", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the ``Repository Id`` associated with this session\n        :rtype: ``osid.id.Id``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.id.Id", 
               "errors": {}
            }, 
            {
               "name": "get_repository", 
               "doc": {
                  "headline": "Gets the ``Repository`` associated with this session.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.repository.Repository) - the ``Repository``\n                associated with this session", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the ``Repository`` associated with this session\n        :rtype: ``osid.repository.Repository``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.repository.Repository", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "can_assign_spatial_coverage", 
               "doc": {
                  "headline": "Tests if this user can manage spatial lookups.", 
                  "body": "        A return of true does not guarantee successful authorization. A\n        return of false indicates that it is known all methods in this\n        session will result in a ``PermissionDenied``. This is intended\n        as a hint to an application that may opt not to offer assignment\n        operations."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``false`` if spatial management is not\n                authorized, ``true`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``false`` if spatial management is not authorized, ``true`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "add_asset_location", 
               "doc": {
                  "headline": "Adds a location to an asset.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    asset_id (osid.id.Id): ``Id`` of the ``Asset``\n        arg:    location_id (osid.id.Id): a location ``Id``\n", 
               "return_doc": "", 
               "error_doc": "        raise:  AlreadyExists - asset already contains this spatial\n                coverage\n        raise:  NotFound - ``asset_id`` or ``location_id`` not ``found``\n        raise:  NullArgument - ``asset_id`` or ``location_id`` is\n                ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization fauilure", 
               "sphinx_param_doc": "        :param asset_id: ``Id`` of the ``Asset``\n        :type asset_id: ``osid.id.Id``\n        :param location_id: a location ``Id``\n        :type location_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``AlreadyExists`` -- asset already contains this spatial coverage\n        :raise: ``NotFound`` -- ``asset_id`` or ``location_id`` not ``found``\n        :raise: ``NullArgument`` -- ``asset_id`` or ``location_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization fauilure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "asset_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "location_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {
                  "ALREADY_EXISTS": "User", 
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "add_asset_spatial_coverage", 
               "doc": {
                  "headline": "Adds a spatial coverage to an asset.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    asset_id (osid.id.Id): ``Id`` of the ``Asset``\n        arg:    spatial_unit (osid.mapping.SpatialUnit): spatial\n                coverage\n", 
               "return_doc": "", 
               "error_doc": "        raise:  AlreadyExists - asset already contains this spatial\n                coverage\n        raise:  NotFound - ``asset_id`` not ``found``\n        raise:  NullArgument - ``asset_id`` or ``spatial_unit`` is\n                ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization fauilure\n        raise:  Unsupported - ``spatial_unit`` not supported", 
               "sphinx_param_doc": "        :param asset_id: ``Id`` of the ``Asset``\n        :type asset_id: ``osid.id.Id``\n        :param spatial_unit: spatial coverage\n        :type spatial_unit: ``osid.mapping.SpatialUnit``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``AlreadyExists`` -- asset already contains this spatial coverage\n        :raise: ``NotFound`` -- ``asset_id`` not ``found``\n        :raise: ``NullArgument`` -- ``asset_id`` or ``spatial_unit`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization fauilure\n        :raise: ``Unsupported`` -- ``spatial_unit`` not supported", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "asset_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.mapping.SpatialUnit", 
                     "var_name": "spatial_unit", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "osid.mapping.SpatialUnit"
               ], 
               "return_type": "", 
               "errors": {
                  "ALREADY_EXISTS": "User", 
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }, 
            {
               "name": "remove_asset_location", 
               "doc": {
                  "headline": "Removes a location from an asset.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    asset_id (osid.id.Id): ``Id`` of the ``Asset``\n        arg:    location_id (osid.id.Id): spatial coverage\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NotFound - ``asset_id`` with ``location_id`` not\n                ``found``\n        raise:  NullArgument - ``asset_id`` or ``location_id`` is\n                ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization fauilure", 
               "sphinx_param_doc": "        :param asset_id: ``Id`` of the ``Asset``\n        :type asset_id: ``osid.id.Id``\n        :param location_id: spatial coverage\n        :type location_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``asset_id`` with ``location_id`` not ``found``\n        :raise: ``NullArgument`` -- ``asset_id`` or ``location_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization fauilure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "asset_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "location_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "remove_asset_spatial_coverage", 
               "doc": {
                  "headline": "Removes a spatial coverage from an asset.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    asset_id (osid.id.Id): ``Id`` of the ``Asset``\n        arg:    spatial_unit (osid.mapping.SpatialUnit): spatial\n                coverage\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NotFound - ``asset_id`` with ``spatial_unit`` not\n                ``found``\n        raise:  NullArgument - ``asset_id`` or ``spatial_unit`` is\n                ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization fauilure", 
               "sphinx_param_doc": "        :param asset_id: ``Id`` of the ``Asset``\n        :type asset_id: ``osid.id.Id``\n        :param spatial_unit: spatial coverage\n        :type spatial_unit: ``osid.mapping.SpatialUnit``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``asset_id`` with ``spatial_unit`` not ``found``\n        :raise: ``NullArgument`` -- ``asset_id`` or ``spatial_unit`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization fauilure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "asset_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.mapping.SpatialUnit", 
                     "var_name": "spatial_unit", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "osid.mapping.SpatialUnit"
               ], 
               "return_type": "", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.repository.AssetCompositionSession", 
         "shortname": "AssetCompositionSession", 
         "category": "sessions", 
         "doc": {
            "headline": "This session defines methods for looking up ``Asset`` to ``Composition`` mappings.", 
            "body": "    A ``Composition`` represents a collection of ``Assets``.\n\n    This lookup session defines several views:\n    \n      * comparative view: elements may be silently omitted or re-ordered\n      * plenary view: provides a complete result set or is an error\n        condition\n      * isolated repository view: All lookup methods in this session\n        operate, retrieve and pertain to asseta and compositions defined\n        explicitly in the current repository. Using an isolated view is\n        useful for managing compositions with the\n        CompositionAdminSession.\n      * federated repository view: All lookup methods in this session\n        operate, retrieve and pertain to all compositions and assets\n        defined in this repository and any other compositions implicitly\n        available in this repository through repository inheritence.\n\n    \n    The methods ``use_federated_asset_composition_view()`` and\n    ``use_isolated_asset_compositiont_view()`` behave as a radio group\n    and one should be selected before invoking any lookup methods."
         }, 
         "inherit_fullnames": [
            "osid.OsidSession"
         ], 
         "inherit_shortnames": [
            "OsidSession"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidSession"
            }
         ], 
         "method_names": [
            "get_repository_id", 
            "get_repository", 
            "can_access_asset_compositions", 
            "use_comparative_asset_composition_view", 
            "use_plenary_asset_composition_view", 
            "use_federated_repository_view", 
            "use_isolated_repository_view", 
            "get_composition_assets", 
            "get_compositions_by_asset"
         ], 
         "methods": [
            {
               "name": "get_repository_id", 
               "doc": {
                  "headline": "Gets the ``Repository``  ``Id`` associated with this session.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.id.Id) - the ``Repository Id`` associated with\n                this session", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the ``Repository Id`` associated with this session\n        :rtype: ``osid.id.Id``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.id.Id", 
               "errors": {}
            }, 
            {
               "name": "get_repository", 
               "doc": {
                  "headline": "Gets the ``Repository`` associated with this session.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.repository.Repository) - the ``Repository``\n                associated with this session", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the ``Repository`` associated with this session\n        :rtype: ``osid.repository.Repository``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.repository.Repository", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "can_access_asset_compositions", 
               "doc": {
                  "headline": "Tests if this user can perform composition lookups.", 
                  "body": "        A return of true does not guarantee successful authorization. A\n        return of false indicates that it is known all methods in this\n        session will result in a ``PermissionDenied``. This is intended\n        as a hint to an application that may opt not to offer lookup\n        operations to unauthorized users."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``false`` if lookup methods are not\n                authorized, ``true`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``false`` if lookup methods are not authorized, ``true`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "use_comparative_asset_composition_view", 
               "doc": {
                  "headline": "The returns from the lookup methods may omit or translate elements based on this session, such as authorization, and not result in an error.", 
                  "body": "        This view is used when greater interoperability is desired at\n        the expense of precision."
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "use_plenary_asset_composition_view", 
               "doc": {
                  "headline": "A complete view of the returns is desired.", 
                  "body": "        Methods will return what is requested or result in an error.\n        This view is used when greater precision is desired at the\n        expense of interoperability."
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "use_federated_repository_view", 
               "doc": {
                  "headline": "Federates the view for methods in this session.", 
                  "body": "        A federated view will include compositions in repositories which\n        are children of this repository in the repository hierarchy."
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "use_isolated_repository_view", 
               "doc": {
                  "headline": "Isolates the view for methods in this session.", 
                  "body": "        An isolated view restricts lookups to this repository only."
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "get_composition_assets", 
               "doc": {
                  "headline": "Gets the list of assets mapped to the given ``Composition``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    composition_id (osid.id.Id): ``Id`` of the\n                ``Composition``\n", 
               "return_doc": "        return: (osid.repository.AssetList) - list of assets", 
               "error_doc": "        raise:  NotFound - ``composition_id`` not found\n        raise:  NullArgument - ``composition_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param composition_id: ``Id`` of the ``Composition``\n        :type composition_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: list of assets\n        :rtype: ``osid.repository.AssetList``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``composition_id`` not found\n        :raise: ``NullArgument`` -- ``composition_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "composition_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "osid.repository.AssetList", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_compositions_by_asset", 
               "doc": {
                  "headline": "Gets a list of compositions including the given asset.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    asset_id (osid.id.Id): ``Id`` of the ``Asset``\n", 
               "return_doc": "        return: (osid.repository.CompositionList) - the returned\n                ``Composition list``", 
               "error_doc": "        raise:  NotFound - ``asset_id`` is not found\n        raise:  NullArgument - ``asset_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param asset_id: ``Id`` of the ``Asset``\n        :type asset_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: the returned ``Composition list``\n        :rtype: ``osid.repository.CompositionList``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``asset_id`` is not found\n        :raise: ``NullArgument`` -- ``asset_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "asset_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "osid.repository.CompositionList", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.repository.AssetCompositionDesignSession", 
         "shortname": "AssetCompositionDesignSession", 
         "category": "sessions", 
         "doc": {
            "headline": "This session provides the means for adding assets to an asset composiiton.", 
            "body": "    The asset is identified inside a composition using its own Id. To\n    add the same asset to the composition, multiple compositions should\n    be used and placed at the same level in the ``Composition``\n    hierarchy."
         }, 
         "inherit_fullnames": [
            "osid.OsidSession"
         ], 
         "inherit_shortnames": [
            "OsidSession"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidSession"
            }
         ], 
         "method_names": [
            "get_repository_id", 
            "get_repository", 
            "can_compose_assets", 
            "add_asset", 
            "move_asset_ahead", 
            "move_asset_behind", 
            "order_assets", 
            "remove_asset"
         ], 
         "methods": [
            {
               "name": "get_repository_id", 
               "doc": {
                  "headline": "Gets the ``Repository``  ``Id`` associated with this session.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.id.Id) - the ``Repository Id`` associated with\n                this session", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the ``Repository Id`` associated with this session\n        :rtype: ``osid.id.Id``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.id.Id", 
               "errors": {}
            }, 
            {
               "name": "get_repository", 
               "doc": {
                  "headline": "Gets the ``Repository`` associated with this session.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.repository.Repository) - the ``Repository``\n                associated with this session", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the ``Repository`` associated with this session\n        :rtype: ``osid.repository.Repository``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.repository.Repository", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "can_compose_assets", 
               "doc": {
                  "headline": "Tests if this user can manage mapping of ``Assets`` to ``Compositions``.", 
                  "body": "        A return of true does not guarantee successful authorization. A\n        return of false indicates that it is known all methods in this\n        session will result in a ``PermissionDenied``. This is intended\n        as an application hint that may opt not to offer composition\n        operations."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``false`` if asset composiion is not\n                authorized, ``true`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``false`` if asset composiion is not authorized, ``true`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "add_asset", 
               "doc": {
                  "headline": "Appends an asset to a composition.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    asset_id (osid.id.Id): ``Id`` of the ``Asset``\n        arg:    composition_id (osid.id.Id): ``Id`` of the\n                ``Composition``\n", 
               "return_doc": "", 
               "error_doc": "        raise:  AlreadyExists - ``asset_id`` already part\n                ``composition_id``\n        raise:  NotFound - ``asset_id`` or ``composition_id`` not found\n        raise:  NullArgument - ``asset_id`` or ``composition_id`` is\n                ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization fauilure", 
               "sphinx_param_doc": "        :param asset_id: ``Id`` of the ``Asset``\n        :type asset_id: ``osid.id.Id``\n        :param composition_id: ``Id`` of the ``Composition``\n        :type composition_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``AlreadyExists`` -- ``asset_id`` already part ``composition_id``\n        :raise: ``NotFound`` -- ``asset_id`` or ``composition_id`` not found\n        :raise: ``NullArgument`` -- ``asset_id`` or ``composition_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization fauilure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "asset_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "composition_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {
                  "ALREADY_EXISTS": "User", 
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "move_asset_ahead", 
               "doc": {
                  "headline": "Reorders assets in a composition by moving the specified asset in front of a reference asset.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    asset_id (osid.id.Id): ``Id`` of the ``Asset``\n        arg:    composition_id (osid.id.Id): ``Id`` of the\n                ``Composition``\n        arg:    reference_id (osid.id.Id): ``Id`` of the reference\n                ``Asset``\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NotFound - ``asset_id`` or ``reference_id``  ``not found\n                in composition_id``\n        raise:  NullArgument - ``asset_id, reference_id`` or\n                ``composition_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization fauilure", 
               "sphinx_param_doc": "        :param asset_id: ``Id`` of the ``Asset``\n        :type asset_id: ``osid.id.Id``\n        :param composition_id: ``Id`` of the ``Composition``\n        :type composition_id: ``osid.id.Id``\n        :param reference_id: ``Id`` of the reference ``Asset``\n        :type reference_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``asset_id`` or ``reference_id``  ``not found in composition_id``\n        :raise: ``NullArgument`` -- ``asset_id, reference_id`` or ``composition_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization fauilure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "asset_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "composition_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "reference_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "osid.id.Id", 
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "move_asset_behind", 
               "doc": {
                  "headline": "Reorders assets in a composition by moving the specified asset behind of a reference asset.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    asset_id (osid.id.Id): ``Id`` of the ``Asset``\n        arg:    composition_id (osid.id.Id): ``Id`` of the\n                ``Composition``\n        arg:    reference_id (osid.id.Id): ``Id`` of the reference\n                ``Asset``\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NotFound - ``asset_id`` or ``reference_id``  ``not found\n                in composition_id``\n        raise:  NullArgument - ``asset_id, reference_id`` or\n                ``composition_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization fauilure", 
               "sphinx_param_doc": "        :param asset_id: ``Id`` of the ``Asset``\n        :type asset_id: ``osid.id.Id``\n        :param composition_id: ``Id`` of the ``Composition``\n        :type composition_id: ``osid.id.Id``\n        :param reference_id: ``Id`` of the reference ``Asset``\n        :type reference_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``asset_id`` or ``reference_id``  ``not found in composition_id``\n        :raise: ``NullArgument`` -- ``asset_id, reference_id`` or ``composition_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization fauilure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "asset_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "composition_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "reference_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "osid.id.Id", 
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "order_assets", 
               "doc": {
                  "headline": "Reorders a set of assets in a composition.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    asset_ids (osid.id.Id[]): ``Ids`` for a set of\n                ``Assets``\n        arg:    composition_id (osid.id.Id): ``Id`` of the\n                ``Composition``\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NotFound - ``composition_id`` not found or, an\n                ``asset_id`` not related to ``composition_id``\n        raise:  NullArgument - ``instruction_ids`` or ``agenda_id`` is\n                ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param asset_ids: ``Ids`` for a set of ``Assets``\n        :type asset_ids: ``osid.id.Id[]``\n        :param composition_id: ``Id`` of the ``Composition``\n        :type composition_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``composition_id`` not found or, an ``asset_id`` not related to ``composition_id``\n        :raise: ``NullArgument`` -- ``instruction_ids`` or ``agenda_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id[]", 
                     "var_name": "asset_ids", 
                     "array": true
                  }, 
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "composition_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id[]", 
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "remove_asset", 
               "doc": {
                  "headline": "Removes an ``Asset`` from a ``Composition``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    asset_id (osid.id.Id): ``Id`` of the ``Asset``\n        arg:    composition_id (osid.id.Id): ``Id`` of the\n                ``Composition``\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NotFound - ``asset_id``  ``not found in composition_id``\n        raise:  NullArgument - ``asset_id`` or ``composition_id`` is\n                ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization fauilure", 
               "sphinx_param_doc": "        :param asset_id: ``Id`` of the ``Asset``\n        :type asset_id: ``osid.id.Id``\n        :param composition_id: ``Id`` of the ``Composition``\n        :type composition_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``asset_id``  ``not found in composition_id``\n        :raise: ``NullArgument`` -- ``asset_id`` or ``composition_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization fauilure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "asset_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "composition_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.repository.CompositionLookupSession", 
         "shortname": "CompositionLookupSession", 
         "category": "sessions", 
         "doc": {
            "headline": "This session provides methods for retrieving ``Composition`` objects.", 
            "body": "    The ``Composition`` represents a collection of ``Assets``.\n\n    This session defines views that offer differing behaviors when\n    retrieving multiple objects.\n    \n      * comparative view: elements may be silently omitted or re-ordered\n      * plenary view: provides a complete and ordered result set or is\n        an error condition\n      * isolated repository view: All lookup methods in this session\n        operate, retrieve and pertain to compositions defined explicitly\n        in the current repository. Using an isolated view is useful for\n        managing compositions with the ``CompositionAdminSession.``\n      * federated repository view: All composition methods in this\n        session operate, retrieve and pertain to all compositions\n        defined in this repository and any other compositions implicitly\n        available in this repository through repository inheritence.\n      * active composition view: All composition lookup methods return\n        active compositions.\n      * any status composition view: Compositions of any active or\n        inactive status are returned from methods.\n      * sequestered composition viiew: All composition methods suppress\n        sequestered compositions.\n      * unsequestered composition view: All composition methods return\n        all compositions.\n\n    \n    Generally, the comparative view should be used for most applications\n    as it permits operation even if there is data that cannot be\n    accessed. For example, a browsing application may only need to\n    examine the ``Composition`` it can access, without breaking\n    execution. However, an administrative application may require a\n    complete set of ``Composition`` objects to be returned.\n    \n    Compositions may have an additional records indicated by their\n    respective record types. The record may not be accessed through a\n    cast of the ``Composition``."
         }, 
         "inherit_fullnames": [
            "osid.OsidSession"
         ], 
         "inherit_shortnames": [
            "OsidSession"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidSession"
            }
         ], 
         "method_names": [
            "get_repository_id", 
            "get_repository", 
            "can_lookup_compositions", 
            "use_comparative_composition_view", 
            "use_plenary_composition_view", 
            "use_federated_repository_view", 
            "use_isolated_repository_view", 
            "use_active_composition_view", 
            "use_any_status_composition_view", 
            "use_sequestered_composition_view", 
            "use_unsequestered_composition_view", 
            "get_composition", 
            "get_compositions_by_ids", 
            "get_compositions_by_genus_type", 
            "get_compositions_by_parent_genus_type", 
            "get_compositions_by_record_type", 
            "get_compositions_by_provider", 
            "get_compositions"
         ], 
         "methods": [
            {
               "name": "get_repository_id", 
               "doc": {
                  "headline": "Gets the ``Repository``  ``Id`` associated with this session.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.id.Id) - the ``Repository Id`` associated with\n                this session", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the ``Repository Id`` associated with this session\n        :rtype: ``osid.id.Id``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.id.Id", 
               "errors": {}
            }, 
            {
               "name": "get_repository", 
               "doc": {
                  "headline": "Gets the ``Repository`` associated with this session.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.repository.Repository) - the ``Repository``\n                associated with this session", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the ``Repository`` associated with this session\n        :rtype: ``osid.repository.Repository``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.repository.Repository", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "can_lookup_compositions", 
               "doc": {
                  "headline": "Tests if this user can perform ``Composition`` lookups.", 
                  "body": "        A return of true does not guarantee successful authorization. A\n        return of false indicates that it is known all methods in this\n        session will result in a ``PermissionDenied``. This is intended\n        as a hint to an application that may opt not to offer lookup\n        operations to unauthorized users."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``false`` if lookup methods are not\n                authorized, ``true`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``false`` if lookup methods are not authorized, ``true`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "use_comparative_composition_view", 
               "doc": {
                  "headline": "The returns from the lookup methods may omit or translate elements based on this session, such as authorization, and not result in an error.", 
                  "body": "        This view is used when greater interoperability is desired at\n        the expense of precision."
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "use_plenary_composition_view", 
               "doc": {
                  "headline": "A complete view of the ``Composition`` returns is desired.", 
                  "body": "        Methods will return what is requested or result in an error.\n        This view is used when greater precision is desired at the\n        expense of interoperability."
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "use_federated_repository_view", 
               "doc": {
                  "headline": "Federates the view for methods in this session.", 
                  "body": "        A federated view will include compositions in repositories which\n        are children of this repository in the repository hierarchy."
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "use_isolated_repository_view", 
               "doc": {
                  "headline": "Isolates the view for methods in this session.", 
                  "body": "        An isolated view restricts lookups to this repository only."
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "use_active_composition_view", 
               "doc": {
                  "headline": "Only active compositions are returned by methods in this session.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "use_any_status_composition_view", 
               "doc": {
                  "headline": "All active and inactive compositions are returned by methods in this session.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "use_sequestered_composition_view", 
               "doc": {
                  "headline": "The methods in this session omit sequestered compositions.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "use_unsequestered_composition_view", 
               "doc": {
                  "headline": "The methods in this session return all compositions, including sequestered compositions.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "get_composition", 
               "doc": {
                  "headline": "Gets the ``Composition`` specified by its ``Id``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    composition_id (osid.id.Id): ``Id`` of the\n                ``Composiiton``\n", 
               "return_doc": "        return: (osid.repository.Composition) - the composition", 
               "error_doc": "        raise:  NotFound - ``composition_id`` not found\n        raise:  NullArgument - ``composition_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param composition_id: ``Id`` of the ``Composiiton``\n        :type composition_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: the composition\n        :rtype: ``osid.repository.Composition``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``composition_id`` not found\n        :raise: ``NullArgument`` -- ``composition_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "composition_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "osid.repository.Composition", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_compositions_by_ids", 
               "doc": {
                  "headline": "Gets a ``CompositionList`` corresponding to the given ``IdList``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    composition_ids (osid.id.IdList): the list of ``Ids`` to\n                retrieve\n", 
               "return_doc": "        return: (osid.repository.CompositionList) - the returned\n                ``Composition list``", 
               "error_doc": "        raise:  NotFound - an ``Id`` was not found\n        raise:  NullArgument - ``composition_ids`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param composition_ids: the list of ``Ids`` to retrieve\n        :type composition_ids: ``osid.id.IdList``\n", 
               "sphinx_return_doc": "        :return: the returned ``Composition list``\n        :rtype: ``osid.repository.CompositionList``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- an ``Id`` was not found\n        :raise: ``NullArgument`` -- ``composition_ids`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.IdList", 
                     "var_name": "composition_ids", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.IdList"
               ], 
               "return_type": "osid.repository.CompositionList", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_compositions_by_genus_type", 
               "doc": {
                  "headline": "Gets a ``CompositionList`` corresponding to the given composition genus ``Type`` which does not include compositions of types derived from the specified ``Type``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    composition_genus_type (osid.type.Type): a composition\n                genus type\n", 
               "return_doc": "        return: (osid.repository.CompositionList) - the returned\n                ``Composition list``", 
               "error_doc": "        raise:  NullArgument - ``composition_genus_type`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param composition_genus_type: a composition genus type\n        :type composition_genus_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "        :return: the returned ``Composition list``\n        :rtype: ``osid.repository.CompositionList``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``composition_genus_type`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "composition_genus_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "osid.repository.CompositionList", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_compositions_by_parent_genus_type", 
               "doc": {
                  "headline": "Gets a ``CompositionList`` corresponding to the given composition genus ``Type`` and include any additional compositions with genus types derived from the specified ``Type``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    composition_genus_type (osid.type.Type): a composition\n                genus type\n", 
               "return_doc": "        return: (osid.repository.CompositionList) - the returned\n                ``Composition list``", 
               "error_doc": "        raise:  NullArgument - ``composition_genus_type`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param composition_genus_type: a composition genus type\n        :type composition_genus_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "        :return: the returned ``Composition list``\n        :rtype: ``osid.repository.CompositionList``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``composition_genus_type`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "composition_genus_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "osid.repository.CompositionList", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_compositions_by_record_type", 
               "doc": {
                  "headline": "Gets a ``CompositionList`` containing the given composition record ``Type``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    composition_record_type (osid.type.Type): a composition\n                record type\n", 
               "return_doc": "        return: (osid.repository.CompositionList) - the returned\n                ``Composition list``", 
               "error_doc": "        raise:  NullArgument - ``composition_record_type`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param composition_record_type: a composition record type\n        :type composition_record_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "        :return: the returned ``Composition list``\n        :rtype: ``osid.repository.CompositionList``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``composition_record_type`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "composition_record_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "osid.repository.CompositionList", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_compositions_by_provider", 
               "doc": {
                  "headline": "Gets a ``CompositionList`` from the given provider ````.", 
                  "body": "        In plenary mode, the returned list contains all known\n        compositions or an error results. Otherwise, the returned list\n        may contain only those compositions that are accessible through\n        this session.\n\n        In sequestered mode, no sequestered compositions are returned.\n        In unsequestered mode, all compositions are returned."
               }, 
               "arg_doc": "        arg:    resource_id (osid.id.Id): a resource ``Id``\n", 
               "return_doc": "        return: (osid.repository.CompositionList) - the returned\n                ``Composition list``", 
               "error_doc": "        raise:  NullArgument - ``resource_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param resource_id: a resource ``Id``\n        :type resource_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: the returned ``Composition list``\n        :rtype: ``osid.repository.CompositionList``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``resource_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "resource_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "osid.repository.CompositionList", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_compositions", 
               "doc": {
                  "headline": "Gets all ``Compositions``.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.repository.CompositionList) - a list of\n                ``Compositions``", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: a list of ``Compositions``\n        :rtype: ``osid.repository.CompositionList``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.repository.CompositionList", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.repository.CompositionQuerySession", 
         "shortname": "CompositionQuerySession", 
         "category": "sessions", 
         "doc": {
            "headline": "This session provides methods for searching among ``Composition`` objects.", 
            "body": "    The search query is constructed using the ``CompositionQuery``.\n\n    This session defines views that offer differing behaviors when\n    searching.\n    \n      * federated repository view: searches include compositions in\n        repositories of which this repository is an ancestor in the\n        repository hierarchy\n      * isolated repository view: searches are restricted to subjects in\n        this repository\n      * sequestered composition viiew: All composition methods suppress\n        sequestered compositions.\n      * unsequestered composition view: All composition methods return\n        all compositions.\n\n    \n    Compositions may have a query record indicated by their respective\n    record types. The query record is accessed via the\n    ``CompositionQuery``."
         }, 
         "inherit_fullnames": [
            "osid.OsidSession"
         ], 
         "inherit_shortnames": [
            "OsidSession"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidSession"
            }
         ], 
         "method_names": [
            "get_repository_id", 
            "get_repository", 
            "can_search_compositions", 
            "use_federated_repository_view", 
            "use_isolated_repository_view", 
            "use_sequestered_composition_view", 
            "use_unsequestered_composition_view", 
            "get_composition_query", 
            "get_compositions_by_query"
         ], 
         "methods": [
            {
               "name": "get_repository_id", 
               "doc": {
                  "headline": "Gets the ``Repository``  ``Id`` associated with this session.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.id.Id) - the ``Repository Id`` associated with\n                this session", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the ``Repository Id`` associated with this session\n        :rtype: ``osid.id.Id``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.id.Id", 
               "errors": {}
            }, 
            {
               "name": "get_repository", 
               "doc": {
                  "headline": "Gets the ``Repository`` associated with this session.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.repository.Repository) - the ``Repository``\n                associated with this session", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the ``Repository`` associated with this session\n        :rtype: ``osid.repository.Repository``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.repository.Repository", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "can_search_compositions", 
               "doc": {
                  "headline": "Tests if this user can perform ``Composition`` searches.", 
                  "body": "        A return of true does not guarantee successful authorization. A\n        return of false indicates that it is known all methods in this\n        session will result in a ``PermissionDenied``. This is intended\n        as a hint to an application that may opt not to offer search\n        operations to unauthorized users."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``false`` if search methods are not\n                authorized, ``true`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``false`` if search methods are not authorized, ``true`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "use_federated_repository_view", 
               "doc": {
                  "headline": "Federates the view for methods in this session.", 
                  "body": "        A federated view will include compositions in repositories which\n        are children of this repository in the repository hierarchy."
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "use_isolated_repository_view", 
               "doc": {
                  "headline": "Isolates the view for methods in this session.", 
                  "body": "        An isolated view restricts lookups to this repository only."
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "use_sequestered_composition_view", 
               "doc": {
                  "headline": "The methods in this session omit sequestered compositions.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "use_unsequestered_composition_view", 
               "doc": {
                  "headline": "The methods in this session return all compositions, including sequestered compositions.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "get_composition_query", 
               "doc": {
                  "headline": "Gets a composition query.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.repository.CompositionQuery) - the composition\n                query", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the composition query\n        :rtype: ``osid.repository.CompositionQuery``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.repository.CompositionQuery", 
               "errors": {}
            }, 
            {
               "name": "get_compositions_by_query", 
               "doc": {
                  "headline": "Gets a list of ``Compositions`` matching the given composition query.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    composition_query (osid.repository.CompositionQuery):\n                the composition query\n", 
               "return_doc": "        return: (osid.repository.CompositionList) - the returned\n                ``CompositionList``", 
               "error_doc": "        raise:  NullArgument - ``composition_query`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        raise:  Unsupported - ``composition_query`` is not of this\n                service", 
               "sphinx_param_doc": "        :param composition_query: the composition query\n        :type composition_query: ``osid.repository.CompositionQuery``\n", 
               "sphinx_return_doc": "        :return: the returned ``CompositionList``\n        :rtype: ``osid.repository.CompositionList``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``composition_query`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure\n        :raise: ``Unsupported`` -- ``composition_query`` is not of this service", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.repository.CompositionQuery", 
                     "var_name": "composition_query", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.repository.CompositionQuery"
               ], 
               "return_type": "osid.repository.CompositionList", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.repository.CompositionSearchSession", 
         "shortname": "CompositionSearchSession", 
         "category": "sessions", 
         "doc": {
            "headline": "This session provides methods for searching among ``Composition`` objects.", 
            "body": "    The search query is constructed using the ``CompositionQuery``.\n\n    ``get_compositions_by_query()`` is the basic search method and\n    returns a list of ``Compositions``. A more advanced search may be\n    performed with ``getCompositionsBySearch()``. It accepts an\n    ``Composition`` in addition to the query for the purpose of\n    specifying additional options affecting the entire search, such as\n    ordering. ``get_compositions_by_search()`` returns an\n    ``CompositionSearchResults`` that can be used to access the\n    resulting ``Composition`` or be used to perform a search within the\n    result set through ``CompositionSearch``.\n    \n    This session defines views that offer differing behaviors when\n    searching.\n    \n      * federated repository view: searches include compositions in\n        repositories of which this repository is an ancestor in the\n        repository hierarchy\n      * isolated repository view: searches are restricted to subjects in\n        this repository\n\n    \n    Compositions may have a query record indicated by their respective\n    record types. The query record is accessed via the\n    ``CompositionQuery``."
         }, 
         "inherit_fullnames": [
            "osid.repository.CompositionQuerySession"
         ], 
         "inherit_shortnames": [
            "CompositionQuerySession"
         ], 
         "inherit_pkg_names": [
            "repository"
         ], 
         "inheritance": [
            {
               "pkg_name": "repository", 
               "name": "CompositionQuerySession"
            }
         ], 
         "method_names": [
            "get_composition_search", 
            "get_composition_search_order", 
            "get_compositions_by_search", 
            "get_composition_query_from_inspector"
         ], 
         "methods": [
            {
               "name": "get_composition_search", 
               "doc": {
                  "headline": "Gets a composition search.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.repository.CompositionSearch) - the composition\n                search", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the composition search\n        :rtype: ``osid.repository.CompositionSearch``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.repository.CompositionSearch", 
               "errors": {}
            }, 
            {
               "name": "get_composition_search_order", 
               "doc": {
                  "headline": "Gets a composition search order.", 
                  "body": "        The ``CompositionSearchOrder`` is supplied to an\n        ``CompositionSearch`` to specify the ordering of results."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.repository.CompositionSearchOrder) - the\n                composition search order", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the composition search order\n        :rtype: ``osid.repository.CompositionSearchOrder``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.repository.CompositionSearchOrder", 
               "errors": {}
            }, 
            {
               "name": "get_compositions_by_search", 
               "doc": {
                  "headline": "Gets the search results matching the given search query using the given search.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    composition_query (osid.repository.CompositionQuery):\n                the composition query\n        arg:    composition_search (osid.repository.CompositionSearch):\n                the composition search\n", 
               "return_doc": "        return: (osid.repository.CompositionSearchResults) - the\n                composition search results", 
               "error_doc": "        raise:  NullArgument - ``composition_query`` or\n                ``composition_search`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        raise:  Unsupported - ``composition_query`` or\n                ``composition_search`` is not of this service", 
               "sphinx_param_doc": "        :param composition_query: the composition query\n        :type composition_query: ``osid.repository.CompositionQuery``\n        :param composition_search: the composition search\n        :type composition_search: ``osid.repository.CompositionSearch``\n", 
               "sphinx_return_doc": "        :return: the composition search results\n        :rtype: ``osid.repository.CompositionSearchResults``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``composition_query`` or ``composition_search`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure\n        :raise: ``Unsupported`` -- ``composition_query`` or ``composition_search`` is not of this service", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.repository.CompositionQuery", 
                     "var_name": "composition_query", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.repository.CompositionSearch", 
                     "var_name": "composition_search", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.repository.CompositionQuery", 
                  "osid.repository.CompositionSearch"
               ], 
               "return_type": "osid.repository.CompositionSearchResults", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_composition_query_from_inspector", 
               "doc": {
                  "headline": "Gets a composition query from an inspector.", 
                  "body": "        The inspector is available from a ``CompositionSearchResults``."
               }, 
               "arg_doc": "        arg:    composition_query_inspector\n                (osid.repository.CompositionQueryInspector): a\n                composition query inspector\n", 
               "return_doc": "        return: (osid.repository.CompositionQuery) - the composition\n                query", 
               "error_doc": "        raise:  NullArgument - ``composition_query_inspector`` is\n                ``null``\n        raise:  Unsupported - ``composition_query_inspector`` is not of\n                this service", 
               "sphinx_param_doc": "        :param composition_query_inspector: a composition query inspector\n        :type composition_query_inspector: ``osid.repository.CompositionQueryInspector``\n", 
               "sphinx_return_doc": "        :return: the composition query\n        :rtype: ``osid.repository.CompositionQuery``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``composition_query_inspector`` is ``null``\n        :raise: ``Unsupported`` -- ``composition_query_inspector`` is not of this service", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.repository.CompositionQueryInspector", 
                     "var_name": "composition_query_inspector", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.repository.CompositionQueryInspector"
               ], 
               "return_type": "osid.repository.CompositionQuery", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.repository.CompositionAdminSession", 
         "shortname": "CompositionAdminSession", 
         "category": "sessions", 
         "doc": {
            "headline": "This session creates, updates, and deletes ``Compositions``.", 
            "body": "    The data for create and update is provided by the consumer via the\n    form object. ``OsidForms`` are requested for each create or update\n    and may not be reused.\n\n    Create and update operations differ in their usage. To create a\n    ``Composition,`` a ``CompositionForm`` is requested using\n    ``get_composition_form_for_create()`` specifying the desired record\n    ``Types`` or none if no record ``Types`` are needed. The returned\n    ``CompositionForm`` will indicate that it is to be used with a\n    create operation and can be used to examine metdata or validate data\n    prior to creation. Once the ``CompositionForm`` is submiited to a\n    create operation, it cannot be reused with another create operation\n    unless the first operation was unsuccessful. Each\n    ``CompositionForm`` corresponds to an attempted transaction.\n    \n    For updates, ``CompositionForms`` are requested to the\n    ``Composition``  ``Id`` that is to be updated using\n    ``getCompositionFormForUpdate()``. Similarly, the\n    ``CompositionForm`` has metadata about the data that can be updated\n    and it can perform validation before submitting the update. The\n    ``CompositionForm`` can only be used once for a successful update\n    and cannot be reused.\n    \n    The delete operations delete ``Compositions``. To unmap a\n    ``Composition`` from the current ``Repository,`` the\n    ``CompositionRepositoryAssignmentSession`` should be used. These\n    delete operations attempt to remove the ``Bid`` itself thus removing\n    it from all known ``Repository`` catalogs.\n    \n    This session includes an ``Id`` aliasing mechanism to assign an\n    external ``Id`` to an internally assigned Id."
         }, 
         "inherit_fullnames": [
            "osid.OsidSession"
         ], 
         "inherit_shortnames": [
            "OsidSession"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidSession"
            }
         ], 
         "method_names": [
            "get_repository_id", 
            "get_repository", 
            "can_create_compositions", 
            "can_create_composition_with_record_types", 
            "get_composition_form_for_create", 
            "create_composition", 
            "can_update_compositions", 
            "get_composition_form_for_update", 
            "update_composition", 
            "can_delete_compositions", 
            "delete_composition", 
            "delete_composition_node", 
            "add_composition_child", 
            "remove_composition_child", 
            "can_manage_composition_aliases", 
            "alias_composition"
         ], 
         "methods": [
            {
               "name": "get_repository_id", 
               "doc": {
                  "headline": "Gets the ``Repository``  ``Id`` associated with this session.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.id.Id) - the ``Repository Id`` associated with\n                this session", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the ``Repository Id`` associated with this session\n        :rtype: ``osid.id.Id``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.id.Id", 
               "errors": {}
            }, 
            {
               "name": "get_repository", 
               "doc": {
                  "headline": "Gets the ``Repository`` associated with this session.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.repository.Repository) - the ``Repository``\n                associated with this session", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the ``Repository`` associated with this session\n        :rtype: ``osid.repository.Repository``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.repository.Repository", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "can_create_compositions", 
               "doc": {
                  "headline": "Tests if this user can create ``Compositions``.", 
                  "body": "        A return of true does not guarantee successful authorization. A\n        return of false indicates that it is known creating a\n        ``Composition`` will result in a ``PermissionDenied``. This is\n        intended as a hint to an application that may not wish to offer\n        create operations to unauthorized users."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``false`` if ``Composition`` creation is not\n                authorized, ``true`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``false`` if ``Composition`` creation is not authorized, ``true`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "can_create_composition_with_record_types", 
               "doc": {
                  "headline": "Tests if this user can create a single ``Composition`` using the desired record types.", 
                  "body": "        While ``RepositoryManager.getCompositionRecordTypes()`` can be\n        used to examine which records are supported, this method tests\n        which record(s) are required for creating a specific\n        ``Composition``. Providing an empty array tests if a\n        ``Composition`` can be created with no records."
               }, 
               "arg_doc": "        arg:    composition_record_types (osid.type.Type[]): array of\n                composition record types\n", 
               "return_doc": "        return: (boolean) - ``true`` if ``Composition`` creation using\n                the specified ``Types`` is supported, ``false``\n                otherwise", 
               "error_doc": "        raise:  NullArgument - ``composition_record_types`` is ``null``", 
               "sphinx_param_doc": "        :param composition_record_types: array of composition record types\n        :type composition_record_types: ``osid.type.Type[]``\n", 
               "sphinx_return_doc": "        :return: ``true`` if ``Composition`` creation using the specified ``Types`` is supported, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``composition_record_types`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type[]", 
                     "var_name": "composition_record_types", 
                     "array": true
                  }
               ], 
               "arg_types": [
                  "osid.type.Type[]"
               ], 
               "return_type": "boolean", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "get_composition_form_for_create", 
               "doc": {
                  "headline": "Gets the composition form for creating new compositions.", 
                  "body": "        A new form should be requested for each create transaction."
               }, 
               "arg_doc": "        arg:    composition_record_types (osid.type.Type[]): array of\n                composition record types\n", 
               "return_doc": "        return: (osid.repository.CompositionForm) - the composition form", 
               "error_doc": "        raise:  NullArgument - ``composition_record_types`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        raise:  Unsupported - unable to get form for requested record\n                types", 
               "sphinx_param_doc": "        :param composition_record_types: array of composition record types\n        :type composition_record_types: ``osid.type.Type[]``\n", 
               "sphinx_return_doc": "        :return: the composition form\n        :rtype: ``osid.repository.CompositionForm``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``composition_record_types`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure\n        :raise: ``Unsupported`` -- unable to get form for requested record types", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type[]", 
                     "var_name": "composition_record_types", 
                     "array": true
                  }
               ], 
               "arg_types": [
                  "osid.type.Type[]"
               ], 
               "return_type": "osid.repository.CompositionForm", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }, 
            {
               "name": "create_composition", 
               "doc": {
                  "headline": "Creates a new ``Composition``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    composiiton_form (osid.repository.CompositionForm): the\n                form for this ``Composition``\n", 
               "return_doc": "        return: (osid.repository.Composition) - the new ``Composition``", 
               "error_doc": "        raise:  IllegalState - ``composition_form`` already used in a\n                create transaction\n        raise:  InvalidArgument - one or more of the form elements is\n                invalid\n        raise:  NullArgument - ``composition_form`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        raise:  Unsupported - ``composition_form`` did not originate\n                from ``get_composition_form_for_create()``", 
               "sphinx_param_doc": "        :param composiiton_form: the form for this ``Composition``\n        :type composiiton_form: ``osid.repository.CompositionForm``\n", 
               "sphinx_return_doc": "        :return: the new ``Composition``\n        :rtype: ``osid.repository.Composition``", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- ``composition_form`` already used in a create transaction\n        :raise: ``InvalidArgument`` -- one or more of the form elements is invalid\n        :raise: ``NullArgument`` -- ``composition_form`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure\n        :raise: ``Unsupported`` -- ``composition_form`` did not originate from ``get_composition_form_for_create()``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.repository.CompositionForm", 
                     "var_name": "composiiton_form", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.repository.CompositionForm"
               ], 
               "return_type": "osid.repository.Composition", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract", 
                  "INVALID_ARGUMENT": "ConsumerContract", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }, 
            {
               "name": "can_update_compositions", 
               "doc": {
                  "headline": "Tests if this user can update ``Compositions``.", 
                  "body": "        A return of true does not guarantee successful authorization. A\n        return of false indicates that it is known updating a\n        ``Composition`` will result in a ``PermissionDenied``. This is\n        intended as a hint to an application that may not wish to offer\n        update operations to unauthorized users."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``false`` if ``Composition`` modification is\n                not authorized, ``true`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``false`` if ``Composition`` modification is not authorized, ``true`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "get_composition_form_for_update", 
               "doc": {
                  "headline": "Gets the composition form for updating an existing composition.", 
                  "body": "        A new composition form should be requested for each update\n        transaction."
               }, 
               "arg_doc": "        arg:    composition_id (osid.id.Id): the ``Id`` of the\n                ``Composition``\n", 
               "return_doc": "        return: (osid.repository.CompositionForm) - the composition form", 
               "error_doc": "        raise:  NotFound - ``composition_id`` is not found\n        raise:  NullArgument - ``composition_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param composition_id: the ``Id`` of the ``Composition``\n        :type composition_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: the composition form\n        :rtype: ``osid.repository.CompositionForm``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``composition_id`` is not found\n        :raise: ``NullArgument`` -- ``composition_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "composition_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "osid.repository.CompositionForm", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "update_composition", 
               "doc": {
                  "headline": "Updates an existing composition.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    composiiton_form (osid.repository.CompositionForm): the\n                form containing the elements to be updated\n", 
               "return_doc": "", 
               "error_doc": "        raise:  IllegalState - ``composition_form`` already used in an\n                update transaction\n        raise:  InvalidArgument - the form contains an invalid value\n        raise:  NullArgument - ``composition_form`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        raise:  Unsupported - ``composition_form`` did not originate\n                from ``get_composition_form_for_update()``", 
               "sphinx_param_doc": "        :param composiiton_form: the form containing the elements to be updated\n        :type composiiton_form: ``osid.repository.CompositionForm``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- ``composition_form`` already used in an update transaction\n        :raise: ``InvalidArgument`` -- the form contains an invalid value\n        :raise: ``NullArgument`` -- ``composition_form`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure\n        :raise: ``Unsupported`` -- ``composition_form`` did not originate from ``get_composition_form_for_update()``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.repository.CompositionForm", 
                     "var_name": "composiiton_form", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.repository.CompositionForm"
               ], 
               "return_type": "", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract", 
                  "INVALID_ARGUMENT": "ConsumerContract", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }, 
            {
               "name": "can_delete_compositions", 
               "doc": {
                  "headline": "Tests if this user can delete ``Compositions``.", 
                  "body": "        A return of true does not guarantee successful authorization. A\n        return of false indicates that it is known deleting a\n        ``Composition`` will result in a ``PermissionDenied``. This is\n        intended as a hint to an application that may not wish to offer\n        delete operations to unauthorized users."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``false`` if ``Composition`` deletion is not\n                authorized, ``true`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``false`` if ``Composition`` deletion is not authorized, ``true`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "delete_composition", 
               "doc": {
                  "headline": "Deletes a ``Composition``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    composition_id (osid.id.Id): the ``Id`` of the\n                ``Composition`` to remove\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NotFound - ``composition_id`` not found\n        raise:  NullArgument - ``composition_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param composition_id: the ``Id`` of the ``Composition`` to remove\n        :type composition_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``composition_id`` not found\n        :raise: ``NullArgument`` -- ``composition_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "composition_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "delete_composition_node", 
               "doc": {
                  "headline": "Deletes a ``Composition`` and all contained children.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    composition_id (osid.id.Id): the ``Id`` of the\n                ``Composition`` to remove\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NotFound - ``composition_id`` not found\n        raise:  NullArgument - ``composition_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param composition_id: the ``Id`` of the ``Composition`` to remove\n        :type composition_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``composition_id`` not found\n        :raise: ``NullArgument`` -- ``composition_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "composition_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "add_composition_child", 
               "doc": {
                  "headline": "Adds a composition to a parent composition.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    composition_id (osid.id.Id): the ``Id`` of a parent\n                ``Composition``\n        arg:    child_composition_id (osid.id.Id): the ``Id`` of a child\n                ``Composition``\n", 
               "return_doc": "", 
               "error_doc": "        raise:  AlreadyExists - ``child_composition_id`` is already a\n                child of ``composition_id``\n        raise:  NotFound - ``composition_id`` or\n                ``child_composition_id`` is not found\n        raise:  NullArgument - ``composition_id`` or\n                ``child_composition_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param composition_id: the ``Id`` of a parent ``Composition``\n        :type composition_id: ``osid.id.Id``\n        :param child_composition_id: the ``Id`` of a child ``Composition``\n        :type child_composition_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``AlreadyExists`` -- ``child_composition_id`` is already a child of ``composition_id``\n        :raise: ``NotFound`` -- ``composition_id`` or ``child_composition_id`` is not found\n        :raise: ``NullArgument`` -- ``composition_id`` or ``child_composition_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "composition_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "child_composition_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {
                  "ALREADY_EXISTS": "User", 
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "remove_composition_child", 
               "doc": {
                  "headline": "Removes a composition from a parent composition.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    composition_id (osid.id.Id): the ``Id`` of a parent\n                ``Composition``\n        arg:    child_composition_id (osid.id.Id): the ``Id`` of a child\n                ``Composition``\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NotFound - ``composition_id`` or\n                ``child_composition_id`` is not found or not related\n        raise:  NullArgument - ``composition_id`` or\n                ``child_composition_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param composition_id: the ``Id`` of a parent ``Composition``\n        :type composition_id: ``osid.id.Id``\n        :param child_composition_id: the ``Id`` of a child ``Composition``\n        :type child_composition_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``composition_id`` or ``child_composition_id`` is not found or not related\n        :raise: ``NullArgument`` -- ``composition_id`` or ``child_composition_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "composition_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "child_composition_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "can_manage_composition_aliases", 
               "doc": {
                  "headline": "Tests if this user can manage ``Id`` aliases for ``Compositions``.", 
                  "body": "        A return of true does not guarantee successful authorization. A\n        return of false indicates that it is known changing an alias\n        will result in a ``PermissionDenied``. This is intended as a\n        hint to an application that may opt not to offer alias\n        operations to an unauthorized user."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``false`` if ``Composition`` aliasing is not\n                authorized, ``true`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``false`` if ``Composition`` aliasing is not authorized, ``true`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "alias_composition", 
               "doc": {
                  "headline": "Adds an ``Id`` to a ``Composition`` for the purpose of creating compatibility.", 
                  "body": "        The primary ``Id`` of the ``Composition`` is determined by the\n        provider. The new ``Id`` is an alias to the primary ``Id``. If\n        the alias is a pointer to another composition, it is reassigned\n        to the given composition ``Id``."
               }, 
               "arg_doc": "        arg:    composition_id (osid.id.Id): the ``Id`` of a\n                ``Composition``\n        arg:    alias_id (osid.id.Id): the alias ``Id``\n", 
               "return_doc": "", 
               "error_doc": "        raise:  AlreadyExists - ``alias_id`` is in use as a primary\n                ``Id``\n        raise:  NotFound - ``composition_id`` not found\n        raise:  NullArgument - ``composition_id`` or ``alias_id`` is\n                ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param composition_id: the ``Id`` of a ``Composition``\n        :type composition_id: ``osid.id.Id``\n        :param alias_id: the alias ``Id``\n        :type alias_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``AlreadyExists`` -- ``alias_id`` is in use as a primary ``Id``\n        :raise: ``NotFound`` -- ``composition_id`` not found\n        :raise: ``NullArgument`` -- ``composition_id`` or ``alias_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "composition_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "alias_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {
                  "ALREADY_EXISTS": "User", 
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.repository.CompositionNotificationSession", 
         "shortname": "CompositionNotificationSession", 
         "category": "sessions", 
         "doc": {
            "headline": "This session defines methods to receive notifications on adds/changes to ``Composition`` objects in this ``Repository``.", 
            "body": "    This session is intended for consumers needing to synchronize their\n    state with this service without the use of polling. Notifications\n    are cancelled when this session is closed.\n\n    Two view are defined in this session:\n    \n      * ``federateRepositoryView:`` includes notifications of\n        compositions in repositories of which this repository is an\n        ancestor in the repository hierarchy\n      * ``isolateRepositoryView:`` restricts notifications to this\n        ``Repository`` only\n"
         }, 
         "inherit_fullnames": [
            "osid.OsidSession"
         ], 
         "inherit_shortnames": [
            "OsidSession"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidSession"
            }
         ], 
         "method_names": [
            "get_repository_id", 
            "get_repository", 
            "can_register_for_composition_notifications", 
            "use_federated_repository_view", 
            "use_isolated_repository_view", 
            "register_for_new_compositions", 
            "register_for_changed_compositions", 
            "register_for_changed_composition", 
            "register_for_deleted_compositions", 
            "register_for_deleted_composition"
         ], 
         "methods": [
            {
               "name": "get_repository_id", 
               "doc": {
                  "headline": "Gets the ``Repository``  ``Id`` associated with this session.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.id.Id) - the ``Repository Id`` associated with\n                this session", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the ``Repository Id`` associated with this session\n        :rtype: ``osid.id.Id``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.id.Id", 
               "errors": {}
            }, 
            {
               "name": "get_repository", 
               "doc": {
                  "headline": "Gets the ``Repository`` associated with this session.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.repository.Repository) - the ``Repository``\n                associated with this session", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the ``Repository`` associated with this session\n        :rtype: ``osid.repository.Repository``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.repository.Repository", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "can_register_for_composition_notifications", 
               "doc": {
                  "headline": "Tests if this user can register for ``Composition`` notifications.", 
                  "body": "        A return of true does not guarantee successful authorization. A\n        return of false indicates that it is known all methods in this\n        session will result in a ``PermissionDenied``. This is intended\n        as a hint to an application that may opt not to offer\n        notification operations."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``false`` if notification methods are not\n                authorized, ``true`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``false`` if notification methods are not authorized, ``true`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "use_federated_repository_view", 
               "doc": {
                  "headline": "Federates the view for composition methods in this session.", 
                  "body": "        A federated view will include compositions in repositories which\n        are children of this repository in the repository hierarchy."
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "use_isolated_repository_view", 
               "doc": {
                  "headline": "Isolates the view for composition methods in this session.", 
                  "body": "        An isolated view restricts notifications to this repository\n        only."
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "register_for_new_compositions", 
               "doc": {
                  "headline": "Register for notifications of new composition.", 
                  "body": "        ``CompositionReceiver.newComposition()`` is invoked when a new\n        ``Composition`` appears in this repository."
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "register_for_changed_compositions", 
               "doc": {
                  "headline": "Register for notifications of new compositions.", 
                  "body": "        ``CompositionReceiver.changedComposition()`` is invoked when a\n        ``Composition`` is changed."
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "register_for_changed_composition", 
               "doc": {
                  "headline": "Registers for notification of an updated composition.", 
                  "body": "        ``CompositionReceiver.changedComposition()`` is invoked when the\n        specified composition is changed."
               }, 
               "arg_doc": "        arg:    composition_id (osid.id.Id): the ``Id`` of the\n                ``Composition`` to monitor\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``composition_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param composition_id: the ``Id`` of the ``Composition`` to monitor\n        :type composition_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``composition_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "composition_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "register_for_deleted_compositions", 
               "doc": {
                  "headline": "Register for notifications of new compositions.", 
                  "body": "        ``CompositionReceiver.deletedComposition()`` is invoked when a\n        ``Composition`` is removed from this repository."
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "register_for_deleted_composition", 
               "doc": {
                  "headline": "Registers for notification of a deleted composition.", 
                  "body": "        ``CompositionReceiver.deletedComposition()`` is invoked when the\n        specified composition is removed from this repository."
               }, 
               "arg_doc": "        arg:    composition_id (osid.id.Id): the ``Id`` of the\n                ``Composition`` to monitor\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``composition_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param composition_id: the ``Id`` of the ``Composition`` to monitor\n        :type composition_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``composition_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "composition_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.repository.CompositionRepositorySession", 
         "shortname": "CompositionRepositorySession", 
         "category": "sessions", 
         "doc": {
            "headline": "This session provides methods to retrieve ``Composition`` to ``Repository`` mappings.", 
            "body": "    A ``Composition`` may appear in multiple ``Repository`` objects.\n    Each ``Repository`` may have its own authorizations governing who is\n    allowed to look at it.\n\n    This lookup session defines several views:\n    \n      * comparative view: elements may be silently omitted or re-ordered\n      * plenary view: provides a complete result set or is an error\n        condition\n"
         }, 
         "inherit_fullnames": [
            "osid.OsidSession"
         ], 
         "inherit_shortnames": [
            "OsidSession"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidSession"
            }
         ], 
         "method_names": [
            "use_comparative_composition_repository_view", 
            "use_plenary_composition_repository_view", 
            "can_lookup_composition_repository_mappings", 
            "get_composition_ids_by_repository", 
            "get_compositions_by_repository", 
            "get_composition_ids_by_repositories", 
            "get_compoitions_by_repositories", 
            "get_repository_ids_by_composition", 
            "get_repositories_by_composition"
         ], 
         "methods": [
            {
               "name": "use_comparative_composition_repository_view", 
               "doc": {
                  "headline": "The returns from the lookup methods may omit or translate elements based on this session, such as authorization, and not result in an error.", 
                  "body": "        This view is used when greater interoperability is desired at\n        the expense of precision."
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "use_plenary_composition_repository_view", 
               "doc": {
                  "headline": "A complete view of the ``Composition`` and ``Repository`` returns is desired.", 
                  "body": "        Methods will return what is requested or result in an error.\n        This view is used when greater precision is desired at the\n        expense of interoperability."
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "can_lookup_composition_repository_mappings", 
               "doc": {
                  "headline": "Tests if this user can perform lookups of composition/repository mappings.", 
                  "body": "        A return of true does not guarantee successful authorization. A\n        return of false indicates that it is known lookup methods in\n        this session will result in a ``PermissionDenied``. This is\n        intended as a hint to an application that may opt not to offer\n        lookup operations to unauthorized users."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``false`` if looking up mappings is not\n                authorized, ``true`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``false`` if looking up mappings is not authorized, ``true`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "get_composition_ids_by_repository", 
               "doc": {
                  "headline": "Gets the list of ``Composition``  ``Ids`` associated with a ``Repository``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    repository_id (osid.id.Id): ``Id`` of the ``Repository``\n", 
               "return_doc": "        return: (osid.id.IdList) - list of related composition ``Ids``", 
               "error_doc": "        raise:  NotFound - ``repository_id`` is not found\n        raise:  NullArgument - ``repository_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param repository_id: ``Id`` of the ``Repository``\n        :type repository_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: list of related composition ``Ids``\n        :rtype: ``osid.id.IdList``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``repository_id`` is not found\n        :raise: ``NullArgument`` -- ``repository_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "repository_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "osid.id.IdList", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_compositions_by_repository", 
               "doc": {
                  "headline": "Gets the list of ``Compositions`` associated with a ``Repository``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    repository_id (osid.id.Id): ``Id`` of the ``Repository``\n", 
               "return_doc": "        return: (osid.repository.CompositionList) - list of related\n                compositions", 
               "error_doc": "        raise:  NotFound - ``repository_id`` is not found\n        raise:  NullArgument - ``repository_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param repository_id: ``Id`` of the ``Repository``\n        :type repository_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: list of related compositions\n        :rtype: ``osid.repository.CompositionList``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``repository_id`` is not found\n        :raise: ``NullArgument`` -- ``repository_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "repository_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "osid.repository.CompositionList", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_composition_ids_by_repositories", 
               "doc": {
                  "headline": "Gets the list of ``Composition``  ``Ids`` corresponding to a list of ``Repository`` objects.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    repository_ids (osid.id.IdList): list of repository\n                ``Ids``\n", 
               "return_doc": "        return: (osid.id.IdList) - list of composition ``Ids``", 
               "error_doc": "        raise:  NullArgument - ``repository_ids`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param repository_ids: list of repository ``Ids``\n        :type repository_ids: ``osid.id.IdList``\n", 
               "sphinx_return_doc": "        :return: list of composition ``Ids``\n        :rtype: ``osid.id.IdList``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``repository_ids`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.IdList", 
                     "var_name": "repository_ids", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.IdList"
               ], 
               "return_type": "osid.id.IdList", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_compoitions_by_repositories", 
               "doc": {
                  "headline": "Gets the list of ``Compositions`` corresponding to a list of ``Repository`` objects.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    repository_ids (osid.id.IdList): list of repository\n                ``Ids``\n", 
               "return_doc": "        return: (osid.repository.CompositionList) - list of Compositions", 
               "error_doc": "        raise:  NullArgument - ``repository_ids`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param repository_ids: list of repository ``Ids``\n        :type repository_ids: ``osid.id.IdList``\n", 
               "sphinx_return_doc": "        :return: list of Compositions\n        :rtype: ``osid.repository.CompositionList``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``repository_ids`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.IdList", 
                     "var_name": "repository_ids", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.IdList"
               ], 
               "return_type": "osid.repository.CompositionList", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_repository_ids_by_composition", 
               "doc": {
                  "headline": "Gets the ``Repository``  ``Ids`` mapped to a ``Composition``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    composition_id (osid.id.Id): ``Id`` of a ``Composition``\n", 
               "return_doc": "        return: (osid.id.IdList) - list of repository ``Ids``", 
               "error_doc": "        raise:  NotFound - ``composition_id`` is not found\n        raise:  NullArgument - ``composition_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param composition_id: ``Id`` of a ``Composition``\n        :type composition_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: list of repository ``Ids``\n        :rtype: ``osid.id.IdList``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``composition_id`` is not found\n        :raise: ``NullArgument`` -- ``composition_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "composition_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "osid.id.IdList", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_repositories_by_composition", 
               "doc": {
                  "headline": "Gets the ``Repository`` objects mapped to a ``Composition``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    composition_id (osid.id.Id): ``Id`` of a ``Composition``\n", 
               "return_doc": "        return: (osid.repository.RepositoryList) - list of repositories", 
               "error_doc": "        raise:  NotFound - ``composition_id`` is not found\n        raise:  NullArgument - ``composition_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param composition_id: ``Id`` of a ``Composition``\n        :type composition_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: list of repositories\n        :rtype: ``osid.repository.RepositoryList``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``composition_id`` is not found\n        :raise: ``NullArgument`` -- ``composition_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "composition_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "osid.repository.RepositoryList", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.repository.CompositionRepositoryAssignmentSession", 
         "shortname": "CompositionRepositoryAssignmentSession", 
         "category": "sessions", 
         "doc": {
            "headline": "This session provides methods to re-assign ``Compositions`` to ``Repository`` objects.", 
            "body": "    A ``Composition`` may be associated with multiple ``Repository``\n    objects. Removing the last reference to a ``Composition`` is the\n    equivalent of deleting it. Each ``Repository`` may have its own\n    authorizations governing who is allowed to operate on it.\n\n    Moving or adding a reference of a ``Composition`` to another\n    ``Repository`` is not a copy operation (eg: does not change its\n    ``Id`` )."
         }, 
         "inherit_fullnames": [
            "osid.OsidSession"
         ], 
         "inherit_shortnames": [
            "OsidSession"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidSession"
            }
         ], 
         "method_names": [
            "can_assign_compositions", 
            "can_assign_compositions_to_repository", 
            "get_assignable_repository_ids", 
            "get_assignable_repository_ids_for_composition", 
            "assign_composition_to_repository", 
            "unassign_composition_from_repository"
         ], 
         "methods": [
            {
               "name": "can_assign_compositions", 
               "doc": {
                  "headline": "Tests if this user can alter composition/repository mappings.", 
                  "body": "        A return of true does not guarantee successful authorization. A\n        return of false indicates that it is known mapping methods in\n        this session will result in a ``PermissionDenied``. This is\n        intended as a hint to an application that may opt not to offer\n        assignment operations to unauthorized users."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``false`` if mapping is not authorized,\n                ``true`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``false`` if mapping is not authorized, ``true`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "can_assign_compositions_to_repository", 
               "doc": {
                  "headline": "Tests if this user can alter composition/repository mappings.", 
                  "body": "        A return of true does not guarantee successful authorization. A\n        return of false indicates that it is known mapping methods in\n        this session will result in a ``PermissionDenied``. This is\n        intended as a hint to an application that may opt not to offer\n        assignment operations to unauthorized users."
               }, 
               "arg_doc": "        arg:    repository_id (osid.id.Id): the ``Id`` of the\n                ``Repository``\n", 
               "return_doc": "        return: (boolean) - ``false`` if mapping is not authorized,\n                ``true`` otherwise", 
               "error_doc": "        raise:  NullArgument - ``repository_id`` is ``null``", 
               "sphinx_param_doc": "        :param repository_id: the ``Id`` of the ``Repository``\n        :type repository_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: ``false`` if mapping is not authorized, ``true`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``repository_id`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "repository_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "boolean", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "get_assignable_repository_ids", 
               "doc": {
                  "headline": "Gets a list of repositories including and under the given repository node in which any composition can be assigned.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    repository_id (osid.id.Id): the ``Id`` of the\n                ``Repository``\n", 
               "return_doc": "        return: (osid.id.IdList) - list of assignable repository ``Ids``", 
               "error_doc": "        raise:  NullArgument - ``repository_id`` is ``null``\n        raise:  OperationFailed - unable to complete request", 
               "sphinx_param_doc": "        :param repository_id: the ``Id`` of the ``Repository``\n        :type repository_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: list of assignable repository ``Ids``\n        :rtype: ``osid.id.IdList``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``repository_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "repository_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "osid.id.IdList", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational"
               }
            }, 
            {
               "name": "get_assignable_repository_ids_for_composition", 
               "doc": {
                  "headline": "Gets a list of repositories including and under the given repository node in which a specific composition can be assigned.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    repository_id (osid.id.Id): the ``Id`` of the\n                ``Repository``\n        arg:    composition_id (osid.id.Id): the ``Id`` of the\n                ``Composition``\n", 
               "return_doc": "        return: (osid.id.IdList) - list of assignable repository ``Ids``", 
               "error_doc": "        raise:  NullArgument - ``repository_id`` or ``composition_id``\n                is ``null``\n        raise:  OperationFailed - unable to complete request", 
               "sphinx_param_doc": "        :param repository_id: the ``Id`` of the ``Repository``\n        :type repository_id: ``osid.id.Id``\n        :param composition_id: the ``Id`` of the ``Composition``\n        :type composition_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: list of assignable repository ``Ids``\n        :rtype: ``osid.id.IdList``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``repository_id`` or ``composition_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "repository_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "composition_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "osid.id.Id"
               ], 
               "return_type": "osid.id.IdList", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational"
               }
            }, 
            {
               "name": "assign_composition_to_repository", 
               "doc": {
                  "headline": "Adds an existing ``Composition`` to a ``Repository``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    composition_id (osid.id.Id): the ``Id`` of the\n                ``Composition``\n        arg:    repository_id (osid.id.Id): the ``Id`` of the\n                ``Repository``\n", 
               "return_doc": "", 
               "error_doc": "        raise:  AlreadyExists - ``composition_id`` already assigned to\n                ``repository_id``\n        raise:  NotFound - ``composition_id`` or ``repository_id`` not\n                found\n        raise:  NullArgument - ``composition_id`` or ``repository_id``\n                is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param composition_id: the ``Id`` of the ``Composition``\n        :type composition_id: ``osid.id.Id``\n        :param repository_id: the ``Id`` of the ``Repository``\n        :type repository_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``AlreadyExists`` -- ``composition_id`` already assigned to ``repository_id``\n        :raise: ``NotFound`` -- ``composition_id`` or ``repository_id`` not found\n        :raise: ``NullArgument`` -- ``composition_id`` or ``repository_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "composition_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "repository_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {
                  "ALREADY_EXISTS": "User", 
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "unassign_composition_from_repository", 
               "doc": {
                  "headline": "Removes ``Composition`` from a ``Repository``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    composition_id (osid.id.Id): the ``Id`` of the\n                ``Composition``\n        arg:    repository_id (osid.id.Id): the ``Id`` of the\n                ``Repository``\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NotFound - ``composition_id`` or ``repository_id`` not\n                found or ``composition_id`` not assigned to\n                ``repository_id``\n        raise:  NullArgument - ``composition_id`` or ``repository_id``\n                is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param composition_id: the ``Id`` of the ``Composition``\n        :type composition_id: ``osid.id.Id``\n        :param repository_id: the ``Id`` of the ``Repository``\n        :type repository_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``composition_id`` or ``repository_id`` not found or ``composition_id`` not assigned to ``repository_id``\n        :raise: ``NullArgument`` -- ``composition_id`` or ``repository_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "composition_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "repository_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.repository.CompositionSmartRepositorySession", 
         "shortname": "CompositionSmartRepositorySession", 
         "category": "sessions", 
         "doc": {
            "headline": "This session manages queries and sequencing to create \"smart\" dynamic catalogs.", 
            "body": "    A ``CompositionQuery`` can be retrieved from this session and mapped\n    to this ``Repository`` to create a virtual collection of\n    ``Compositions``. The compositions may be sequenced using the\n    ``CompositionSearchOrder`` from this session.\n\n    This ``Repository`` has a default query that matches any composition\n    and a default search order that specifies no sequencing. The queries\n    may be examined using a ``CompositionQueryInspector``. The query may\n    be modified by converting the inspector back to a\n    ``CompositionQuery``."
         }, 
         "inherit_fullnames": [
            "osid.OsidSession"
         ], 
         "inherit_shortnames": [
            "OsidSession"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidSession"
            }
         ], 
         "method_names": [
            "get_repository_id", 
            "get_repository", 
            "can_manage_smart_repository", 
            "get_composition_query", 
            "get_composition_search_order", 
            "apply_composition_query", 
            "inspect_composition_query", 
            "apply_composition_sequencing", 
            "get_composition_query_from_inspector"
         ], 
         "methods": [
            {
               "name": "get_repository_id", 
               "doc": {
                  "headline": "Gets the ``Repository``  ``Id`` associated with this session.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.id.Id) - the ``Repository Id`` associated with\n                this session", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the ``Repository Id`` associated with this session\n        :rtype: ``osid.id.Id``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.id.Id", 
               "errors": {}
            }, 
            {
               "name": "get_repository", 
               "doc": {
                  "headline": "Gets the ``Repository`` associated with this session.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.repository.Repository) - the ``Repository``\n                associated with this session", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the ``Repository`` associated with this session\n        :rtype: ``osid.repository.Repository``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.repository.Repository", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "can_manage_smart_repository", 
               "doc": {
                  "headline": "Tests if this user can manage smart repository.", 
                  "body": "        A return of true does not guarantee successful authorization. A\n        return of false indicates that it is known methods in this\n        session will result in a ``PermissionDenied``. This is intended\n        as a hint to an application that may opt not to offer operations\n        to unauthorized users."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``false`` if smart repository management is\n                not authorized, ``true`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``false`` if smart repository management is not authorized, ``true`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "get_composition_query", 
               "doc": {
                  "headline": "Gets a composition query.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.repository.CompositionQuery) - the composition\n                query", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the composition query\n        :rtype: ``osid.repository.CompositionQuery``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.repository.CompositionQuery", 
               "errors": {}
            }, 
            {
               "name": "get_composition_search_order", 
               "doc": {
                  "headline": "Gets a composition search order.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.repository.CompositionSearchOrder) - the\n                composition search order", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the composition search order\n        :rtype: ``osid.repository.CompositionSearchOrder``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.repository.CompositionSearchOrder", 
               "errors": {}
            }, 
            {
               "name": "apply_composition_query", 
               "doc": {
                  "headline": "Applies a composition query to this repository.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    composition_query (osid.repository.CompositionQuery):\n                the composition query\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``composition_query`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure occurred\n        raise:  Unsupported - ``composition_query`` not of this service", 
               "sphinx_param_doc": "        :param composition_query: the composition query\n        :type composition_query: ``osid.repository.CompositionQuery``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``composition_query`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure occurred\n        :raise: ``Unsupported`` -- ``composition_query`` not of this service", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.repository.CompositionQuery", 
                     "var_name": "composition_query", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.repository.CompositionQuery"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }, 
            {
               "name": "inspect_composition_query", 
               "doc": {
                  "headline": "Gets a composition query inspector for this repository.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.repository.CompositionQueryInspector) - the\n                composition query inspector", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure occurred", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the composition query inspector\n        :rtype: ``osid.repository.CompositionQueryInspector``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure occurred", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.repository.CompositionQueryInspector", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "apply_composition_sequencing", 
               "doc": {
                  "headline": "Applies a composition search order to this repository.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    composition_search_order\n                (osid.repository.CompositionSearchOrder): the\n                composition search order\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``composition_search_order`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure occurred\n        raise:  Unsupported - ``composition_search_order`` not of this\n                service", 
               "sphinx_param_doc": "        :param composition_search_order: the composition search order\n        :type composition_search_order: ``osid.repository.CompositionSearchOrder``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``composition_search_order`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure occurred\n        :raise: ``Unsupported`` -- ``composition_search_order`` not of this service", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.repository.CompositionSearchOrder", 
                     "var_name": "composition_search_order", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.repository.CompositionSearchOrder"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_composition_query_from_inspector", 
               "doc": {
                  "headline": "Gets a composition query from an inspector.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    composition_query_inspector\n                (osid.repository.CompositionQueryInspector): a resorce\n                relationship query inspector\n", 
               "return_doc": "        return: (osid.repository.CompositionQuery) - the composition\n                query", 
               "error_doc": "        raise:  NullArgument - ``composition_query_inspector`` is\n                ``null``\n        raise:  Unsupported - ``composition_query_inspector`` is not of\n                this service", 
               "sphinx_param_doc": "        :param composition_query_inspector: a resorce relationship query inspector\n        :type composition_query_inspector: ``osid.repository.CompositionQueryInspector``\n", 
               "sphinx_return_doc": "        :return: the composition query\n        :rtype: ``osid.repository.CompositionQuery``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``composition_query_inspector`` is ``null``\n        :raise: ``Unsupported`` -- ``composition_query_inspector`` is not of this service", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.repository.CompositionQueryInspector", 
                     "var_name": "composition_query_inspector", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.repository.CompositionQueryInspector"
               ], 
               "return_type": "osid.repository.CompositionQuery", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.repository.RepositoryLookupSession", 
         "shortname": "RepositoryLookupSession", 
         "category": "sessions", 
         "doc": {
            "headline": "This session provides methods for retrieving ``Repository`` objects.", 
            "body": "    The ``Repository`` represents a collection of ``Assets`` and\n    ``Compositions``.\n\n    This session defines views that offer differing behaviors when\n    retrieving multiple objects.\n    \n      * comparative view: elements may be silently omitted or re-ordered\n      * plenary view: provides a complete set or is an error condition\n\n    \n    Generally, the comparative view should be used for most applications\n    as it permits operation even if there is data that cannot be\n    accessed. For example, a browsing application may only need to\n    examine the ``Repositories`` it can access, without breaking\n    execution. However, an administrative application may require all\n    ``Repository`` elements to be available.\n    \n    Repositories may have an additional records indicated by their\n    respective record types. The record may not be accessed through a\n    cast of the ``Repository``."
         }, 
         "inherit_fullnames": [
            "osid.OsidSession"
         ], 
         "inherit_shortnames": [
            "OsidSession"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidSession"
            }
         ], 
         "method_names": [
            "can_lookup_repositories", 
            "use_comparative_repository_view", 
            "use_plenary_repository_view", 
            "get_repository", 
            "get_repositories_by_ids", 
            "get_repositories_by_genus_type", 
            "get_repositories_by_parent_genus_type", 
            "get_repositories_by_record_type", 
            "get_repositories_by_provider", 
            "get_repositories"
         ], 
         "methods": [
            {
               "name": "can_lookup_repositories", 
               "doc": {
                  "headline": "Tests if this user can perform ``Repository`` lookups.", 
                  "body": "        A return of true does not guarantee successful authorization. A\n        return of false indicates that it is known all methods in this\n        session will result in a ``PermissionDenied``. This is intended\n        as a hint to an application that may opt not to offer lookup\n        operations to unauthorized users."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``false`` if lookup methods are not\n                authorized, ``true`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``false`` if lookup methods are not authorized, ``true`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "use_comparative_repository_view", 
               "doc": {
                  "headline": "The returns from the lookup methods may omit or translate elements based on this session, such as authorization, and not result in an error.", 
                  "body": "        This view is used when greater interoperability is desired at\n        the expense of precision."
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "use_plenary_repository_view", 
               "doc": {
                  "headline": "A complete view of the ``Repository`` returns is desired.", 
                  "body": "        Methods will return what is requested or result in an error.\n        This view is used when greater precision is desired at the\n        expense of interoperability."
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "get_repository", 
               "doc": {
                  "headline": "Gets the ``Repository`` specified by its ``Id``.", 
                  "body": "        In plenary mode, the exact ``Id`` is found or a ``NotFound``\n        results. Otherwise, the returned ``Repository`` may have a\n        different ``Id`` than requested, such as the case where a\n        duplicate ``Id`` was assigned to a ``Repository`` and retained\n        for compatibility."
               }, 
               "arg_doc": "        arg:    repository_id (osid.id.Id): ``Id`` of the ``Repository``\n", 
               "return_doc": "        return: (osid.repository.Repository) - the repository", 
               "error_doc": "        raise:  NotFound - ``repository_id`` not found\n        raise:  NullArgument - ``repository_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param repository_id: ``Id`` of the ``Repository``\n        :type repository_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: the repository\n        :rtype: ``osid.repository.Repository``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``repository_id`` not found\n        :raise: ``NullArgument`` -- ``repository_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "repository_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "osid.repository.Repository", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_repositories_by_ids", 
               "doc": {
                  "headline": "Gets a ``RepositoryList`` corresponding to the given ``IdList``.", 
                  "body": "        In plenary mode, the returned list contains all of the\n        repositories specified in the ``Id`` list, in the order of the\n        list, including duplicates, or an error results if an ``Id`` in\n        the supplied list is not found or inaccessible. Otherwise,\n        inaccessible ``Repositories`` may be omitted from the list and\n        may present the elements in any order including returning a\n        unique set."
               }, 
               "arg_doc": "        arg:    repository_ids (osid.id.IdList): the list of ``Ids`` to\n                retrieve\n", 
               "return_doc": "        return: (osid.repository.RepositoryList) - the returned\n                ``Repository list``", 
               "error_doc": "        raise:  NotFound - an ``Id`` was not found\n        raise:  NullArgument - ``repository_ids`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param repository_ids: the list of ``Ids`` to retrieve\n        :type repository_ids: ``osid.id.IdList``\n", 
               "sphinx_return_doc": "        :return: the returned ``Repository list``\n        :rtype: ``osid.repository.RepositoryList``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- an ``Id`` was not found\n        :raise: ``NullArgument`` -- ``repository_ids`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.IdList", 
                     "var_name": "repository_ids", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.IdList"
               ], 
               "return_type": "osid.repository.RepositoryList", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_repositories_by_genus_type", 
               "doc": {
                  "headline": "Gets a ``RepositoryList`` corresponding to the given repository genus ``Type`` which does not include repositories of types derived from the specified ``Type``.", 
                  "body": "        In plenary mode, the returned list contains all known\n        repositories or an error results. Otherwise, the returned list\n        may contain only those repositories that are accessible through\n        this session."
               }, 
               "arg_doc": "        arg:    repository_genus_type (osid.type.Type): a repository\n                genus type\n", 
               "return_doc": "        return: (osid.repository.RepositoryList) - the returned\n                ``Repository list``", 
               "error_doc": "        raise:  NullArgument - ``repository_genus_type`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param repository_genus_type: a repository genus type\n        :type repository_genus_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "        :return: the returned ``Repository list``\n        :rtype: ``osid.repository.RepositoryList``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``repository_genus_type`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "repository_genus_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "osid.repository.RepositoryList", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_repositories_by_parent_genus_type", 
               "doc": {
                  "headline": "Gets a ``RepositoryList`` corresponding to the given repository genus ``Type`` and include any additional repositories with genus types derived from the specified ``Type``.", 
                  "body": "        In plenary mode, the returned list contains all known\n        repositories or an error results. Otherwise, the returned list\n        may contain only those repositories that are accessible through\n        this session."
               }, 
               "arg_doc": "        arg:    repository_genus_type (osid.type.Type): a repository\n                genus type\n", 
               "return_doc": "        return: (osid.repository.RepositoryList) - the returned\n                ``Repository list``", 
               "error_doc": "        raise:  NullArgument - ``repository_genus_type`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param repository_genus_type: a repository genus type\n        :type repository_genus_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "        :return: the returned ``Repository list``\n        :rtype: ``osid.repository.RepositoryList``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``repository_genus_type`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "repository_genus_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "osid.repository.RepositoryList", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_repositories_by_record_type", 
               "doc": {
                  "headline": "Gets a ``RepositoryList`` containing the given repository record ``Type``.", 
                  "body": "        In plenary mode, the returned list contains all known\n        repositories or an error results. Otherwise, the returned list\n        may contain only those repositories that are accessible through\n        this session."
               }, 
               "arg_doc": "        arg:    repository_record_type (osid.type.Type): a repository\n                record type\n", 
               "return_doc": "        return: (osid.repository.RepositoryList) - the returned\n                ``Repository list``", 
               "error_doc": "        raise:  NullArgument - ``repository_record_type`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param repository_record_type: a repository record type\n        :type repository_record_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "        :return: the returned ``Repository list``\n        :rtype: ``osid.repository.RepositoryList``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``repository_record_type`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "repository_record_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "osid.repository.RepositoryList", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_repositories_by_provider", 
               "doc": {
                  "headline": "Gets a ``RepositoryList`` from the given provider ````.", 
                  "body": "        In plenary mode, the returned list contains all known\n        repositories or an error results. Otherwise, the returned list\n        may contain only those repositories that are accessible through\n        this session."
               }, 
               "arg_doc": "        arg:    resource_id (osid.id.Id): a resource ``Id``\n", 
               "return_doc": "        return: (osid.repository.RepositoryList) - the returned\n                ``Repository list``", 
               "error_doc": "        raise:  NullArgument - ``resource_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param resource_id: a resource ``Id``\n        :type resource_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: the returned ``Repository list``\n        :rtype: ``osid.repository.RepositoryList``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``resource_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "resource_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "osid.repository.RepositoryList", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_repositories", 
               "doc": {
                  "headline": "Gets all ``Repositories``.", 
                  "body": "        In plenary mode, the returned list contains all known\n        repositories or an error results. Otherwise, the returned list\n        may contain only those repositories that are accessible through\n        this session."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.repository.RepositoryList) - a list of\n                ``Repositories``", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: a list of ``Repositories``\n        :rtype: ``osid.repository.RepositoryList``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.repository.RepositoryList", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.repository.RepositoryQuerySession", 
         "shortname": "RepositoryQuerySession", 
         "category": "sessions", 
         "doc": {
            "headline": "This session provides methods for searching among ``Repository`` objects.", 
            "body": "    The search query is constructed using the ``RepositoryQuery``.\n\n    Repositories may have a query record indicated by their respective\n    record types. The query record is accessed via the\n    ``RepositoryQuery``."
         }, 
         "inherit_fullnames": [
            "osid.OsidSession"
         ], 
         "inherit_shortnames": [
            "OsidSession"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidSession"
            }
         ], 
         "method_names": [
            "can_search_repositories", 
            "get_repository_query", 
            "get_repositories_by_query"
         ], 
         "methods": [
            {
               "name": "can_search_repositories", 
               "doc": {
                  "headline": "Tests if this user can perform ``Repository`` searches.", 
                  "body": "        A return of true does not guarantee successful authorization. A\n        return of false indicates that it is known all methods in this\n        session will result in a ``PermissionDenied``. This is intended\n        as a hint to an application that may opt not to offer search\n        operations to unauthorized users."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``false`` if search methods are not\n                authorized, ``true`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``false`` if search methods are not authorized, ``true`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "get_repository_query", 
               "doc": {
                  "headline": "Gets a repository query.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.repository.RepositoryQuery) - the repository query", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the repository query\n        :rtype: ``osid.repository.RepositoryQuery``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.repository.RepositoryQuery", 
               "errors": {}
            }, 
            {
               "name": "get_repositories_by_query", 
               "doc": {
                  "headline": "Gets a list of ``Repositories`` matching the given repository query.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    repository_query (osid.repository.RepositoryQuery): the\n                repository query\n", 
               "return_doc": "        return: (osid.repository.RepositoryList) - the returned\n                ``RepositoryList``", 
               "error_doc": "        raise:  NullArgument - ``repository_query`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        raise:  Unsupported - ``repository_query`` is not of this\n                service", 
               "sphinx_param_doc": "        :param repository_query: the repository query\n        :type repository_query: ``osid.repository.RepositoryQuery``\n", 
               "sphinx_return_doc": "        :return: the returned ``RepositoryList``\n        :rtype: ``osid.repository.RepositoryList``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``repository_query`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure\n        :raise: ``Unsupported`` -- ``repository_query`` is not of this service", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.repository.RepositoryQuery", 
                     "var_name": "repository_query", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.repository.RepositoryQuery"
               ], 
               "return_type": "osid.repository.RepositoryList", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.repository.RepositorySearchSession", 
         "shortname": "RepositorySearchSession", 
         "category": "sessions", 
         "doc": {
            "headline": "This session provides methods for searching among ``Repository`` objects.", 
            "body": "    The search query is constructed using the ``RepositoryQuery``.\n\n    ``get_repositories_by_query()`` is the basic search method and\n    returns a list of ``Repository`` objects.A more advanced search may\n    be performed with ``getRepositoriesBySearch()``. It accepts a\n    ``RepositorySearch`` in addition to the query for the purpose of\n    specifying additional options affecting the entire search, such as\n    ordering. ``get_repositories_by_search()`` returns a\n    ``RepositorySearchResults`` that can be used to access the resulting\n    ``RepositoryList`` or be used to perform a search within the result\n    set through ``RepositorySearch``.\n    \n    Repositories may have a query record indicated by their respective\n    record types. The query record is accessed via the\n    ``RepositoryQuery``."
         }, 
         "inherit_fullnames": [
            "osid.repository.RepositoryQuerySession"
         ], 
         "inherit_shortnames": [
            "RepositoryQuerySession"
         ], 
         "inherit_pkg_names": [
            "repository"
         ], 
         "inheritance": [
            {
               "pkg_name": "repository", 
               "name": "RepositoryQuerySession"
            }
         ], 
         "method_names": [
            "get_repository_search", 
            "get_repository_search_order", 
            "get_repositories_by_search", 
            "get_repository_query_from_inspector"
         ], 
         "methods": [
            {
               "name": "get_repository_search", 
               "doc": {
                  "headline": "Gets a repository search.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.repository.RepositorySearch) - the repository\n                search", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the repository search\n        :rtype: ``osid.repository.RepositorySearch``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.repository.RepositorySearch", 
               "errors": {}
            }, 
            {
               "name": "get_repository_search_order", 
               "doc": {
                  "headline": "Gets a repository search order.", 
                  "body": "        The ``RepositorySearchOrder`` is supplied to a\n        ``RepositorySearch`` to specify the ordering of results."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.repository.RepositorySearchOrder) - the repository\n                search order", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the repository search order\n        :rtype: ``osid.repository.RepositorySearchOrder``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.repository.RepositorySearchOrder", 
               "errors": {}
            }, 
            {
               "name": "get_repositories_by_search", 
               "doc": {
                  "headline": "Gets the search results matching the given search query using the given search.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    repository_query (osid.repository.RepositoryQuery): the\n                repository query\n        arg:    repository_search (osid.repository.RepositorySearch):\n                the repository search\n", 
               "return_doc": "        return: (osid.repository.RepositorySearchResults) - the\n                repository search results", 
               "error_doc": "        raise:  NullArgument - ``repository_query`` or\n                ``repository_search`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        raise:  Unsupported - ``repository_query`` or\n                ``repository_search`` is not of this service", 
               "sphinx_param_doc": "        :param repository_query: the repository query\n        :type repository_query: ``osid.repository.RepositoryQuery``\n        :param repository_search: the repository search\n        :type repository_search: ``osid.repository.RepositorySearch``\n", 
               "sphinx_return_doc": "        :return: the repository search results\n        :rtype: ``osid.repository.RepositorySearchResults``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``repository_query`` or ``repository_search`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure\n        :raise: ``Unsupported`` -- ``repository_query`` or ``repository_search`` is not of this service", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.repository.RepositoryQuery", 
                     "var_name": "repository_query", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.repository.RepositorySearch", 
                     "var_name": "repository_search", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.repository.RepositoryQuery", 
                  "osid.repository.RepositorySearch"
               ], 
               "return_type": "osid.repository.RepositorySearchResults", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_repository_query_from_inspector", 
               "doc": {
                  "headline": "Gets a repository query from an inspector.", 
                  "body": "        The inspector is available from a ``RepositorySearchResults``."
               }, 
               "arg_doc": "        arg:    repository_query_inspector\n                (osid.repository.RepositoryQueryInspector): a repository\n                query inspector\n", 
               "return_doc": "        return: (osid.repository.RepositoryQuery) - the repository query", 
               "error_doc": "        raise:  NullArgument - ``repository_query_inspector`` is\n                ``null``\n        raise:  Unsupported - ``repository_query_inspector`` is not of\n                this service", 
               "sphinx_param_doc": "        :param repository_query_inspector: a repository query inspector\n        :type repository_query_inspector: ``osid.repository.RepositoryQueryInspector``\n", 
               "sphinx_return_doc": "        :return: the repository query\n        :rtype: ``osid.repository.RepositoryQuery``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``repository_query_inspector`` is ``null``\n        :raise: ``Unsupported`` -- ``repository_query_inspector`` is not of this service", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.repository.RepositoryQueryInspector", 
                     "var_name": "repository_query_inspector", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.repository.RepositoryQueryInspector"
               ], 
               "return_type": "osid.repository.RepositoryQuery", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.repository.RepositoryAdminSession", 
         "shortname": "RepositoryAdminSession", 
         "category": "sessions", 
         "doc": {
            "headline": "This session creates, updates, and deletes ``Repositories``.", 
            "body": "    The data for create and update is provided by the consumer via the\n    form object. ``OsidForms`` are requested for each create or update\n    and may not be reused.\n\n    Create and update operations differ in their usage. To create a\n    ``Repository,`` a ``RepositoryForm`` is requested using\n    ``get_repository_form_for_create()`` specifying the desired record\n    ``Types`` or none if no record ``Types`` are needed. The returned\n    ``RepositoryForm`` will indicate that it is to be used with a create\n    operation and can be used to examine metdata or validate data prior\n    to creation. Once the ``RepositoryForm`` is submiited to a create\n    operation, it cannot be reused with another create operation unless\n    the first operation was unsuccessful. Each ``RepositoryForm``\n    corresponds to an attempted transaction.\n    \n    For updates, ``RepositoryForms`` are requested to the ``Repository``\n    ``Id`` that is to be updated using ``getRepositoryFormForUpdate()``.\n    Similarly, the ``RepositoryForm`` has metadata about the data that\n    can be updated and it can perform validation before submitting the\n    update. The ``RepositoryForm`` can only be used once for a\n    successful update and cannot be reused.\n    \n    The delete operations delete ``Repositories``. This session includes\n    an ``Id`` aliasing mechanism to assign an external ``Id`` to an\n    internally assigned Id."
         }, 
         "inherit_fullnames": [
            "osid.OsidSession"
         ], 
         "inherit_shortnames": [
            "OsidSession"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidSession"
            }
         ], 
         "method_names": [
            "can_create_repositories", 
            "can_create_repository_with_record_types", 
            "get_repository_form_for_create", 
            "create_repository", 
            "can_update_repositories", 
            "get_repository_form_for_update", 
            "update_repository", 
            "can_delete_repositories", 
            "delete_repository", 
            "can_manage_repository_aliases", 
            "alias_repository"
         ], 
         "methods": [
            {
               "name": "can_create_repositories", 
               "doc": {
                  "headline": "Tests if this user can create ``Repositories``.", 
                  "body": "        A return of true does not guarantee successful authorization. A\n        return of false indicates that it is known creating a\n        ``Repository`` will result in a ``PermissionDenied``. This is\n        intended as a hint to an application that may not wish to offer\n        create operations to unauthorized users."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``false`` if ``Repository`` creation is not\n                authorized, ``true`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``false`` if ``Repository`` creation is not authorized, ``true`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "can_create_repository_with_record_types", 
               "doc": {
                  "headline": "Tests if this user can create a single ``Repository`` using the desired record types.", 
                  "body": "        While ``RepositoryManager.getRepositoryRecordTypes()`` can be\n        used to examine which records are supported, this method tests\n        which record(s) are required for creating a specific\n        ``Repository``. Providing an empty array tests if a\n        ``Repository`` can be created with no records."
               }, 
               "arg_doc": "        arg:    repository_record_types (osid.type.Type[]): array of\n                repository record types\n", 
               "return_doc": "        return: (boolean) - ``true`` if ``Repository`` creation using\n                the specified ``Types`` is supported, ``false``\n                otherwise", 
               "error_doc": "        raise:  NullArgument - ``repository_record_types`` is ``null``", 
               "sphinx_param_doc": "        :param repository_record_types: array of repository record types\n        :type repository_record_types: ``osid.type.Type[]``\n", 
               "sphinx_return_doc": "        :return: ``true`` if ``Repository`` creation using the specified ``Types`` is supported, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``repository_record_types`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type[]", 
                     "var_name": "repository_record_types", 
                     "array": true
                  }
               ], 
               "arg_types": [
                  "osid.type.Type[]"
               ], 
               "return_type": "boolean", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "get_repository_form_for_create", 
               "doc": {
                  "headline": "Gets the repository form for creating new repositories.", 
                  "body": "        A new form should be requested for each create transaction."
               }, 
               "arg_doc": "        arg:    repository_record_types (osid.type.Type[]): array of\n                repository record types\n", 
               "return_doc": "        return: (osid.repository.RepositoryForm) - the repository form", 
               "error_doc": "        raise:  NullArgument - ``repository_record_types`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        raise:  Unsupported - unable to get form for requested record\n                types", 
               "sphinx_param_doc": "        :param repository_record_types: array of repository record types\n        :type repository_record_types: ``osid.type.Type[]``\n", 
               "sphinx_return_doc": "        :return: the repository form\n        :rtype: ``osid.repository.RepositoryForm``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``repository_record_types`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure\n        :raise: ``Unsupported`` -- unable to get form for requested record types", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type[]", 
                     "var_name": "repository_record_types", 
                     "array": true
                  }
               ], 
               "arg_types": [
                  "osid.type.Type[]"
               ], 
               "return_type": "osid.repository.RepositoryForm", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }, 
            {
               "name": "create_repository", 
               "doc": {
                  "headline": "Creates a new ``Repository``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    repository_form (osid.repository.RepositoryForm): the\n                form for this ``Repository``\n", 
               "return_doc": "        return: (osid.repository.Repository) - the new ``Repository``", 
               "error_doc": "        raise:  IllegalState - ``repository_form`` already used in a\n                create transaction\n        raise:  InvalidArgument - one or more of the form elements is\n                invalid\n        raise:  NullArgument - ``repository_form`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        raise:  Unsupported - ``repository_form`` did not originate from\n                ``get_repository_form_for_create()``", 
               "sphinx_param_doc": "        :param repository_form: the form for this ``Repository``\n        :type repository_form: ``osid.repository.RepositoryForm``\n", 
               "sphinx_return_doc": "        :return: the new ``Repository``\n        :rtype: ``osid.repository.Repository``", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- ``repository_form`` already used in a create transaction\n        :raise: ``InvalidArgument`` -- one or more of the form elements is invalid\n        :raise: ``NullArgument`` -- ``repository_form`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure\n        :raise: ``Unsupported`` -- ``repository_form`` did not originate from ``get_repository_form_for_create()``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.repository.RepositoryForm", 
                     "var_name": "repository_form", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.repository.RepositoryForm"
               ], 
               "return_type": "osid.repository.Repository", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract", 
                  "INVALID_ARGUMENT": "ConsumerContract", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }, 
            {
               "name": "can_update_repositories", 
               "doc": {
                  "headline": "Tests if this user can update ``Repositories``.", 
                  "body": "        A return of true does not guarantee successful authorization. A\n        return of false indicates that it is known updating a\n        ``Repository`` will result in a ``PermissionDenied``. This is\n        intended as a hint to an application that may not wish to offer\n        update operations to unauthorized users."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``false`` if ``Repository`` modification is\n                not authorized, ``true`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``false`` if ``Repository`` modification is not authorized, ``true`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "get_repository_form_for_update", 
               "doc": {
                  "headline": "Gets the repository form for updating an existing repository.", 
                  "body": "        A new repository form should be requested for each update\n        transaction."
               }, 
               "arg_doc": "        arg:    repository_id (osid.id.Id): the ``Id`` of the\n                ``Repository``\n", 
               "return_doc": "        return: (osid.repository.RepositoryForm) - the repository form", 
               "error_doc": "        raise:  NotFound - ``repository_id`` is not found\n        raise:  NullArgument - ``repository_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param repository_id: the ``Id`` of the ``Repository``\n        :type repository_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: the repository form\n        :rtype: ``osid.repository.RepositoryForm``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``repository_id`` is not found\n        :raise: ``NullArgument`` -- ``repository_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "repository_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "osid.repository.RepositoryForm", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "update_repository", 
               "doc": {
                  "headline": "Updates an existing repository.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    repository_form (osid.repository.RepositoryForm): the\n                form containing the elements to be updated\n", 
               "return_doc": "", 
               "error_doc": "        raise:  IllegalState - ``repository_form`` already used in an\n                update transaction\n        raise:  InvalidArgument - the form contains an invalid value\n        raise:  NullArgument - ``repository_form`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        raise:  Unsupported - ``repository_form`` did not originate from\n                ``get_repository_form_for_update()``", 
               "sphinx_param_doc": "        :param repository_form: the form containing the elements to be updated\n        :type repository_form: ``osid.repository.RepositoryForm``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- ``repository_form`` already used in an update transaction\n        :raise: ``InvalidArgument`` -- the form contains an invalid value\n        :raise: ``NullArgument`` -- ``repository_form`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure\n        :raise: ``Unsupported`` -- ``repository_form`` did not originate from ``get_repository_form_for_update()``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.repository.RepositoryForm", 
                     "var_name": "repository_form", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.repository.RepositoryForm"
               ], 
               "return_type": "", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract", 
                  "INVALID_ARGUMENT": "ConsumerContract", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }, 
            {
               "name": "can_delete_repositories", 
               "doc": {
                  "headline": "Tests if this user can delete ``Repositories``.", 
                  "body": "        A return of true does not guarantee successful authorization. A\n        return of false indicates that it is known deleting a\n        ``Repository`` will result in a ``PermissionDenied``. This is\n        intended as a hint to an application that may not wish to offer\n        delete operations to unauthorized users."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``false`` if ``Repository`` deletion is not\n                authorized, ``true`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``false`` if ``Repository`` deletion is not authorized, ``true`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "delete_repository", 
               "doc": {
                  "headline": "Deletes a ``Repository``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    repository_id (osid.id.Id): the ``Id`` of the\n                ``Repository`` to remove\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NotFound - ``repository_id`` not found\n        raise:  NullArgument - ``repository_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param repository_id: the ``Id`` of the ``Repository`` to remove\n        :type repository_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``repository_id`` not found\n        :raise: ``NullArgument`` -- ``repository_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "repository_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "can_manage_repository_aliases", 
               "doc": {
                  "headline": "Tests if this user can manage ``Id`` aliases for repositories.", 
                  "body": "        A return of true does not guarantee successful authorization. A\n        return of false indicates that it is known changing an alias\n        will result in a ``PermissionDenied``. This is intended as a\n        hint to an application that may opt not to offer alias\n        operations to an unauthorized user."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``false`` if ``Repository`` aliasing is not\n                authorized, ``true`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``false`` if ``Repository`` aliasing is not authorized, ``true`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "alias_repository", 
               "doc": {
                  "headline": "Adds an ``Id`` to a ``Repository`` for the purpose of creating compatibility.", 
                  "body": "        The primary ``Id`` of the ``Repository`` is determined by the\n        provider. The new ``Id`` is an alias to the primary ``Id``. If\n        the alias is a pointer to another repository, it is reassigned\n        to the given repository ``Id``."
               }, 
               "arg_doc": "        arg:    repository_id (osid.id.Id): the ``Id`` of a\n                ``Repository``\n        arg:    alias_id (osid.id.Id): the alias ``Id``\n", 
               "return_doc": "", 
               "error_doc": "        raise:  AlreadyExists - ``alias_id`` is in use as a primary\n                ``Id``\n        raise:  NotFound - ``repository_id`` not found\n        raise:  NullArgument - ``repository_id`` or ``alias_id`` is\n                ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param repository_id: the ``Id`` of a ``Repository``\n        :type repository_id: ``osid.id.Id``\n        :param alias_id: the alias ``Id``\n        :type alias_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``AlreadyExists`` -- ``alias_id`` is in use as a primary ``Id``\n        :raise: ``NotFound`` -- ``repository_id`` not found\n        :raise: ``NullArgument`` -- ``repository_id`` or ``alias_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "repository_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "alias_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {
                  "ALREADY_EXISTS": "User", 
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.repository.RepositoryNotificationSession", 
         "shortname": "RepositoryNotificationSession", 
         "category": "sessions", 
         "doc": {
            "headline": "This session defines methods to receive notifications on adds/changes to ``Repository`` objects.", 
            "body": "    This session is intended for consumers needing to synchronize their\n    state with this service without the use of polling. Notifications\n    are cancelled when this session is closed."
         }, 
         "inherit_fullnames": [
            "osid.OsidSession"
         ], 
         "inherit_shortnames": [
            "OsidSession"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidSession"
            }
         ], 
         "method_names": [
            "can_register_for_repository_notifications", 
            "register_for_new_repositories", 
            "register_for_new_repository_ancestors", 
            "register_for_new_repository_descendants", 
            "register_for_changed_repositories", 
            "register_for_changed_repository", 
            "register_for_deleted_repositories", 
            "register_for_deleted_repository", 
            "register_for_deleted_repository_ancestors", 
            "register_for_deleted_repository_descendants"
         ], 
         "methods": [
            {
               "name": "can_register_for_repository_notifications", 
               "doc": {
                  "headline": "Tests if this user can register for ``Repository`` notifications.", 
                  "body": "        A return of true does not guarantee successful authorization. A\n        return of false indicates that it is known all methods in this\n        session will result in a ``PermissionDenied``. This is intended\n        as a hint to an application that may opt not to offer\n        notification operations."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``false`` if notification methods are not\n                authorized, ``true`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``false`` if notification methods are not authorized, ``true`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "register_for_new_repositories", 
               "doc": {
                  "headline": "Register for notifications of new repositories.", 
                  "body": "        ``RepositoryReceiver.newRepository()`` is invoked when a new\n        ``Repository`` is created."
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "register_for_new_repository_ancestors", 
               "doc": {
                  "headline": "Registers for notification if an ancestor is added to the specified repository in the repository hierarchy.", 
                  "body": "        ``RepositoryReceiver.newRepositoryAncestor()`` is invoked when\n        the specified repository experiences an addition in ancestry."
               }, 
               "arg_doc": "        arg:    repository_id (osid.id.Id): the ``Id`` of the repository\n                to monitor\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``repository_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param repository_id: the ``Id`` of the repository to monitor\n        :type repository_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``repository_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "repository_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "register_for_new_repository_descendants", 
               "doc": {
                  "headline": "Registers for notification if a descendant is added to the specified repository in the repository hierarchy.", 
                  "body": "        ``RepositoryReceiver.newRepositoryDescendant()`` is invoked when\n        the specified repository experiences an addition in descendants."
               }, 
               "arg_doc": "        arg:    repository_id (osid.id.Id): the ``Id`` of the repository\n                to monitor\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``repository_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param repository_id: the ``Id`` of the repository to monitor\n        :type repository_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``repository_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "repository_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "register_for_changed_repositories", 
               "doc": {
                  "headline": "Registers for notification of updated repositories.", 
                  "body": "        ``RepositoryReceiver.changedRepository()`` is invoked when a\n        repository is changed."
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "register_for_changed_repository", 
               "doc": {
                  "headline": "Registers for notification of an updated repository.", 
                  "body": "        ``RepositoryReceiver.changedRepository()`` is invoked when the\n        specified repository is changed."
               }, 
               "arg_doc": "        arg:    repository_id (osid.id.Id): the ``Id`` of the\n                ``Repository`` to monitor\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``repository_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param repository_id: the ``Id`` of the ``Repository`` to monitor\n        :type repository_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``repository_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "repository_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "register_for_deleted_repositories", 
               "doc": {
                  "headline": "Registers for notification of deleted repositories.", 
                  "body": "        ``RepositoryReceiver.deletedRepository()`` is invoked when a\n        repository is deleted."
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "register_for_deleted_repository", 
               "doc": {
                  "headline": "Registers for notification of a deleted repository.", 
                  "body": "        ``RepositoryReceiver.deletedRepository()`` is invoked when the\n        specified repository is deleted."
               }, 
               "arg_doc": "        arg:    repository_id (osid.id.Id): the ``Id`` of the\n                ``Repository`` to monitor\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``repository_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param repository_id: the ``Id`` of the ``Repository`` to monitor\n        :type repository_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``repository_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "repository_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "register_for_deleted_repository_ancestors", 
               "doc": {
                  "headline": "Registers for notification if an ancestor is removed from the specified repository in the repository hierarchy.", 
                  "body": "        ``RepositoryReceiver.deletedRepositoryAncestor()`` is invoked\n        when the specified repository experiences a removal of an\n        ancestor."
               }, 
               "arg_doc": "        arg:    repository_id (osid.id.Id): the ``Id`` of the repository\n                to monitor\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``repository_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param repository_id: the ``Id`` of the repository to monitor\n        :type repository_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``repository_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "repository_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "register_for_deleted_repository_descendants", 
               "doc": {
                  "headline": "Registers for notification if a descendant is removed from fthe specified repository in the repository hierarchy.", 
                  "body": "        ``RepositoryReceiver.deletedRepositoryDescednant()`` is invoked\n        when the specified repository experiences a removal of one of\n        its descdendents."
               }, 
               "arg_doc": "        arg:    repository_id (osid.id.Id): the ``Id`` of the repository\n                to monitor\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``repository_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param repository_id: the ``Id`` of the repository to monitor\n        :type repository_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``repository_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "repository_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.repository.RepositoryHierarchySession", 
         "shortname": "RepositoryHierarchySession", 
         "category": "sessions", 
         "doc": {
            "headline": "This session defines methods for traversing a hierarchy of ``Repository`` objects.", 
            "body": "    Each node in the hierarchy is a unique ``Repository``. The hierarchy\n    may be traversed recursively to establish the tree structure through\n    ``get_parents()`` and ``getChildren()``. To relate these ``Ids`` to\n    another OSID, ``get_ancestors()`` and ``get_descendants()`` can be\n    used for retrievals that can be used for bulk lookups in other\n    OSIDs. Any ``Repository`` available in the Repository OSID is known\n    to this hierarchy but does not appear in the hierarchy traversal\n    until added as a root node or a child of another node.\n\n    A user may not be authorized to traverse the entire hierarchy. Parts\n    of the hierarchy may be made invisible through omission from the\n    returns of ``get_parents()`` or ``get_children()`` in lieu of a\n    ``PermissionDenied`` error that may disrupt the traversal through\n    authorized pathways.\n    \n    This session defines views that offer differing behaviors when\n    retrieving multiple objects.\n    \n      * comparative view: repository elements may be silently omitted or\n        re-ordered\n      * plenary view: provides a complete set or is an error condition\n"
         }, 
         "inherit_fullnames": [
            "osid.OsidSession"
         ], 
         "inherit_shortnames": [
            "OsidSession"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidSession"
            }
         ], 
         "method_names": [
            "get_repository_hierarchy_id", 
            "get_repository_hierarchy", 
            "can_access_repository_hierarchy", 
            "use_comparative_repository_view", 
            "use_plenary_repository_view", 
            "get_root_repository_ids", 
            "get_root_repositories", 
            "has_parent_repositories", 
            "is_parent_of_repository", 
            "get_parent_repository_ids", 
            "get_parent_repositories", 
            "is_ancestor_of_repository", 
            "has_child_repositories", 
            "is_child_of_repository", 
            "get_child_repository_ids", 
            "get_child_repositories", 
            "is_descendant_of_repository", 
            "get_repository_node_ids", 
            "get_repository_nodes"
         ], 
         "methods": [
            {
               "name": "get_repository_hierarchy_id", 
               "doc": {
                  "headline": "Gets the hierarchy ``Id`` associated with this session.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.id.Id) - the hierarchy ``Id`` associated with this\n                session", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the hierarchy ``Id`` associated with this session\n        :rtype: ``osid.id.Id``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.id.Id", 
               "errors": {}
            }, 
            {
               "name": "get_repository_hierarchy", 
               "doc": {
                  "headline": "Gets the hierarchy associated with this session.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.hierarchy.Hierarchy) - the hierarchy associated\n                with this session", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the hierarchy associated with this session\n        :rtype: ``osid.hierarchy.Hierarchy``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.hierarchy.Hierarchy", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "can_access_repository_hierarchy", 
               "doc": {
                  "headline": "Tests if this user can perform hierarchy queries.", 
                  "body": "        A return of true does not guarantee successful authorization. A\n        return of false indicates that it is known all methods in this\n        session will result in a ``PermissionDenied``. This is intended\n        as a hint to an application that may opt not to offer lookup\n        operations."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``false`` if hierarchy traversal methods are\n                not authorized, ``true`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``false`` if hierarchy traversal methods are not authorized, ``true`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "use_comparative_repository_view", 
               "doc": {
                  "headline": "The returns from the repository methods may omit or translate elements based on this session, such as authorization, and not result in an error.", 
                  "body": "        This view is used when greater interoperability is desired at\n        the expense of precision."
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "use_plenary_repository_view", 
               "doc": {
                  "headline": "A complete view of the ``Repository`` returns is desired.", 
                  "body": "        Methods will return what is requested or result in an error.\n        This view is used when greater precision is desired at the\n        expense of interoperability."
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "get_root_repository_ids", 
               "doc": {
                  "headline": "Gets the root repository ``Ids`` in this hierarchy.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.id.IdList) - the root repository ``Ids``", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the root repository ``Ids``\n        :rtype: ``osid.id.IdList``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.id.IdList", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_root_repositories", 
               "doc": {
                  "headline": "Gets the root repositories in the repository hierarchy.", 
                  "body": "        A node with no parents is an orphan. While all repository\n        ``Ids`` are known to the hierarchy, an orphan does not appear in\n        the hierarchy unless explicitly added as a root node or child of\n        another node."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.repository.RepositoryList) - the root repositories", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the root repositories\n        :rtype: ``osid.repository.RepositoryList``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.repository.RepositoryList", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "has_parent_repositories", 
               "doc": {
                  "headline": "Tests if the ``Repository`` has any parents.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    repository_id (osid.id.Id): a repository ``Id``\n", 
               "return_doc": "        return: (boolean) - ``true`` if the repository has parents,\n                ``false`` otherwise", 
               "error_doc": "        raise:  NotFound - ``repository_id`` is not found\n        raise:  NullArgument - ``repository_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param repository_id: a repository ``Id``\n        :type repository_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: ``true`` if the repository has parents, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``repository_id`` is not found\n        :raise: ``NullArgument`` -- ``repository_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "repository_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "boolean", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "is_parent_of_repository", 
               "doc": {
                  "headline": "Tests if an ``Id`` is a direct parent of a repository.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    id (osid.id.Id): an ``Id``\n        arg:    repository_id (osid.id.Id): the ``Id`` of a repository\n", 
               "return_doc": "        return: (boolean) - ``true`` if this ``id`` is a parent of\n                ``repository_id,``  ``false`` otherwise", 
               "error_doc": "        raise:  NotFound - ``repository_id`` is not found\n        raise:  NullArgument - ``id`` or ``repository_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param id: an ``Id``\n        :type id: ``osid.id.Id``\n        :param repository_id: the ``Id`` of a repository\n        :type repository_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: ``true`` if this ``id`` is a parent of ``repository_id,``  ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``repository_id`` is not found\n        :raise: ``NullArgument`` -- ``id`` or ``repository_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "        *implementation notes*: If ``id`` not found return ``false``.\n", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "id_", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "repository_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "osid.id.Id"
               ], 
               "return_type": "boolean", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_parent_repository_ids", 
               "doc": {
                  "headline": "Gets the parent ``Ids`` of the given repository.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    repository_id (osid.id.Id): a repository ``Id``\n", 
               "return_doc": "        return: (osid.id.IdList) - the parent ``Ids`` of the repository", 
               "error_doc": "        raise:  NotFound - ``repository_id`` is not found\n        raise:  NullArgument - ``repository_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param repository_id: a repository ``Id``\n        :type repository_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: the parent ``Ids`` of the repository\n        :rtype: ``osid.id.IdList``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``repository_id`` is not found\n        :raise: ``NullArgument`` -- ``repository_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "repository_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "osid.id.IdList", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_parent_repositories", 
               "doc": {
                  "headline": "Gets the parents of the given repository.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    repository_id (osid.id.Id): the ``Id`` to query\n", 
               "return_doc": "        return: (osid.repository.RepositoryList) - the parents of the\n                repository", 
               "error_doc": "        raise:  NotFound - ``repository_id`` not found\n        raise:  NullArgument - ``repository_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param repository_id: the ``Id`` to query\n        :type repository_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: the parents of the repository\n        :rtype: ``osid.repository.RepositoryList``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``repository_id`` not found\n        :raise: ``NullArgument`` -- ``repository_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "repository_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "osid.repository.RepositoryList", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "is_ancestor_of_repository", 
               "doc": {
                  "headline": "Tests if an ``Id`` is an ancestor of a repository.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    id (osid.id.Id): an ``Id``\n        arg:    repository_id (osid.id.Id): the Id of a repository\n", 
               "return_doc": "        return: (boolean) - ``true`` if this ``id`` is an ancestor of\n                ``repository_id,``  ``false`` otherwise", 
               "error_doc": "        raise:  NotFound - ``repository_id`` not found\n        raise:  NullArgument - ``repository_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param id: an ``Id``\n        :type id: ``osid.id.Id``\n        :param repository_id: the Id of a repository\n        :type repository_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: ``true`` if this ``id`` is an ancestor of ``repository_id,``  ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``repository_id`` not found\n        :raise: ``NullArgument`` -- ``repository_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "        *implementation notes*: If ``id`` not found return ``false``.\n", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "id_", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "repository_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "osid.id.Id"
               ], 
               "return_type": "boolean", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "has_child_repositories", 
               "doc": {
                  "headline": "Tests if a repository has any children.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    repository_id (osid.id.Id): a repository ``Id``\n", 
               "return_doc": "        return: (boolean) - ``true`` if the ``repository_id`` has\n                children, ``false`` otherwise", 
               "error_doc": "        raise:  NotFound - ``repository_id`` not found\n        raise:  NullArgument - ``repository_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param repository_id: a repository ``Id``\n        :type repository_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: ``true`` if the ``repository_id`` has children, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``repository_id`` not found\n        :raise: ``NullArgument`` -- ``repository_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "repository_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "boolean", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "is_child_of_repository", 
               "doc": {
                  "headline": "Tests if a node is a direct child of another.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    id (osid.id.Id): an ``Id``\n        arg:    repository_id (osid.id.Id): the ``Id`` of a repository\n", 
               "return_doc": "        return: (boolean) - ``true`` if the ``id`` is a child of\n                ``repository_id,``  ``false`` otherwise", 
               "error_doc": "        raise:  NotFound - ``repository_id`` not found\n        raise:  NullArgument - ``repository_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param id: an ``Id``\n        :type id: ``osid.id.Id``\n        :param repository_id: the ``Id`` of a repository\n        :type repository_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: ``true`` if the ``id`` is a child of ``repository_id,``  ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``repository_id`` not found\n        :raise: ``NullArgument`` -- ``repository_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "        *implementation notes*: If ``id`` not found return ``false``.\n", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "id_", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "repository_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "osid.id.Id"
               ], 
               "return_type": "boolean", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_child_repository_ids", 
               "doc": {
                  "headline": "Gets the ``Ids`` of the children of the given repository.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    repository_id (osid.id.Id): the ``Id`` to query\n", 
               "return_doc": "        return: (osid.id.IdList) - the children of the repository", 
               "error_doc": "        raise:  NotFound - ``repository_id`` not found\n        raise:  NullArgument - ``repository_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param repository_id: the ``Id`` to query\n        :type repository_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: the children of the repository\n        :rtype: ``osid.id.IdList``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``repository_id`` not found\n        :raise: ``NullArgument`` -- ``repository_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "repository_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "osid.id.IdList", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_child_repositories", 
               "doc": {
                  "headline": "Gets the children of the given repository.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    repository_id (osid.id.Id): the ``Id`` to query\n", 
               "return_doc": "        return: (osid.repository.RepositoryList) - the children of the\n                repository", 
               "error_doc": "        raise:  NotFound - ``repository_id`` not found\n        raise:  NullArgument - ``repository_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param repository_id: the ``Id`` to query\n        :type repository_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: the children of the repository\n        :rtype: ``osid.repository.RepositoryList``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``repository_id`` not found\n        :raise: ``NullArgument`` -- ``repository_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "repository_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "osid.repository.RepositoryList", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "is_descendant_of_repository", 
               "doc": {
                  "headline": "Tests if an ``Id`` is a descendant of a repository.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    id (osid.id.Id): an ``Id``\n        arg:    repository_id (osid.id.Id): the ``Id`` of a repository\n", 
               "return_doc": "        return: (boolean) - ``true`` if the ``id`` is a descendant of\n                the ``repository_id,`` ``false`` otherwise", 
               "error_doc": "        raise:  NotFound - ``repository_id`` not found\n        raise:  NullArgument - ``repository_id`` or ``id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param id: an ``Id``\n        :type id: ``osid.id.Id``\n        :param repository_id: the ``Id`` of a repository\n        :type repository_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: ``true`` if the ``id`` is a descendant of the ``repository_id,``  ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``repository_id`` not found\n        :raise: ``NullArgument`` -- ``repository_id`` or ``id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "        *implementation notes*: If ``id`` is not found return ``false``.\n", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "id_", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "repository_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "osid.id.Id"
               ], 
               "return_type": "boolean", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_repository_node_ids", 
               "doc": {
                  "headline": "Gets a portion of the hierarchy for the given repository.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    repository_id (osid.id.Id): the ``Id`` to query\n        arg:    ancestor_levels (cardinal): the maximum number of\n                ancestor levels to include. A value of 0 returns no\n                parents in the node.\n        arg:    descendant_levels (cardinal): the maximum number of\n                descendant levels to include. A value of 0 returns no\n                children in the node.\n        arg:    include_siblings (boolean): ``true`` to include the\n                siblings of the given node, ``false`` to omit the\n                siblings\n", 
               "return_doc": "        return: (osid.hierarchy.Node) - the specified repository node", 
               "error_doc": "        raise:  NotFound - ``repository_id`` not found\n        raise:  NullArgument - ``repository_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param repository_id: the ``Id`` to query\n        :type repository_id: ``osid.id.Id``\n        :param ancestor_levels: the maximum number of ancestor levels to include. A value of 0 returns no parents in the node.\n        :type ancestor_levels: ``cardinal``\n        :param descendant_levels: the maximum number of descendant levels to include. A value of 0 returns no children in the node.\n        :type descendant_levels: ``cardinal``\n        :param include_siblings: ``true`` to include the siblings of the given node, ``false`` to omit the siblings\n        :type include_siblings: ``boolean``\n", 
               "sphinx_return_doc": "        :return: the specified repository node\n        :rtype: ``osid.hierarchy.Node``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``repository_id`` not found\n        :raise: ``NullArgument`` -- ``repository_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "repository_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "cardinal", 
                     "var_name": "ancestor_levels", 
                     "array": false
                  }, 
                  {
                     "arg_type": "cardinal", 
                     "var_name": "descendant_levels", 
                     "array": false
                  }, 
                  {
                     "arg_type": "boolean", 
                     "var_name": "include_siblings", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "cardinal", 
                  "cardinal", 
                  "boolean"
               ], 
               "return_type": "osid.hierarchy.Node", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_repository_nodes", 
               "doc": {
                  "headline": "Gets a portion of the hierarchy for the given repository.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    repository_id (osid.id.Id): the ``Id`` to query\n        arg:    ancestor_levels (cardinal): the maximum number of\n                ancestor levels to include. A value of 0 returns no\n                parents in the node.\n        arg:    descendant_levels (cardinal): the maximum number of\n                descendant levels to include. A value of 0 returns no\n                children in the node.\n        arg:    include_siblings (boolean): ``true`` to include the\n                siblings of the given node, ``false`` to omit the\n                siblings\n", 
               "return_doc": "        return: (osid.repository.RepositoryNode) - the specified\n                repository node", 
               "error_doc": "        raise:  NotFound - ``repository_id`` not found\n        raise:  NullArgument - ``repository_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param repository_id: the ``Id`` to query\n        :type repository_id: ``osid.id.Id``\n        :param ancestor_levels: the maximum number of ancestor levels to include. A value of 0 returns no parents in the node.\n        :type ancestor_levels: ``cardinal``\n        :param descendant_levels: the maximum number of descendant levels to include. A value of 0 returns no children in the node.\n        :type descendant_levels: ``cardinal``\n        :param include_siblings: ``true`` to include the siblings of the given node, ``false`` to omit the siblings\n        :type include_siblings: ``boolean``\n", 
               "sphinx_return_doc": "        :return: the specified repository node\n        :rtype: ``osid.repository.RepositoryNode``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``repository_id`` not found\n        :raise: ``NullArgument`` -- ``repository_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "repository_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "cardinal", 
                     "var_name": "ancestor_levels", 
                     "array": false
                  }, 
                  {
                     "arg_type": "cardinal", 
                     "var_name": "descendant_levels", 
                     "array": false
                  }, 
                  {
                     "arg_type": "boolean", 
                     "var_name": "include_siblings", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "cardinal", 
                  "cardinal", 
                  "boolean"
               ], 
               "return_type": "osid.repository.RepositoryNode", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.repository.RepositoryHierarchyDesignSession", 
         "shortname": "RepositoryHierarchyDesignSession", 
         "category": "sessions", 
         "doc": {
            "headline": "This session defines methods for managing a hierarchy of ``Repository`` objects.", 
            "body": "    Each node in the hierarchy is a unique ``Repository``."
         }, 
         "inherit_fullnames": [
            "osid.OsidSession"
         ], 
         "inherit_shortnames": [
            "OsidSession"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidSession"
            }
         ], 
         "method_names": [
            "get_repository_hierarchy_id", 
            "get_repository_hierarchy", 
            "can_modify_repository_hierarchy", 
            "add_root_repository", 
            "remove_root_repository", 
            "add_child_repository", 
            "remove_child_repository", 
            "remove_child_repositories"
         ], 
         "methods": [
            {
               "name": "get_repository_hierarchy_id", 
               "doc": {
                  "headline": "Gets the hierarchy ``Id`` associated with this session.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.id.Id) - the hierarchy ``Id`` associated with this\n                session", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the hierarchy ``Id`` associated with this session\n        :rtype: ``osid.id.Id``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.id.Id", 
               "errors": {}
            }, 
            {
               "name": "get_repository_hierarchy", 
               "doc": {
                  "headline": "Gets the hierarchy associated with this session.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.hierarchy.Hierarchy) - the hierarchy associated\n                with this session", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the hierarchy associated with this session\n        :rtype: ``osid.hierarchy.Hierarchy``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.hierarchy.Hierarchy", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "can_modify_repository_hierarchy", 
               "doc": {
                  "headline": "Tests if this user can change the hierarchy.", 
                  "body": "        A return of true does not guarantee successful authorization. A\n        return of false indicates that it is known performing any update\n        will result in a ``PermissionDenied``. This is intended as a\n        hint to an application that may opt not to offer these\n        operations to an unauthorized user."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``false`` if changing this hierarchy is not\n                authorized, ``true`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``false`` if changing this hierarchy is not authorized, ``true`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "add_root_repository", 
               "doc": {
                  "headline": "Adds a root repository.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    repository_id (osid.id.Id): the ``Id`` of a repository\n", 
               "return_doc": "", 
               "error_doc": "        raise:  AlreadyExists - ``repository_id`` is already in\n                hierarchy\n        raise:  NotFound - ``repository_id`` not found\n        raise:  NullArgument - ``repository_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param repository_id: the ``Id`` of a repository\n        :type repository_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``AlreadyExists`` -- ``repository_id`` is already in hierarchy\n        :raise: ``NotFound`` -- ``repository_id`` not found\n        :raise: ``NullArgument`` -- ``repository_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "repository_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {
                  "ALREADY_EXISTS": "User", 
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "remove_root_repository", 
               "doc": {
                  "headline": "Removes a root repository.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    repository_id (osid.id.Id): the ``Id`` of a repository\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NotFound - ``repository_id`` not a root\n        raise:  NullArgument - ``repository_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param repository_id: the ``Id`` of a repository\n        :type repository_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``repository_id`` not a root\n        :raise: ``NullArgument`` -- ``repository_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "repository_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "add_child_repository", 
               "doc": {
                  "headline": "Adds a child to a repository.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    repository_id (osid.id.Id): the ``Id`` of a repository\n        arg:    child_id (osid.id.Id): the ``Id`` of the new child\n", 
               "return_doc": "", 
               "error_doc": "        raise:  AlreadyExists - ``repository_id`` is already a parent of\n                ``child_id``\n        raise:  NotFound - ``repository_id`` or ``child_id`` not found\n        raise:  NullArgument - ``repository_id`` or ``child_id`` is\n                ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param repository_id: the ``Id`` of a repository\n        :type repository_id: ``osid.id.Id``\n        :param child_id: the ``Id`` of the new child\n        :type child_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``AlreadyExists`` -- ``repository_id`` is already a parent of ``child_id``\n        :raise: ``NotFound`` -- ``repository_id`` or ``child_id`` not found\n        :raise: ``NullArgument`` -- ``repository_id`` or ``child_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "repository_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "child_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {
                  "ALREADY_EXISTS": "User", 
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "remove_child_repository", 
               "doc": {
                  "headline": "Removes a child from a repository.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    repository_id (osid.id.Id): the ``Id`` of a repository\n        arg:    child_id (osid.id.Id): the ``Id`` of the new child\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NotFound - ``repository_id`` not a parent of\n                ``child_id``\n        raise:  NullArgument - ``repository_id`` or ``child_id`` is\n                ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param repository_id: the ``Id`` of a repository\n        :type repository_id: ``osid.id.Id``\n        :param child_id: the ``Id`` of the new child\n        :type child_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``repository_id`` not a parent of ``child_id``\n        :raise: ``NullArgument`` -- ``repository_id`` or ``child_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "repository_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "child_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "remove_child_repositories", 
               "doc": {
                  "headline": "Removes all children from a repository.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    repository_id (osid.id.Id): the ``Id`` of a repository\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NotFound - ``repository_id`` not in hierarchy\n        raise:  NullArgument - ``repository_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param repository_id: the ``Id`` of a repository\n        :type repository_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``repository_id`` not in hierarchy\n        :raise: ``NullArgument`` -- ``repository_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "repository_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.repository.Asset", 
         "shortname": "Asset", 
         "category": "objects", 
         "doc": {
            "headline": "An ``Asset`` represents some digital content.", 
            "body": "    Example assets might be a text document, an image, or a movie. The\n    content data, and metadata related directly to the content format\n    and quality, is accessed through ``AssetContent. Assets`` , like all\n    ``OsidObjects,`` include a type a record to qualify the ``Asset``\n    and include additional data. The division between the ``Asset``\n    ``Type`` and ``AssetContent`` is to separate data describing the\n    asset from data describing the format of the contents, allowing a\n    consumer to select among multiple formats, sizes or levels of\n    fidelity.\n\n    An example is a photograph of the Bay Bridge. The content may\n    deliver a JPEG in multiple resolutions where the ``AssetContent``\n    may also desribe size or compression factor for each one. The\n    content may also include an uncompressed TIFF version. The ``Asset``\n    ``Type`` may be \"photograph\" indicating that the photo itself is the\n    asset managed in this repository.\n    \n    Since an Asset may have multiple ``AssetContent`` structures, the\n    decision of how many things to stuff inside a single asset comes\n    down to if the content is actually a different format, or size, or\n    quality, falling under the same creator, copyright, publisher and\n    distribution rights as the original. This may, in some cases,\n    provide a means to implement some accessibility, it doesn't handle\n    the case where, to meet an accessibility requirement, one asset\n    needs to be substituted for another. The Repository OSID manages\n    this aspect outside the scope of the core ``Asset`` definition.\n    \n    ``Assets`` map to ``AssetSubjects``.  ``AssetSubjects`` are\n    ``OsidObjects`` that capture a subject matter. In the above example,\n    an ``AssetSubject`` may be defined for the Bay Bridge and include\n    data describing the bridge. The single subject can map to multiple\n    assets depicting the bridge providing a single entry for a search\n    and a single place to describe a bridge. Bridges, as physical items,\n    may also be described using the Resource OSID in which case the use\n    of the ``AssetSubject`` acts as a cover for the underlying\n    ``Resource`` to assist repository-only consumers.\n    \n    The ``Asset`` definition includes some basic copyright and related\n    licensing information to assist in finding free-to-use content, or\n    to convey the distribution restrictions that may be placed on the\n    asset. Generally, if no data is available it is to be assumed that\n    all rights are reserved.\n    \n    A publisher is applicable if the content of this ``Asset`` has been\n    published. Not all ``Assets`` in this ``Repository`` may have a\n    published status and such a status may effect the applicability of\n    copyright law. To trace the source of an ``Asset,`` both a provider\n    and source are defined. The provider indicates where this repository\n    acquired the asset and the source indicates the original provider or\n    copyright owner. In the case of a published asset, the source is the\n    publisher.\n    \n    ``Assets`` also define methods to facilitate searches over time and\n    space as it relates to the subject matter. This may at times be\n    redundant with the ``AssetSubject``. In the case of the Bay Bridge\n    photograph, the temporal coverage may include 1936, when it opened,\n    and/or indicate when the photo was taken to capture a current event\n    of the bridge. The decision largeley depends on what desired effect\n    is from a search. The spatial coverage may describe the gps\n    coordinates of the bridge or describe the spatial area encompassed\n    in the view. In either case, a \"photograph\" type may unambiguously\n    defined methods to describe the exact time the photograph was taken\n    and the location of the photographer.\n    \n    The core Asset defines methods to perform general searches and\n    construct bibliographic entries without knowledge of a particular\n    ``Asset`` or ``AssetContent`` record ``Type``."
         }, 
         "inherit_fullnames": [
            "osid.OsidObject", 
            "osid.Aggregateable", 
            "osid.Sourceable"
         ], 
         "inherit_shortnames": [
            "OsidObject", 
            "Aggregateable", 
            "Sourceable"
         ], 
         "inherit_pkg_names": [
            "osid", 
            "osid", 
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidObject"
            }, 
            {
               "pkg_name": "osid", 
               "name": "Aggregateable"
            }, 
            {
               "pkg_name": "osid", 
               "name": "Sourceable"
            }
         ], 
         "method_names": [
            "get_title", 
            "is_copyright_status_known", 
            "is_public_domain", 
            "get_copyright", 
            "get_copyright_registration", 
            "can_distribute_verbatim", 
            "can_distribute_alterations", 
            "can_distribute_compositions", 
            "get_source_id", 
            "get_source", 
            "get_provider_link_ids", 
            "get_provider_links", 
            "get_created_date", 
            "is_published", 
            "get_published_date", 
            "get_principal_credit_string", 
            "get_asset_content_ids", 
            "get_asset_contents", 
            "is_composition", 
            "get_composition_id", 
            "get_composition", 
            "get_asset_record"
         ], 
         "methods": [
            {
               "name": "get_title", 
               "doc": {
                  "headline": "Gets the proper title of this asset.", 
                  "body": "        This may be the same as the display name or the display name may\n        be used for a less formal label."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.locale.DisplayText) - the title of this asset", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the title of this asset\n        :rtype: ``osid.locale.DisplayText``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.locale.DisplayText", 
               "errors": {}
            }, 
            {
               "name": "is_copyright_status_known", 
               "doc": {
                  "headline": "Tests if the copyright status is known.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if the copyright status of this\n                asset is known, ``false`` otherwise. If ``false,\n                is_public_domain(),`` ``can_distribute_verbatim(),\n                can_distribute_alterations() and\n                can_distribute_compositions()`` may also be ``false``.", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if the copyright status of this asset is known, ``false`` otherwise. If ``false, is_public_domain(),``  ``can_distribute_verbatim(), can_distribute_alterations() and\ncan_distribute_compositions()`` may also be ``false``.\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "is_public_domain", 
               "doc": {
                  "headline": "Tests if this asset is in the public domain.", 
                  "body": "        An asset is in the public domain if copyright is not applicable,\n        the copyright has expired, or the copyright owner has expressly\n        relinquished the copyright."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if this asset is in the public\n                domain, ``false`` otherwise. If ``true,``\n                ``can_distribute_verbatim(),\n                can_distribute_alterations() and\n                can_distribute_compositions()`` must also be ``true``.", 
               "error_doc": "        raise:  IllegalState - ``is_copyright_status_known()`` is\n                ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if this asset is in the public domain, ``false`` otherwise. If ``true,``  ``can_distribute_verbatim(), can_distribute_alterations() and can_distribute_compositions()`` must also be ``true``.\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- ``is_copyright_status_known()`` is ``false``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract"
               }
            }, 
            {
               "name": "get_copyright", 
               "doc": {
                  "headline": "Gets the copyright statement and of this asset which identifies the current copyright holder.", 
                  "body": "        For an asset in the public domain, this method may return the\n        original copyright statement although it may be no longer valid."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.locale.DisplayText) - the copyright statement or\n                an empty string if none available. An empty string does\n                not imply the asset is not protected by copyright.", 
               "error_doc": "        raise:  IllegalState - ``is_copyright_status_known()`` is\n                ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the copyright statement or an empty string if none available. An empty string does not imply the asset is not protected by copyright.\n        :rtype: ``osid.locale.DisplayText``", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- ``is_copyright_status_known()`` is ``false``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.locale.DisplayText", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract"
               }
            }, 
            {
               "name": "get_copyright_registration", 
               "doc": {
                  "headline": "Gets the copyright registration information for this asset.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (string) - the copyright registration. An empty string\n                means the registration status isn't known.", 
               "error_doc": "        raise:  IllegalState - ``is_copyright_status_known()`` is\n                ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the copyright registration. An empty string means the registration status isn't known.\n        :rtype: ``string``", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- ``is_copyright_status_known()`` is ``false``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "string", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract"
               }
            }, 
            {
               "name": "can_distribute_verbatim", 
               "doc": {
                  "headline": "Tests if there are any license restrictions on this asset that restrict the distribution, re-publication or public display of this asset, commercial or otherwise, without modification, alteration, or inclusion in other works.", 
                  "body": "        This method is intended to offer consumers a means of filtering\n        out search results that restrict distribution for any purpose.\n        The scope of this method does not include licensing that\n        describes warranty disclaimers or attribution requirements. This\n        method is intended for informational purposes only and does not\n        replace or override the terms specified in a license agreement\n        which may specify exceptions or additional restrictions."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if the asset can be distributed\n                verbatim, ``false`` otherwise.", 
               "error_doc": "        raise:  IllegalState - ``is_copyright_status_known()`` is\n                ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if the asset can be distributed verbatim, ``false`` otherwise.\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- ``is_copyright_status_known()`` is ``false``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract"
               }
            }, 
            {
               "name": "can_distribute_alterations", 
               "doc": {
                  "headline": "Tests if there are any license restrictions on this asset that restrict the distribution, re-publication or public display of any alterations or modifications to this asset, commercial or otherwise, for any purpose.", 
                  "body": "        This method is intended to offer consumers a means of filtering\n        out search results that restrict the distribution or public\n        display of any modification or alteration of the content or its\n        metadata of any kind, including editing, translation,\n        resampling, resizing and cropping. The scope of this method does\n        not include licensing that describes warranty disclaimers or\n        attribution requirements. This method is intended for\n        informational purposes only and does not replace or override the\n        terms specified in a license agreement which may specify\n        exceptions or additional restrictions."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if the asset can be modified,\n                ``false`` otherwise. If ``true,``\n                ``can_distribute_verbatim()`` must also be ``true``.", 
               "error_doc": "        raise:  IllegalState - ``is_copyright_status_known()`` is\n                ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if the asset can be modified, ``false`` otherwise. If ``true,``  ``can_distribute_verbatim()`` must also be ``true``.\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- ``is_copyright_status_known()`` is ``false``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract"
               }
            }, 
            {
               "name": "can_distribute_compositions", 
               "doc": {
                  "headline": "Tests if there are any license restrictions on this asset that restrict the distribution, re-publication or public display of this asset as an inclusion within other content or composition, commercial or otherwise, for any purpose, including restrictions upon the distribution or license of the resulting composition.", 
                  "body": "        This method is intended to offer consumers a means of filtering\n        out search results that restrict the use of this asset within\n        compositions. The scope of this method does not include\n        licensing that describes warranty disclaimers or attribution\n        requirements. This method is intended for informational purposes\n        only and does not replace or override the terms specified in a\n        license agreement which may specify exceptions or additional\n        restrictions."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if the asset can be part of a\n                larger composition ``false`` otherwise. If ``true,``\n                ``can_distribute_verbatim()`` must also be ``true``.", 
               "error_doc": "        raise:  IllegalState - ``is_copyright_status_known()`` is\n                ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if the asset can be part of a larger composition ``false`` otherwise. If ``true,``  ``can_distribute_verbatim()`` must also be ``true``.\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- ``is_copyright_status_known()`` is ``false``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract"
               }
            }, 
            {
               "name": "get_source_id", 
               "doc": {
                  "headline": "Gets the ``Resource Id`` of the source of this asset.", 
                  "body": "        The source is the original owner of the copyright of this asset\n        and may differ from the creator of this asset. The source for a\n        published book written by Margaret Mitchell would be Macmillan.\n        The source for an unpublished painting by Arthur Goodwin would\n        be Arthur Goodwin.\n\n        An ``Asset`` is ``Sourceable`` and also contains a provider\n        identity. The provider is the entity that makes this digital\n        asset available in this repository but may or may not be the\n        publisher of the contents depicted in the asset. For example, a\n        map published by Ticknor and Fields in 1848 may have a provider\n        of Library of Congress and a source of Ticknor and Fields. If\n        copied from a repository at Middlebury College, the provider\n        would be Middlebury College and a source of Ticknor and Fields."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.id.Id) - the source ``Id``", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the source ``Id``\n        :rtype: ``osid.id.Id``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.id.Id", 
               "errors": {}
            }, 
            {
               "name": "get_source", 
               "doc": {
                  "headline": "Gets the ``Resource`` of the source of this asset.", 
                  "body": "        The source is the original owner of the copyright of this asset\n        and may differ from the creator of this asset. The source for a\n        published book written by Margaret Mitchell would be Macmillan.\n        The source for an unpublished painting by Arthur Goodwin would\n        be Arthur Goodwin."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.resource.Resource) - the source", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the source\n        :rtype: ``osid.resource.Resource``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.resource.Resource", 
               "errors": {}
            }, 
            {
               "name": "get_provider_link_ids", 
               "doc": {
                  "headline": "Gets the resource ``Ids`` representing the source of this asset in order from the most recent provider to the originating source.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.id.IdList) - the provider ``Ids``", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the provider ``Ids``\n        :rtype: ``osid.id.IdList``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.id.IdList", 
               "errors": {}
            }, 
            {
               "name": "get_provider_links", 
               "doc": {
                  "headline": "Gets the ``Resources`` representing the source of this asset in order from the most recent provider to the originating source.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.resource.ResourceList) - the provider chain", 
               "error_doc": "        raise:  OperationFailed - unable to complete request", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the provider chain\n        :rtype: ``osid.resource.ResourceList``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.resource.ResourceList", 
               "errors": {
                  "OPERATION_FAILED": "Operational"
               }
            }, 
            {
               "name": "get_created_date", 
               "doc": {
                  "headline": "Gets the created date of this asset, which is generally not related to when the object representing the asset was created.", 
                  "body": "        The date returned may indicate that not much is known."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.DateTime) - the created date", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the created date\n        :rtype: ``osid.calendaring.DateTime``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.DateTime", 
               "errors": {}
            }, 
            {
               "name": "is_published", 
               "doc": {
                  "headline": "Tests if this asset has been published.", 
                  "body": "        Not all assets viewable in this repository may have been\n        published. The source of a published asset indicates the\n        publisher."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - true if this asset has been published,\n                ``false`` if unpublished or its published status is not\n                known", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: true if this asset has been published, ``false`` if unpublished or its published status is not known\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "get_published_date", 
               "doc": {
                  "headline": "Gets the published date of this asset.", 
                  "body": "        Unpublished assets have no published date. A published asset has\n        a date available, however the date returned may indicate that\n        not much is known."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.DateTime) - the published date", 
               "error_doc": "        raise:  IllegalState - ``is_published()`` is ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the published date\n        :rtype: ``osid.calendaring.DateTime``", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- ``is_published()`` is ``false``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.DateTime", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract"
               }
            }, 
            {
               "name": "get_principal_credit_string", 
               "doc": {
                  "headline": "Gets the credits of the principal people involved in the production of this asset as a display string.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.locale.DisplayText) - the principal credits", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the principal credits\n        :rtype: ``osid.locale.DisplayText``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.locale.DisplayText", 
               "errors": {}
            }, 
            {
               "name": "get_asset_content_ids", 
               "doc": {
                  "headline": "Gets the content ``Ids`` of this asset.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.id.IdList) - the asset content ``Ids``", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the asset content ``Ids``\n        :rtype: ``osid.id.IdList``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.id.IdList", 
               "errors": {}
            }, 
            {
               "name": "get_asset_contents", 
               "doc": {
                  "headline": "Gets the content of this asset.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.repository.AssetContentList) - the asset contents", 
               "error_doc": "        raise:  OperationFailed - unable to complete request", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the asset contents\n        :rtype: ``osid.repository.AssetContentList``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.repository.AssetContentList", 
               "errors": {
                  "OPERATION_FAILED": "Operational"
               }
            }, 
            {
               "name": "is_composition", 
               "doc": {
                  "headline": "Tetss if this asset is a representation of a composition of assets.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - true if this asset is a composition,\n                ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: true if this asset is a composition, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "get_composition_id", 
               "doc": {
                  "headline": "Gets the ``Composition``  ``Id`` corresponding to this asset.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.id.Id) - the composiiton ``Id``", 
               "error_doc": "        raise:  IllegalState - ``is_composition()`` is ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the composiiton ``Id``\n        :rtype: ``osid.id.Id``", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- ``is_composition()`` is ``false``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.id.Id", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract"
               }
            }, 
            {
               "name": "get_composition", 
               "doc": {
                  "headline": "Gets the Composition corresponding to this asset.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.repository.Composition) - the composiiton", 
               "error_doc": "        raise:  IllegalState - ``is_composition()`` is ``false``\n        raise:  OperationFailed - unable to complete request", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the composiiton\n        :rtype: ``osid.repository.Composition``", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- ``is_composition()`` is ``false``\n        :raise: ``OperationFailed`` -- unable to complete request", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.repository.Composition", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational"
               }
            }, 
            {
               "name": "get_asset_record", 
               "doc": {
                  "headline": "Gets the asset record corresponding to the given ``Asset`` record ``Type``.", 
                  "body": "        This method is used to retrieve an object implementing the\n        requested record. The ``asset_record_type`` may be the ``Type``\n        returned in ``get_record_types()`` or any of its parents in a\n        ``Type`` hierarchy where ``has_record_type(asset_record_type)``\n        is ``true`` ."
               }, 
               "arg_doc": "        arg:    asset_record_type (osid.type.Type): an asset record type\n", 
               "return_doc": "        return: (osid.repository.records.AssetRecord) - the asset record", 
               "error_doc": "        raise:  NullArgument - ``asset_record_type`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unsupported - ``has_record_type(asset_record_type)`` is\n                ``false``", 
               "sphinx_param_doc": "        :param asset_record_type: an asset record type\n        :type asset_record_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "        :return: the asset record\n        :rtype: ``osid.repository.records.AssetRecord``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``asset_record_type`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unsupported`` -- ``has_record_type(asset_record_type)`` is ``false``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "asset_record_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "osid.repository.records.AssetRecord", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.repository.records.AssetRecord", 
         "shortname": "AssetRecord", 
         "category": "records", 
         "doc": {
            "headline": "A record for an ``Asset``.", 
            "body": "    The methods specified by the record type are available through the\n    underlying object."
         }, 
         "inherit_fullnames": [
            "osid.OsidRecord"
         ], 
         "inherit_shortnames": [
            "OsidRecord"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidRecord"
            }
         ], 
         "method_names": [], 
         "methods": []
      }, 
      {
         "fullname": "osid.repository.AssetQuery", 
         "shortname": "AssetQuery", 
         "category": "queries", 
         "doc": {
            "headline": "This is the query for searching assets.", 
            "body": "    Each method specifies an ``AND`` term while multiple invocations of\n    the same method produce a nested ``OR``. The query record is\n    identified by the ``Asset Type``."
         }, 
         "inherit_fullnames": [
            "osid.OsidObjectQuery", 
            "osid.OsidAggregateableQuery", 
            "osid.OsidSourceableQuery"
         ], 
         "inherit_shortnames": [
            "OsidObjectQuery", 
            "OsidAggregateableQuery", 
            "OsidSourceableQuery"
         ], 
         "inherit_pkg_names": [
            "osid", 
            "osid", 
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidObjectQuery"
            }, 
            {
               "pkg_name": "osid", 
               "name": "OsidAggregateableQuery"
            }, 
            {
               "pkg_name": "osid", 
               "name": "OsidSourceableQuery"
            }
         ], 
         "method_names": [
            "match_title", 
            "match_any_title", 
            "clear_title_terms", 
            "match_public_domain", 
            "match_any_public_domain", 
            "clear_public_domain_terms", 
            "match_copyright", 
            "match_any_copyright", 
            "clear_copyright_terms", 
            "match_copyright_registration", 
            "match_any_copyright_registration", 
            "clear_copyright_registration_terms", 
            "match_distribute_verbatim", 
            "clear_distribute_verbatim_terms", 
            "match_distribute_alterations", 
            "clear_distribute_alterations_terms", 
            "match_distribute_compositions", 
            "clear_distribute_compositions_terms", 
            "match_source_id", 
            "clear_source_id_terms", 
            "supports_source_query", 
            "get_source_query", 
            "match_any_source", 
            "clear_source_terms", 
            "match_created_date", 
            "match_any_created_date", 
            "clear_created_date_terms", 
            "match_published", 
            "clear_published_terms", 
            "match_published_date", 
            "match_any_published_date", 
            "clear_published_date_terms", 
            "match_principal_credit_string", 
            "match_any_principal_credit_string", 
            "clear_principal_credit_string_terms", 
            "match_temporal_coverage", 
            "match_any_temporal_coverage", 
            "clear_temporal_coverage_terms", 
            "match_location_id", 
            "clear_location_id_terms", 
            "supports_location_query", 
            "get_location_query", 
            "match_any_location", 
            "clear_location_terms", 
            "match_spatial_coverage", 
            "clear_spatial_coverage_terms", 
            "match_spatial_coverage_overlap", 
            "match_any_spatial_coverage", 
            "clear_spatial_coverage_overlap_terms", 
            "match_asset_content_id", 
            "clear_asset_content_id_terms", 
            "supports_asset_content_query", 
            "get_asset_content_query", 
            "match_any_asset_content", 
            "clear_asset_content_terms", 
            "match_composition_id", 
            "clear_composition_id_terms", 
            "supports_composition_query", 
            "get_composition_query", 
            "match_any_composition", 
            "clear_composition_terms", 
            "match_repository_id", 
            "clear_repository_id_terms", 
            "supports_repository_query", 
            "get_repository_query", 
            "clear_repository_terms", 
            "get_asset_query_record"
         ], 
         "methods": [
            {
               "name": "match_title", 
               "doc": {
                  "headline": "Adds a title for this query.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    title (string): title string to match\n        arg:    string_match_type (osid.type.Type): the string match\n                type\n        arg:    match (boolean): ``true`` for a positive match,\n                ``false`` for a negative match\n", 
               "return_doc": "", 
               "error_doc": "        raise:  InvalidArgument - ``title`` not of ``string_match_type``\n        raise:  NullArgument - ``title`` or ``string_match_type`` is\n                ``null``\n        raise:  Unsupported -\n                ``supports_string_match_type(string_match_type)`` is\n                ``false``", 
               "sphinx_param_doc": "        :param title: title string to match\n        :type title: ``string``\n        :param string_match_type: the string match type\n        :type string_match_type: ``osid.type.Type``\n        :param match: ``true`` for a positive match, ``false`` for a negative match\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``InvalidArgument`` -- ``title`` not of ``string_match_type``\n        :raise: ``NullArgument`` -- ``title`` or ``string_match_type`` is ``null``\n        :raise: ``Unsupported`` -- ``supports_string_match_type(string_match_type)`` is ``false``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "string", 
                     "var_name": "title", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "string_match_type", 
                     "array": false
                  }, 
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "string", 
                  "osid.type.Type", 
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {
                  "INVALID_ARGUMENT": "ConsumerContract", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }, 
            {
               "name": "match_any_title", 
               "doc": {
                  "headline": "Matches a title that has any value.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    match (boolean): ``true`` to match assets with any\n                title, ``false`` to match assets with no title\n", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "        :param match: ``true`` to match assets with any title, ``false`` to match assets with no title\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "clear_title_terms", 
               "doc": {
                  "headline": "Clears the title terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "match_public_domain", 
               "doc": {
                  "headline": "Matches assets marked as public domain.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    public_domain (boolean): public domain flag\n", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "        :param public_domain: public domain flag\n        :type public_domain: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "boolean", 
                     "var_name": "public_domain", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "match_any_public_domain", 
               "doc": {
                  "headline": "Matches assets with any public domain value.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    match (boolean): ``true`` to match assets with any\n                public domain value, ``false`` to match assets with no\n                public domain value\n", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "        :param match: ``true`` to match assets with any public domain value, ``false`` to match assets with no public domain value\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "clear_public_domain_terms", 
               "doc": {
                  "headline": "Clears the public domain terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "match_copyright", 
               "doc": {
                  "headline": "Adds a copyright for this query.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    copyright (string): copyright string to match\n        arg:    string_match_type (osid.type.Type): the string match\n                type\n        arg:    match (boolean): ``true`` for a positive match,\n                ``false`` for a negative match\n", 
               "return_doc": "", 
               "error_doc": "        raise:  InvalidArgument - ``copyright`` not of\n                ``string_match_type``\n        raise:  NullArgument - ``copyright`` or ``string_match_type`` is\n                ``null``\n        raise:  Unsupported -\n                ``supports_string_match_type(string_match_type)`` is\n                ``false``", 
               "sphinx_param_doc": "        :param copyright: copyright string to match\n        :type copyright: ``string``\n        :param string_match_type: the string match type\n        :type string_match_type: ``osid.type.Type``\n        :param match: ``true`` for a positive match, ``false`` for a negative match\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``InvalidArgument`` -- ``copyright`` not of ``string_match_type``\n        :raise: ``NullArgument`` -- ``copyright`` or ``string_match_type`` is ``null``\n        :raise: ``Unsupported`` -- ``supports_string_match_type(string_match_type)`` is ``false``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "string", 
                     "var_name": "copyright", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "string_match_type", 
                     "array": false
                  }, 
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "string", 
                  "osid.type.Type", 
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {
                  "INVALID_ARGUMENT": "ConsumerContract", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }, 
            {
               "name": "match_any_copyright", 
               "doc": {
                  "headline": "Matches assets with any copyright statement.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    match (boolean): ``true`` to match assets with any\n                copyright value, ``false`` to match assets with no\n                copyright value\n", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "        :param match: ``true`` to match assets with any copyright value, ``false`` to match assets with no copyright value\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "clear_copyright_terms", 
               "doc": {
                  "headline": "Clears the copyright terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "match_copyright_registration", 
               "doc": {
                  "headline": "Adds a copyright registration for this query.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    registration (string): copyright registration string to\n                match\n        arg:    string_match_type (osid.type.Type): the string match\n                type\n        arg:    match (boolean): ``true`` for a positive match,\n                ``false`` for a negative match\n", 
               "return_doc": "", 
               "error_doc": "        raise:  InvalidArgument - ``registration`` not of\n                ``string_match_type``\n        raise:  NullArgument - ``registration`` or ``string_match_type``\n                is ``null``\n        raise:  Unsupported -\n                ``supports_string_match_type(string_match_type)`` is\n                ``false``", 
               "sphinx_param_doc": "        :param registration: copyright registration string to match\n        :type registration: ``string``\n        :param string_match_type: the string match type\n        :type string_match_type: ``osid.type.Type``\n        :param match: ``true`` for a positive match, ``false`` for a negative match\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``InvalidArgument`` -- ``registration`` not of ``string_match_type``\n        :raise: ``NullArgument`` -- ``registration`` or ``string_match_type`` is ``null``\n        :raise: ``Unsupported`` -- ``supports_string_match_type(string_match_type)`` is ``false``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "string", 
                     "var_name": "registration", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "string_match_type", 
                     "array": false
                  }, 
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "string", 
                  "osid.type.Type", 
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {
                  "INVALID_ARGUMENT": "ConsumerContract", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }, 
            {
               "name": "match_any_copyright_registration", 
               "doc": {
                  "headline": "Matches assets with any copyright registration.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    match (boolean): ``true`` to match assets with any\n                copyright registration value, ``false`` to match assets\n                with no copyright registration value\n", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "        :param match: ``true`` to match assets with any copyright registration value, ``false`` to match assets with no copyright registration value\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "clear_copyright_registration_terms", 
               "doc": {
                  "headline": "Clears the copyright registration terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "match_distribute_verbatim", 
               "doc": {
                  "headline": "Matches assets marked as distributable.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    distributable (boolean): distribute verbatim rights flag\n", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "        :param distributable: distribute verbatim rights flag\n        :type distributable: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "boolean", 
                     "var_name": "distributable", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "clear_distribute_verbatim_terms", 
               "doc": {
                  "headline": "Clears the distribute verbatim terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "match_distribute_alterations", 
               "doc": {
                  "headline": "Matches assets that whose alterations can be distributed.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    alterable (boolean): distribute alterations rights flag\n", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "        :param alterable: distribute alterations rights flag\n        :type alterable: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "boolean", 
                     "var_name": "alterable", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "clear_distribute_alterations_terms", 
               "doc": {
                  "headline": "Clears the distribute alterations terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "match_distribute_compositions", 
               "doc": {
                  "headline": "Matches assets that can be distributed as part of other compositions.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    composable (boolean): distribute compositions rights\n                flag\n", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "        :param composable: distribute compositions rights flag\n        :type composable: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "boolean", 
                     "var_name": "composable", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "clear_distribute_compositions_terms", 
               "doc": {
                  "headline": "Clears the distribute compositions terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "match_source_id", 
               "doc": {
                  "headline": "Sets the source ``Id`` for this query.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    source_id (osid.id.Id): the source ``Id``\n        arg:    match (boolean): ``true`` for a positive match,\n                ``false`` for a negative match\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``source_id`` is ``null``", 
               "sphinx_param_doc": "        :param source_id: the source ``Id``\n        :type source_id: ``osid.id.Id``\n        :param match: ``true`` for a positive match, ``false`` for a negative match\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``source_id`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "source_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "clear_source_id_terms", 
               "doc": {
                  "headline": "Clears the source ``Id`` terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "supports_source_query", 
               "doc": {
                  "headline": "Tests if a ``ResourceQuery`` is available for the source.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if a resource query is available,\n                ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if a resource query is available, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "get_source_query", 
               "doc": {
                  "headline": "Gets the query for the source.", 
                  "body": "        Multiple queries can be retrieved for a nested ``OR`` term."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.resource.ResourceQuery) - the source query", 
               "error_doc": "        raise:  Unimplemented - ``supports_source_query()`` is ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the source query\n        :rtype: ``osid.resource.ResourceQuery``", 
               "sphinx_error_doc": "        :raise: ``Unimplemented`` -- ``supports_source_query()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_source_query()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.resource.ResourceQuery", 
               "errors": {
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "match_any_source", 
               "doc": {
                  "headline": "Matches assets with any source.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    match (boolean): ``true`` to match assets with any\n                source, ``false`` to match assets with no sources\n", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "        :param match: ``true`` to match assets with any source, ``false`` to match assets with no sources\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "clear_source_terms", 
               "doc": {
                  "headline": "Clears the source terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "match_created_date", 
               "doc": {
                  "headline": "Match assets that are created between the specified time period.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    start (osid.calendaring.DateTime): start time of the\n                query\n        arg:    end (osid.calendaring.DateTime): end time of the query\n        arg:    match (boolean): ``true`` for a positive match,\n                ``false`` for a negative match\n", 
               "return_doc": "", 
               "error_doc": "        raise:  InvalidArgument - ``end`` is les than ``start``\n        raise:  NullArgument - ``start`` or ``end`` is ``null``", 
               "sphinx_param_doc": "        :param start: start time of the query\n        :type start: ``osid.calendaring.DateTime``\n        :param end: end time of the query\n        :type end: ``osid.calendaring.DateTime``\n        :param match: ``true`` for a positive match, ``false`` for a negative match\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``InvalidArgument`` -- ``end`` is les than ``start``\n        :raise: ``NullArgument`` -- ``start`` or ``end`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.calendaring.DateTime", 
                     "var_name": "start", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.calendaring.DateTime", 
                     "var_name": "end", 
                     "array": false
                  }, 
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.calendaring.DateTime", 
                  "osid.calendaring.DateTime", 
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {
                  "INVALID_ARGUMENT": "ConsumerContract", 
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "match_any_created_date", 
               "doc": {
                  "headline": "Matches assets with any creation time.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    match (boolean): ``true`` to match assets with any\n                created time, ``false`` to match assets with no cerated\n                time\n", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "        :param match: ``true`` to match assets with any created time, ``false`` to match assets with no cerated time\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "clear_created_date_terms", 
               "doc": {
                  "headline": "Clears the created time terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "match_published", 
               "doc": {
                  "headline": "Marks assets that are marked as published.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    published (boolean): published flag\n", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "        :param published: published flag\n        :type published: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "boolean", 
                     "var_name": "published", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "clear_published_terms", 
               "doc": {
                  "headline": "Clears the published terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "match_published_date", 
               "doc": {
                  "headline": "Match assets that are published between the specified time period.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    start (osid.calendaring.DateTime): start time of the\n                query\n        arg:    end (osid.calendaring.DateTime): end time of the query\n        arg:    match (boolean): ``true`` for a positive match,\n                ``false`` for a negative match\n", 
               "return_doc": "", 
               "error_doc": "        raise:  InvalidArgument - ``end`` is les than ``start``\n        raise:  NullArgument - ``start`` or ``end`` is ``null``", 
               "sphinx_param_doc": "        :param start: start time of the query\n        :type start: ``osid.calendaring.DateTime``\n        :param end: end time of the query\n        :type end: ``osid.calendaring.DateTime``\n        :param match: ``true`` for a positive match, ``false`` for a negative match\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``InvalidArgument`` -- ``end`` is les than ``start``\n        :raise: ``NullArgument`` -- ``start`` or ``end`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.calendaring.DateTime", 
                     "var_name": "start", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.calendaring.DateTime", 
                     "var_name": "end", 
                     "array": false
                  }, 
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.calendaring.DateTime", 
                  "osid.calendaring.DateTime", 
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {
                  "INVALID_ARGUMENT": "ConsumerContract", 
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "match_any_published_date", 
               "doc": {
                  "headline": "Matches assets with any published time.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    match (boolean): ``true`` to match assets with any\n                published time, ``false`` to match assets with no\n                published time\n", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "        :param match: ``true`` to match assets with any published time, ``false`` to match assets with no published time\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "clear_published_date_terms", 
               "doc": {
                  "headline": "Clears the published time terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "match_principal_credit_string", 
               "doc": {
                  "headline": "Adds a principal credit string for this query.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    credit (string): credit string to match\n        arg:    string_match_type (osid.type.Type): the string match\n                type\n        arg:    match (boolean): ``true`` for a positive match,\n                ``false`` for a negative match\n", 
               "return_doc": "", 
               "error_doc": "        raise:  InvalidArgument - ``credit`` not of\n                ``string_match_type``\n        raise:  NullArgument - ``credit`` or ``string_match_type`` is\n                ``null``\n        raise:  Unsupported -\n                ``supports_string_match_type(string_match_type)`` is\n                ``false``", 
               "sphinx_param_doc": "        :param credit: credit string to match\n        :type credit: ``string``\n        :param string_match_type: the string match type\n        :type string_match_type: ``osid.type.Type``\n        :param match: ``true`` for a positive match, ``false`` for a negative match\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``InvalidArgument`` -- ``credit`` not of ``string_match_type``\n        :raise: ``NullArgument`` -- ``credit`` or ``string_match_type`` is ``null``\n        :raise: ``Unsupported`` -- ``supports_string_match_type(string_match_type)`` is ``false``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "string", 
                     "var_name": "credit", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "string_match_type", 
                     "array": false
                  }, 
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "string", 
                  "osid.type.Type", 
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {
                  "INVALID_ARGUMENT": "ConsumerContract", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }, 
            {
               "name": "match_any_principal_credit_string", 
               "doc": {
                  "headline": "Matches a principal credit string that has any value.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    match (boolean): ``true`` to match assets with any\n                principal credit string, ``false`` to match assets with\n                no principal credit string\n", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "        :param match: ``true`` to match assets with any principal credit string, ``false`` to match assets with no principal credit string\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "clear_principal_credit_string_terms", 
               "doc": {
                  "headline": "Clears the principal credit string terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "match_temporal_coverage", 
               "doc": {
                  "headline": "Match assets that whose coverage falls between the specified time period inclusive.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    start (osid.calendaring.DateTime): start time of the\n                query\n        arg:    end (osid.calendaring.DateTime): end time of the query\n        arg:    match (boolean): ``true`` for a positive match,\n                ``false`` for a negative match\n", 
               "return_doc": "", 
               "error_doc": "        raise:  InvalidArgument - ``end`` is less than ``start``\n        raise:  NullArgument - ``start`` or ``end`` is ``null``", 
               "sphinx_param_doc": "        :param start: start time of the query\n        :type start: ``osid.calendaring.DateTime``\n        :param end: end time of the query\n        :type end: ``osid.calendaring.DateTime``\n        :param match: ``true`` for a positive match, ``false`` for a negative match\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``InvalidArgument`` -- ``end`` is less than ``start``\n        :raise: ``NullArgument`` -- ``start`` or ``end`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.calendaring.DateTime", 
                     "var_name": "start", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.calendaring.DateTime", 
                     "var_name": "end", 
                     "array": false
                  }, 
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.calendaring.DateTime", 
                  "osid.calendaring.DateTime", 
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {
                  "INVALID_ARGUMENT": "ConsumerContract", 
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "match_any_temporal_coverage", 
               "doc": {
                  "headline": "Matches assets with any temporal coverage.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    match (boolean): ``true`` to match assets with any\n                temporal coverage, ``false`` to match assets with no\n                temporal coverage\n", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "        :param match: ``true`` to match assets with any temporal coverage, ``false`` to match assets with no temporal coverage\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "clear_temporal_coverage_terms", 
               "doc": {
                  "headline": "Clears the temporal coverage terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "match_location_id", 
               "doc": {
                  "headline": "Sets the location ``Id`` for this query of spatial coverage.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    location_id (osid.id.Id): the location ``Id``\n        arg:    match (boolean): ``true`` for a positive match,\n                ``false`` for a negative match\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``location_id`` is ``null``", 
               "sphinx_param_doc": "        :param location_id: the location ``Id``\n        :type location_id: ``osid.id.Id``\n        :param match: ``true`` for a positive match, ``false`` for a negative match\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``location_id`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "location_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "clear_location_id_terms", 
               "doc": {
                  "headline": "Clears the location ``Id`` terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "supports_location_query", 
               "doc": {
                  "headline": "Tests if a ``LocationQuery`` is available for the provider.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if a location query is available,\n                ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if a location query is available, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "get_location_query", 
               "doc": {
                  "headline": "Gets the query for a location.", 
                  "body": "        Multiple queries can be retrieved for a nested ``OR`` term."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.mapping.LocationQuery) - the location query", 
               "error_doc": "        raise:  Unimplemented - ``supports_location_query()`` is\n                ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the location query\n        :rtype: ``osid.mapping.LocationQuery``", 
               "sphinx_error_doc": "        :raise: ``Unimplemented`` -- ``supports_location_query()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_location_query()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.mapping.LocationQuery", 
               "errors": {
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "match_any_location", 
               "doc": {
                  "headline": "Matches assets with any provider.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    match (boolean): ``true`` to match assets with any\n                location, ``false`` to match assets with no locations\n", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "        :param match: ``true`` to match assets with any location, ``false`` to match assets with no locations\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "clear_location_terms", 
               "doc": {
                  "headline": "Clears the location terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "match_spatial_coverage", 
               "doc": {
                  "headline": "Matches assets that are contained within the given spatial unit.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    spatial_unit (osid.mapping.SpatialUnit): the spatial\n                unit\n        arg:    match (boolean): ``true`` for a positive match,\n                ``false`` for a negative match\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``spatial_unit`` is ``null``\n        raise:  Unsupported - ``spatial_unit`` is not suppoted", 
               "sphinx_param_doc": "        :param spatial_unit: the spatial unit\n        :type spatial_unit: ``osid.mapping.SpatialUnit``\n        :param match: ``true`` for a positive match, ``false`` for a negative match\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``spatial_unit`` is ``null``\n        :raise: ``Unsupported`` -- ``spatial_unit`` is not suppoted", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.mapping.SpatialUnit", 
                     "var_name": "spatial_unit", 
                     "array": false
                  }, 
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.mapping.SpatialUnit", 
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }, 
            {
               "name": "clear_spatial_coverage_terms", 
               "doc": {
                  "headline": "Clears the spatial coverage terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "match_spatial_coverage_overlap", 
               "doc": {
                  "headline": "Matches assets that overlap or touch the given spatial unit.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    spatial_unit (osid.mapping.SpatialUnit): the spatial\n                unit\n        arg:    match (boolean): ``true`` for a positive match,\n                ``false`` for a negative match\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``spatial_unit`` is ``null``\n        raise:  Unsupported - ``spatial_unit`` is not suppoted", 
               "sphinx_param_doc": "        :param spatial_unit: the spatial unit\n        :type spatial_unit: ``osid.mapping.SpatialUnit``\n        :param match: ``true`` for a positive match, ``false`` for a negative match\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``spatial_unit`` is ``null``\n        :raise: ``Unsupported`` -- ``spatial_unit`` is not suppoted", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.mapping.SpatialUnit", 
                     "var_name": "spatial_unit", 
                     "array": false
                  }, 
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.mapping.SpatialUnit", 
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }, 
            {
               "name": "match_any_spatial_coverage", 
               "doc": {
                  "headline": "Matches assets with no spatial coverage.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    match (boolean): ``true`` to match assets with any\n                spatial coverage, ``false`` to match assets with no\n                spatial coverage\n", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "        :param match: ``true`` to match assets with any spatial coverage, ``false`` to match assets with no spatial coverage\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "clear_spatial_coverage_overlap_terms", 
               "doc": {
                  "headline": "Clears the spatial coverage overlap terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "match_asset_content_id", 
               "doc": {
                  "headline": "Sets the asset content ``Id`` for this query.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    asset_content_id (osid.id.Id): the asset content ``Id``\n        arg:    match (boolean): ``true`` for a positive match,\n                ``false`` for a negative match\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``asset_content_id`` is ``null``", 
               "sphinx_param_doc": "        :param asset_content_id: the asset content ``Id``\n        :type asset_content_id: ``osid.id.Id``\n        :param match: ``true`` for a positive match, ``false`` for a negative match\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``asset_content_id`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "asset_content_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "clear_asset_content_id_terms", 
               "doc": {
                  "headline": "Clears the asset content ``Id`` terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "supports_asset_content_query", 
               "doc": {
                  "headline": "Tests if an ``AssetContentQuery`` is available.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if an asset content query is\n                available, ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if an asset content query is available, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "get_asset_content_query", 
               "doc": {
                  "headline": "Gets the query for the asset content.", 
                  "body": "        Multiple queries can be retrieved for a nested ``OR`` term."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.repository.AssetContentQuery) - the asset contents\n                query", 
               "error_doc": "        raise:  Unimplemented - ``supports_asset_content_query()`` is\n                ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the asset contents query\n        :rtype: ``osid.repository.AssetContentQuery``", 
               "sphinx_error_doc": "        :raise: ``Unimplemented`` -- ``supports_asset_content_query()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_asset_content_query()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.repository.AssetContentQuery", 
               "errors": {
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "match_any_asset_content", 
               "doc": {
                  "headline": "Matches assets with any content.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    match (boolean): ``true`` to match assets with any\n                content, ``false`` to match assets with no content\n", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "        :param match: ``true`` to match assets with any content, ``false`` to match assets with no content\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "clear_asset_content_terms", 
               "doc": {
                  "headline": "Clears the asset content terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "match_composition_id", 
               "doc": {
                  "headline": "Sets the composition ``Id`` for this query to match assets that are a part of the composition.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    composition_id (osid.id.Id): the composition ``Id``\n        arg:    match (boolean): ``true`` for a positive match,\n                ``false`` for a negative match\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``composition_id`` is ``null``", 
               "sphinx_param_doc": "        :param composition_id: the composition ``Id``\n        :type composition_id: ``osid.id.Id``\n        :param match: ``true`` for a positive match, ``false`` for a negative match\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``composition_id`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "composition_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "clear_composition_id_terms", 
               "doc": {
                  "headline": "Clears the composition ``Id`` terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "supports_composition_query", 
               "doc": {
                  "headline": "Tests if a ``CompositionQuery`` is available.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if a composition query is\n                available, ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if a composition query is available, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "get_composition_query", 
               "doc": {
                  "headline": "Gets the query for a composition.", 
                  "body": "        Multiple queries can be retrieved for a nested ``OR`` term."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.repository.CompositionQuery) - the composition\n                query", 
               "error_doc": "        raise:  Unimplemented - ``supports_composition_query()`` is\n                ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the composition query\n        :rtype: ``osid.repository.CompositionQuery``", 
               "sphinx_error_doc": "        :raise: ``Unimplemented`` -- ``supports_composition_query()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_composition_query()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.repository.CompositionQuery", 
               "errors": {
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "match_any_composition", 
               "doc": {
                  "headline": "Matches assets with any composition mappings.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    match (boolean): ``true`` to match assets with any\n                composition, ``false`` to match assets with no\n                composition mappings\n", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "        :param match: ``true`` to match assets with any composition, ``false`` to match assets with no composition mappings\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "clear_composition_terms", 
               "doc": {
                  "headline": "Clears the composition terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "match_repository_id", 
               "doc": {
                  "headline": "Sets the repository ``Id`` for this query.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    repository_id (osid.id.Id): the repository ``Id``\n        arg:    match (boolean): ``true`` for a positive match,\n                ``false`` for a negative match\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``repository_id`` is ``null``", 
               "sphinx_param_doc": "        :param repository_id: the repository ``Id``\n        :type repository_id: ``osid.id.Id``\n        :param match: ``true`` for a positive match, ``false`` for a negative match\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``repository_id`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "repository_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "clear_repository_id_terms", 
               "doc": {
                  "headline": "Clears the repository ``Id`` terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "supports_repository_query", 
               "doc": {
                  "headline": "Tests if a ``RepositoryQuery`` is available.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if a repository query is available,\n                ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if a repository query is available, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "get_repository_query", 
               "doc": {
                  "headline": "Gets the query for a repository.", 
                  "body": "        Multiple queries can be retrieved for a nested ``OR`` term."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.repository.RepositoryQuery) - the repository query", 
               "error_doc": "        raise:  Unimplemented - ``supports_repository_query()`` is\n                ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the repository query\n        :rtype: ``osid.repository.RepositoryQuery``", 
               "sphinx_error_doc": "        :raise: ``Unimplemented`` -- ``supports_repository_query()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_repository_query()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.repository.RepositoryQuery", 
               "errors": {
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "clear_repository_terms", 
               "doc": {
                  "headline": "Clears the repository terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "get_asset_query_record", 
               "doc": {
                  "headline": "Gets the asset query record corresponding to the given ``Asset`` record ``Type``.", 
                  "body": "        Multiuple retrievals produce a nested ``OR`` term."
               }, 
               "arg_doc": "        arg:    asset_record_type (osid.type.Type): an asset record type\n", 
               "return_doc": "        return: (osid.repository.records.AssetQueryRecord) - the asset\n                query record", 
               "error_doc": "        raise:  NullArgument - ``asset_record_type`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unsupported - ``has_record_type(asset_record_type)`` is\n                ``false``", 
               "sphinx_param_doc": "        :param asset_record_type: an asset record type\n        :type asset_record_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "        :return: the asset query record\n        :rtype: ``osid.repository.records.AssetQueryRecord``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``asset_record_type`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unsupported`` -- ``has_record_type(asset_record_type)`` is ``false``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "asset_record_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "osid.repository.records.AssetQueryRecord", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.repository.records.AssetQueryRecord", 
         "shortname": "AssetQueryRecord", 
         "category": "records", 
         "doc": {
            "headline": "A record for an ``AssetQuery``.", 
            "body": "    The methods specified by the record type are available through the\n    underlying object."
         }, 
         "inherit_fullnames": [
            "osid.OsidRecord"
         ], 
         "inherit_shortnames": [
            "OsidRecord"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidRecord"
            }
         ], 
         "method_names": [], 
         "methods": []
      }, 
      {
         "fullname": "osid.repository.AssetQueryInspector", 
         "shortname": "AssetQueryInspector", 
         "category": "query_inspectors", 
         "doc": {
            "headline": "This is the query inspector for examining asset queries.", 
            "body": ""
         }, 
         "inherit_fullnames": [
            "osid.OsidObjectQueryInspector", 
            "osid.OsidAggregateableQueryInspector", 
            "osid.OsidSourceableQueryInspector"
         ], 
         "inherit_shortnames": [
            "OsidObjectQueryInspector", 
            "OsidAggregateableQueryInspector", 
            "OsidSourceableQueryInspector"
         ], 
         "inherit_pkg_names": [
            "osid", 
            "osid", 
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidObjectQueryInspector"
            }, 
            {
               "pkg_name": "osid", 
               "name": "OsidAggregateableQueryInspector"
            }, 
            {
               "pkg_name": "osid", 
               "name": "OsidSourceableQueryInspector"
            }
         ], 
         "method_names": [
            "get_title_terms", 
            "get_public_domain_terms", 
            "get_copyright_terms", 
            "get_copyright_registration_terms", 
            "get_distribute_verbatim_terms", 
            "get_distribute_alterations_terms", 
            "get_distribute_compositions_terms", 
            "get_source_id_terms", 
            "get_source_terms", 
            "get_created_date_terms", 
            "get_published_terms", 
            "get_published_date_terms", 
            "get_principal_credit_string_terms", 
            "get_temporal_coverage_terms", 
            "get_location_id_terms", 
            "get_location_terms", 
            "get_spatial_coverage_terms", 
            "get_spatial_coverage_overlap_terms", 
            "get_asset_content_id_terms", 
            "get_asset_content_terms", 
            "get_composition_id_terms", 
            "get_composition_terms", 
            "get_repository_id_terms", 
            "get_repository_terms", 
            "get_asset_query_inspector_record"
         ], 
         "methods": [
            {
               "name": "get_title_terms", 
               "doc": {
                  "headline": "Gets the title query terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.search.terms.StringTerm) - the title terms", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the title terms\n        :rtype: ``osid.search.terms.StringTerm``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.search.terms.StringTerm", 
               "errors": {}
            }, 
            {
               "name": "get_public_domain_terms", 
               "doc": {
                  "headline": "Gets the public domain query terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.search.terms.BooleanTerm) - the query terms", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the query terms\n        :rtype: ``osid.search.terms.BooleanTerm``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.search.terms.BooleanTerm", 
               "errors": {}
            }, 
            {
               "name": "get_copyright_terms", 
               "doc": {
                  "headline": "Gets the copyright query terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.search.terms.StringTerm) - the query terms", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the query terms\n        :rtype: ``osid.search.terms.StringTerm``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.search.terms.StringTerm", 
               "errors": {}
            }, 
            {
               "name": "get_copyright_registration_terms", 
               "doc": {
                  "headline": "Gets the copyright registration query terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.search.terms.StringTerm) - the query terms", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the query terms\n        :rtype: ``osid.search.terms.StringTerm``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.search.terms.StringTerm", 
               "errors": {}
            }, 
            {
               "name": "get_distribute_verbatim_terms", 
               "doc": {
                  "headline": "Gets the verbatim distribution query terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.search.terms.BooleanTerm) - the query terms", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the query terms\n        :rtype: ``osid.search.terms.BooleanTerm``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.search.terms.BooleanTerm", 
               "errors": {}
            }, 
            {
               "name": "get_distribute_alterations_terms", 
               "doc": {
                  "headline": "Gets the alteration distribution query terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.search.terms.BooleanTerm) - the query terms", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the query terms\n        :rtype: ``osid.search.terms.BooleanTerm``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.search.terms.BooleanTerm", 
               "errors": {}
            }, 
            {
               "name": "get_distribute_compositions_terms", 
               "doc": {
                  "headline": "Gets the composition distribution query terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.search.terms.BooleanTerm) - the query terms", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the query terms\n        :rtype: ``osid.search.terms.BooleanTerm``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.search.terms.BooleanTerm", 
               "errors": {}
            }, 
            {
               "name": "get_source_id_terms", 
               "doc": {
                  "headline": "Gets the source ``Id`` query terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.search.terms.IdTerm) - the query terms", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the query terms\n        :rtype: ``osid.search.terms.IdTerm``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.search.terms.IdTerm", 
               "errors": {}
            }, 
            {
               "name": "get_source_terms", 
               "doc": {
                  "headline": "Gets the source query terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.resource.ResourceQueryInspector) - the query terms", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the query terms\n        :rtype: ``osid.resource.ResourceQueryInspector``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.resource.ResourceQueryInspector", 
               "errors": {}
            }, 
            {
               "name": "get_created_date_terms", 
               "doc": {
                  "headline": "Gets the created time query terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.search.terms.DateTimeRangeTerm) - the query terms", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the query terms\n        :rtype: ``osid.search.terms.DateTimeRangeTerm``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.search.terms.DateTimeRangeTerm", 
               "errors": {}
            }, 
            {
               "name": "get_published_terms", 
               "doc": {
                  "headline": "Gets the published query terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.search.terms.BooleanTerm) - the query terms", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the query terms\n        :rtype: ``osid.search.terms.BooleanTerm``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.search.terms.BooleanTerm", 
               "errors": {}
            }, 
            {
               "name": "get_published_date_terms", 
               "doc": {
                  "headline": "Gets the published time query terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.search.terms.DateTimeRangeTerm) - the query terms", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the query terms\n        :rtype: ``osid.search.terms.DateTimeRangeTerm``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.search.terms.DateTimeRangeTerm", 
               "errors": {}
            }, 
            {
               "name": "get_principal_credit_string_terms", 
               "doc": {
                  "headline": "Gets the principal credit string query terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.search.terms.StringTerm) - the principal credit\n                string terms", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the principal credit string terms\n        :rtype: ``osid.search.terms.StringTerm``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.search.terms.StringTerm", 
               "errors": {}
            }, 
            {
               "name": "get_temporal_coverage_terms", 
               "doc": {
                  "headline": "Gets the temporal coverage query terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.search.terms.DateTimeRangeTerm) - the query terms", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the query terms\n        :rtype: ``osid.search.terms.DateTimeRangeTerm``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.search.terms.DateTimeRangeTerm", 
               "errors": {}
            }, 
            {
               "name": "get_location_id_terms", 
               "doc": {
                  "headline": "Gets the location ``Id`` query terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.search.terms.IdTerm) - the query terms", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the query terms\n        :rtype: ``osid.search.terms.IdTerm``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.search.terms.IdTerm", 
               "errors": {}
            }, 
            {
               "name": "get_location_terms", 
               "doc": {
                  "headline": "Gets the location query terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.mapping.LocationQueryInspector) - the query terms", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the query terms\n        :rtype: ``osid.mapping.LocationQueryInspector``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.mapping.LocationQueryInspector", 
               "errors": {}
            }, 
            {
               "name": "get_spatial_coverage_terms", 
               "doc": {
                  "headline": "Gets the spatial coverage query terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.search.terms.SpatialUnitTerm) - the query terms", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the query terms\n        :rtype: ``osid.search.terms.SpatialUnitTerm``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.search.terms.SpatialUnitTerm", 
               "errors": {}
            }, 
            {
               "name": "get_spatial_coverage_overlap_terms", 
               "doc": {
                  "headline": "Gets the spatial coverage overlap query terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.search.terms.SpatialUnitTerm) - the query terms", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the query terms\n        :rtype: ``osid.search.terms.SpatialUnitTerm``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.search.terms.SpatialUnitTerm", 
               "errors": {}
            }, 
            {
               "name": "get_asset_content_id_terms", 
               "doc": {
                  "headline": "Gets the asset content ``Id`` query terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.search.terms.IdTerm) - the query terms", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the query terms\n        :rtype: ``osid.search.terms.IdTerm``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.search.terms.IdTerm", 
               "errors": {}
            }, 
            {
               "name": "get_asset_content_terms", 
               "doc": {
                  "headline": "Gets the asset content query terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.repository.AssetContentQueryInspector) - the query\n                terms", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the query terms\n        :rtype: ``osid.repository.AssetContentQueryInspector``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.repository.AssetContentQueryInspector", 
               "errors": {}
            }, 
            {
               "name": "get_composition_id_terms", 
               "doc": {
                  "headline": "Gets the composition ``Id`` query terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.search.terms.IdTerm) - the query terms", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the query terms\n        :rtype: ``osid.search.terms.IdTerm``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.search.terms.IdTerm", 
               "errors": {}
            }, 
            {
               "name": "get_composition_terms", 
               "doc": {
                  "headline": "Gets the composition query terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.repository.CompositionQueryInspector) - the query\n                terms", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the query terms\n        :rtype: ``osid.repository.CompositionQueryInspector``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.repository.CompositionQueryInspector", 
               "errors": {}
            }, 
            {
               "name": "get_repository_id_terms", 
               "doc": {
                  "headline": "Gets the repository ``Id`` query terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.search.terms.IdTerm) - the query terms", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the query terms\n        :rtype: ``osid.search.terms.IdTerm``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.search.terms.IdTerm", 
               "errors": {}
            }, 
            {
               "name": "get_repository_terms", 
               "doc": {
                  "headline": "Gets the repository query terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.repository.RepositoryQueryInspector) - the query\n                terms", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the query terms\n        :rtype: ``osid.repository.RepositoryQueryInspector``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.repository.RepositoryQueryInspector", 
               "errors": {}
            }, 
            {
               "name": "get_asset_query_inspector_record", 
               "doc": {
                  "headline": "Gets the asset query inspector record corresponding to the given ``Asset`` record ``Type``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    asset_record_type (osid.type.Type): an asset record type\n", 
               "return_doc": "        return: (osid.repository.records.AssetQueryInspectorRecord) -\n                the asset query inspector record", 
               "error_doc": "        raise:  NullArgument - ``asset_record_type`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unsupported - ``has_record_type(asset_record_type)`` is\n                ``false``", 
               "sphinx_param_doc": "        :param asset_record_type: an asset record type\n        :type asset_record_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "        :return: the asset query inspector record\n        :rtype: ``osid.repository.records.AssetQueryInspectorRecord``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``asset_record_type`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unsupported`` -- ``has_record_type(asset_record_type)`` is ``false``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "asset_record_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "osid.repository.records.AssetQueryInspectorRecord", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.repository.records.AssetQueryInspectorRecord", 
         "shortname": "AssetQueryInspectorRecord", 
         "category": "records", 
         "doc": {
            "headline": "A record for an ``AssetQueryInspector``.", 
            "body": "    The methods specified by the record type are available through the\n    underlying object."
         }, 
         "inherit_fullnames": [
            "osid.OsidRecord"
         ], 
         "inherit_shortnames": [
            "OsidRecord"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidRecord"
            }
         ], 
         "method_names": [], 
         "methods": []
      }, 
      {
         "fullname": "osid.repository.AssetForm", 
         "shortname": "AssetForm", 
         "category": "objects", 
         "doc": {
            "headline": "This is the form for creating and updating ``Assets``.", 
            "body": "    Like all ``OsidForm`` objects, various data elements may be set here\n    for use in the create and update methods in the\n    ``AssetAdminSession``. For each data element that may be set,\n    metadata may be examined to provide display hints or data\n    constraints."
         }, 
         "inherit_fullnames": [
            "osid.OsidObjectForm", 
            "osid.OsidAggregateableForm", 
            "osid.OsidSourceableForm"
         ], 
         "inherit_shortnames": [
            "OsidObjectForm", 
            "OsidAggregateableForm", 
            "OsidSourceableForm"
         ], 
         "inherit_pkg_names": [
            "osid", 
            "osid", 
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidObjectForm"
            }, 
            {
               "pkg_name": "osid", 
               "name": "OsidAggregateableForm"
            }, 
            {
               "pkg_name": "osid", 
               "name": "OsidSourceableForm"
            }
         ], 
         "method_names": [
            "get_title_metadata", 
            "set_title", 
            "clear_title", 
            "get_public_domain_metadata", 
            "set_public_domain", 
            "clear_public_domain", 
            "get_copyright_metadata", 
            "set_copyright", 
            "clear_copyright", 
            "get_distribute_verbatim_metadata", 
            "set_distribute_verbatim", 
            "clear_distribute_verbatim", 
            "get_distribute_alterations_metadata", 
            "set_distribute_alterations", 
            "clear_distribute_alterations", 
            "get_distribute_compositions_metadata", 
            "set_distribute_compositions", 
            "clear_distribute_compositions", 
            "get_source_metadata", 
            "set_source", 
            "clear_source", 
            "get_provider_links_metadata", 
            "set_provider_links", 
            "clear_provider_links", 
            "get_created_date_metadata", 
            "set_created_date", 
            "clear_created_date", 
            "get_published_metadata", 
            "set_published", 
            "clear_published", 
            "get_published_date_metadata", 
            "set_published_date", 
            "clear_published_date", 
            "get_principal_credit_string_metadata", 
            "set_principal_credit_string", 
            "clear_principal_credit_string", 
            "get_composition_metadata", 
            "set_composition", 
            "clear_composition", 
            "get_asset_form_record"
         ], 
         "methods": [
            {
               "name": "get_title_metadata", 
               "doc": {
                  "headline": "Gets the metadata for an asset title.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.Metadata) - metadata for the title", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: metadata for the title\n        :rtype: ``osid.Metadata``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.Metadata", 
               "errors": {}
            }, 
            {
               "name": "set_title", 
               "doc": {
                  "headline": "Sets the title.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    title (string): the new title\n", 
               "return_doc": "", 
               "error_doc": "        raise:  InvalidArgument - ``title`` is invalid\n        raise:  NoAccess - ``Metadata.isReadOnly()`` is ``true``\n        raise:  NullArgument - ``title`` is ``null``", 
               "sphinx_param_doc": "        :param title: the new title\n        :type title: ``string``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``InvalidArgument`` -- ``title`` is invalid\n        :raise: ``NoAccess`` -- ``Metadata.isReadOnly()`` is ``true``\n        :raise: ``NullArgument`` -- ``title`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "string", 
                     "var_name": "title", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "string"
               ], 
               "return_type": "", 
               "errors": {
                  "INVALID_ARGUMENT": "ConsumerContract", 
                  "NO_ACCESS": "ConsumerContract", 
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "clear_title", 
               "doc": {
                  "headline": "Removes the title.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "        raise:  NoAccess - ``Metadata.isRequired()`` is ``true`` or\n                ``Metadata.isReadOnly()`` is ``true``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NoAccess`` -- ``Metadata.isRequired()`` is ``true`` or ``Metadata.isReadOnly()`` is ``true``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {
                  "NO_ACCESS": "ConsumerContract"
               }
            }, 
            {
               "name": "get_public_domain_metadata", 
               "doc": {
                  "headline": "Gets the metadata for the public domain flag.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.Metadata) - metadata for the public domain", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: metadata for the public domain\n        :rtype: ``osid.Metadata``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.Metadata", 
               "errors": {}
            }, 
            {
               "name": "set_public_domain", 
               "doc": {
                  "headline": "Sets the public domain flag.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    public_domain (boolean): the public domain status\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NoAccess - ``Metadata.isReadOnly()`` is ``true``", 
               "sphinx_param_doc": "        :param public_domain: the public domain status\n        :type public_domain: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NoAccess`` -- ``Metadata.isReadOnly()`` is ``true``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "boolean", 
                     "var_name": "public_domain", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {
                  "NO_ACCESS": "ConsumerContract"
               }
            }, 
            {
               "name": "clear_public_domain", 
               "doc": {
                  "headline": "Removes the public domain status.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "        raise:  NoAccess - ``Metadata.isRequired()`` is ``true`` or\n                ``Metadata.isReadOnly()`` is ``true``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NoAccess`` -- ``Metadata.isRequired()`` is ``true`` or ``Metadata.isReadOnly()`` is ``true``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {
                  "NO_ACCESS": "ConsumerContract"
               }
            }, 
            {
               "name": "get_copyright_metadata", 
               "doc": {
                  "headline": "Gets the metadata for the copyright.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.Metadata) - metadata for the copyright", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: metadata for the copyright\n        :rtype: ``osid.Metadata``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.Metadata", 
               "errors": {}
            }, 
            {
               "name": "set_copyright", 
               "doc": {
                  "headline": "Sets the copyright.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    copyright (string): the new copyright\n", 
               "return_doc": "", 
               "error_doc": "        raise:  InvalidArgument - ``copyright`` is invalid\n        raise:  NoAccess - ``Metadata.isReadOnly()`` is ``true``\n        raise:  NullArgument - ``copyright`` is ``null``", 
               "sphinx_param_doc": "        :param copyright: the new copyright\n        :type copyright: ``string``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``InvalidArgument`` -- ``copyright`` is invalid\n        :raise: ``NoAccess`` -- ``Metadata.isReadOnly()`` is ``true``\n        :raise: ``NullArgument`` -- ``copyright`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "string", 
                     "var_name": "copyright", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "string"
               ], 
               "return_type": "", 
               "errors": {
                  "INVALID_ARGUMENT": "ConsumerContract", 
                  "NO_ACCESS": "ConsumerContract", 
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "clear_copyright", 
               "doc": {
                  "headline": "Removes the copyright.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "        raise:  NoAccess - ``Metadata.isRequired()`` is ``true`` or\n                ``Metadata.isReadOnly()`` is ``true``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NoAccess`` -- ``Metadata.isRequired()`` is ``true`` or ``Metadata.isReadOnly()`` is ``true``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {
                  "NO_ACCESS": "ConsumerContract"
               }
            }, 
            {
               "name": "get_distribute_verbatim_metadata", 
               "doc": {
                  "headline": "Gets the metadata for the distribute verbatim rights flag.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.Metadata) - metadata for the distribution rights\n                fields", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: metadata for the distribution rights fields\n        :rtype: ``osid.Metadata``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.Metadata", 
               "errors": {}
            }, 
            {
               "name": "set_distribute_verbatim", 
               "doc": {
                  "headline": "Sets the distribution rights.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    distribute_verbatim (boolean): right to distribute\n                verbatim copies\n", 
               "return_doc": "", 
               "error_doc": "        raise:  InvalidArgument - ``distribute_verbatim`` is invalid\n        raise:  NoAccess - authorization failure", 
               "sphinx_param_doc": "        :param distribute_verbatim: right to distribute verbatim copies\n        :type distribute_verbatim: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``InvalidArgument`` -- ``distribute_verbatim`` is invalid\n        :raise: ``NoAccess`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "boolean", 
                     "var_name": "distribute_verbatim", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {
                  "INVALID_ARGUMENT": "ConsumerContract", 
                  "NO_ACCESS": "ConsumerContract"
               }
            }, 
            {
               "name": "clear_distribute_verbatim", 
               "doc": {
                  "headline": "Removes the distribution rights.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "        raise:  NoAccess - ``Metadata.isRequired()`` is ``true`` or\n                ``Metadata.isReadOnly()`` is ``true``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NoAccess`` -- ``Metadata.isRequired()`` is ``true`` or ``Metadata.isReadOnly()`` is ``true``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {
                  "NO_ACCESS": "ConsumerContract"
               }
            }, 
            {
               "name": "get_distribute_alterations_metadata", 
               "doc": {
                  "headline": "Gets the metadata for the distribute alterations rights flag.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.Metadata) - metadata for the distribution rights\n                fields", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: metadata for the distribution rights fields\n        :rtype: ``osid.Metadata``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.Metadata", 
               "errors": {}
            }, 
            {
               "name": "set_distribute_alterations", 
               "doc": {
                  "headline": "Sets the distribute alterations flag.", 
                  "body": "        This also sets distribute verbatim to ``true``."
               }, 
               "arg_doc": "        arg:    distribute_mods (boolean): right to distribute\n                modifications\n", 
               "return_doc": "", 
               "error_doc": "        raise:  InvalidArgument - ``distribute_mods`` is invalid\n        raise:  NoAccess - authorization failure", 
               "sphinx_param_doc": "        :param distribute_mods: right to distribute modifications\n        :type distribute_mods: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``InvalidArgument`` -- ``distribute_mods`` is invalid\n        :raise: ``NoAccess`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "boolean", 
                     "var_name": "distribute_mods", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {
                  "INVALID_ARGUMENT": "ConsumerContract", 
                  "NO_ACCESS": "ConsumerContract"
               }
            }, 
            {
               "name": "clear_distribute_alterations", 
               "doc": {
                  "headline": "Removes the distribution rights.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "        raise:  NoAccess - ``Metadata.isRequired()`` is ``true`` or\n                ``Metadata.isReadOnly()`` is ``true``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NoAccess`` -- ``Metadata.isRequired()`` is ``true`` or ``Metadata.isReadOnly()`` is ``true``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {
                  "NO_ACCESS": "ConsumerContract"
               }
            }, 
            {
               "name": "get_distribute_compositions_metadata", 
               "doc": {
                  "headline": "Gets the metadata for the distribute compositions rights flag.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.Metadata) - metadata for the distribution rights\n                fields", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: metadata for the distribution rights fields\n        :rtype: ``osid.Metadata``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.Metadata", 
               "errors": {}
            }, 
            {
               "name": "set_distribute_compositions", 
               "doc": {
                  "headline": "Sets the distribution rights.", 
                  "body": "        This sets distribute verbatim to ``true``."
               }, 
               "arg_doc": "        arg:    distribute_comps (boolean): right to distribute\n                modifications\n", 
               "return_doc": "", 
               "error_doc": "        raise:  InvalidArgument - ``distribute_comps`` is invalid\n        raise:  NoAccess - authorization failure", 
               "sphinx_param_doc": "        :param distribute_comps: right to distribute modifications\n        :type distribute_comps: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``InvalidArgument`` -- ``distribute_comps`` is invalid\n        :raise: ``NoAccess`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "boolean", 
                     "var_name": "distribute_comps", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {
                  "INVALID_ARGUMENT": "ConsumerContract", 
                  "NO_ACCESS": "ConsumerContract"
               }
            }, 
            {
               "name": "clear_distribute_compositions", 
               "doc": {
                  "headline": "Removes the distribution rights.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "        raise:  NoAccess - ``Metadata.isRequired()`` is ``true`` or\n                ``Metadata.isReadOnly()`` is ``true``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NoAccess`` -- ``Metadata.isRequired()`` is ``true`` or ``Metadata.isReadOnly()`` is ``true``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {
                  "NO_ACCESS": "ConsumerContract"
               }
            }, 
            {
               "name": "get_source_metadata", 
               "doc": {
                  "headline": "Gets the metadata for the source.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.Metadata) - metadata for the source", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: metadata for the source\n        :rtype: ``osid.Metadata``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.Metadata", 
               "errors": {}
            }, 
            {
               "name": "set_source", 
               "doc": {
                  "headline": "Sets the source.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    source_id (osid.id.Id): the new publisher\n", 
               "return_doc": "", 
               "error_doc": "        raise:  InvalidArgument - ``source_id`` is invalid\n        raise:  NoAccess - ``Metadata.isReadOnly()`` is ``true``\n        raise:  NullArgument - ``source_id`` is ``null``", 
               "sphinx_param_doc": "        :param source_id: the new publisher\n        :type source_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``InvalidArgument`` -- ``source_id`` is invalid\n        :raise: ``NoAccess`` -- ``Metadata.isReadOnly()`` is ``true``\n        :raise: ``NullArgument`` -- ``source_id`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "source_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {
                  "INVALID_ARGUMENT": "ConsumerContract", 
                  "NO_ACCESS": "ConsumerContract", 
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "clear_source", 
               "doc": {
                  "headline": "Removes the source.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "        raise:  NoAccess - ``Metadata.isRequired()`` is ``true`` or\n                ``Metadata.isReadOnly()`` is ``true``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NoAccess`` -- ``Metadata.isRequired()`` is ``true`` or ``Metadata.isReadOnly()`` is ``true``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {
                  "NO_ACCESS": "ConsumerContract"
               }
            }, 
            {
               "name": "get_provider_links_metadata", 
               "doc": {
                  "headline": "Gets the metadata for the provider chain.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.Metadata) - metadata for the provider chain", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: metadata for the provider chain\n        :rtype: ``osid.Metadata``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.Metadata", 
               "errors": {}
            }, 
            {
               "name": "set_provider_links", 
               "doc": {
                  "headline": "Sets a provider chain in order from the most recent source to the originating source.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    resource_ids (osid.id.Id[]): the new source\n", 
               "return_doc": "", 
               "error_doc": "        raise:  InvalidArgument - ``resource_ids`` is invalid\n        raise:  NoAccess - ``Metadata.isReadOnly()`` is ``true``\n        raise:  NullArgument - ``resource_ids`` is ``null``", 
               "sphinx_param_doc": "        :param resource_ids: the new source\n        :type resource_ids: ``osid.id.Id[]``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``InvalidArgument`` -- ``resource_ids`` is invalid\n        :raise: ``NoAccess`` -- ``Metadata.isReadOnly()`` is ``true``\n        :raise: ``NullArgument`` -- ``resource_ids`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id[]", 
                     "var_name": "resource_ids", 
                     "array": true
                  }
               ], 
               "arg_types": [
                  "osid.id.Id[]"
               ], 
               "return_type": "", 
               "errors": {
                  "INVALID_ARGUMENT": "ConsumerContract", 
                  "NO_ACCESS": "ConsumerContract", 
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "clear_provider_links", 
               "doc": {
                  "headline": "Removes the provider chain.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "        raise:  NoAccess - ``Metadata.isRequired()`` is ``true`` or\n                ``Metadata.isReadOnly()`` is ``true``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NoAccess`` -- ``Metadata.isRequired()`` is ``true`` or ``Metadata.isReadOnly()`` is ``true``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {
                  "NO_ACCESS": "ConsumerContract"
               }
            }, 
            {
               "name": "get_created_date_metadata", 
               "doc": {
                  "headline": "Gets the metadata for the asset creation date.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.Metadata) - metadata for the created date", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: metadata for the created date\n        :rtype: ``osid.Metadata``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.Metadata", 
               "errors": {}
            }, 
            {
               "name": "set_created_date", 
               "doc": {
                  "headline": "Sets the created date.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    created_date (osid.calendaring.DateTime): the new\n                created date\n", 
               "return_doc": "", 
               "error_doc": "        raise:  InvalidArgument - ``created_date`` is invalid\n        raise:  NoAccess - ``Metadata.isReadOnly()`` is ``true``\n        raise:  NullArgument - ``created_date`` is ``null``", 
               "sphinx_param_doc": "        :param created_date: the new created date\n        :type created_date: ``osid.calendaring.DateTime``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``InvalidArgument`` -- ``created_date`` is invalid\n        :raise: ``NoAccess`` -- ``Metadata.isReadOnly()`` is ``true``\n        :raise: ``NullArgument`` -- ``created_date`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.calendaring.DateTime", 
                     "var_name": "created_date", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.calendaring.DateTime"
               ], 
               "return_type": "", 
               "errors": {
                  "INVALID_ARGUMENT": "ConsumerContract", 
                  "NO_ACCESS": "ConsumerContract", 
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "clear_created_date", 
               "doc": {
                  "headline": "Removes the created date.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "        raise:  NoAccess - ``Metadata.isRequired()`` is ``true`` or\n                ``Metadata.isReadOnly()`` is ``true``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NoAccess`` -- ``Metadata.isRequired()`` is ``true`` or ``Metadata.isReadOnly()`` is ``true``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {
                  "NO_ACCESS": "ConsumerContract"
               }
            }, 
            {
               "name": "get_published_metadata", 
               "doc": {
                  "headline": "Gets the metadata for the published status.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.Metadata) - metadata for the published field", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: metadata for the published field\n        :rtype: ``osid.Metadata``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.Metadata", 
               "errors": {}
            }, 
            {
               "name": "set_published", 
               "doc": {
                  "headline": "Sets the published status.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    published (boolean): the published status\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NoAccess - ``Metadata.isReadOnly()`` is ``true``", 
               "sphinx_param_doc": "        :param published: the published status\n        :type published: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NoAccess`` -- ``Metadata.isReadOnly()`` is ``true``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "boolean", 
                     "var_name": "published", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {
                  "NO_ACCESS": "ConsumerContract"
               }
            }, 
            {
               "name": "clear_published", 
               "doc": {
                  "headline": "Removes the published status.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "        raise:  NoAccess - ``Metadata.isRequired()`` is ``true`` or\n                ``Metadata.isReadOnly()`` is ``true``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NoAccess`` -- ``Metadata.isRequired()`` is ``true`` or ``Metadata.isReadOnly()`` is ``true``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {
                  "NO_ACCESS": "ConsumerContract"
               }
            }, 
            {
               "name": "get_published_date_metadata", 
               "doc": {
                  "headline": "Gets the metadata for the published date.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.Metadata) - metadata for the published date", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: metadata for the published date\n        :rtype: ``osid.Metadata``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.Metadata", 
               "errors": {}
            }, 
            {
               "name": "set_published_date", 
               "doc": {
                  "headline": "Sets the published date.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    published_date (osid.calendaring.DateTime): the new\n                published date\n", 
               "return_doc": "", 
               "error_doc": "        raise:  InvalidArgument - ``published_date`` is invalid\n        raise:  NoAccess - ``Metadata.isReadOnly()`` is ``true``\n        raise:  NullArgument - ``published_date`` is ``null``", 
               "sphinx_param_doc": "        :param published_date: the new published date\n        :type published_date: ``osid.calendaring.DateTime``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``InvalidArgument`` -- ``published_date`` is invalid\n        :raise: ``NoAccess`` -- ``Metadata.isReadOnly()`` is ``true``\n        :raise: ``NullArgument`` -- ``published_date`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.calendaring.DateTime", 
                     "var_name": "published_date", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.calendaring.DateTime"
               ], 
               "return_type": "", 
               "errors": {
                  "INVALID_ARGUMENT": "ConsumerContract", 
                  "NO_ACCESS": "ConsumerContract", 
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "clear_published_date", 
               "doc": {
                  "headline": "Removes the puiblished date.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "        raise:  NoAccess - ``Metadata.isRequired()`` is ``true`` or\n                ``Metadata.isReadOnly()`` is ``true``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NoAccess`` -- ``Metadata.isRequired()`` is ``true`` or ``Metadata.isReadOnly()`` is ``true``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {
                  "NO_ACCESS": "ConsumerContract"
               }
            }, 
            {
               "name": "get_principal_credit_string_metadata", 
               "doc": {
                  "headline": "Gets the metadata for the principal credit string.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.Metadata) - metadata for the credit string", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: metadata for the credit string\n        :rtype: ``osid.Metadata``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.Metadata", 
               "errors": {}
            }, 
            {
               "name": "set_principal_credit_string", 
               "doc": {
                  "headline": "Sets the principal credit string.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    credit_string (string): the new credit string\n", 
               "return_doc": "", 
               "error_doc": "        raise:  InvalidArgument - ``credit_string`` is invalid\n        raise:  NoAccess - ``Metadata.isReadOnly()`` is ``true``\n        raise:  NullArgument - ``credit_string`` is ``null``", 
               "sphinx_param_doc": "        :param credit_string: the new credit string\n        :type credit_string: ``string``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``InvalidArgument`` -- ``credit_string`` is invalid\n        :raise: ``NoAccess`` -- ``Metadata.isReadOnly()`` is ``true``\n        :raise: ``NullArgument`` -- ``credit_string`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "string", 
                     "var_name": "credit_string", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "string"
               ], 
               "return_type": "", 
               "errors": {
                  "INVALID_ARGUMENT": "ConsumerContract", 
                  "NO_ACCESS": "ConsumerContract", 
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "clear_principal_credit_string", 
               "doc": {
                  "headline": "Removes the principal credit string.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "        raise:  NoAccess - ``Metadata.isRequired()`` is ``true`` or\n                ``Metadata.isReadOnly()`` is ``true``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NoAccess`` -- ``Metadata.isRequired()`` is ``true`` or ``Metadata.isReadOnly()`` is ``true``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {
                  "NO_ACCESS": "ConsumerContract"
               }
            }, 
            {
               "name": "get_composition_metadata", 
               "doc": {
                  "headline": "Gets the metadata for linking this asset to a composition.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.Metadata) - metadata for the composition", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: metadata for the composition\n        :rtype: ``osid.Metadata``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.Metadata", 
               "errors": {}
            }, 
            {
               "name": "set_composition", 
               "doc": {
                  "headline": "Sets the composition.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    composition_id (osid.id.Id): a composition\n", 
               "return_doc": "", 
               "error_doc": "        raise:  InvalidArgument - ``composition_id`` is invalid\n        raise:  NoAccess - ``Metadata.isReadOnly()`` is ``true``\n        raise:  NullArgument - ``composition_id`` is ``null``", 
               "sphinx_param_doc": "        :param composition_id: a composition\n        :type composition_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``InvalidArgument`` -- ``composition_id`` is invalid\n        :raise: ``NoAccess`` -- ``Metadata.isReadOnly()`` is ``true``\n        :raise: ``NullArgument`` -- ``composition_id`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "composition_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {
                  "INVALID_ARGUMENT": "ConsumerContract", 
                  "NO_ACCESS": "ConsumerContract", 
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "clear_composition", 
               "doc": {
                  "headline": "Removes the composition link.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "        raise:  NoAccess - ``Metadata.isRequired()`` is ``true`` or\n                ``Metadata.isReadOnly()`` is ``true``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NoAccess`` -- ``Metadata.isRequired()`` is ``true`` or ``Metadata.isReadOnly()`` is ``true``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {
                  "NO_ACCESS": "ConsumerContract"
               }
            }, 
            {
               "name": "get_asset_form_record", 
               "doc": {
                  "headline": "Gets the ``AssetFormRecord`` corresponding to the given ``Asset`` record ``Type``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    asset_record_type (osid.type.Type): an asset record type\n", 
               "return_doc": "        return: (osid.repository.records.AssetFormRecord) - the asset\n                form record", 
               "error_doc": "        raise:  NullArgument - ``asset_record_type`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unsupported - ``has_record_type(asset_record_type)`` is\n                ``false``", 
               "sphinx_param_doc": "        :param asset_record_type: an asset record type\n        :type asset_record_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "        :return: the asset form record\n        :rtype: ``osid.repository.records.AssetFormRecord``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``asset_record_type`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unsupported`` -- ``has_record_type(asset_record_type)`` is ``false``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "asset_record_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "osid.repository.records.AssetFormRecord", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.repository.records.AssetFormRecord", 
         "shortname": "AssetFormRecord", 
         "category": "records", 
         "doc": {
            "headline": "A record for an ``AssetForm``.", 
            "body": "    The methods specified by the record type are available through the\n    underlying object."
         }, 
         "inherit_fullnames": [
            "osid.OsidRecord"
         ], 
         "inherit_shortnames": [
            "OsidRecord"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidRecord"
            }
         ], 
         "method_names": [], 
         "methods": []
      }, 
      {
         "fullname": "osid.repository.AssetSearchOrder", 
         "shortname": "AssetSearchOrder", 
         "category": "search_orders", 
         "doc": {
            "headline": "An interface for specifying the ordering of search results.", 
            "body": ""
         }, 
         "inherit_fullnames": [
            "osid.OsidObjectSearchOrder", 
            "osid.OsidAggregateableSearchOrder", 
            "osid.OsidSourceableSearchOrder"
         ], 
         "inherit_shortnames": [
            "OsidObjectSearchOrder", 
            "OsidAggregateableSearchOrder", 
            "OsidSourceableSearchOrder"
         ], 
         "inherit_pkg_names": [
            "osid", 
            "osid", 
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidObjectSearchOrder"
            }, 
            {
               "pkg_name": "osid", 
               "name": "OsidAggregateableSearchOrder"
            }, 
            {
               "pkg_name": "osid", 
               "name": "OsidSourceableSearchOrder"
            }
         ], 
         "method_names": [
            "order_by_title", 
            "order_by_public_domain", 
            "order_by_distribute_verbatim", 
            "order_by_distribute_alterations", 
            "order_by_distribute_compositions", 
            "order_by_source", 
            "supports_source_search_order", 
            "get_source_search_order", 
            "order_by_created_date", 
            "order_by_published", 
            "order_by_published_date", 
            "order_by_principal_credit_string", 
            "order_by_temporal_coverage", 
            "get_asset_search_order_record"
         ], 
         "methods": [
            {
               "name": "order_by_title", 
               "doc": {
                  "headline": "Specifies a preference for ordering the result set by asset title.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    style (osid.SearchOrderStyle): search order record\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``style`` is ``null``", 
               "sphinx_param_doc": "        :param style: search order record\n        :type style: ``osid.SearchOrderStyle``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``style`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.SearchOrderStyle", 
                     "var_name": "style", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.SearchOrderStyle"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "order_by_public_domain", 
               "doc": {
                  "headline": "Specifies a preference for grouping the result set by published domain.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    style (osid.SearchOrderStyle): search order record\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``style`` is ``null``", 
               "sphinx_param_doc": "        :param style: search order record\n        :type style: ``osid.SearchOrderStyle``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``style`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.SearchOrderStyle", 
                     "var_name": "style", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.SearchOrderStyle"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "order_by_distribute_verbatim", 
               "doc": {
                  "headline": "Specifies a preference for grouping the result set by the ability to distribute copies.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    style (osid.SearchOrderStyle): search order record\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``style`` is ``null``", 
               "sphinx_param_doc": "        :param style: search order record\n        :type style: ``osid.SearchOrderStyle``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``style`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.SearchOrderStyle", 
                     "var_name": "style", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.SearchOrderStyle"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "order_by_distribute_alterations", 
               "doc": {
                  "headline": "Specifies a preference for grouping the result set by the ability to distribute alterations.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    style (osid.SearchOrderStyle): search order record\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``style`` is ``null``", 
               "sphinx_param_doc": "        :param style: search order record\n        :type style: ``osid.SearchOrderStyle``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``style`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.SearchOrderStyle", 
                     "var_name": "style", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.SearchOrderStyle"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "order_by_distribute_compositions", 
               "doc": {
                  "headline": "Specifies a preference for grouping the result set by the ability to distribute compositions.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    style (osid.SearchOrderStyle): search order record\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``style`` is ``null``", 
               "sphinx_param_doc": "        :param style: search order record\n        :type style: ``osid.SearchOrderStyle``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``style`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.SearchOrderStyle", 
                     "var_name": "style", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.SearchOrderStyle"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "order_by_source", 
               "doc": {
                  "headline": "Specifies a preference for ordering the result set by asset source.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    style (osid.SearchOrderStyle): search order record\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``style`` is ``null``", 
               "sphinx_param_doc": "        :param style: search order record\n        :type style: ``osid.SearchOrderStyle``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``style`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.SearchOrderStyle", 
                     "var_name": "style", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.SearchOrderStyle"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "supports_source_search_order", 
               "doc": {
                  "headline": "Tests if a source order interface is available.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if a source search order is\n                available, ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if a source search order is available, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "get_source_search_order", 
               "doc": {
                  "headline": "Gets the source order.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.resource.ResourceSearchOrder) - the resource\n                search order for the source", 
               "error_doc": "        raise:  Unimplemented - ``supports_source_search_order()`` is\n                ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the resource search order for the source\n        :rtype: ``osid.resource.ResourceSearchOrder``", 
               "sphinx_error_doc": "        :raise: ``Unimplemented`` -- ``supports_source_search_order()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_source_search_order()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.resource.ResourceSearchOrder", 
               "errors": {
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "order_by_created_date", 
               "doc": {
                  "headline": "Specifies a preference for ordering the result set by created date.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    style (osid.SearchOrderStyle): search order record\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``style`` is ``null``", 
               "sphinx_param_doc": "        :param style: search order record\n        :type style: ``osid.SearchOrderStyle``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``style`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.SearchOrderStyle", 
                     "var_name": "style", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.SearchOrderStyle"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "order_by_published", 
               "doc": {
                  "headline": "Specifies a preference for grouping the result set by published status.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    style (osid.SearchOrderStyle): search order record\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``style`` is ``null``", 
               "sphinx_param_doc": "        :param style: search order record\n        :type style: ``osid.SearchOrderStyle``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``style`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.SearchOrderStyle", 
                     "var_name": "style", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.SearchOrderStyle"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "order_by_published_date", 
               "doc": {
                  "headline": "Specifies a preference for ordering the result set by published date.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    style (osid.SearchOrderStyle): search order record\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``style`` is ``null``", 
               "sphinx_param_doc": "        :param style: search order record\n        :type style: ``osid.SearchOrderStyle``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``style`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.SearchOrderStyle", 
                     "var_name": "style", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.SearchOrderStyle"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "order_by_principal_credit_string", 
               "doc": {
                  "headline": "Specifies a preference for ordering the result set by the principal credit string.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    style (osid.SearchOrderStyle): search order record\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``style`` is ``null``", 
               "sphinx_param_doc": "        :param style: search order record\n        :type style: ``osid.SearchOrderStyle``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``style`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.SearchOrderStyle", 
                     "var_name": "style", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.SearchOrderStyle"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "order_by_temporal_coverage", 
               "doc": {
                  "headline": "Specifies a preference for ordering the result set by temporal coverage.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    style (osid.SearchOrderStyle): search order record\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``style`` is ``null``", 
               "sphinx_param_doc": "        :param style: search order record\n        :type style: ``osid.SearchOrderStyle``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``style`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.SearchOrderStyle", 
                     "var_name": "style", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.SearchOrderStyle"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "get_asset_search_order_record", 
               "doc": {
                  "headline": "Gets the asset search order record corresponding to the given asset record ``Type``.", 
                  "body": "        Multiple retrievals return the same underlying object."
               }, 
               "arg_doc": "        arg:    asset_record_type (osid.type.Type): an asset record type\n", 
               "return_doc": "        return: (osid.repository.records.AssetSearchOrderRecord) - the\n                asset search order record", 
               "error_doc": "        raise:  NullArgument - ``asset_record_type`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unsupported - ``has_record_type(asset_record_type)`` is\n                ``false``", 
               "sphinx_param_doc": "        :param asset_record_type: an asset record type\n        :type asset_record_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "        :return: the asset search order record\n        :rtype: ``osid.repository.records.AssetSearchOrderRecord``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``asset_record_type`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unsupported`` -- ``has_record_type(asset_record_type)`` is ``false``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "asset_record_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "osid.repository.records.AssetSearchOrderRecord", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.repository.records.AssetSearchOrderRecord", 
         "shortname": "AssetSearchOrderRecord", 
         "category": "records", 
         "doc": {
            "headline": "A record for an ``AssetSearchOrder``.", 
            "body": "    The methods specified by the record type are available through the\n    underlying object."
         }, 
         "inherit_fullnames": [
            "osid.OsidRecord"
         ], 
         "inherit_shortnames": [
            "OsidRecord"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidRecord"
            }
         ], 
         "method_names": [], 
         "methods": []
      }, 
      {
         "fullname": "osid.repository.AssetSearch", 
         "shortname": "AssetSearch", 
         "category": "searches", 
         "doc": {
            "headline": "The search interface for governing asset searches.", 
            "body": ""
         }, 
         "inherit_fullnames": [
            "osid.OsidSearch"
         ], 
         "inherit_shortnames": [
            "OsidSearch"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidSearch"
            }
         ], 
         "method_names": [
            "search_among_assets", 
            "order_asset_results", 
            "get_asset_search_record"
         ], 
         "methods": [
            {
               "name": "search_among_assets", 
               "doc": {
                  "headline": "Execute this search among the given list of assets.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    asset_ids (osid.id.IdList): list of asset ``Ids``\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``asset_ids`` is ``null``", 
               "sphinx_param_doc": "        :param asset_ids: list of asset ``Ids``\n        :type asset_ids: ``osid.id.IdList``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``asset_ids`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.IdList", 
                     "var_name": "asset_ids", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.IdList"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "order_asset_results", 
               "doc": {
                  "headline": "Specify an ordering to the search results.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    asset_search_order (osid.repository.AssetSearchOrder):\n                asset search order\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``asset_search_order`` is ``null``\n        raise:  Unsupported - ``asset_search_order`` is not of this\n                service", 
               "sphinx_param_doc": "        :param asset_search_order: asset search order\n        :type asset_search_order: ``osid.repository.AssetSearchOrder``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``asset_search_order`` is ``null``\n        :raise: ``Unsupported`` -- ``asset_search_order`` is not of this service", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.repository.AssetSearchOrder", 
                     "var_name": "asset_search_order", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.repository.AssetSearchOrder"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_asset_search_record", 
               "doc": {
                  "headline": "Gets the asset search record corresponding to the given asset search record ``Type``.", 
                  "body": "        This method used to retrieve an object implementing the\n        requested record."
               }, 
               "arg_doc": "        arg:    asset_search_record_type (osid.type.Type): an asset\n                search record type\n", 
               "return_doc": "        return: (osid.repository.records.AssetSearchRecord) - the asset\n                search record", 
               "error_doc": "        raise:  NullArgument - ``asset_search_record_type`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unsupported -\n                ``has_record_type(asset_search_record_type)`` is\n                ``false``", 
               "sphinx_param_doc": "        :param asset_search_record_type: an asset search record type\n        :type asset_search_record_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "        :return: the asset search record\n        :rtype: ``osid.repository.records.AssetSearchRecord``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``asset_search_record_type`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unsupported`` -- ``has_record_type(asset_search_record_type)`` is ``false``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "asset_search_record_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "osid.repository.records.AssetSearchRecord", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.repository.records.AssetSearchRecord", 
         "shortname": "AssetSearchRecord", 
         "category": "records", 
         "doc": {
            "headline": "A record for an ``AssetSearch``.", 
            "body": "    The methods specified by the record type are available through the\n    underlying object."
         }, 
         "inherit_fullnames": [
            "osid.OsidRecord"
         ], 
         "inherit_shortnames": [
            "OsidRecord"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidRecord"
            }
         ], 
         "method_names": [], 
         "methods": []
      }, 
      {
         "fullname": "osid.repository.AssetSearchResults", 
         "shortname": "AssetSearchResults", 
         "category": "searches", 
         "doc": {
            "headline": "This interface provides a means to capture results of a search.", 
            "body": ""
         }, 
         "inherit_fullnames": [
            "osid.OsidSearchResults"
         ], 
         "inherit_shortnames": [
            "OsidSearchResults"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidSearchResults"
            }
         ], 
         "method_names": [
            "get_assets", 
            "get_asset_query_inspector", 
            "get_asset_search_results_record"
         ], 
         "methods": [
            {
               "name": "get_assets", 
               "doc": {
                  "headline": "Gets the asset list resulting from a search.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.repository.AssetList) - the asset list", 
               "error_doc": "        raise:  IllegalState - the list has already been retrieved", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the asset list\n        :rtype: ``osid.repository.AssetList``", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- the list has already been retrieved", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.repository.AssetList", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract"
               }
            }, 
            {
               "name": "get_asset_query_inspector", 
               "doc": {
                  "headline": "Gets the inspector for the query to examine the terms used in the search.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.repository.AssetQueryInspector) - the query\n                inspector", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the query inspector\n        :rtype: ``osid.repository.AssetQueryInspector``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.repository.AssetQueryInspector", 
               "errors": {}
            }, 
            {
               "name": "get_asset_search_results_record", 
               "doc": {
                  "headline": "Gets the asset search results record corresponding to the given asset search record ``Type``.", 
                  "body": "        This method is used to retrieve an object implementing the\n        requested record."
               }, 
               "arg_doc": "        arg:    asset_search_record_type (osid.type.Type): an asset\n                search record type\n", 
               "return_doc": "        return: (osid.repository.records.AssetSearchResultsRecord) - the\n                asset search results record", 
               "error_doc": "        raise:  NullArgument - ``asset_search_record_type`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unsupported -\n                ``has_record_type(asset_search_record_type)`` is\n                ``false``", 
               "sphinx_param_doc": "        :param asset_search_record_type: an asset search record type\n        :type asset_search_record_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "        :return: the asset search results record\n        :rtype: ``osid.repository.records.AssetSearchResultsRecord``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``asset_search_record_type`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unsupported`` -- ``has_record_type(asset_search_record_type)`` is ``false``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "asset_search_record_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "osid.repository.records.AssetSearchResultsRecord", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.repository.records.AssetSearchResultsRecord", 
         "shortname": "AssetSearchResultsRecord", 
         "category": "records", 
         "doc": {
            "headline": "A record for an ``AssetSearchResults``.", 
            "body": "    The methods specified by the record type are available through the\n    underlying object."
         }, 
         "inherit_fullnames": [
            "osid.OsidRecord"
         ], 
         "inherit_shortnames": [
            "OsidRecord"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidRecord"
            }
         ], 
         "method_names": [], 
         "methods": []
      }, 
      {
         "fullname": "osid.repository.AssetReceiver", 
         "shortname": "AssetReceiver", 
         "category": "receivers", 
         "doc": {
            "headline": "The asset receiver is the consumer supplied interface for receiving notifications pertaining to new, updated or deleted ``Asset`` objects.", 
            "body": ""
         }, 
         "inherit_fullnames": [
            "osid.OsidReceiver"
         ], 
         "inherit_shortnames": [
            "OsidReceiver"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidReceiver"
            }
         ], 
         "method_names": [
            "new_asset", 
            "changed_asset", 
            "deleted_asset"
         ], 
         "methods": [
            {
               "name": "new_asset", 
               "doc": {
                  "headline": "The callback for notifications of new assets.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    asset_id (osid.id.Id): the ``Id`` of the new ``Asset``\n", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "        :param asset_id: the ``Id`` of the new ``Asset``\n        :type asset_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "asset_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "changed_asset", 
               "doc": {
                  "headline": "The callback for notification of updated assets.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    asset_id (osid.id.Id): the ``Id`` of the updated\n                ``Asset``\n", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "        :param asset_id: the ``Id`` of the updated ``Asset``\n        :type asset_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "asset_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "deleted_asset", 
               "doc": {
                  "headline": "the callback for notification of deleted assets.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    asset_id (osid.id.Id): the ``Id`` of the deleted\n                ``Asset``\n", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "        :param asset_id: the ``Id`` of the deleted ``Asset``\n        :type asset_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "asset_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {}
            }
         ]
      }, 
      {
         "fullname": "osid.repository.AssetList", 
         "shortname": "AssetList", 
         "category": "objects", 
         "doc": {
            "headline": "Like all ``OsidLists,``  ``AssetList`` provides a means for accessing ``Asset`` elements sequentially either one at a time or many at a time.", 
            "body": "    Examples: while (al.hasNext()) { Asset asset = al.getNextAsset(); }\n\n    or\n      while (al.hasNext()) {\n           Asset[] assets = al.getNextAssets(al.available());\n      }\n    \n"
         }, 
         "inherit_fullnames": [
            "osid.OsidList"
         ], 
         "inherit_shortnames": [
            "OsidList"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidList"
            }
         ], 
         "method_names": [
            "get_next_asset", 
            "get_next_assets"
         ], 
         "methods": [
            {
               "name": "get_next_asset", 
               "doc": {
                  "headline": "Gets the next ``Asset`` in this list.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.repository.Asset) - the next ``Asset`` in this\n                list. The ``has_next()`` method should be used to test\n                that a next ``Asset`` is available before calling this\n                method.", 
               "error_doc": "        raise:  IllegalState - no more elements available in this list\n        raise:  OperationFailed - unable to complete request", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the next ``Asset`` in this list. The ``has_next()`` method should be used to test that a next ``Asset`` is available before calling this method.\n        :rtype: ``osid.repository.Asset``", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- no more elements available in this list\n        :raise: ``OperationFailed`` -- unable to complete request", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.repository.Asset", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational"
               }
            }, 
            {
               "name": "get_next_assets", 
               "doc": {
                  "headline": "Gets the next set of ``Assets`` in this list which must be less than or equal to the return from ``available()``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    n (cardinal): the number of ``Asset`` elements requested\n                which must be less than or equal to ``available()``\n", 
               "return_doc": "        return: (osid.repository.Asset) - an array of ``Asset``\n                elements.The length of the array is less than or equal\n                to the number specified.", 
               "error_doc": "        raise:  IllegalState - no more elements available in this list\n        raise:  OperationFailed - unable to complete request", 
               "sphinx_param_doc": "        :param n: the number of ``Asset`` elements requested which must be less than or equal to ``available()``\n        :type n: ``cardinal``\n", 
               "sphinx_return_doc": "        :return: an array of ``Asset`` elements.The length of the array is less than or equal to the number specified.\n        :rtype: ``osid.repository.Asset``", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- no more elements available in this list\n        :raise: ``OperationFailed`` -- unable to complete request", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "cardinal", 
                     "var_name": "n", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "cardinal"
               ], 
               "return_type": "osid.repository.Asset", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.repository.AssetContent", 
         "shortname": "AssetContent", 
         "category": "objects", 
         "doc": {
            "headline": "``AssetContent`` represents a version of content represented by an ``Asset``.", 
            "body": "    Although ``AssetContent`` is a separate ``OsidObject`` with its own\n    ``Id`` to distuinguish it from other content inside an ``Asset,\n    AssetContent`` can only be accessed through an ``Asset``.\n\n    Once an ``Asset`` is selected, multiple contents should be\n    negotiated using the size, fidelity, accessibility requirements or\n    application evnironment."
         }, 
         "inherit_fullnames": [
            "osid.OsidObject", 
            "osid.Subjugateable"
         ], 
         "inherit_shortnames": [
            "OsidObject", 
            "Subjugateable"
         ], 
         "inherit_pkg_names": [
            "osid", 
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidObject"
            }, 
            {
               "pkg_name": "osid", 
               "name": "Subjugateable"
            }
         ], 
         "method_names": [
            "get_asset_id", 
            "get_asset", 
            "get_accessibility_types", 
            "has_data_length", 
            "get_data_length", 
            "get_data", 
            "has_url", 
            "get_url", 
            "get_asset_content_record"
         ], 
         "methods": [
            {
               "name": "get_asset_id", 
               "doc": {
                  "headline": "Gets the ``Asset Id`` corresponding to this content.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.id.Id) - the asset ``Id``", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the asset ``Id``\n        :rtype: ``osid.id.Id``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.id.Id", 
               "errors": {}
            }, 
            {
               "name": "get_asset", 
               "doc": {
                  "headline": "Gets the ``Asset`` corresponding to this content.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.repository.Asset) - the asset", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the asset\n        :rtype: ``osid.repository.Asset``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.repository.Asset", 
               "errors": {}
            }, 
            {
               "name": "get_accessibility_types", 
               "doc": {
                  "headline": "Gets the accessibility types associated with this content.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.type.TypeList) - list of content accessibility\n                types", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: list of content accessibility types\n        :rtype: ``osid.type.TypeList``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.type.TypeList", 
               "errors": {}
            }, 
            {
               "name": "has_data_length", 
               "doc": {
                  "headline": "Tests if a data length is available.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if a length is available for this\n                content, ``false`` otherwise.", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if a length is available for this content, ``false`` otherwise.\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "get_data_length", 
               "doc": {
                  "headline": "Gets the length of the data represented by this content in bytes.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (cardinal) - the length of the data stream", 
               "error_doc": "        raise:  IllegalState - ``has_data_length()`` is ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the length of the data stream\n        :rtype: ``cardinal``", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- ``has_data_length()`` is ``false``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "cardinal", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract"
               }
            }, 
            {
               "name": "get_data", 
               "doc": {
                  "headline": "Gets the asset content data.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.transport.DataInputStream) - the length of the\n                content data", 
               "error_doc": "        raise:  OperationFailed - unable to complete request", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the length of the content data\n        :rtype: ``osid.transport.DataInputStream``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.transport.DataInputStream", 
               "errors": {
                  "OPERATION_FAILED": "Operational"
               }
            }, 
            {
               "name": "has_url", 
               "doc": {
                  "headline": "Tests if a URL is associated with this content.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if a URL is available, ``false``\n                otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if a URL is available, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "get_url", 
               "doc": {
                  "headline": "Gets the URL associated with this content for web-based retrieval.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (string) - the url for this data", 
               "error_doc": "        raise:  IllegalState - ``has_url()`` is ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the url for this data\n        :rtype: ``string``", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- ``has_url()`` is ``false``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "string", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract"
               }
            }, 
            {
               "name": "get_asset_content_record", 
               "doc": {
                  "headline": "Gets the asset content record corresponding to the given ``AssetContent`` record ``Type``.", 
                  "body": "        This method is used to retrieve an object implementing the\n        requested record. The ``asset_record_type`` may be the ``Type``\n        returned in ``get_record_types()`` or any of its parents in a\n        ``Type`` hierarchy where ``has_record_type(asset_record_type)``\n        is ``true`` ."
               }, 
               "arg_doc": "        arg:    asset_content_content_record_type (osid.type.Type): the\n                type of the record to retrieve\n", 
               "return_doc": "        return: (osid.repository.records.AssetContentRecord) - the asset\n                content record", 
               "error_doc": "        raise:  NullArgument - ``asset_content_record_type`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unsupported -\n                ``has_record_type(asset_content_record_type)`` is\n                ``false``", 
               "sphinx_param_doc": "        :param asset_content_content_record_type: the type of the record to retrieve\n        :type asset_content_content_record_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "        :return: the asset content record\n        :rtype: ``osid.repository.records.AssetContentRecord``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``asset_content_record_type`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unsupported`` -- ``has_record_type(asset_content_record_type)`` is ``false``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "asset_content_content_record_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "osid.repository.records.AssetContentRecord", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.repository.records.AssetContentRecord", 
         "shortname": "AssetContentRecord", 
         "category": "records", 
         "doc": {
            "headline": "A record for an ``AssetContent``.", 
            "body": "    The methods specified by the record type are available through the\n    underlying object."
         }, 
         "inherit_fullnames": [
            "osid.OsidRecord"
         ], 
         "inherit_shortnames": [
            "OsidRecord"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidRecord"
            }
         ], 
         "method_names": [], 
         "methods": []
      }, 
      {
         "fullname": "osid.repository.AssetContentQuery", 
         "shortname": "AssetContentQuery", 
         "category": "queries", 
         "doc": {
            "headline": "This is the query for searching asset contents.", 
            "body": "    Each method forms an ``AND`` term while multiple invocations of the\n    same method produce a nested ``OR``."
         }, 
         "inherit_fullnames": [
            "osid.OsidObjectQuery", 
            "osid.OsidSubjugateableQuery"
         ], 
         "inherit_shortnames": [
            "OsidObjectQuery", 
            "OsidSubjugateableQuery"
         ], 
         "inherit_pkg_names": [
            "osid", 
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidObjectQuery"
            }, 
            {
               "pkg_name": "osid", 
               "name": "OsidSubjugateableQuery"
            }
         ], 
         "method_names": [
            "match_accessibility_type", 
            "match_any_accessibility_type", 
            "clear_accessibility_type_terms", 
            "match_data_length", 
            "match_any_data_length", 
            "clear_data_length_terms", 
            "match_data", 
            "match_any_data", 
            "clear_data_terms", 
            "match_url", 
            "match_any_url", 
            "clear_url_terms", 
            "get_asset_content_query_record"
         ], 
         "methods": [
            {
               "name": "match_accessibility_type", 
               "doc": {
                  "headline": "Sets the accessibility types for this query.", 
                  "body": "        Supplying multiple types behaves like a boolean OR among the\n        elements."
               }, 
               "arg_doc": "        arg:    accessibility_type (osid.type.Type): an\n                accessibilityType\n        arg:    match (boolean): ``true`` for a positive match,\n                ``false`` for a negative match\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``accessibility_type`` is ``null``", 
               "sphinx_param_doc": "        :param accessibility_type: an accessibilityType\n        :type accessibility_type: ``osid.type.Type``\n        :param match: ``true`` for a positive match, ``false`` for a negative match\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``accessibility_type`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "accessibility_type", 
                     "array": false
                  }, 
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type", 
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "match_any_accessibility_type", 
               "doc": {
                  "headline": "Matches asset content that has any accessibility type.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    match (boolean): ``true`` to match content with any\n                accessibility type, ``false`` to match content with no\n                accessibility type\n", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "        :param match: ``true`` to match content with any accessibility type, ``false`` to match content with no accessibility type\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "clear_accessibility_type_terms", 
               "doc": {
                  "headline": "Clears the accessibility terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "match_data_length", 
               "doc": {
                  "headline": "Matches content whose length of the data in bytes are inclusive of the given range.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    low (cardinal): low range\n        arg:    high (cardinal): high range\n        arg:    match (boolean): ``true`` for a positive match,\n                ``false`` for a negative match\n", 
               "return_doc": "", 
               "error_doc": "        raise:  InvalidArgument - ``low`` is greater than ``high``", 
               "sphinx_param_doc": "        :param low: low range\n        :type low: ``cardinal``\n        :param high: high range\n        :type high: ``cardinal``\n        :param match: ``true`` for a positive match, ``false`` for a negative match\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``InvalidArgument`` -- ``low`` is greater than ``high``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "cardinal", 
                     "var_name": "low", 
                     "array": false
                  }, 
                  {
                     "arg_type": "cardinal", 
                     "var_name": "high", 
                     "array": false
                  }, 
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "cardinal", 
                  "cardinal", 
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {
                  "INVALID_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "match_any_data_length", 
               "doc": {
                  "headline": "Matches content that has any data length.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    match (boolean): ``true`` to match content with any data\n                length, ``false`` to match content with no data length\n", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "        :param match: ``true`` to match content with any data length, ``false`` to match content with no data length\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "clear_data_length_terms", 
               "doc": {
                  "headline": "Clears the data length terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "match_data", 
               "doc": {
                  "headline": "Matches data in this content.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    data (byte[]): list of matching strings\n        arg:    match (boolean): ``true`` for a positive match,\n                ``false`` for a negative match\n        arg:    partial (boolean): ``true`` for a partial match,\n                ``false`` for a complete match\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``data`` is ``null``", 
               "sphinx_param_doc": "        :param data: list of matching strings\n        :type data: ``byte[]``\n        :param match: ``true`` for a positive match, ``false`` for a negative match\n        :type match: ``boolean``\n        :param partial: ``true`` for a partial match, ``false`` for a complete match\n        :type partial: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``data`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "byte[]", 
                     "var_name": "data", 
                     "array": true
                  }, 
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }, 
                  {
                     "arg_type": "boolean", 
                     "var_name": "partial", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "byte[]", 
                  "boolean", 
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "match_any_data", 
               "doc": {
                  "headline": "Matches content that has any data.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    match (boolean): ``true`` to match content with any\n                data, ``false`` to match content with no data\n", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "        :param match: ``true`` to match content with any data, ``false`` to match content with no data\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "clear_data_terms", 
               "doc": {
                  "headline": "Clears the data terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "match_url", 
               "doc": {
                  "headline": "Sets the url for this query.", 
                  "body": "        Supplying multiple strings behaves like a boolean ``OR`` among\n        the elements each which must correspond to the\n        ``stringMatchType``."
               }, 
               "arg_doc": "        arg:    url (string): url string to match\n        arg:    string_match_type (osid.type.Type): the string match\n                type\n        arg:    match (boolean): ``true`` for a positive match,\n                ``false`` for a negative match\n", 
               "return_doc": "", 
               "error_doc": "        raise:  InvalidArgument - ``url`` not of ``string_match_type``\n        raise:  NullArgument - ``url`` or ``string_match_type`` is\n                ``null``\n        raise:  Unsupported - ``supports_string_match_type(url)`` is\n                ``false``", 
               "sphinx_param_doc": "        :param url: url string to match\n        :type url: ``string``\n        :param string_match_type: the string match type\n        :type string_match_type: ``osid.type.Type``\n        :param match: ``true`` for a positive match, ``false`` for a negative match\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``InvalidArgument`` -- ``url`` not of ``string_match_type``\n        :raise: ``NullArgument`` -- ``url`` or ``string_match_type`` is ``null``\n        :raise: ``Unsupported`` -- ``supports_string_match_type(url)`` is ``false``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "string", 
                     "var_name": "url", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "string_match_type", 
                     "array": false
                  }, 
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "string", 
                  "osid.type.Type", 
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {
                  "INVALID_ARGUMENT": "ConsumerContract", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }, 
            {
               "name": "match_any_url", 
               "doc": {
                  "headline": "Matches content that has any url.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    match (boolean): ``true`` to match content with any url,\n                ``false`` to match content with no url\n", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "        :param match: ``true`` to match content with any url, ``false`` to match content with no url\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "clear_url_terms", 
               "doc": {
                  "headline": "Clears the url terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "get_asset_content_query_record", 
               "doc": {
                  "headline": "Gets the asset content query record corresponding to the given ``AssetContent`` record ``Type``.", 
                  "body": "        Multiple record retrievals produce a nested ``OR`` term."
               }, 
               "arg_doc": "        arg:    asset_content_record_type (osid.type.Type): an asset\n                content record type\n", 
               "return_doc": "        return: (osid.repository.records.AssetContentQueryRecord) - the\n                asset content query record", 
               "error_doc": "        raise:  NullArgument - ``asset_content_record_type`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unsupported -\n                ``has_record_type(asset_content_record_type)`` is\n                ``false``", 
               "sphinx_param_doc": "        :param asset_content_record_type: an asset content record type\n        :type asset_content_record_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "        :return: the asset content query record\n        :rtype: ``osid.repository.records.AssetContentQueryRecord``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``asset_content_record_type`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unsupported`` -- ``has_record_type(asset_content_record_type)`` is ``false``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "asset_content_record_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "osid.repository.records.AssetContentQueryRecord", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.repository.records.AssetContentQueryRecord", 
         "shortname": "AssetContentQueryRecord", 
         "category": "records", 
         "doc": {
            "headline": "A record for an ``AssetContentQuery``.", 
            "body": "    The methods specified by the record type are available through the\n    underlying object."
         }, 
         "inherit_fullnames": [
            "osid.OsidRecord"
         ], 
         "inherit_shortnames": [
            "OsidRecord"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidRecord"
            }
         ], 
         "method_names": [], 
         "methods": []
      }, 
      {
         "fullname": "osid.repository.AssetContentQueryInspector", 
         "shortname": "AssetContentQueryInspector", 
         "category": "query_inspectors", 
         "doc": {
            "headline": "This is the query inspector for examining asset content queries.", 
            "body": ""
         }, 
         "inherit_fullnames": [
            "osid.OsidObjectQueryInspector", 
            "osid.OsidSubjugateableQueryInspector"
         ], 
         "inherit_shortnames": [
            "OsidObjectQueryInspector", 
            "OsidSubjugateableQueryInspector"
         ], 
         "inherit_pkg_names": [
            "osid", 
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidObjectQueryInspector"
            }, 
            {
               "pkg_name": "osid", 
               "name": "OsidSubjugateableQueryInspector"
            }
         ], 
         "method_names": [
            "get_accessibility_type_terms", 
            "get_data_length_terms", 
            "get_data_terms", 
            "get_url_terms", 
            "get_asset_content_query_inspector_record"
         ], 
         "methods": [
            {
               "name": "get_accessibility_type_terms", 
               "doc": {
                  "headline": "Gets the accesibility type query terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.search.terms.TypeTerm) - the query terms", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the query terms\n        :rtype: ``osid.search.terms.TypeTerm``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.search.terms.TypeTerm", 
               "errors": {}
            }, 
            {
               "name": "get_data_length_terms", 
               "doc": {
                  "headline": "Gets the data length query terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.search.terms.CardinalRangeTerm) - the query terms", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the query terms\n        :rtype: ``osid.search.terms.CardinalRangeTerm``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.search.terms.CardinalRangeTerm", 
               "errors": {}
            }, 
            {
               "name": "get_data_terms", 
               "doc": {
                  "headline": "Gets the data query terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.search.terms.BytesTerm) - the query terms", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the query terms\n        :rtype: ``osid.search.terms.BytesTerm``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.search.terms.BytesTerm", 
               "errors": {}
            }, 
            {
               "name": "get_url_terms", 
               "doc": {
                  "headline": "Gets the url query terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.search.terms.StringTerm) - the query terms", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the query terms\n        :rtype: ``osid.search.terms.StringTerm``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.search.terms.StringTerm", 
               "errors": {}
            }, 
            {
               "name": "get_asset_content_query_inspector_record", 
               "doc": {
                  "headline": "Gets the asset content query inspector corresponding to the given ``AssetContent`` record ``Type``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    asset_content_record_type (osid.type.Type): an asset\n                content record type\n", 
               "return_doc": "        return:\n                (osid.repository.records.AssetContentQueryInspectorRecor\n                d) - the asset content query inspector record", 
               "error_doc": "        raise:  NullArgument - ``asset_content_record_type`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unsupported -\n                ``has_record_type(asset_content_record_type)`` is\n                ``false``", 
               "sphinx_param_doc": "        :param asset_content_record_type: an asset content record type\n        :type asset_content_record_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "        :return: the asset content query inspector record\n        :rtype: ``osid.repository.records.AssetContentQueryInspectorRecord``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``asset_content_record_type`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unsupported`` -- ``has_record_type(asset_content_record_type)`` is ``false``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "asset_content_record_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "osid.repository.records.AssetContentQueryInspectorRecord", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.repository.records.AssetContentQueryInspectorRecord", 
         "shortname": "AssetContentQueryInspectorRecord", 
         "category": "records", 
         "doc": {
            "headline": "A record for an ``AssetContentQueryInspector``.", 
            "body": "    The methods specified by the record type are available through the\n    underlying object."
         }, 
         "inherit_fullnames": [
            "osid.OsidRecord"
         ], 
         "inherit_shortnames": [
            "OsidRecord"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidRecord"
            }
         ], 
         "method_names": [], 
         "methods": []
      }, 
      {
         "fullname": "osid.repository.AssetContentForm", 
         "shortname": "AssetContentForm", 
         "category": "objects", 
         "doc": {
            "headline": "This is the form for creating and updating content for ``AssetContent``.", 
            "body": "    Like all ``OsidForm`` objects, various data elements may be set here\n    for use in the create and update methods in the\n    ``AssetAdminSession``. For each data element that may be set,\n    metadata may be examined to provide display hints or data\n    constraints."
         }, 
         "inherit_fullnames": [
            "osid.OsidObjectForm", 
            "osid.OsidSubjugateableForm"
         ], 
         "inherit_shortnames": [
            "OsidObjectForm", 
            "OsidSubjugateableForm"
         ], 
         "inherit_pkg_names": [
            "osid", 
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidObjectForm"
            }, 
            {
               "pkg_name": "osid", 
               "name": "OsidSubjugateableForm"
            }
         ], 
         "method_names": [
            "get_accessibility_type_metadata", 
            "add_accessibility_type", 
            "remove_accessibility_type", 
            "clear_accessibility_types", 
            "get_data_metadata", 
            "set_data", 
            "clear_data", 
            "get_url_metadata", 
            "set_url", 
            "clear_url", 
            "get_asset_content_form_record"
         ], 
         "methods": [
            {
               "name": "get_accessibility_type_metadata", 
               "doc": {
                  "headline": "Gets the metadata for an accessibility type.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.Metadata) - metadata for the accessibility types", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: metadata for the accessibility types\n        :rtype: ``osid.Metadata``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.Metadata", 
               "errors": {}
            }, 
            {
               "name": "add_accessibility_type", 
               "doc": {
                  "headline": "Adds an accessibility type.", 
                  "body": "        Multiple types can be added."
               }, 
               "arg_doc": "        arg:    accessibility_type (osid.type.Type): a new accessibility\n                type\n", 
               "return_doc": "", 
               "error_doc": "        raise:  InvalidArgument - ``accessibility_type`` is invalid\n        raise:  NoAccess - ``Metadata.isReadOnly()`` is ``true``\n        raise:  NullArgument - ``accessibility_t_ype`` is ``null``", 
               "sphinx_param_doc": "        :param accessibility_type: a new accessibility type\n        :type accessibility_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``InvalidArgument`` -- ``accessibility_type`` is invalid\n        :raise: ``NoAccess`` -- ``Metadata.isReadOnly()`` is ``true``\n        :raise: ``NullArgument`` -- ``accessibility_t_ype`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "accessibility_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "", 
               "errors": {
                  "INVALID_ARGUMENT": "ConsumerContract", 
                  "NO_ACCESS": "ConsumerContract", 
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "remove_accessibility_type", 
               "doc": {
                  "headline": "Removes an accessibility type.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    accessibility_type (osid.type.Type): accessibility type\n                to remove\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NoAccess - ``Metadata.isReadOnly()`` is ``true``\n        raise:  NotFound - acessibility type not found\n        raise:  NullArgument - ``accessibility_type`` is ``null``", 
               "sphinx_param_doc": "        :param accessibility_type: accessibility type to remove\n        :type accessibility_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NoAccess`` -- ``Metadata.isReadOnly()`` is ``true``\n        :raise: ``NotFound`` -- acessibility type not found\n        :raise: ``NullArgument`` -- ``accessibility_type`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "accessibility_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "", 
               "errors": {
                  "NO_ACCESS": "ConsumerContract", 
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "clear_accessibility_types", 
               "doc": {
                  "headline": "Removes all accessibility types.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "        raise:  NoAccess - ``Metadata.isReadOnly()`` is ``true``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NoAccess`` -- ``Metadata.isReadOnly()`` is ``true``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {
                  "NO_ACCESS": "ConsumerContract"
               }
            }, 
            {
               "name": "get_data_metadata", 
               "doc": {
                  "headline": "Gets the metadata for the content data.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.Metadata) - metadata for the content data", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: metadata for the content data\n        :rtype: ``osid.Metadata``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.Metadata", 
               "errors": {}
            }, 
            {
               "name": "set_data", 
               "doc": {
                  "headline": "Sets the content data.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    data (osid.transport.DataInputStream): the content data\n", 
               "return_doc": "", 
               "error_doc": "        raise:  InvalidArgument - ``data`` is invalid\n        raise:  NoAccess - ``Metadata.isReadOnly()`` is ``true``\n        raise:  NullArgument - ``data`` is ``null``", 
               "sphinx_param_doc": "        :param data: the content data\n        :type data: ``osid.transport.DataInputStream``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``InvalidArgument`` -- ``data`` is invalid\n        :raise: ``NoAccess`` -- ``Metadata.isReadOnly()`` is ``true``\n        :raise: ``NullArgument`` -- ``data`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.transport.DataInputStream", 
                     "var_name": "data", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.transport.DataInputStream"
               ], 
               "return_type": "", 
               "errors": {
                  "INVALID_ARGUMENT": "ConsumerContract", 
                  "NO_ACCESS": "ConsumerContract", 
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "clear_data", 
               "doc": {
                  "headline": "Removes the content data.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "        raise:  NoAccess - ``Metadata.isRequired()`` is ``true`` or\n                ``Metadata.isReadOnly()`` is ``true``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NoAccess`` -- ``Metadata.isRequired()`` is ``true`` or ``Metadata.isReadOnly()`` is ``true``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {
                  "NO_ACCESS": "ConsumerContract"
               }
            }, 
            {
               "name": "get_url_metadata", 
               "doc": {
                  "headline": "Gets the metadata for the url.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.Metadata) - metadata for the url", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: metadata for the url\n        :rtype: ``osid.Metadata``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.Metadata", 
               "errors": {}
            }, 
            {
               "name": "set_url", 
               "doc": {
                  "headline": "Sets the url.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    url (string): the new copyright\n", 
               "return_doc": "", 
               "error_doc": "        raise:  InvalidArgument - ``url`` is invalid\n        raise:  NoAccess - ``Metadata.isReadOnly()`` is ``true``\n        raise:  NullArgument - ``url`` is ``null``", 
               "sphinx_param_doc": "        :param url: the new copyright\n        :type url: ``string``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``InvalidArgument`` -- ``url`` is invalid\n        :raise: ``NoAccess`` -- ``Metadata.isReadOnly()`` is ``true``\n        :raise: ``NullArgument`` -- ``url`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "string", 
                     "var_name": "url", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "string"
               ], 
               "return_type": "", 
               "errors": {
                  "INVALID_ARGUMENT": "ConsumerContract", 
                  "NO_ACCESS": "ConsumerContract", 
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "clear_url", 
               "doc": {
                  "headline": "Removes the url.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "        raise:  NoAccess - ``Metadata.isRequired()`` is ``true`` or\n                ``Metadata.isReadOnly()`` is ``true``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NoAccess`` -- ``Metadata.isRequired()`` is ``true`` or ``Metadata.isReadOnly()`` is ``true``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {
                  "NO_ACCESS": "ConsumerContract"
               }
            }, 
            {
               "name": "get_asset_content_form_record", 
               "doc": {
                  "headline": "Gets the ``AssetContentFormRecord`` corresponding to the given asset content record ``Type``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    asset_content_record_type (osid.type.Type): an asset\n                content record type\n", 
               "return_doc": "        return: (osid.repository.records.AssetContentFormRecord) - the\n                asset content form record", 
               "error_doc": "        raise:  NullArgument - ``asset_content_record_type`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unsupported -\n                ``has_record_type(asset_content_record_type)`` is\n                ``false``", 
               "sphinx_param_doc": "        :param asset_content_record_type: an asset content record type\n        :type asset_content_record_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "        :return: the asset content form record\n        :rtype: ``osid.repository.records.AssetContentFormRecord``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``asset_content_record_type`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unsupported`` -- ``has_record_type(asset_content_record_type)`` is ``false``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "asset_content_record_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "osid.repository.records.AssetContentFormRecord", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.repository.records.AssetContentFormRecord", 
         "shortname": "AssetContentFormRecord", 
         "category": "records", 
         "doc": {
            "headline": "A record for an ``AssetForm``.", 
            "body": "    The methods specified by the record type are available through the\n    underlying object."
         }, 
         "inherit_fullnames": [
            "osid.OsidRecord"
         ], 
         "inherit_shortnames": [
            "OsidRecord"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidRecord"
            }
         ], 
         "method_names": [], 
         "methods": []
      }, 
      {
         "fullname": "osid.repository.AssetContentList", 
         "shortname": "AssetContentList", 
         "category": "objects", 
         "doc": {
            "headline": "Like all ``OsidLists,``  ``AssetContentList`` provides a means for accessing ``AssetContent`` elements sequentially either one at a time or many at a time.", 
            "body": "    Examples: while (acl.hasNext()) { AssetContent content =\n    acl.getNextAssetContent(); }\n\n    or\n      while (acl.hasNext()) {\n           AssetContent[] contents = acl.getNextAssetContents(acl.available());\n      }\n    \n"
         }, 
         "inherit_fullnames": [
            "osid.OsidList"
         ], 
         "inherit_shortnames": [
            "OsidList"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidList"
            }
         ], 
         "method_names": [
            "get_next_asset_content", 
            "get_next_asset_contents"
         ], 
         "methods": [
            {
               "name": "get_next_asset_content", 
               "doc": {
                  "headline": "Gets the next ``AssetContent`` in this list.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.repository.AssetContent) - the next\n                ``AssetContent`` in this list. The ``has_next()`` method\n                should be used to test that a next ``AssetContent`` is\n                available before calling this method.", 
               "error_doc": "        raise:  IllegalState - no more elements available in this list\n        raise:  OperationFailed - unable to complete request", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the next ``AssetContent`` in this list. The ``has_next()`` method should be used to test that a next ``AssetContent`` is available before calling this method.\n        :rtype: ``osid.repository.AssetContent``", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- no more elements available in this list\n        :raise: ``OperationFailed`` -- unable to complete request", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.repository.AssetContent", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational"
               }
            }, 
            {
               "name": "get_next_asset_contents", 
               "doc": {
                  "headline": "Gets the next set of ``AssetContents`` in this list which must be less than or equal to the return from ``available()``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    n (cardinal): the number of ``AssetContent`` elements\n                requested which must be less than or equal to\n                ``available()``\n", 
               "return_doc": "        return: (osid.repository.AssetContent) - an array of\n                ``AssetContent`` elements.The length of the array is\n                less than or equal to the number specified.", 
               "error_doc": "        raise:  IllegalState - no more elements available in this list\n        raise:  OperationFailed - unable to complete request", 
               "sphinx_param_doc": "        :param n: the number of ``AssetContent`` elements requested which must be less than or equal to ``available()``\n        :type n: ``cardinal``\n", 
               "sphinx_return_doc": "        :return: an array of ``AssetContent`` elements.The length of the array is less than or equal to the number specified.\n        :rtype: ``osid.repository.AssetContent``", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- no more elements available in this list\n        :raise: ``OperationFailed`` -- unable to complete request", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "cardinal", 
                     "var_name": "n", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "cardinal"
               ], 
               "return_type": "osid.repository.AssetContent", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.repository.Composition", 
         "shortname": "Composition", 
         "category": "objects", 
         "doc": {
            "headline": "A ``Composition`` represents an authenticatable identity.", 
            "body": "    Like all OSID objects, a ``Composition`` is identified by its Id and\n    any persisted references should use the Id."
         }, 
         "inherit_fullnames": [
            "osid.OsidObject", 
            "osid.Containable", 
            "osid.Operable", 
            "osid.Sourceable"
         ], 
         "inherit_shortnames": [
            "OsidObject", 
            "Containable", 
            "Operable", 
            "Sourceable"
         ], 
         "inherit_pkg_names": [
            "osid", 
            "osid", 
            "osid", 
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidObject"
            }, 
            {
               "pkg_name": "osid", 
               "name": "Containable"
            }, 
            {
               "pkg_name": "osid", 
               "name": "Operable"
            }, 
            {
               "pkg_name": "osid", 
               "name": "Sourceable"
            }
         ], 
         "method_names": [
            "get_children_ids", 
            "get_children", 
            "get_composition_record"
         ], 
         "methods": [
            {
               "name": "get_children_ids", 
               "doc": {
                  "headline": "Gets the child ``Ids`` of this composition.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.id.IdList) - the composition child ``Ids``", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the composition child ``Ids``\n        :rtype: ``osid.id.IdList``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.id.IdList", 
               "errors": {}
            }, 
            {
               "name": "get_children", 
               "doc": {
                  "headline": "Gets the children of this composition.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.repository.CompositionList) - the composition\n                children", 
               "error_doc": "        raise:  OperationFailed - unable to complete request", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the composition children\n        :rtype: ``osid.repository.CompositionList``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.repository.CompositionList", 
               "errors": {
                  "OPERATION_FAILED": "Operational"
               }
            }, 
            {
               "name": "get_composition_record", 
               "doc": {
                  "headline": "Gets the composition record corresponding to the given ``Composition`` record ``Type``.", 
                  "body": "        This method is used to retrieve an object implementing the\n        requested record. The ``composition_record_type`` may be the\n        ``Type`` returned in ``get_record_types()`` or any of its\n        parents in a ``Type`` hierarchy where\n        ``has_record_type(composition_record_type)`` is ``true`` ."
               }, 
               "arg_doc": "        arg:    composition_record_type (osid.type.Type): a composition\n                record type\n", 
               "return_doc": "        return: (osid.repository.records.CompositionRecord) - the\n                composition record", 
               "error_doc": "        raise:  NullArgument - ``composition_record_type`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unsupported -\n                ``has_record_type(composition_record_type)`` is\n                ``false``", 
               "sphinx_param_doc": "        :param composition_record_type: a composition record type\n        :type composition_record_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "        :return: the composition record\n        :rtype: ``osid.repository.records.CompositionRecord``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``composition_record_type`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unsupported`` -- ``has_record_type(composition_record_type)`` is ``false``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "composition_record_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "osid.repository.records.CompositionRecord", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.repository.records.CompositionRecord", 
         "shortname": "CompositionRecord", 
         "category": "records", 
         "doc": {
            "headline": "A record for a ``Composition``.", 
            "body": "    The methods specified by the record type are available through the\n    underlying object."
         }, 
         "inherit_fullnames": [
            "osid.OsidRecord"
         ], 
         "inherit_shortnames": [
            "OsidRecord"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidRecord"
            }
         ], 
         "method_names": [], 
         "methods": []
      }, 
      {
         "fullname": "osid.repository.CompositionQuery", 
         "shortname": "CompositionQuery", 
         "category": "queries", 
         "doc": {
            "headline": "This is the query for searching compositions.", 
            "body": "    Each method specifies an ``AND`` term while multiple invocations of\n    the same method produces a nested ``OR``."
         }, 
         "inherit_fullnames": [
            "osid.OsidObjectQuery", 
            "osid.OsidContainableQuery", 
            "osid.OsidOperableQuery", 
            "osid.OsidSourceableQuery"
         ], 
         "inherit_shortnames": [
            "OsidObjectQuery", 
            "OsidContainableQuery", 
            "OsidOperableQuery", 
            "OsidSourceableQuery"
         ], 
         "inherit_pkg_names": [
            "osid", 
            "osid", 
            "osid", 
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidObjectQuery"
            }, 
            {
               "pkg_name": "osid", 
               "name": "OsidContainableQuery"
            }, 
            {
               "pkg_name": "osid", 
               "name": "OsidOperableQuery"
            }, 
            {
               "pkg_name": "osid", 
               "name": "OsidSourceableQuery"
            }
         ], 
         "method_names": [
            "match_asset_id", 
            "clear_asset_id_terms", 
            "supports_asset_query", 
            "get_asset_query", 
            "match_any_asset", 
            "clear_asset_terms", 
            "match_containing_composition_id", 
            "clear_containing_composition_id_terms", 
            "supports_containing_composition_query", 
            "get_containing_composition_query", 
            "match_any_containing_composition", 
            "clear_containing_composition_terms", 
            "match_contained_composition_id", 
            "clear_contained_composition_id_terms", 
            "supports_contained_composition_query", 
            "get_contained_composition_query", 
            "match_any_contained_composition", 
            "clear_contained_composition_terms", 
            "match_repository_id", 
            "clear_repository_id_terms", 
            "supports_repository_query", 
            "get_repository_query", 
            "clear_repository_terms", 
            "get_composition_query_record"
         ], 
         "methods": [
            {
               "name": "match_asset_id", 
               "doc": {
                  "headline": "Sets the asset ``Id`` for this query.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    asset_id (osid.id.Id): the asset ``Id``\n        arg:    match (boolean): ``true`` for a positive match,\n                ``false`` for a negative match\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``asset_id`` is ``null``", 
               "sphinx_param_doc": "        :param asset_id: the asset ``Id``\n        :type asset_id: ``osid.id.Id``\n        :param match: ``true`` for a positive match, ``false`` for a negative match\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``asset_id`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "asset_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "clear_asset_id_terms", 
               "doc": {
                  "headline": "Clears the asset ``Id`` terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "supports_asset_query", 
               "doc": {
                  "headline": "Tests if an ``AssetQuery`` is available.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if an asset query is available,\n                ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if an asset query is available, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "get_asset_query", 
               "doc": {
                  "headline": "Gets the query for an asset.", 
                  "body": "        Multiple retrievals produce a nested ``OR`` term."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.repository.AssetQuery) - the asset query", 
               "error_doc": "        raise:  Unimplemented - ``supports_asset_query()`` is ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the asset query\n        :rtype: ``osid.repository.AssetQuery``", 
               "sphinx_error_doc": "        :raise: ``Unimplemented`` -- ``supports_asset_query()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_asset_query()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.repository.AssetQuery", 
               "errors": {
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "match_any_asset", 
               "doc": {
                  "headline": "Matches compositions that has any asset mapping.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    match (boolean): ``true`` to match compositions with any\n                asset, ``false`` to match compositions with no asset\n", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "        :param match: ``true`` to match compositions with any asset, ``false`` to match compositions with no asset\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "clear_asset_terms", 
               "doc": {
                  "headline": "Clears the asset terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "match_containing_composition_id", 
               "doc": {
                  "headline": "Sets the composition ``Id`` for this query to match compositions that have the specified composition as an ancestor.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    composition_id (osid.id.Id): a composition ``Id``\n        arg:    match (boolean): ``true`` for a positive match,\n                ``false`` for a negative match\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``composition_id`` is ``null``", 
               "sphinx_param_doc": "        :param composition_id: a composition ``Id``\n        :type composition_id: ``osid.id.Id``\n        :param match: ``true`` for a positive match, ``false`` for a negative match\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``composition_id`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "composition_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "clear_containing_composition_id_terms", 
               "doc": {
                  "headline": "Clears the containing composition ``Id`` terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "supports_containing_composition_query", 
               "doc": {
                  "headline": "Tests if an ``CompositionQuery`` is available.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if a composition query is\n                available, ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if a composition query is available, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "get_containing_composition_query", 
               "doc": {
                  "headline": "Gets the query for a composition.", 
                  "body": "        Multiple retrievals produce a nested ``OR`` term."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.repository.CompositionQuery) - the composition\n                query", 
               "error_doc": "        raise:  Unimplemented -\n                ``supports_containing_composition_query()`` is ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the composition query\n        :rtype: ``osid.repository.CompositionQuery``", 
               "sphinx_error_doc": "        :raise: ``Unimplemented`` -- ``supports_containing_composition_query()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_containing_composition_query()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.repository.CompositionQuery", 
               "errors": {
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "match_any_containing_composition", 
               "doc": {
                  "headline": "Matches compositions with any ancestor.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    match (boolean): ``true`` to match composition with any\n                ancestor, ``false`` to match root compositions\n", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "        :param match: ``true`` to match composition with any ancestor, ``false`` to match root compositions\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "clear_containing_composition_terms", 
               "doc": {
                  "headline": "Clears the containing composition terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "match_contained_composition_id", 
               "doc": {
                  "headline": "Sets the composition ``Id`` for this query to match compositions that contain the specified composition.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    composition_id (osid.id.Id): a composition ``Id``\n        arg:    match (boolean): ``true`` for a positive match,\n                ``false`` for a negative match\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``composition_id`` is ``null``", 
               "sphinx_param_doc": "        :param composition_id: a composition ``Id``\n        :type composition_id: ``osid.id.Id``\n        :param match: ``true`` for a positive match, ``false`` for a negative match\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``composition_id`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "composition_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "clear_contained_composition_id_terms", 
               "doc": {
                  "headline": "Clears the contained composition ``Id`` terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "supports_contained_composition_query", 
               "doc": {
                  "headline": "Tests if an ``CompositionQuery`` is available.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if a composition query is\n                available, ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if a composition query is available, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "get_contained_composition_query", 
               "doc": {
                  "headline": "Gets the query for a composition.", 
                  "body": "        Multiple retrievals produce a nested ``OR`` term."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.repository.CompositionQuery) - the composition\n                query", 
               "error_doc": "        raise:  Unimplemented -\n                ``supports_contained_composition_query()`` is ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the composition query\n        :rtype: ``osid.repository.CompositionQuery``", 
               "sphinx_error_doc": "        :raise: ``Unimplemented`` -- ``supports_contained_composition_query()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_contained_composition_query()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.repository.CompositionQuery", 
               "errors": {
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "match_any_contained_composition", 
               "doc": {
                  "headline": "Matches compositions that contain any other compositions.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    match (boolean): ``true`` to match composition with any\n                descendant, ``false`` to match leaf compositions\n", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "        :param match: ``true`` to match composition with any descendant, ``false`` to match leaf compositions\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "clear_contained_composition_terms", 
               "doc": {
                  "headline": "Clears the contained composition terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "match_repository_id", 
               "doc": {
                  "headline": "Sets the repository ``Id`` for this query.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    repository_id (osid.id.Id): the repository ``Id``\n        arg:    match (boolean): ``true`` for a positive match,\n                ``false`` for a negative match\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``repository_id`` is ``null``", 
               "sphinx_param_doc": "        :param repository_id: the repository ``Id``\n        :type repository_id: ``osid.id.Id``\n        :param match: ``true`` for a positive match, ``false`` for a negative match\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``repository_id`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "repository_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "clear_repository_id_terms", 
               "doc": {
                  "headline": "Clears the repository ``Id`` terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "supports_repository_query", 
               "doc": {
                  "headline": "Tests if a ``RepositoryQuery`` is available.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if a repository query is available,\n                ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if a repository query is available, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "get_repository_query", 
               "doc": {
                  "headline": "Gets the query for a repository.", 
                  "body": "        Multiple queries can be retrieved for a nested ``OR`` term."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.repository.RepositoryQuery) - the repository query", 
               "error_doc": "        raise:  Unimplemented - ``supports_repository_query()`` is\n                ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the repository query\n        :rtype: ``osid.repository.RepositoryQuery``", 
               "sphinx_error_doc": "        :raise: ``Unimplemented`` -- ``supports_repository_query()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_repository_query()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.repository.RepositoryQuery", 
               "errors": {
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "clear_repository_terms", 
               "doc": {
                  "headline": "Clears the repository terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "get_composition_query_record", 
               "doc": {
                  "headline": "Gets the composition query record corresponding to the given ``Composition`` record ``Type``.", 
                  "body": "        Multiple retrievals produce a nested ``OR`` term."
               }, 
               "arg_doc": "        arg:    composition_record_type (osid.type.Type): a composition\n                record type\n", 
               "return_doc": "        return: (osid.repository.records.CompositionQueryRecord) - the\n                composition query record", 
               "error_doc": "        raise:  NullArgument - ``composition_record_type`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unsupported -\n                ``has_record_type(composition_record_type)`` is\n                ``false``", 
               "sphinx_param_doc": "        :param composition_record_type: a composition record type\n        :type composition_record_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "        :return: the composition query record\n        :rtype: ``osid.repository.records.CompositionQueryRecord``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``composition_record_type`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unsupported`` -- ``has_record_type(composition_record_type)`` is ``false``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "composition_record_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "osid.repository.records.CompositionQueryRecord", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.repository.records.CompositionQueryRecord", 
         "shortname": "CompositionQueryRecord", 
         "category": "records", 
         "doc": {
            "headline": "A record for a ``CompositionQuery``.", 
            "body": "    The methods specified by the record type are available through the\n    underlying object."
         }, 
         "inherit_fullnames": [
            "osid.OsidRecord"
         ], 
         "inherit_shortnames": [
            "OsidRecord"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidRecord"
            }
         ], 
         "method_names": [], 
         "methods": []
      }, 
      {
         "fullname": "osid.repository.CompositionQueryInspector", 
         "shortname": "CompositionQueryInspector", 
         "category": "query_inspectors", 
         "doc": {
            "headline": "This is the query inspector for examining composition queries.", 
            "body": ""
         }, 
         "inherit_fullnames": [
            "osid.OsidObjectQueryInspector", 
            "osid.OsidContainableQueryInspector", 
            "osid.OsidOperableQueryInspector", 
            "osid.OsidSourceableQueryInspector"
         ], 
         "inherit_shortnames": [
            "OsidObjectQueryInspector", 
            "OsidContainableQueryInspector", 
            "OsidOperableQueryInspector", 
            "OsidSourceableQueryInspector"
         ], 
         "inherit_pkg_names": [
            "osid", 
            "osid", 
            "osid", 
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidObjectQueryInspector"
            }, 
            {
               "pkg_name": "osid", 
               "name": "OsidContainableQueryInspector"
            }, 
            {
               "pkg_name": "osid", 
               "name": "OsidOperableQueryInspector"
            }, 
            {
               "pkg_name": "osid", 
               "name": "OsidSourceableQueryInspector"
            }
         ], 
         "method_names": [
            "get_asset_id_terms", 
            "get_asset_terms", 
            "get_containing_composition_id_terms", 
            "get_containing_composition_terms", 
            "get_contained_composition_id_terms", 
            "get_contained_composition_terms", 
            "get_repository_id_terms", 
            "get_repository_terms", 
            "get_composition_query_inspector_record"
         ], 
         "methods": [
            {
               "name": "get_asset_id_terms", 
               "doc": {
                  "headline": "Gets the asset ``Id`` query terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.search.terms.IdTerm) - the query terms", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the query terms\n        :rtype: ``osid.search.terms.IdTerm``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.search.terms.IdTerm", 
               "errors": {}
            }, 
            {
               "name": "get_asset_terms", 
               "doc": {
                  "headline": "Gets the asset query terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.repository.AssetQueryInspector) - the query terms", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the query terms\n        :rtype: ``osid.repository.AssetQueryInspector``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.repository.AssetQueryInspector", 
               "errors": {}
            }, 
            {
               "name": "get_containing_composition_id_terms", 
               "doc": {
                  "headline": "Gets the containing composition ``Id`` query terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.search.terms.IdTerm) - the query terms", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the query terms\n        :rtype: ``osid.search.terms.IdTerm``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.search.terms.IdTerm", 
               "errors": {}
            }, 
            {
               "name": "get_containing_composition_terms", 
               "doc": {
                  "headline": "Gets the containing composition query terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.repository.CompositionQueryInspector) - the query\n                terms", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the query terms\n        :rtype: ``osid.repository.CompositionQueryInspector``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.repository.CompositionQueryInspector", 
               "errors": {}
            }, 
            {
               "name": "get_contained_composition_id_terms", 
               "doc": {
                  "headline": "Gets the contained composition ``Id`` query terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.search.terms.IdTerm) - the query terms", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the query terms\n        :rtype: ``osid.search.terms.IdTerm``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.search.terms.IdTerm", 
               "errors": {}
            }, 
            {
               "name": "get_contained_composition_terms", 
               "doc": {
                  "headline": "Gets the contained composition query terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.repository.CompositionQueryInspector) - the query\n                terms", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the query terms\n        :rtype: ``osid.repository.CompositionQueryInspector``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.repository.CompositionQueryInspector", 
               "errors": {}
            }, 
            {
               "name": "get_repository_id_terms", 
               "doc": {
                  "headline": "Gets the repository ``Id`` query terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.search.terms.IdTerm) - the query terms", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the query terms\n        :rtype: ``osid.search.terms.IdTerm``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.search.terms.IdTerm", 
               "errors": {}
            }, 
            {
               "name": "get_repository_terms", 
               "doc": {
                  "headline": "Gets the repository query terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.repository.RepositoryQueryInspector) - the query\n                terms", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the query terms\n        :rtype: ``osid.repository.RepositoryQueryInspector``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.repository.RepositoryQueryInspector", 
               "errors": {}
            }, 
            {
               "name": "get_composition_query_inspector_record", 
               "doc": {
                  "headline": "Gets the composition query inspector record corresponding to the given ``Composition`` record ``Type``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    composition_record_type (osid.type.Type): a composition\n                record type\n", 
               "return_doc": "        return:\n                (osid.repository.records.CompositionQueryInspectorRecord\n                ) - the composition query inspector record", 
               "error_doc": "        raise:  NullArgument - ``composition_record_type`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unsupported -\n                ``has_record_type(composition_record_type)`` is\n                ``false``", 
               "sphinx_param_doc": "        :param composition_record_type: a composition record type\n        :type composition_record_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "        :return: the composition query inspector record\n        :rtype: ``osid.repository.records.CompositionQueryInspectorRecord``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``composition_record_type`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unsupported`` -- ``has_record_type(composition_record_type)`` is ``false``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "composition_record_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "osid.repository.records.CompositionQueryInspectorRecord", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.repository.records.CompositionQueryInspectorRecord", 
         "shortname": "CompositionQueryInspectorRecord", 
         "category": "records", 
         "doc": {
            "headline": "A record for a ``CompositionQueryInspector``.", 
            "body": "    The methods specified by the record type are available through the\n    underlying object."
         }, 
         "inherit_fullnames": [
            "osid.OsidRecord"
         ], 
         "inherit_shortnames": [
            "OsidRecord"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidRecord"
            }
         ], 
         "method_names": [], 
         "methods": []
      }, 
      {
         "fullname": "osid.repository.CompositionForm", 
         "shortname": "CompositionForm", 
         "category": "objects", 
         "doc": {
            "headline": "This is the form for creating and updating ``Compositions``.", 
            "body": "    Like all ``OsidForm`` objects, various data elements may be set here\n    for use in the create and update methods in the\n    ``CompositionAdminSession``. For each data element that may be set,\n    metadata may be examined to provide display hints or data\n    constraints."
         }, 
         "inherit_fullnames": [
            "osid.OsidObjectForm", 
            "osid.OsidContainableForm", 
            "osid.OsidOperableForm", 
            "osid.OsidSourceableForm"
         ], 
         "inherit_shortnames": [
            "OsidObjectForm", 
            "OsidContainableForm", 
            "OsidOperableForm", 
            "OsidSourceableForm"
         ], 
         "inherit_pkg_names": [
            "osid", 
            "osid", 
            "osid", 
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidObjectForm"
            }, 
            {
               "pkg_name": "osid", 
               "name": "OsidContainableForm"
            }, 
            {
               "pkg_name": "osid", 
               "name": "OsidOperableForm"
            }, 
            {
               "pkg_name": "osid", 
               "name": "OsidSourceableForm"
            }
         ], 
         "method_names": [
            "get_composition_form_record"
         ], 
         "methods": [
            {
               "name": "get_composition_form_record", 
               "doc": {
                  "headline": "Gets the ``CompositionFormRecord`` corresponding to the given repository record ``Type``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    composition_record_type (osid.type.Type): a composition\n                record type\n", 
               "return_doc": "        return: (osid.repository.records.CompositionFormRecord) - the\n                composition form record", 
               "error_doc": "        raise:  NullArgument - ``composition_record_type`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unsupported -\n                ``has_record_type(composition_record_type)`` is\n                ``false``", 
               "sphinx_param_doc": "        :param composition_record_type: a composition record type\n        :type composition_record_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "        :return: the composition form record\n        :rtype: ``osid.repository.records.CompositionFormRecord``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``composition_record_type`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unsupported`` -- ``has_record_type(composition_record_type)`` is ``false``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "composition_record_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "osid.repository.records.CompositionFormRecord", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.repository.records.CompositionFormRecord", 
         "shortname": "CompositionFormRecord", 
         "category": "records", 
         "doc": {
            "headline": "A record for a ``CompositionForm``.", 
            "body": "    The methods specified by the record type are available through the\n    underlying object."
         }, 
         "inherit_fullnames": [
            "osid.OsidRecord"
         ], 
         "inherit_shortnames": [
            "OsidRecord"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidRecord"
            }
         ], 
         "method_names": [], 
         "methods": []
      }, 
      {
         "fullname": "osid.repository.CompositionSearchOrder", 
         "shortname": "CompositionSearchOrder", 
         "category": "search_orders", 
         "doc": {
            "headline": "An interface for specifying the ordering of search results.", 
            "body": ""
         }, 
         "inherit_fullnames": [
            "osid.OsidObjectSearchOrder", 
            "osid.OsidContainableSearchOrder", 
            "osid.OsidOperableSearchOrder", 
            "osid.OsidSourceableSearchOrder"
         ], 
         "inherit_shortnames": [
            "OsidObjectSearchOrder", 
            "OsidContainableSearchOrder", 
            "OsidOperableSearchOrder", 
            "OsidSourceableSearchOrder"
         ], 
         "inherit_pkg_names": [
            "osid", 
            "osid", 
            "osid", 
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidObjectSearchOrder"
            }, 
            {
               "pkg_name": "osid", 
               "name": "OsidContainableSearchOrder"
            }, 
            {
               "pkg_name": "osid", 
               "name": "OsidOperableSearchOrder"
            }, 
            {
               "pkg_name": "osid", 
               "name": "OsidSourceableSearchOrder"
            }
         ], 
         "method_names": [
            "get_composition_search_order_record"
         ], 
         "methods": [
            {
               "name": "get_composition_search_order_record", 
               "doc": {
                  "headline": "Gets the composition search order record corresponding to the given repository record ``Type``.", 
                  "body": "        Multiple retrievals return the same underlying object."
               }, 
               "arg_doc": "        arg:    composition_record_type (osid.type.Type): a composition\n                record type\n", 
               "return_doc": "        return: (osid.repository.records.CompositionSearchOrderRecord) -\n                the composition search order record", 
               "error_doc": "        raise:  NullArgument - ``composition_record_type`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure occurred\n        raise:  Unsupported -\n                ``has_record_type(composition_record_type)`` is\n                ``false``", 
               "sphinx_param_doc": "        :param composition_record_type: a composition record type\n        :type composition_record_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "        :return: the composition search order record\n        :rtype: ``osid.repository.records.CompositionSearchOrderRecord``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``composition_record_type`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure occurred\n        :raise: ``Unsupported`` -- ``has_record_type(composition_record_type)`` is ``false``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "composition_record_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "osid.repository.records.CompositionSearchOrderRecord", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.repository.records.CompositionSearchOrderRecord", 
         "shortname": "CompositionSearchOrderRecord", 
         "category": "records", 
         "doc": {
            "headline": "A record for a ``CompositionSearchOrder``.", 
            "body": "    The methods specified by the record type are available through the\n    underlying object."
         }, 
         "inherit_fullnames": [
            "osid.OsidRecord"
         ], 
         "inherit_shortnames": [
            "OsidRecord"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidRecord"
            }
         ], 
         "method_names": [], 
         "methods": []
      }, 
      {
         "fullname": "osid.repository.CompositionSearch", 
         "shortname": "CompositionSearch", 
         "category": "searches", 
         "doc": {
            "headline": "The interface for governing composition searches.", 
            "body": ""
         }, 
         "inherit_fullnames": [
            "osid.OsidSearch"
         ], 
         "inherit_shortnames": [
            "OsidSearch"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidSearch"
            }
         ], 
         "method_names": [
            "search_among_compositions", 
            "order_composition_results", 
            "get_composition_search_record"
         ], 
         "methods": [
            {
               "name": "search_among_compositions", 
               "doc": {
                  "headline": "Execute this search among the given list of compositions.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    composition_ids (osid.id.IdList): list of compositions\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``composition_ids`` is ``null``", 
               "sphinx_param_doc": "        :param composition_ids: list of compositions\n        :type composition_ids: ``osid.id.IdList``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``composition_ids`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.IdList", 
                     "var_name": "composition_ids", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.IdList"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "order_composition_results", 
               "doc": {
                  "headline": "Specify an ordering to the search results.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    composition_search_order\n                (osid.repository.CompositionSearchOrder): composition\n                search order\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``composition_search_order`` is ``null``\n        raise:  Unsupported - ``composition_search_order`` is not of\n                this service", 
               "sphinx_param_doc": "        :param composition_search_order: composition search order\n        :type composition_search_order: ``osid.repository.CompositionSearchOrder``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``composition_search_order`` is ``null``\n        :raise: ``Unsupported`` -- ``composition_search_order`` is not of this service", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.repository.CompositionSearchOrder", 
                     "var_name": "composition_search_order", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.repository.CompositionSearchOrder"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_composition_search_record", 
               "doc": {
                  "headline": "Gets the composition search record corresponding to the given composition search record ``Type``.", 
                  "body": "        This method is used to retrieve an object implementing the\n        requested record."
               }, 
               "arg_doc": "        arg:    composition_search_record_type (osid.type.Type): a\n                composition search record type\n", 
               "return_doc": "        return: (osid.repository.records.CompositionSearchRecord) - the\n                composition search record", 
               "error_doc": "        raise:  NullArgument - ``composition_search_record_type`` is\n                ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unsupported -\n                ``has_record_type(composition_search_record_type)`` is\n                ``false``", 
               "sphinx_param_doc": "        :param composition_search_record_type: a composition search record type\n        :type composition_search_record_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "        :return: the composition search record\n        :rtype: ``osid.repository.records.CompositionSearchRecord``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``composition_search_record_type`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unsupported`` -- ``has_record_type(composition_search_record_type)`` is ``false``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "composition_search_record_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "osid.repository.records.CompositionSearchRecord", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.repository.records.CompositionSearchRecord", 
         "shortname": "CompositionSearchRecord", 
         "category": "records", 
         "doc": {
            "headline": "A record for a ``CompositionSearch``.", 
            "body": "    The methods specified by the record type are available through the\n    underlying object."
         }, 
         "inherit_fullnames": [
            "osid.OsidRecord"
         ], 
         "inherit_shortnames": [
            "OsidRecord"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidRecord"
            }
         ], 
         "method_names": [], 
         "methods": []
      }, 
      {
         "fullname": "osid.repository.CompositionSearchResults", 
         "shortname": "CompositionSearchResults", 
         "category": "searches", 
         "doc": {
            "headline": "This interface provides a means to capture results of a search.", 
            "body": ""
         }, 
         "inherit_fullnames": [
            "osid.OsidSearchResults"
         ], 
         "inherit_shortnames": [
            "OsidSearchResults"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidSearchResults"
            }
         ], 
         "method_names": [
            "get_compositions", 
            "get_composition_query_inspector", 
            "get_composition_search_results_record"
         ], 
         "methods": [
            {
               "name": "get_compositions", 
               "doc": {
                  "headline": "Gets the composition list resulting from a search.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.repository.CompositionList) - the composition list", 
               "error_doc": "        raise:  IllegalState - the list has already been retrieved", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the composition list\n        :rtype: ``osid.repository.CompositionList``", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- the list has already been retrieved", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.repository.CompositionList", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract"
               }
            }, 
            {
               "name": "get_composition_query_inspector", 
               "doc": {
                  "headline": "Gets the inspector for the query to examine the terms used in the search.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.repository.CompositionQueryInspector) - the query\n                inspector", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the query inspector\n        :rtype: ``osid.repository.CompositionQueryInspector``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.repository.CompositionQueryInspector", 
               "errors": {}
            }, 
            {
               "name": "get_composition_search_results_record", 
               "doc": {
                  "headline": "Gets the composition search results record corresponding to the given composition search record ``Type``.", 
                  "body": "        This method is used to retrieve an object implementing the\n        requested record."
               }, 
               "arg_doc": "        arg:    composition_search_record_type (osid.type.Type): a\n                composition search record type\n", 
               "return_doc": "        return: (osid.repository.records.CompositionSearchResultsRecord)\n                - the composition search results record", 
               "error_doc": "        raise:  NullArgument - ``composition_search_record_type`` is\n                ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unsupported -\n                ``has_record_type(composition_search_record_type)`` is\n                ``false``", 
               "sphinx_param_doc": "        :param composition_search_record_type: a composition search record type\n        :type composition_search_record_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "        :return: the composition search results record\n        :rtype: ``osid.repository.records.CompositionSearchResultsRecord``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``composition_search_record_type`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unsupported`` -- ``has_record_type(composition_search_record_type)`` is ``false``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "composition_search_record_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "osid.repository.records.CompositionSearchResultsRecord", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.repository.records.CompositionSearchResultsRecord", 
         "shortname": "CompositionSearchResultsRecord", 
         "category": "records", 
         "doc": {
            "headline": "A record for a ``CompositionSearchResults``.", 
            "body": "    The methods specified by the record type are available through the\n    underlying object."
         }, 
         "inherit_fullnames": [
            "osid.OsidRecord"
         ], 
         "inherit_shortnames": [
            "OsidRecord"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidRecord"
            }
         ], 
         "method_names": [], 
         "methods": []
      }, 
      {
         "fullname": "osid.repository.CompositionReceiver", 
         "shortname": "CompositionReceiver", 
         "category": "receivers", 
         "doc": {
            "headline": "The composition receiver is the consumer supplied interface for receiving notifications pertaining to new, updated or deleted ``Composition`` objects.", 
            "body": ""
         }, 
         "inherit_fullnames": [
            "osid.OsidReceiver"
         ], 
         "inherit_shortnames": [
            "OsidReceiver"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidReceiver"
            }
         ], 
         "method_names": [
            "new_composition", 
            "new_composition_asset", 
            "new_composition_ancestor", 
            "new_composition_descendant", 
            "changed_composition", 
            "deleted_composition", 
            "deleted_composition_asset", 
            "deleted_composition_ancestor", 
            "deleted_composition_descendant"
         ], 
         "methods": [
            {
               "name": "new_composition", 
               "doc": {
                  "headline": "The callback for notifications of new compositions.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    composition_id (osid.id.Id): the ``Id`` of the new\n                ``Composition``\n", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "        :param composition_id: the ``Id`` of the new ``Composition``\n        :type composition_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "composition_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "new_composition_asset", 
               "doc": {
                  "headline": "The callback for notifications of new assets in the composition.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    asset_id (osid.id.Id): the ``Id`` of the new ``Asset``\n", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "        :param asset_id: the ``Id`` of the new ``Asset``\n        :type asset_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "asset_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "new_composition_ancestor", 
               "doc": {
                  "headline": "The callback for notifications of new composition ancestors.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    composition_id (osid.id.Id): the ``Id`` of the\n                ``Composition``\n        arg:    ancestor_id (osid.id.Id): the ``Id`` of the new\n                ``Composition`` descendant\n", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "        :param composition_id: the ``Id`` of the ``Composition``\n        :type composition_id: ``osid.id.Id``\n        :param ancestor_id: the ``Id`` of the new ``Composition`` descendant\n        :type ancestor_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "composition_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "ancestor_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "new_composition_descendant", 
               "doc": {
                  "headline": "The callback for notifications of new composition descendants.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    composition_id (osid.id.Id): the ``Id`` of the\n                ``Composition``\n        arg:    descendant_id (osid.id.Id): the ``Id`` of the new\n                ``Composition`` ancestor\n", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "        :param composition_id: the ``Id`` of the ``Composition``\n        :type composition_id: ``osid.id.Id``\n        :param descendant_id: the ``Id`` of the new ``Composition`` ancestor\n        :type descendant_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "composition_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "descendant_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "changed_composition", 
               "doc": {
                  "headline": "The callback for notification of updated compositions.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    composition_id (osid.id.Id): the ``Id`` of the updated\n                ``Composition``\n", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "        :param composition_id: the ``Id`` of the updated ``Composition``\n        :type composition_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "composition_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "deleted_composition", 
               "doc": {
                  "headline": "the callback for notification of deleted compositions.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    composition_id (osid.id.Id): the ``Id`` of the deleted\n                ``Composition``\n", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "        :param composition_id: the ``Id`` of the deleted ``Composition``\n        :type composition_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "composition_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "deleted_composition_asset", 
               "doc": {
                  "headline": "The callback for notifications of deleted assets from this composition.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    asset_id (osid.id.Id): the ``Id`` of the removed\n                ``Asset``\n", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "        :param asset_id: the ``Id`` of the removed ``Asset``\n        :type asset_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "asset_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "deleted_composition_ancestor", 
               "doc": {
                  "headline": "The callback for notifications of deleted composition ancestors.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    composition_id (osid.id.Id): the ``Id`` of the\n                ``Composition``\n        arg:    ancestor_id (osid.id.Id): the ``Id`` of the removed\n                ``Composition`` ancestor\n", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "        :param composition_id: the ``Id`` of the ``Composition``\n        :type composition_id: ``osid.id.Id``\n        :param ancestor_id: the ``Id`` of the removed ``Composition`` ancestor\n        :type ancestor_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "composition_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "ancestor_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "deleted_composition_descendant", 
               "doc": {
                  "headline": "The callback for notifications of deleted composition descendants.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    composition_id (osid.id.Id): the ``Id`` of the\n                ``Composition``\n        arg:    descendant_id (osid.id.Id): the ``Id`` of the removed\n                ``Composition`` descendant\n", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "        :param composition_id: the ``Id`` of the ``Composition``\n        :type composition_id: ``osid.id.Id``\n        :param descendant_id: the ``Id`` of the removed ``Composition`` descendant\n        :type descendant_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "composition_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "descendant_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {}
            }
         ]
      }, 
      {
         "fullname": "osid.repository.CompositionList", 
         "shortname": "CompositionList", 
         "category": "objects", 
         "doc": {
            "headline": "Like all ``OsidLists,``  ``CompositionList`` provides a means for accessing ``Composition`` elements sequentially either one at a time or many at a time.", 
            "body": "    Examples: while (cl.hasNext()) { Composition composition =\n    cl.getNextComposition(); }\n\n    or\n      while (cl.hasNext()) {\n           Composition[] compositions = cl.getNextCompositions(cl.available());\n      }\n    \n"
         }, 
         "inherit_fullnames": [
            "osid.OsidList"
         ], 
         "inherit_shortnames": [
            "OsidList"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidList"
            }
         ], 
         "method_names": [
            "get_next_composition", 
            "get_next_compositions"
         ], 
         "methods": [
            {
               "name": "get_next_composition", 
               "doc": {
                  "headline": "Gets the next ``Composition`` in this list.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.repository.Composition) - the next ``Composition``\n                in this list. The ``has_next()`` method should be used\n                to test that a next ``Composition`` is available before\n                calling this method.", 
               "error_doc": "        raise:  IllegalState - no more elements available in this list\n        raise:  OperationFailed - unable to complete request", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the next ``Composition`` in this list. The ``has_next()`` method should be used to test that a next ``Composition`` is available before calling this method.\n        :rtype: ``osid.repository.Composition``", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- no more elements available in this list\n        :raise: ``OperationFailed`` -- unable to complete request", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.repository.Composition", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational"
               }
            }, 
            {
               "name": "get_next_compositions", 
               "doc": {
                  "headline": "Gets the next set of ``Composition`` elements in this list which must be less than or equal to the return from ``available()``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    n (cardinal): the number of ``Composition`` elements\n                requested which must be less than or equal to\n                ``available()``\n", 
               "return_doc": "        return: (osid.repository.Composition) - an array of\n                ``Composition`` elements.The length of the array is less\n                than or equal to the number specified.", 
               "error_doc": "        raise:  IllegalState - no more elements available in this list\n        raise:  OperationFailed - unable to complete request", 
               "sphinx_param_doc": "        :param n: the number of ``Composition`` elements requested which must be less than or equal to ``available()``\n        :type n: ``cardinal``\n", 
               "sphinx_return_doc": "        :return: an array of ``Composition`` elements.The length of the array is less than or equal to the number specified.\n        :rtype: ``osid.repository.Composition``", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- no more elements available in this list\n        :raise: ``OperationFailed`` -- unable to complete request", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "cardinal", 
                     "var_name": "n", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "cardinal"
               ], 
               "return_type": "osid.repository.Composition", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.repository.Repository", 
         "shortname": "Repository", 
         "category": "objects", 
         "doc": {
            "headline": "A repository defines a collection of assets.", 
            "body": ""
         }, 
         "inherit_fullnames": [
            "osid.OsidCatalog"
         ], 
         "inherit_shortnames": [
            "OsidCatalog"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidCatalog"
            }
         ], 
         "method_names": [
            "get_repository_record"
         ], 
         "methods": [
            {
               "name": "get_repository_record", 
               "doc": {
                  "headline": "Gets the record corresponding to the given ``Repository`` record ``Type``.", 
                  "body": "        This method is used to retrieve an object implementing the\n        requested record. The ``repository_record_type`` may be the\n        ``Type`` returned in ``get_record_types()`` or any of its\n        parents in a ``Type`` hierarchy where\n        ``has_record_type(repository_record_type)`` is ``true`` ."
               }, 
               "arg_doc": "        arg:    repository_record_type (osid.type.Type): a repository\n                record type\n", 
               "return_doc": "        return: (osid.repository.records.RepositoryRecord) - the\n                repository record", 
               "error_doc": "        raise:  NullArgument - ``repository_record_type`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unsupported -\n                ``has_record_type(repository_record_type)`` is ``false``", 
               "sphinx_param_doc": "        :param repository_record_type: a repository record type\n        :type repository_record_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "        :return: the repository record\n        :rtype: ``osid.repository.records.RepositoryRecord``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``repository_record_type`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unsupported`` -- ``has_record_type(repository_record_type)`` is ``false``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "repository_record_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "osid.repository.records.RepositoryRecord", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.repository.records.RepositoryRecord", 
         "shortname": "RepositoryRecord", 
         "category": "records", 
         "doc": {
            "headline": "A record for a ``Repository``.", 
            "body": "    The methods specified by the record type are available through the\n    underlying object."
         }, 
         "inherit_fullnames": [
            "osid.OsidRecord"
         ], 
         "inherit_shortnames": [
            "OsidRecord"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidRecord"
            }
         ], 
         "method_names": [], 
         "methods": []
      }, 
      {
         "fullname": "osid.repository.RepositoryQuery", 
         "shortname": "RepositoryQuery", 
         "category": "queries", 
         "doc": {
            "headline": "This is the query for searching repositories.", 
            "body": "    Each method specifies an ``AND`` term while multiple invocations of\n    the same method produce a nested ``OR``."
         }, 
         "inherit_fullnames": [
            "osid.OsidCatalogQuery"
         ], 
         "inherit_shortnames": [
            "OsidCatalogQuery"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidCatalogQuery"
            }
         ], 
         "method_names": [
            "match_asset_id", 
            "clear_asset_id_terms", 
            "supports_asset_query", 
            "get_asset_query", 
            "match_any_asset", 
            "clear_asset_terms", 
            "match_composition_id", 
            "clear_composition_id_terms", 
            "supports_composition_query", 
            "get_composition_query", 
            "match_any_composition", 
            "clear_composition_terms", 
            "match_ancestor_repository_id", 
            "clear_ancestor_repository_id_terms", 
            "supports_ancestor_repository_query", 
            "get_ancestor_repository_query", 
            "match_any_ancestor_repository", 
            "clear_ancestor_repository_terms", 
            "match_descendant_repository_id", 
            "clear_descendant_repository_id_terms", 
            "supports_descendant_repository_query", 
            "get_descendant_repository_query", 
            "match_any_descendant_repository", 
            "clear_descendant_repository_terms", 
            "get_repository_query_record"
         ], 
         "methods": [
            {
               "name": "match_asset_id", 
               "doc": {
                  "headline": "Sets the asset ``Id`` for this query.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    asset_id (osid.id.Id): an asset ``Id``\n        arg:    match (boolean): ``true`` for a positive match,\n                ``false`` for a negative match\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``asset_id`` is ``null``", 
               "sphinx_param_doc": "        :param asset_id: an asset ``Id``\n        :type asset_id: ``osid.id.Id``\n        :param match: ``true`` for a positive match, ``false`` for a negative match\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``asset_id`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "asset_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "clear_asset_id_terms", 
               "doc": {
                  "headline": "Clears the asset ``Id`` terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "supports_asset_query", 
               "doc": {
                  "headline": "Tests if an ``AssetQuery`` is available.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if an asset query is available,\n                ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if an asset query is available, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "get_asset_query", 
               "doc": {
                  "headline": "Gets the query for an asset.", 
                  "body": "        Multiple retrievals produce a nested ``OR`` term."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.repository.AssetQuery) - the asset query", 
               "error_doc": "        raise:  Unimplemented - ``supports_asset_query()`` is ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the asset query\n        :rtype: ``osid.repository.AssetQuery``", 
               "sphinx_error_doc": "        :raise: ``Unimplemented`` -- ``supports_asset_query()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_asset_query()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.repository.AssetQuery", 
               "errors": {
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "match_any_asset", 
               "doc": {
                  "headline": "Matches repositories that has any asset mapping.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    match (boolean): ``true`` to match repositories with any\n                asset, ``false`` to match repositories with no asset\n", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "        :param match: ``true`` to match repositories with any asset, ``false`` to match repositories with no asset\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "clear_asset_terms", 
               "doc": {
                  "headline": "Clears the asset terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "match_composition_id", 
               "doc": {
                  "headline": "Sets the composition ``Id`` for this query.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    composition_id (osid.id.Id): a composition ``Id``\n        arg:    match (boolean): ``true`` for a positive match,\n                ``false`` for a negative match\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``composition_id`` is ``null``", 
               "sphinx_param_doc": "        :param composition_id: a composition ``Id``\n        :type composition_id: ``osid.id.Id``\n        :param match: ``true`` for a positive match, ``false`` for a negative match\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``composition_id`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "composition_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "clear_composition_id_terms", 
               "doc": {
                  "headline": "Clears the composition ``Id`` terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "supports_composition_query", 
               "doc": {
                  "headline": "Tests if a ``CompositionQuery`` is available.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if a composition query is\n                available, ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if a composition query is available, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "get_composition_query", 
               "doc": {
                  "headline": "Gets the query for a composition.", 
                  "body": "        Multiple retrievals produce a nested ``OR`` term."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.repository.CompositionQuery) - the composition\n                query", 
               "error_doc": "        raise:  Unimplemented - ``supports_composition_query()`` is\n                ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the composition query\n        :rtype: ``osid.repository.CompositionQuery``", 
               "sphinx_error_doc": "        :raise: ``Unimplemented`` -- ``supports_composition_query()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_composition_query()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.repository.CompositionQuery", 
               "errors": {
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "match_any_composition", 
               "doc": {
                  "headline": "Matches repositories that has any composition mapping.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    match (boolean): ``true`` to match repositories with any\n                composition, ``false`` to match repositories with no\n                composition\n", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "        :param match: ``true`` to match repositories with any composition, ``false`` to match repositories with no composition\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "clear_composition_terms", 
               "doc": {
                  "headline": "Clears the composition terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "match_ancestor_repository_id", 
               "doc": {
                  "headline": "Sets the repository ``Id`` for this query to match repositories that have the specified repository as an ancestor.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    repository_id (osid.id.Id): a repository ``Id``\n        arg:    match (boolean): ``true`` for a positive match,\n                ``false`` for a negative match\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``repository_id`` is ``null``", 
               "sphinx_param_doc": "        :param repository_id: a repository ``Id``\n        :type repository_id: ``osid.id.Id``\n        :param match: ``true`` for a positive match, ``false`` for a negative match\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``repository_id`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "repository_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "clear_ancestor_repository_id_terms", 
               "doc": {
                  "headline": "Clears the ancestor repository ``Id`` terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "supports_ancestor_repository_query", 
               "doc": {
                  "headline": "Tests if a ``RepositoryQuery`` is available.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if a repository query is available,\n                ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if a repository query is available, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "get_ancestor_repository_query", 
               "doc": {
                  "headline": "Gets the query for a repository.", 
                  "body": "        Multiple retrievals produce a nested ``OR`` term."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.repository.RepositoryQuery) - the repository query", 
               "error_doc": "        raise:  Unimplemented - ``supports_ancestor_repository_query()``\n                is ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the repository query\n        :rtype: ``osid.repository.RepositoryQuery``", 
               "sphinx_error_doc": "        :raise: ``Unimplemented`` -- ``supports_ancestor_repository_query()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_ancestor_repository_query()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.repository.RepositoryQuery", 
               "errors": {
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "match_any_ancestor_repository", 
               "doc": {
                  "headline": "Matches repositories with any ancestor.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    match (boolean): ``true`` to match repositories with any\n                ancestor, ``false`` to match root repositories\n", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "        :param match: ``true`` to match repositories with any ancestor, ``false`` to match root repositories\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "clear_ancestor_repository_terms", 
               "doc": {
                  "headline": "Clears the ancestor repository terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "match_descendant_repository_id", 
               "doc": {
                  "headline": "Sets the repository ``Id`` for this query to match repositories that have the specified repository as a descendant.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    repository_id (osid.id.Id): a repository ``Id``\n        arg:    match (boolean): ``true`` for a positive match,\n                ``false`` for a negative match\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``repository_id`` is ``null``", 
               "sphinx_param_doc": "        :param repository_id: a repository ``Id``\n        :type repository_id: ``osid.id.Id``\n        :param match: ``true`` for a positive match, ``false`` for a negative match\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``repository_id`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "repository_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "clear_descendant_repository_id_terms", 
               "doc": {
                  "headline": "Clears the descendant repository ``Id`` terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "supports_descendant_repository_query", 
               "doc": {
                  "headline": "Tests if a ``RepositoryQuery`` is available.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if a repository query is available,\n                ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if a repository query is available, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "get_descendant_repository_query", 
               "doc": {
                  "headline": "Gets the query for a repository.", 
                  "body": "        Multiple retrievals produce a nested ``OR`` term."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.repository.RepositoryQuery) - the repository query", 
               "error_doc": "        raise:  Unimplemented -\n                ``supports_descendant_repository_query()`` is ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the repository query\n        :rtype: ``osid.repository.RepositoryQuery``", 
               "sphinx_error_doc": "        :raise: ``Unimplemented`` -- ``supports_descendant_repository_query()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_descendant_repository_query()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.repository.RepositoryQuery", 
               "errors": {
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "match_any_descendant_repository", 
               "doc": {
                  "headline": "Matches repositories with any descendant.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    match (boolean): ``true`` to match repositories with any\n                descendant, ``false`` to match leaf repositories\n", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "        :param match: ``true`` to match repositories with any descendant, ``false`` to match leaf repositories\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "clear_descendant_repository_terms", 
               "doc": {
                  "headline": "Clears the descendant repository terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "get_repository_query_record", 
               "doc": {
                  "headline": "Gets the repository query record corresponding to the given ``Repository`` record ``Type``.", 
                  "body": "        Multiple record retrievals produce a nested ``OR`` term."
               }, 
               "arg_doc": "        arg:    repository_record_type (osid.type.Type): a repository\n                record type\n", 
               "return_doc": "        return: (osid.repository.records.RepositoryQueryRecord) - the\n                repository query record", 
               "error_doc": "        raise:  NullArgument - ``repository_record_type`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unsupported -\n                ``has_record_type(repository_record_type)`` is ``false``", 
               "sphinx_param_doc": "        :param repository_record_type: a repository record type\n        :type repository_record_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "        :return: the repository query record\n        :rtype: ``osid.repository.records.RepositoryQueryRecord``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``repository_record_type`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unsupported`` -- ``has_record_type(repository_record_type)`` is ``false``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "repository_record_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "osid.repository.records.RepositoryQueryRecord", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.repository.records.RepositoryQueryRecord", 
         "shortname": "RepositoryQueryRecord", 
         "category": "records", 
         "doc": {
            "headline": "A record for a ``RepositoryQuery``.", 
            "body": "    The methods specified by the record type are available through the\n    underlying object."
         }, 
         "inherit_fullnames": [
            "osid.OsidRecord"
         ], 
         "inherit_shortnames": [
            "OsidRecord"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidRecord"
            }
         ], 
         "method_names": [], 
         "methods": []
      }, 
      {
         "fullname": "osid.repository.RepositoryQueryInspector", 
         "shortname": "RepositoryQueryInspector", 
         "category": "query_inspectors", 
         "doc": {
            "headline": "This is the query inspector for examining repository queries.", 
            "body": ""
         }, 
         "inherit_fullnames": [
            "osid.OsidCatalogQueryInspector"
         ], 
         "inherit_shortnames": [
            "OsidCatalogQueryInspector"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidCatalogQueryInspector"
            }
         ], 
         "method_names": [
            "get_asset_id_terms", 
            "get_asset_terms", 
            "get_composition_id_terms", 
            "get_composition_terms", 
            "get_ancestor_repository_id_terms", 
            "get_ancestor_repository_terms", 
            "get_descendant_repository_id_terms", 
            "get_descendant_repository_terms", 
            "get_repository_query_inspector_record"
         ], 
         "methods": [
            {
               "name": "get_asset_id_terms", 
               "doc": {
                  "headline": "Gets the asset ``Id`` query terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.search.terms.IdTerm) - the query terms", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the query terms\n        :rtype: ``osid.search.terms.IdTerm``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.search.terms.IdTerm", 
               "errors": {}
            }, 
            {
               "name": "get_asset_terms", 
               "doc": {
                  "headline": "Gets the asset query terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.repository.AssetQueryInspector) - the query terms", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the query terms\n        :rtype: ``osid.repository.AssetQueryInspector``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.repository.AssetQueryInspector", 
               "errors": {}
            }, 
            {
               "name": "get_composition_id_terms", 
               "doc": {
                  "headline": "Gets the composition ``Id`` query terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.search.terms.IdTerm) - the query terms", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the query terms\n        :rtype: ``osid.search.terms.IdTerm``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.search.terms.IdTerm", 
               "errors": {}
            }, 
            {
               "name": "get_composition_terms", 
               "doc": {
                  "headline": "Gets the composition query terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.repository.CompositionQueryInspector) - the query\n                terms", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the query terms\n        :rtype: ``osid.repository.CompositionQueryInspector``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.repository.CompositionQueryInspector", 
               "errors": {}
            }, 
            {
               "name": "get_ancestor_repository_id_terms", 
               "doc": {
                  "headline": "Gets the ancestor repository ``Id`` query terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.search.terms.IdTerm) - the query terms", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the query terms\n        :rtype: ``osid.search.terms.IdTerm``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.search.terms.IdTerm", 
               "errors": {}
            }, 
            {
               "name": "get_ancestor_repository_terms", 
               "doc": {
                  "headline": "Gets the ancestor repository query terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.repository.RepositoryQueryInspector) - the query\n                terms", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the query terms\n        :rtype: ``osid.repository.RepositoryQueryInspector``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.repository.RepositoryQueryInspector", 
               "errors": {}
            }, 
            {
               "name": "get_descendant_repository_id_terms", 
               "doc": {
                  "headline": "Gets the descendant repository ``Id`` query terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.search.terms.IdTerm) - the query terms", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the query terms\n        :rtype: ``osid.search.terms.IdTerm``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.search.terms.IdTerm", 
               "errors": {}
            }, 
            {
               "name": "get_descendant_repository_terms", 
               "doc": {
                  "headline": "Gets the descendant repository query terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.repository.RepositoryQueryInspector) - the query\n                terms", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the query terms\n        :rtype: ``osid.repository.RepositoryQueryInspector``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.repository.RepositoryQueryInspector", 
               "errors": {}
            }, 
            {
               "name": "get_repository_query_inspector_record", 
               "doc": {
                  "headline": "Gets the repository query inspector record corresponding to the given ``Repository`` record ``Type``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    repository_record_type (osid.type.Type): a repository\n                record type\n", 
               "return_doc": "        return: (osid.repository.records.RepositoryQueryInspectorRecord)\n                - the repository query inspector record", 
               "error_doc": "        raise:  NullArgument - ``repository_record_type`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unsupported -\n                ``has_record_type(repository_record_type)`` is ``false``", 
               "sphinx_param_doc": "        :param repository_record_type: a repository record type\n        :type repository_record_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "        :return: the repository query inspector record\n        :rtype: ``osid.repository.records.RepositoryQueryInspectorRecord``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``repository_record_type`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unsupported`` -- ``has_record_type(repository_record_type)`` is ``false``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "repository_record_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "osid.repository.records.RepositoryQueryInspectorRecord", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.repository.records.RepositoryQueryInspectorRecord", 
         "shortname": "RepositoryQueryInspectorRecord", 
         "category": "records", 
         "doc": {
            "headline": "A record for a ``RepositoryQueryInspector``.", 
            "body": "    The methods specified by the record type are available through the\n    underlying object."
         }, 
         "inherit_fullnames": [
            "osid.OsidRecord"
         ], 
         "inherit_shortnames": [
            "OsidRecord"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidRecord"
            }
         ], 
         "method_names": [], 
         "methods": []
      }, 
      {
         "fullname": "osid.repository.RepositoryForm", 
         "shortname": "RepositoryForm", 
         "category": "objects", 
         "doc": {
            "headline": "This is the form for creating and updating repositories.", 
            "body": "    Like all ``OsidForm`` objects, various data elements may be set here\n    for use in the create and update methods in the\n    ``RepositoryAdminSession``. For each data element that may be set,\n    metadata may be examined to provide display hints or data\n    constraints."
         }, 
         "inherit_fullnames": [
            "osid.OsidCatalogForm"
         ], 
         "inherit_shortnames": [
            "OsidCatalogForm"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidCatalogForm"
            }
         ], 
         "method_names": [
            "get_repository_form_record"
         ], 
         "methods": [
            {
               "name": "get_repository_form_record", 
               "doc": {
                  "headline": "Gets the ``RepositoryFormRecord`` corresponding to the given repository record ``Type``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    repository_record_type (osid.type.Type): a repository\n                record type\n", 
               "return_doc": "        return: (osid.repository.records.RepositoryFormRecord) - the\n                repository form record", 
               "error_doc": "        raise:  NullArgument - ``repository_record_type`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unsupported -\n                ``has_record_type(repository_record_type)`` is ``false``", 
               "sphinx_param_doc": "        :param repository_record_type: a repository record type\n        :type repository_record_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "        :return: the repository form record\n        :rtype: ``osid.repository.records.RepositoryFormRecord``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``repository_record_type`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unsupported`` -- ``has_record_type(repository_record_type)`` is ``false``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "repository_record_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "osid.repository.records.RepositoryFormRecord", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.repository.records.RepositoryFormRecord", 
         "shortname": "RepositoryFormRecord", 
         "category": "records", 
         "doc": {
            "headline": "A record for a ``RepositoryForm``.", 
            "body": "    The methods specified by the record type are available through the\n    underlying object."
         }, 
         "inherit_fullnames": [
            "osid.OsidRecord"
         ], 
         "inherit_shortnames": [
            "OsidRecord"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidRecord"
            }
         ], 
         "method_names": [], 
         "methods": []
      }, 
      {
         "fullname": "osid.repository.RepositorySearchOrder", 
         "shortname": "RepositorySearchOrder", 
         "category": "search_orders", 
         "doc": {
            "headline": "An interface for specifying the ordering of search results.", 
            "body": ""
         }, 
         "inherit_fullnames": [
            "osid.OsidCatalogSearchOrder"
         ], 
         "inherit_shortnames": [
            "OsidCatalogSearchOrder"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidCatalogSearchOrder"
            }
         ], 
         "method_names": [
            "get_repository_search_order_record"
         ], 
         "methods": [
            {
               "name": "get_repository_search_order_record", 
               "doc": {
                  "headline": "Gets the repository search order record corresponding to the given repository record ``Type``.", 
                  "body": "        Multiple retrievals return the same underlying object."
               }, 
               "arg_doc": "        arg:    repository_record_type (osid.type.Type): a repository\n                record type\n", 
               "return_doc": "        return: (osid.repository.records.RepositorySearchOrderRecord) -\n                the repository search order record", 
               "error_doc": "        raise:  NullArgument - ``repository_record_type`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unsupported -\n                ``has_record_type(repository_record_type)`` is ``false``", 
               "sphinx_param_doc": "        :param repository_record_type: a repository record type\n        :type repository_record_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "        :return: the repository search order record\n        :rtype: ``osid.repository.records.RepositorySearchOrderRecord``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``repository_record_type`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unsupported`` -- ``has_record_type(repository_record_type)`` is ``false``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "repository_record_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "osid.repository.records.RepositorySearchOrderRecord", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.repository.records.RepositorySearchOrderRecord", 
         "shortname": "RepositorySearchOrderRecord", 
         "category": "records", 
         "doc": {
            "headline": "A record for a ``RepositorySearchOrder``.", 
            "body": "    The methods specified by the record type are available through the\n    underlying object."
         }, 
         "inherit_fullnames": [
            "osid.OsidRecord"
         ], 
         "inherit_shortnames": [
            "OsidRecord"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidRecord"
            }
         ], 
         "method_names": [], 
         "methods": []
      }, 
      {
         "fullname": "osid.repository.RepositorySearch", 
         "shortname": "RepositorySearch", 
         "category": "searches", 
         "doc": {
            "headline": "The interface for governing repository searches.", 
            "body": ""
         }, 
         "inherit_fullnames": [
            "osid.OsidSearch"
         ], 
         "inherit_shortnames": [
            "OsidSearch"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidSearch"
            }
         ], 
         "method_names": [
            "search_among_repositories", 
            "order_repository_results", 
            "get_repository_search_record"
         ], 
         "methods": [
            {
               "name": "search_among_repositories", 
               "doc": {
                  "headline": "Execute this search among the given list of repositories.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    repository_ids (osid.id.IdList): list of repositories\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``repository_ids`` is ``null``", 
               "sphinx_param_doc": "        :param repository_ids: list of repositories\n        :type repository_ids: ``osid.id.IdList``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``repository_ids`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.IdList", 
                     "var_name": "repository_ids", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.IdList"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "order_repository_results", 
               "doc": {
                  "headline": "Specify an ordering to the search results.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    repository_search_order\n                (osid.repository.RepositorySearchOrder): repository\n                search order\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``repository_search_order`` is ``null``\n        raise:  Unsupported - ``repository_search_order`` is not of this\n                service", 
               "sphinx_param_doc": "        :param repository_search_order: repository search order\n        :type repository_search_order: ``osid.repository.RepositorySearchOrder``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``repository_search_order`` is ``null``\n        :raise: ``Unsupported`` -- ``repository_search_order`` is not of this service", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.repository.RepositorySearchOrder", 
                     "var_name": "repository_search_order", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.repository.RepositorySearchOrder"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_repository_search_record", 
               "doc": {
                  "headline": "Gets the repository search record corresponding to the given repository search record ``Type``.", 
                  "body": "        This method is used to retrieve an object implementing the\n        requested record."
               }, 
               "arg_doc": "        arg:    repository_search_record_type (osid.type.Type): a\n                repository search record type\n", 
               "return_doc": "        return: (osid.repository.records.RepositorySearchRecord) - the\n                repository search record", 
               "error_doc": "        raise:  NullArgument - ``repository_search_record_type`` is\n                ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unsupported -\n                ``has_record_type(repository_search_record_type)`` is\n                ``false``", 
               "sphinx_param_doc": "        :param repository_search_record_type: a repository search record type\n        :type repository_search_record_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "        :return: the repository search record\n        :rtype: ``osid.repository.records.RepositorySearchRecord``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``repository_search_record_type`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unsupported`` -- ``has_record_type(repository_search_record_type)`` is ``false``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "repository_search_record_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "osid.repository.records.RepositorySearchRecord", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.repository.records.RepositorySearchRecord", 
         "shortname": "RepositorySearchRecord", 
         "category": "records", 
         "doc": {
            "headline": "A record for a ``RepositorySearch``.", 
            "body": "    The methods specified by the record type are available through the\n    underlying object."
         }, 
         "inherit_fullnames": [
            "osid.OsidRecord"
         ], 
         "inherit_shortnames": [
            "OsidRecord"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidRecord"
            }
         ], 
         "method_names": [], 
         "methods": []
      }, 
      {
         "fullname": "osid.repository.RepositorySearchResults", 
         "shortname": "RepositorySearchResults", 
         "category": "searches", 
         "doc": {
            "headline": "This interface provides a means to capture results of a search.", 
            "body": ""
         }, 
         "inherit_fullnames": [
            "osid.OsidSearchResults"
         ], 
         "inherit_shortnames": [
            "OsidSearchResults"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidSearchResults"
            }
         ], 
         "method_names": [
            "get_repositories", 
            "get_repository_query_inspector", 
            "get_repository_search_results_record"
         ], 
         "methods": [
            {
               "name": "get_repositories", 
               "doc": {
                  "headline": "Gets the repository list resulting from the search.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.repository.RepositoryList) - the repository list", 
               "error_doc": "        raise:  IllegalState - the list has already been retrieved", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the repository list\n        :rtype: ``osid.repository.RepositoryList``", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- the list has already been retrieved", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.repository.RepositoryList", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract"
               }
            }, 
            {
               "name": "get_repository_query_inspector", 
               "doc": {
                  "headline": "Gets the inspector for the query to examine the terms used in the search.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.repository.RepositoryQueryInspector) - the query\n                inspector", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the query inspector\n        :rtype: ``osid.repository.RepositoryQueryInspector``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.repository.RepositoryQueryInspector", 
               "errors": {}
            }, 
            {
               "name": "get_repository_search_results_record", 
               "doc": {
                  "headline": "Gets the repository search results record corresponding to the given repository search record ``Type``.", 
                  "body": "        This method is used to retrieve an object implementing the\n        requested record."
               }, 
               "arg_doc": "        arg:    repository_search_record_type (osid.type.Type): a\n                repository search record type\n", 
               "return_doc": "        return: (osid.repository.records.RepositorySearchResultsRecord)\n                - the repository search results record", 
               "error_doc": "        raise:  NullArgument - ``repository_search_record_type`` is\n                ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unsupported -\n                ``has_record_type(repository_search_record_type)`` is\n                ``false``", 
               "sphinx_param_doc": "        :param repository_search_record_type: a repository search record type\n        :type repository_search_record_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "        :return: the repository search results record\n        :rtype: ``osid.repository.records.RepositorySearchResultsRecord``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``repository_search_record_type`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unsupported`` -- ``has_record_type(repository_search_record_type)`` is ``false``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "repository_search_record_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "osid.repository.records.RepositorySearchResultsRecord", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.repository.records.RepositorySearchResultsRecord", 
         "shortname": "RepositorySearchResultsRecord", 
         "category": "records", 
         "doc": {
            "headline": "A record for a ``RepositorySearchResults``.", 
            "body": "    The methods specified by the record type are available through the\n    underlying object."
         }, 
         "inherit_fullnames": [
            "osid.OsidRecord"
         ], 
         "inherit_shortnames": [
            "OsidRecord"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidRecord"
            }
         ], 
         "method_names": [], 
         "methods": []
      }, 
      {
         "fullname": "osid.repository.RepositoryReceiver", 
         "shortname": "RepositoryReceiver", 
         "category": "receivers", 
         "doc": {
            "headline": "The repository receiver is the consumer supplied interface for receiving notifications pertaining to new, updated or deleted ``Repository`` objects.", 
            "body": ""
         }, 
         "inherit_fullnames": [
            "osid.OsidReceiver"
         ], 
         "inherit_shortnames": [
            "OsidReceiver"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidReceiver"
            }
         ], 
         "method_names": [
            "new_repository", 
            "new_ancestor_repository", 
            "new_descendant_repository", 
            "changed_repository", 
            "deleted_repository", 
            "deleted_ancestor_repository", 
            "deleted_descendant_repository"
         ], 
         "methods": [
            {
               "name": "new_repository", 
               "doc": {
                  "headline": "The callback for notifications of new repositories.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    repository_id (osid.id.Id): the ``Id`` of the new\n                ``Repository``\n", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "        :param repository_id: the ``Id`` of the new ``Repository``\n        :type repository_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "repository_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "new_ancestor_repository", 
               "doc": {
                  "headline": "The callback for notifications of new repository ancestors.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    repository_id (osid.id.Id): the ``Id`` of the\n                ``Repository``\n        arg:    ancestor_id (osid.id.Id): the ``Id`` of the new\n                ``Repository`` ancestor\n", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "        :param repository_id: the ``Id`` of the ``Repository``\n        :type repository_id: ``osid.id.Id``\n        :param ancestor_id: the ``Id`` of the new ``Repository`` ancestor\n        :type ancestor_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "repository_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "ancestor_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "new_descendant_repository", 
               "doc": {
                  "headline": "The callback for notifications of new repository descendants.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    repository_id (osid.id.Id): the ``Id`` of the\n                ``Repository``\n        arg:    descendant_id (osid.id.Id): the ``Id`` of the new\n                ``Repository`` descendant\n", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "        :param repository_id: the ``Id`` of the ``Repository``\n        :type repository_id: ``osid.id.Id``\n        :param descendant_id: the ``Id`` of the new ``Repository`` descendant\n        :type descendant_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "repository_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "descendant_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "changed_repository", 
               "doc": {
                  "headline": "The callback for notification of updated repositories.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    repository_id (osid.id.Id): the ``Id`` of the updated\n                ``Repository``\n", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "        :param repository_id: the ``Id`` of the updated ``Repository``\n        :type repository_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "repository_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "deleted_repository", 
               "doc": {
                  "headline": "The callback for notification of deleted repositories.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    repository_id (osid.id.Id): the ``Id`` of the deleted\n                ``Repository``\n", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "        :param repository_id: the ``Id`` of the deleted ``Repository``\n        :type repository_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "repository_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "deleted_ancestor_repository", 
               "doc": {
                  "headline": "The callback for notifications of deleted repository ancestors.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    repository_id (osid.id.Id): the ``Id`` of the\n                ``Repository``\n        arg:    ancestor_id (osid.id.Id): the ``Id`` of the removed\n                ``Repository`` ancestor\n", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "        :param repository_id: the ``Id`` of the ``Repository``\n        :type repository_id: ``osid.id.Id``\n        :param ancestor_id: the ``Id`` of the removed ``Repository`` ancestor\n        :type ancestor_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "repository_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "ancestor_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "deleted_descendant_repository", 
               "doc": {
                  "headline": "The callback for notifications of deleted repository descendants.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    repository_id (osid.id.Id): the ``Id`` of the\n                ``Repository``\n        arg:    descendant_id (osid.id.Id): the ``Id`` of the removed\n                ``Repository`` descendant\n", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "        :param repository_id: the ``Id`` of the ``Repository``\n        :type repository_id: ``osid.id.Id``\n        :param descendant_id: the ``Id`` of the removed ``Repository`` descendant\n        :type descendant_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "repository_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "descendant_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {}
            }
         ]
      }, 
      {
         "fullname": "osid.repository.RepositoryList", 
         "shortname": "RepositoryList", 
         "category": "objects", 
         "doc": {
            "headline": "Like all ``OsidLists,``  ``RepositoryList`` provides a means for accessing ``Repository`` elements sequentially either one at a time or many at a time.", 
            "body": "    Examples: while (rl.hasNext()) { Repository repository =\n    rl.getNextRepository(); }\n\n    or\n      while (rl.hasNext()) {\n           Repository[] repositories = rl.getNextRepositories(rl.available());\n      }\n    \n"
         }, 
         "inherit_fullnames": [
            "osid.OsidList"
         ], 
         "inherit_shortnames": [
            "OsidList"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidList"
            }
         ], 
         "method_names": [
            "get_next_repository", 
            "get_next_repositories"
         ], 
         "methods": [
            {
               "name": "get_next_repository", 
               "doc": {
                  "headline": "Gets the next ``Repository`` in this list.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.repository.Repository) - the next ``Repository``\n                in this list. The ``has_next()`` method should be used\n                to test that a next ``Repository`` is available before\n                calling this method.", 
               "error_doc": "        raise:  IllegalState - no more elements available in this list\n        raise:  OperationFailed - unable to complete request", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the next ``Repository`` in this list. The ``has_next()`` method should be used to test that a next ``Repository`` is available before calling this method.\n        :rtype: ``osid.repository.Repository``", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- no more elements available in this list\n        :raise: ``OperationFailed`` -- unable to complete request", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.repository.Repository", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational"
               }
            }, 
            {
               "name": "get_next_repositories", 
               "doc": {
                  "headline": "Gets the next set of ``Repository`` elements in this list which must be less than or equal to the return from ``available()``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    n (cardinal): the number of ``Repository`` elements\n                requested which must be less than or equal to\n                ``available()``\n", 
               "return_doc": "        return: (osid.repository.Repository) - an array of\n                ``Repository`` elements.The length of the array is less\n                than or equal to the number specified.", 
               "error_doc": "        raise:  IllegalState - no more elements available in this list\n        raise:  OperationFailed - unable to complete request", 
               "sphinx_param_doc": "        :param n: the number of ``Repository`` elements requested which must be less than or equal to ``available()``\n        :type n: ``cardinal``\n", 
               "sphinx_return_doc": "        :return: an array of ``Repository`` elements.The length of the array is less than or equal to the number specified.\n        :rtype: ``osid.repository.Repository``", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- no more elements available in this list\n        :raise: ``OperationFailed`` -- unable to complete request", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "cardinal", 
                     "var_name": "n", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "cardinal"
               ], 
               "return_type": "osid.repository.Repository", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.repository.RepositoryNode", 
         "shortname": "RepositoryNode", 
         "category": "objects", 
         "doc": {
            "headline": "This interface is a container for a partial hierarchy retrieval.", 
            "body": "    The number of hierarchy levels traversable through this interface\n    depend on the number of levels requested in the\n    ``RepositoryHierarchySession``."
         }, 
         "inherit_fullnames": [
            "osid.OsidNode"
         ], 
         "inherit_shortnames": [
            "OsidNode"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidNode"
            }
         ], 
         "method_names": [
            "get_repository", 
            "get_parent_repository_nodes", 
            "get_child_repository_nodes"
         ], 
         "methods": [
            {
               "name": "get_repository", 
               "doc": {
                  "headline": "Gets the ``Repository`` at this node.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.repository.Repository) - the repository\n                represented by this node", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the repository represented by this node\n        :rtype: ``osid.repository.Repository``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.repository.Repository", 
               "errors": {}
            }, 
            {
               "name": "get_parent_repository_nodes", 
               "doc": {
                  "headline": "Gets the parents of this repository.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.repository.RepositoryNodeList) - the parents of\n                the ``id``", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the parents of the ``id``\n        :rtype: ``osid.repository.RepositoryNodeList``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.repository.RepositoryNodeList", 
               "errors": {}
            }, 
            {
               "name": "get_child_repository_nodes", 
               "doc": {
                  "headline": "Gets the children of this repository.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.repository.RepositoryNodeList) - the children of\n                this repository", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the children of this repository\n        :rtype: ``osid.repository.RepositoryNodeList``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.repository.RepositoryNodeList", 
               "errors": {}
            }
         ]
      }, 
      {
         "fullname": "osid.repository.RepositoryNodeList", 
         "shortname": "RepositoryNodeList", 
         "category": "objects", 
         "doc": {
            "headline": "Like all ``OsidLists,``  ``RepositoryNodeList`` provides a means for accessing ``RepositoryNode`` elements sequentially either one at a time or many at a time.", 
            "body": "    Examples: while (rnl.hasNext()) { RepositoryNode node =\n    rnl.getNextRepositoryNode(); }\n\n    or\n      while (rnl.hasNext()) {\n           RepositoryNode[] nodes = rnl.getNextRepositoryNodes(rnl.available());\n      }\n    \n"
         }, 
         "inherit_fullnames": [
            "osid.OsidList"
         ], 
         "inherit_shortnames": [
            "OsidList"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidList"
            }
         ], 
         "method_names": [
            "get_next_repository_node", 
            "get_next_repository_nodes"
         ], 
         "methods": [
            {
               "name": "get_next_repository_node", 
               "doc": {
                  "headline": "Gets the next ``RepositoryNode`` in this list.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.repository.RepositoryNode) - the next\n                ``RepositoryNode`` in this list. The ``has_next()``\n                method should be used to test that a next\n                ``RepositoryNode`` is available before calling this\n                method.", 
               "error_doc": "        raise:  IllegalState - no more elements available in this list\n        raise:  OperationFailed - unable to complete request", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the next ``RepositoryNode`` in this list. The ``has_next()`` method should be used to test that a next ``RepositoryNode`` is available before calling this method.\n        :rtype: ``osid.repository.RepositoryNode``", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- no more elements available in this list\n        :raise: ``OperationFailed`` -- unable to complete request", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.repository.RepositoryNode", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational"
               }
            }, 
            {
               "name": "get_next_repository_nodes", 
               "doc": {
                  "headline": "Gets the next set of ``RepositoryNode`` elements in this list which must be less than or equal to the return from ``available()``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    n (cardinal): the number of ``RepositoryNode`` elements\n                requested which must be less than or equal to\n                ``available()``\n", 
               "return_doc": "        return: (osid.repository.RepositoryNode) - an array of\n                ``RepositoryNode`` elements.The length of the array is\n                less than or equal to the number specified.", 
               "error_doc": "        raise:  IllegalState - no more elements available in this list\n        raise:  OperationFailed - unable to complete request", 
               "sphinx_param_doc": "        :param n: the number of ``RepositoryNode`` elements requested which must be less than or equal to ``available()``\n        :type n: ``cardinal``\n", 
               "sphinx_return_doc": "        :return: an array of ``RepositoryNode`` elements.The length of the array is less than or equal to the number specified.\n        :rtype: ``osid.repository.RepositoryNode``", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- no more elements available in this list\n        :raise: ``OperationFailed`` -- unable to complete request", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "cardinal", 
                     "var_name": "n", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "cardinal"
               ], 
               "return_type": "osid.repository.RepositoryNode", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational"
               }
            }
         ]
      }
   ], 
   "full_name": "osid.repository"
}
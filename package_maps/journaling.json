{
   "name": "journaling", 
   "version": "3.0.0", 
   "title": "Journaling Open Service Interface Definitions", 
   "copyright": "Copyright (c) 2009, 2011 Ingenescus. All Rights Reserved.", 
   "license": "This Work is being provided by the copyright holder(s) subject to the\nfollowing license. By obtaining, using and/or copying this Work, you\nagree that you have read, understand, and will comply with the following\nterms and conditions.\n\nPermission to use, copy and distribute unmodified versions of this Work,\nfor any purpose, without fee or royalty is hereby granted, provided that\nyou include the above copyright notices and the terms of this license on\nALL copies of the Work or portions thereof.\n\nYou may nodify or create Derivatives of this Work only for your internal\npurposes. You shall not distribute or transfer any such Derivative of\nthis Work to any location or to any third party. For the purposes of\nthis license, \"Derivative\" shall mean any derivative of the Work as\ndefined in the United States Copyright Act of 1976, such as a\ntranslation or modification.\n\nThis Work and the information contained herein is provided on an \"AS IS\"\nbasis WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT\nNOT LIMITED TO WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR\nPURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\nHOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN\nAN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\nCONNECTION WITH THE WORK OR THE USE OR OTHER DEALINGS IN THE WORK.\n\nThe export of software employing encryption technology may require a\nspecific license from the United States Government. It is the\nresponsibility of any person or organization contemplating export to\nobtain such a license before exporting this Work.", 
   "summary": "The Journaling OSID defines an auxiliary service to manage journals and\njournal entries for versioining.\n\nJournal Entries\n\nA journal entry represents a change to an object that can be another\nOSID. The journal entry contains a time, a source ``Id`` and a version\n``Id``. The source ``Id`` is the principal identifier for the journaled\nobject while the version ``Id`` can be used to retrieve a previous\nversion of the object by using its respective lookup session.\n\nJournal Cataloging\n\nJournal entries can be categorized into ``Journals,`` which may also be\norganized into hierarchies for the purpose of federating journal\nentries.\n\nAgents & Resources\n\nAn ``Agent`` creates a ``JournalEntry``. The ``JournalEntry`` directly\nexposes the related ``Resource`` to manage the orchestration with a\nResourtce OSID. Multiple ``Agents`` may be acting on behalf of a\n``Resource``.\n\nOrchestration\n\nAn orchestrated journaling service is one that creates a journaling\nentry for each create and update of an ``OsidObject``. The orchestration\ncan be tricky since there is no means for connecting a ``JournalEntry``\nto a specific ``OsidObject``. other than to arrange the ``Journals``\nsuch that each ``Journal`` contains entries for a designated\n``OsidObject`` interface where multiple ``OsidObjects`` are journaled.\n\nThe Journaling OSID is designed to provide a history of the data\ncontained within an OSID object, such as the evolution of an ``Asset``\nor a ``Resource``. OSIDs tend to offer a complex array of relationships.\nTo capture a history of all relationships, states, and cataloging of an\n``OsidObject,`` an OSID Provider can offer a rollback of an entire OSID\nto a designated point in time.\n\nSub Packages\n\nThe Journaling OSID contains a Journaling Batch OSID for managing\n``JournalEntries,``  ``Branches,`` and ``Journals`` in bulk.", 
   "interfaces": [
      {
         "fullname": "osid.journaling.JournalingProfile", 
         "shortname": "JournalingProfile", 
         "category": "managers", 
         "doc": {
            "headline": "The journaling profile describes the interoperability among journaling services.", 
            "body": ""
         }, 
         "inherit_fullnames": [
            "osid.OsidProfile"
         ], 
         "inherit_shortnames": [
            "OsidProfile"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidProfile"
            }
         ], 
         "method_names": [
            "supports_visible_federation", 
            "supports_journal_entry_lookup", 
            "supports_journal_entry_query", 
            "supports_journal_entry_search", 
            "supports_journal_entry_admin", 
            "supports_journal_entry_notification", 
            "supports_branch_lookup", 
            "supports_branch_query", 
            "supports_branch_search", 
            "supports_branch_admin", 
            "supports_branch_notification", 
            "supports_branch_smart_journal", 
            "supports_journal_lookup", 
            "supports_journal_query", 
            "supports_journal_search", 
            "supports_journal_admin", 
            "supports_journal_notification", 
            "supports_journal_hierarchy", 
            "supports_journal_hierarchy_design", 
            "supports_journalng_batch", 
            "get_journal_entry_record_types", 
            "supports_journal_entry_record_type", 
            "get_journal_entry_search_record_types", 
            "supports_journal_entry_search_record_type", 
            "get_branch_record_types", 
            "supports_branch_record_type", 
            "get_branch_search_record_types", 
            "supports_branch_search_record_type", 
            "get_journal_record_types", 
            "supports_journal_record_type", 
            "get_journal_search_record_types", 
            "supports_journal_search_record_type"
         ], 
         "methods": [
            {
               "name": "supports_visible_federation", 
               "doc": {
                  "headline": "Tests if any journal federation is exposed.", 
                  "body": "        Federation is exposed when a specific journal may be identified,\n        selected and used to create a lookup or admin session.\n        Federation is not exposed when a set of journals appears as a\n        single journal."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if visible federation is supproted,\n                ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if visible federation is supproted, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "supports_journal_entry_lookup", 
               "doc": {
                  "headline": "Tests for the availability of a journal entry lookup service.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if journal entry lookup is\n                available, ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if journal entry lookup is available, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "supports_journal_entry_query", 
               "doc": {
                  "headline": "Tests if querying journal entries is available.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if journal entry query is\n                available, ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if journal entry query is available, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "supports_journal_entry_search", 
               "doc": {
                  "headline": "Tests if searching for journal entries is available.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if journal entry search is\n                available, ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if journal entry search is available, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "supports_journal_entry_admin", 
               "doc": {
                  "headline": "Tests if searching for journal entries is available.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if journal entry search is\n                available, ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if journal entry search is available, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "supports_journal_entry_notification", 
               "doc": {
                  "headline": "Tests if journal entry notification is available.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if journal entry notification is\n                available, ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if journal entry notification is available, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "supports_branch_lookup", 
               "doc": {
                  "headline": "Tests if branch lookup is supported.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if branch lookup is supported ``,``\n                ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if branch lookup is supported ``,``  ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "supports_branch_query", 
               "doc": {
                  "headline": "Tests if branch query is supported.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if branch query is supported ``,``\n                ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if branch query is supported ``,``  ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "supports_branch_search", 
               "doc": {
                  "headline": "Tests if branch search is supported.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if branch search is supported ``,``\n                ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if branch search is supported ``,``  ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "supports_branch_admin", 
               "doc": {
                  "headline": "Tests if branch administration is supported.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if branch administration is\n                supported, ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if branch administration is supported, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "supports_branch_notification", 
               "doc": {
                  "headline": "Tests if branch notification is supported.", 
                  "body": "        Messages may be sent when branches are created, modified, or\n        deleted."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if branch notification is supported\n                ``,``  ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if branch notification is supported ``,``  ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "supports_branch_smart_journal", 
               "doc": {
                  "headline": "Tests if branch smart journals are available.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if branch smart journals are\n                supported ``,``  ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if branch smart journals are supported ``,``  ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "supports_journal_lookup", 
               "doc": {
                  "headline": "Tests for the availability of an journal lookup service.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if journal lookup is available,\n                ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if journal lookup is available, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "supports_journal_query", 
               "doc": {
                  "headline": "Tests if querying journals is available.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if journal query is available,\n                ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if journal query is available, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "supports_journal_search", 
               "doc": {
                  "headline": "Tests if searching for journals is available.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if journal search is available,\n                ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if journal search is available, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "supports_journal_admin", 
               "doc": {
                  "headline": "Tests for the availability of a journal administrative service for creating and deleting journals.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if journal administration is\n                available, ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if journal administration is available, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "supports_journal_notification", 
               "doc": {
                  "headline": "Tests for the availability of a journal notification service.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if journal notification is\n                available, ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if journal notification is available, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented in all providers.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "supports_journal_hierarchy", 
               "doc": {
                  "headline": "Tests for the availability of a journal hierarchy traversal service.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if journal hierarchy traversal is\n                available, ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if journal hierarchy traversal is available, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "supports_journal_hierarchy_design", 
               "doc": {
                  "headline": "Tests for the availability of a journal hierarchy design service.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if journal hierarchy design is\n                available, ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if journal hierarchy design is available, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented in all providers.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "supports_journalng_batch", 
               "doc": {
                  "headline": "Tests for the availability of a journaling batch service.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if journaling batch service is\n                available, ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if journaling batch service is available, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented in all providers.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "get_journal_entry_record_types", 
               "doc": {
                  "headline": "Gets the supported ``JournalEntry`` record types.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.type.TypeList) - a list containing the supported\n                journal entry record types", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: a list containing the supported journal entry record types\n        :rtype: ``osid.type.TypeList``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.type.TypeList", 
               "errors": {}
            }, 
            {
               "name": "supports_journal_entry_record_type", 
               "doc": {
                  "headline": "Tests if the given ``JournalEntry`` record type is supported.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    journal_entry_record_type (osid.type.Type): a ``Type``\n                indicating a ``JournalEntry`` record type\n", 
               "return_doc": "        return: (boolean) - ``true`` if the given ``Type`` is supported,\n                ``false`` otherwise", 
               "error_doc": "        raise:  NullArgument - ``journal_entry_record_type`` is ``null``", 
               "sphinx_param_doc": "        :param journal_entry_record_type: a ``Type`` indicating a ``JournalEntry`` record type\n        :type journal_entry_record_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "        :return: ``true`` if the given ``Type`` is supported, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``journal_entry_record_type`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "journal_entry_record_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "boolean", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "get_journal_entry_search_record_types", 
               "doc": {
                  "headline": "Gets the supported journal entry search record types.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.type.TypeList) - a list containing the supported\n                journal entry search record types", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: a list containing the supported journal entry search record types\n        :rtype: ``osid.type.TypeList``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.type.TypeList", 
               "errors": {}
            }, 
            {
               "name": "supports_journal_entry_search_record_type", 
               "doc": {
                  "headline": "Tests if the given journal entry search record type is supported.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    journal_entry_search_record_type (osid.type.Type): a\n                ``Type`` indicating a journal entry record type\n", 
               "return_doc": "        return: (boolean) - ``true`` if the given ``Type`` is supported,\n                ``false`` otherwise", 
               "error_doc": "        raise:  NullArgument - ``journal_entry_search_record_type`` is\n                ``null``", 
               "sphinx_param_doc": "        :param journal_entry_search_record_type: a ``Type`` indicating a journal entry record type\n        :type journal_entry_search_record_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "        :return: ``true`` if the given ``Type`` is supported, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``journal_entry_search_record_type`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "journal_entry_search_record_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "boolean", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "get_branch_record_types", 
               "doc": {
                  "headline": "Gets all the branch record types supported.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.type.TypeList) - the list of supported branch\n                record types", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the list of supported branch record types\n        :rtype: ``osid.type.TypeList``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.type.TypeList", 
               "errors": {}
            }, 
            {
               "name": "supports_branch_record_type", 
               "doc": {
                  "headline": "Tests if a given branch record type is supported.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    branch_record_type (osid.type.Type): the branch type\n", 
               "return_doc": "        return: (boolean) - ``true`` if the branch record type is\n                supported ``,``  ``false`` otherwise", 
               "error_doc": "        raise:  NullArgument - ``branch_record_type`` is ``null``", 
               "sphinx_param_doc": "        :param branch_record_type: the branch type\n        :type branch_record_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "        :return: ``true`` if the branch record type is supported ``,``  ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``branch_record_type`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "branch_record_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "boolean", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "get_branch_search_record_types", 
               "doc": {
                  "headline": "Gets all the branch search record types supported.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.type.TypeList) - the list of supported branch\n                search record types", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the list of supported branch search record types\n        :rtype: ``osid.type.TypeList``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.type.TypeList", 
               "errors": {}
            }, 
            {
               "name": "supports_branch_search_record_type", 
               "doc": {
                  "headline": "Tests if a given branch search type is supported.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    branch_search_record_type (osid.type.Type): the branch\n                search type\n", 
               "return_doc": "        return: (boolean) - ``true`` if the branch search record type is\n                supported ``,``  ``false`` otherwise", 
               "error_doc": "        raise:  NullArgument - ``branch_search_record_type`` is ``null``", 
               "sphinx_param_doc": "        :param branch_search_record_type: the branch search type\n        :type branch_search_record_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "        :return: ``true`` if the branch search record type is supported ``,``  ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``branch_search_record_type`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "branch_search_record_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "boolean", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "get_journal_record_types", 
               "doc": {
                  "headline": "Gets the supported ``Journal`` record types.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.type.TypeList) - a list containing the supported\n                journal record types", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: a list containing the supported journal record types\n        :rtype: ``osid.type.TypeList``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.type.TypeList", 
               "errors": {}
            }, 
            {
               "name": "supports_journal_record_type", 
               "doc": {
                  "headline": "Tests if the given ``Journal`` record type is supported.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    journal_record_type (osid.type.Type): a ``Type``\n                indicating a ``Journal`` record type\n", 
               "return_doc": "        return: (boolean) - ``true`` if the given ``Type`` is supported,\n                ``false`` otherwise", 
               "error_doc": "        raise:  NullArgument - ``journal_record_type`` is ``null``", 
               "sphinx_param_doc": "        :param journal_record_type: a ``Type`` indicating a ``Journal`` record type\n        :type journal_record_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "        :return: ``true`` if the given ``Type`` is supported, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``journal_record_type`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "journal_record_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "boolean", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "get_journal_search_record_types", 
               "doc": {
                  "headline": "Gets the supported journal search record types.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.type.TypeList) - a list containing the supported\n                journal search record types", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: a list containing the supported journal search record types\n        :rtype: ``osid.type.TypeList``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.type.TypeList", 
               "errors": {}
            }, 
            {
               "name": "supports_journal_search_record_type", 
               "doc": {
                  "headline": "Tests if the given journal search record type is supported.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    journal_search_record_type (osid.type.Type): a ``Type``\n                indicating a journal record type\n", 
               "return_doc": "        return: (boolean) - ``true`` if the given ``Type`` is supported,\n                ``false`` otherwise", 
               "error_doc": "        raise:  NullArgument - ``journal_entry_search_record_type`` is\n                ``null``", 
               "sphinx_param_doc": "        :param journal_search_record_type: a ``Type`` indicating a journal record type\n        :type journal_search_record_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "        :return: ``true`` if the given ``Type`` is supported, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``journal_entry_search_record_type`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "journal_search_record_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "boolean", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.journaling.JournalingManager", 
         "shortname": "JournalingManager", 
         "category": "managers", 
         "doc": {
            "headline": "The journaling manager provides access to journaling sessions and provides interoperability tests for various aspects of this service.", 
            "body": "    The sessions included in this manager are:\n\n      * ``JournalEntryLookupSession:`` a session to lookup journal\n        entries\n      * ``JournalEntryQuerySession:`` a session to query journal entries\n      * ``JournalEntrySearchSession:`` a session to search journal\n        entries\n      * ``JournalEntryAdminSession:`` a session to manage journal\n        entries\n      * ``JournalEntryNotificationSession:`` a session to subscribe to\n        notifications of journal entry changes\n    \n      * ``BranchLookupSession:`` a session to retrieve branches\n      * ``BranchQuerySession:`` a session to query branches\n      * ``BranchSearchSession:`` a session to search for branches\n      * ``BranchAdminSession:`` a session to create and delete brancehs\n      * ``BranchNotificationSession:`` a session to receive\n        notifications pertaining to branch changes\n      * ``BranchSmartJournalSession:`` a session to manage smart branch\n        journals\n    \n      * ``JournalLookupSession:`` a session to retrieve journals\n      * ``JournalQuerySession`` : a session to query journals\n      * ``JournalSearchSession:`` a session to search for journals\n      * ``JournalAdminSession:`` a session to create, update and delete\n        journals\n      * ``JournalNotificationSession:`` a session to receive\n        notifications for changes in journals\n      * ``JournalHierarchyTraversalSession:`` a session to traverse\n        hierarchies of journals\n      * ``JournalHierarchyDesignSession:`` a session to manage\n        hierarchies of journals\n\n    \n    The journaling manager also provides a profile for determing the\n    supported search types supported by this service."
         }, 
         "inherit_fullnames": [
            "osid.OsidManager", 
            "osid.journaling.JournalingProfile"
         ], 
         "inherit_shortnames": [
            "OsidManager", 
            "JournalingProfile"
         ], 
         "inherit_pkg_names": [
            "osid", 
            "journaling"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidManager"
            }, 
            {
               "pkg_name": "journaling", 
               "name": "JournalingProfile"
            }
         ], 
         "method_names": [
            "get_journal_entry_lookup_session", 
            "get_journal_entry_lookup_session_for_journal", 
            "get_journal_entry_query_session", 
            "get_journal_entry_query_session_for_journal", 
            "get_journal_entry_search_session", 
            "get_journal_entry_search_session_for_journal", 
            "get_journal_entry_admin_session", 
            "get_journal_entry_admin_session_for_journal", 
            "get_journal_entry_notification_session", 
            "get_journal_entry_notification_session_for_journal", 
            "get_branch_lookup_session", 
            "get_branch_lookup_session_for_journal", 
            "get_branch_query_session", 
            "get_branch_query_session_for_journal", 
            "get_branch_search_session", 
            "get_branch_search_session_for_journal", 
            "get_branch_admin_session", 
            "get_branch_admin_session_for_journal", 
            "get_branch_notification_session", 
            "get_branch_notification_session_for_journal", 
            "get_branch_smart_journal_session", 
            "get_journal_lookup_session", 
            "get_journal_query_session", 
            "get_journal_search_session", 
            "get_journal_admin_session", 
            "get_journal_notification_session", 
            "get_journal_hierarchy_session", 
            "get_journal_hierarchy_design_session", 
            "get_journaling_batch_manager"
         ], 
         "methods": [
            {
               "name": "get_journal_entry_lookup_session", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` associated with the journal entry lookup service.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.journaling.JournalEntryLookupSession) - a\n                ``JournalEntryLookupSession``", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_journal_entry_lookup()`` is\n                ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: a ``JournalEntryLookupSession``\n        :rtype: ``osid.journaling.JournalEntryLookupSession``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_journal_entry_lookup()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_journal_entry_lookup()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.journaling.JournalEntryLookupSession", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_journal_entry_lookup_session_for_journal", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` associated with the journal entry lookup service for the given journal.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    journal_id (osid.id.Id): the ``Id`` of the ``Journal``\n", 
               "return_doc": "        return: (osid.journaling.JournalEntryLookupSession) - a\n                ``JournalEntryLookupSession``", 
               "error_doc": "        raise:  NotFound - no ``Journal`` found by the given ``Id``\n        raise:  NullArgument - ``journal_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_journal_entry_lookup()`` or\n                ``supports_visible_federation()`` is ``false``", 
               "sphinx_param_doc": "        :param journal_id: the ``Id`` of the ``Journal``\n        :type journal_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: a ``JournalEntryLookupSession``\n        :rtype: ``osid.journaling.JournalEntryLookupSession``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- no ``Journal`` found by the given ``Id``\n        :raise: ``NullArgument`` -- ``journal_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_journal_entry_lookup()`` or ``supports_visible_federation()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_journal_entry_lookup()`` and ``supports_visible_federation()`` are ``true``*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "journal_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "osid.journaling.JournalEntryLookupSession", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_journal_entry_query_session", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` associated with the journal entry query service.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.journaling.JournalEntryQuerySession) - a\n                ``JournalEntryQuerySession``", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_journal_entry_query()`` is\n                ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: a ``JournalEntryQuerySession``\n        :rtype: ``osid.journaling.JournalEntryQuerySession``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_journal_entry_query()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_journal_entry_query()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.journaling.JournalEntryQuerySession", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_journal_entry_query_session_for_journal", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` associated with the journal entry query service for the given journal.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    journal_id (osid.id.Id): the ``Id`` of the ``Journal``\n", 
               "return_doc": "        return: (osid.journaling.JournalEntryQuerySession) - a\n                ``JournalEntryQuerySession``", 
               "error_doc": "        raise:  NotFound - no ``Journal`` found by the given ``Id``\n        raise:  NullArgument - ``journal_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_journal_entry_query()`` or\n                ``supports_visible_federation()`` is ``false``", 
               "sphinx_param_doc": "        :param journal_id: the ``Id`` of the ``Journal``\n        :type journal_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: a ``JournalEntryQuerySession``\n        :rtype: ``osid.journaling.JournalEntryQuerySession``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- no ``Journal`` found by the given ``Id``\n        :raise: ``NullArgument`` -- ``journal_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_journal_entry_query()`` or ``supports_visible_federation()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_journal_entry_query()`` and ``supports_visible_federation()`` are ``true``*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "journal_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "osid.journaling.JournalEntryQuerySession", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_journal_entry_search_session", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` associated with the journal entry search service.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.journaling.JournalEntrySearchSession) - a\n                ``JournalEntrySearchSession``", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_journal_entry_search()`` is\n                ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: a ``JournalEntrySearchSession``\n        :rtype: ``osid.journaling.JournalEntrySearchSession``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_journal_entry_search()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_journal_entry_search()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.journaling.JournalEntrySearchSession", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_journal_entry_search_session_for_journal", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` associated with the journal entry search service for the given journal.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    journal_id (osid.id.Id): the ``Id`` of the ``Journal``\n", 
               "return_doc": "        return: (osid.journaling.JournalEntrySearchSession) - a\n                ``JournalEntrySearchSession``", 
               "error_doc": "        raise:  NotFound - no ``Journal`` found by the given ``Id``\n        raise:  NullArgument - ``journal_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_journal_entry_search()`` or\n                ``supports_visible_federation()`` is ``false``", 
               "sphinx_param_doc": "        :param journal_id: the ``Id`` of the ``Journal``\n        :type journal_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: a ``JournalEntrySearchSession``\n        :rtype: ``osid.journaling.JournalEntrySearchSession``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- no ``Journal`` found by the given ``Id``\n        :raise: ``NullArgument`` -- ``journal_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_journal_entry_search()`` or ``supports_visible_federation()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_journal_entry_search()`` and ``supports_visible_federation()`` are ``true``*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "journal_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "osid.journaling.JournalEntrySearchSession", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_journal_entry_admin_session", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` associated with the journal entry administration service.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.journaling.JournalEntryAdminSession) - a\n                ``JournalEntryAdminSession``", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_journal_entry_admin()`` is\n                ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: a ``JournalEntryAdminSession``\n        :rtype: ``osid.journaling.JournalEntryAdminSession``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_journal_entry_admin()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_journal_entry_admin()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.journaling.JournalEntryAdminSession", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_journal_entry_admin_session_for_journal", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` associated with the journal entry administration service for the given journal.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    journal_id (osid.id.Id): the ``Id`` of the ``Journal``\n", 
               "return_doc": "        return: (osid.journaling.JournalEntryAdminSession) - a\n                ``JournalEntryAdminSession``", 
               "error_doc": "        raise:  NotFound - no ``Journal`` found by the given ``Id``\n        raise:  NullArgument - ``journal_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_journal_entry_admin()`` or\n                ``supports_visible_federation()`` is ``false``", 
               "sphinx_param_doc": "        :param journal_id: the ``Id`` of the ``Journal``\n        :type journal_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: a ``JournalEntryAdminSession``\n        :rtype: ``osid.journaling.JournalEntryAdminSession``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- no ``Journal`` found by the given ``Id``\n        :raise: ``NullArgument`` -- ``journal_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_journal_entry_admin()`` or ``supports_visible_federation()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_journal_entry_admin()`` and ``supports_visible_federation()`` are ``true``*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "journal_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "osid.journaling.JournalEntryAdminSession", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_journal_entry_notification_session", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` associated with the journal entry notification service.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    journal_entry_receiver\n                (osid.journaling.JournalEntryReceiver): the receiver\n", 
               "return_doc": "        return: (osid.journaling.JournalEntryNotificationSession) - a\n                ``JournalEntryNotificationSession``", 
               "error_doc": "        raise:  NullArgument - ``journal_entry_receiver`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented -\n                ``supports_journal_entry_notification()`` is ``false``", 
               "sphinx_param_doc": "        :param journal_entry_receiver: the receiver\n        :type journal_entry_receiver: ``osid.journaling.JournalEntryReceiver``\n", 
               "sphinx_return_doc": "        :return: a ``JournalEntryNotificationSession``\n        :rtype: ``osid.journaling.JournalEntryNotificationSession``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``journal_entry_receiver`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_journal_entry_notification()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_journal_entry_notification()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.journaling.JournalEntryReceiver", 
                     "var_name": "journal_entry_receiver", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.journaling.JournalEntryReceiver"
               ], 
               "return_type": "osid.journaling.JournalEntryNotificationSession", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_journal_entry_notification_session_for_journal", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` associated with the journal entry notification service for the given journal.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    journal_entry_receiver\n                (osid.journaling.JournalEntryReceiver): the receiver\n        arg:    journal_id (osid.id.Id): the ``Id`` of the ``Journal``\n", 
               "return_doc": "        return: (osid.journaling.JournalEntryNotificationSession) - a\n                ``JournalEntryNotificationSession``", 
               "error_doc": "        raise:  NotFound - no ``Journal`` found by the given ``Id``\n        raise:  NullArgument - ``journal_entry_receiver`` or\n                ``journal_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented -\n                ``supports_journal_entry_notification()`` or\n                ``supports_visible_federation()`` is ``false``", 
               "sphinx_param_doc": "        :param journal_entry_receiver: the receiver\n        :type journal_entry_receiver: ``osid.journaling.JournalEntryReceiver``\n        :param journal_id: the ``Id`` of the ``Journal``\n        :type journal_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: a ``JournalEntryNotificationSession``\n        :rtype: ``osid.journaling.JournalEntryNotificationSession``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- no ``Journal`` found by the given ``Id``\n        :raise: ``NullArgument`` -- ``journal_entry_receiver`` or ``journal_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_journal_entry_notification()`` or ``supports_visible_federation()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_journal_entry_notification()`` and ``supports_visible_federation()`` are ``true``*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.journaling.JournalEntryReceiver", 
                     "var_name": "journal_entry_receiver", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "journal_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.journaling.JournalEntryReceiver", 
                  "osid.id.Id"
               ], 
               "return_type": "osid.journaling.JournalEntryNotificationSession", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_branch_lookup_session", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` associated with the branch lookup service.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.journaling.BranchLookupSession) - ``a\n                BranchLookupSession``", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_branch_lookup()`` is\n                ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``a BranchLookupSession``\n        :rtype: ``osid.journaling.BranchLookupSession``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_branch_lookup()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_branch_lookup()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.journaling.BranchLookupSession", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_branch_lookup_session_for_journal", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` associated with the branch lookup service for the given journal.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    journal_id (osid.id.Id): the ``Id`` of the journal\n", 
               "return_doc": "        return: (osid.journaling.BranchLookupSession) - ``a\n                BranchLookupSession``", 
               "error_doc": "        raise:  NotFound - ``journal_id`` not found\n        raise:  NullArgument - ``journal_id`` is ``null``\n        raise:  OperationFailed - ``unable to complete request``\n        raise:  Unimplemented - ``supports_branch_lookup()`` or\n                ``supports_visible_federation()`` is ``false``", 
               "sphinx_param_doc": "        :param journal_id: the ``Id`` of the journal\n        :type journal_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: ``a BranchLookupSession``\n        :rtype: ``osid.journaling.BranchLookupSession``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``journal_id`` not found\n        :raise: ``NullArgument`` -- ``journal_id`` is ``null``\n        :raise: ``OperationFailed`` -- ``unable to complete request``\n        :raise: ``Unimplemented`` -- ``supports_branch_lookup()`` or ``supports_visible_federation()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_branch_lookup()`` and ``supports_visible_federation()`` are ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "journal_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "osid.journaling.BranchLookupSession", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_branch_query_session", 
               "doc": {
                  "headline": "Gets a branch query session.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.journaling.BranchQuerySession) - ``a\n                BranchQuerySession``", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_branch_query()`` is ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``a BranchQuerySession``\n        :rtype: ``osid.journaling.BranchQuerySession``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_branch_query()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_branch_query()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.journaling.BranchQuerySession", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_branch_query_session_for_journal", 
               "doc": {
                  "headline": "Gets a branch query session for the given journal.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    journal_id (osid.id.Id): the ``Id`` of the journal\n", 
               "return_doc": "        return: (osid.journaling.BranchQuerySession) - ``a\n                BranchQuerySession``", 
               "error_doc": "        raise:  NotFound - ``journal_id`` not found\n        raise:  NullArgument - ``journal_id`` is ``null``\n        raise:  OperationFailed - ``unable to complete request``\n        raise:  Unimplemented - ``supports_branch_query()`` or\n                ``supports_visible_federation()`` is ``false``", 
               "sphinx_param_doc": "        :param journal_id: the ``Id`` of the journal\n        :type journal_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: ``a BranchQuerySession``\n        :rtype: ``osid.journaling.BranchQuerySession``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``journal_id`` not found\n        :raise: ``NullArgument`` -- ``journal_id`` is ``null``\n        :raise: ``OperationFailed`` -- ``unable to complete request``\n        :raise: ``Unimplemented`` -- ``supports_branch_query()`` or ``supports_visible_federation()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_branch_query()`` and ``supports_visible_federation()`` are ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "journal_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "osid.journaling.BranchQuerySession", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_branch_search_session", 
               "doc": {
                  "headline": "Gets a branch search session.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.journaling.BranchSearchSession) - ``a\n                BranchSearchSession``", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_branch_search()`` is\n                ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``a BranchSearchSession``\n        :rtype: ``osid.journaling.BranchSearchSession``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_branch_search()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_branch_search()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.journaling.BranchSearchSession", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_branch_search_session_for_journal", 
               "doc": {
                  "headline": "Gets a branch search session for the given journal.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    journal_id (osid.id.Id): the ``Id`` of the journal\n", 
               "return_doc": "        return: (osid.journaling.BranchSearchSession) - ``a\n                BranchSearchSession``", 
               "error_doc": "        raise:  NotFound - ``journal_id`` not found\n        raise:  NullArgument - ``journal_id`` is ``null``\n        raise:  OperationFailed - ``unable to complete request``\n        raise:  Unimplemented - ``supports_branch_search()`` or\n                ``supports_visible_federation()`` is ``false``", 
               "sphinx_param_doc": "        :param journal_id: the ``Id`` of the journal\n        :type journal_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: ``a BranchSearchSession``\n        :rtype: ``osid.journaling.BranchSearchSession``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``journal_id`` not found\n        :raise: ``NullArgument`` -- ``journal_id`` is ``null``\n        :raise: ``OperationFailed`` -- ``unable to complete request``\n        :raise: ``Unimplemented`` -- ``supports_branch_search()`` or ``supports_visible_federation()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_branch_search()`` and ``supports_visible_federation()`` are ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "journal_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "osid.journaling.BranchSearchSession", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_branch_admin_session", 
               "doc": {
                  "headline": "Gets a branch administration session for creating, updating and deleting branches.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.journaling.BranchAdminSession) - ``a\n                BranchAdminSession``", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_branch_admin()`` is ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``a BranchAdminSession``\n        :rtype: ``osid.journaling.BranchAdminSession``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_branch_admin()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_branch_admin()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.journaling.BranchAdminSession", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_branch_admin_session_for_journal", 
               "doc": {
                  "headline": "Gets a branch administration session for the given journal.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    journal_id (osid.id.Id): the ``Id`` of the journal\n", 
               "return_doc": "        return: (osid.journaling.BranchAdminSession) - ``a\n                BranchAdminSession``", 
               "error_doc": "        raise:  NotFound - ``journal_id`` not found\n        raise:  NullArgument - ``journal_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_branch_admin()`` or\n                ``supports_visible_federation()`` is ``false``", 
               "sphinx_param_doc": "        :param journal_id: the ``Id`` of the journal\n        :type journal_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: ``a BranchAdminSession``\n        :rtype: ``osid.journaling.BranchAdminSession``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``journal_id`` not found\n        :raise: ``NullArgument`` -- ``journal_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_branch_admin()`` or ``supports_visible_federation()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_branch_admin()`` and ``supports_visible_federation()`` are ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "journal_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "osid.journaling.BranchAdminSession", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_branch_notification_session", 
               "doc": {
                  "headline": "Gets the notification session for notifications pertaining to branch changes.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    branch_receiver (osid.journaling.BranchReceiver): the\n                notification callback\n", 
               "return_doc": "        return: (osid.journaling.BranchNotificationSession) - ``a\n                BranchNotificationSession``", 
               "error_doc": "        raise:  NullArgument - ``branch_receiver`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_branch_notification()`` is\n                ``false``", 
               "sphinx_param_doc": "        :param branch_receiver: the notification callback\n        :type branch_receiver: ``osid.journaling.BranchReceiver``\n", 
               "sphinx_return_doc": "        :return: ``a BranchNotificationSession``\n        :rtype: ``osid.journaling.BranchNotificationSession``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``branch_receiver`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_branch_notification()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_branch_notification()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.journaling.BranchReceiver", 
                     "var_name": "branch_receiver", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.journaling.BranchReceiver"
               ], 
               "return_type": "osid.journaling.BranchNotificationSession", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_branch_notification_session_for_journal", 
               "doc": {
                  "headline": "Gets the branch notification session for the given journal.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    branch_receiver (osid.journaling.BranchReceiver): the\n                notification callback\n        arg:    journal_id (osid.id.Id): the ``Id`` of the journal\n", 
               "return_doc": "        return: (osid.journaling.BranchNotificationSession) - ``a\n                BranchNotificationSession``", 
               "error_doc": "        raise:  NotFound - ``journal_id`` not found\n        raise:  NullArgument - ``branch_receiver`` or ``journal_id`` is\n                ``null``\n        raise:  OperationFailed - ``unable to complete request``\n        raise:  Unimplemented - ``supports_branch_notification()`` or\n                ``supports_visible_federation()`` is ``false``", 
               "sphinx_param_doc": "        :param branch_receiver: the notification callback\n        :type branch_receiver: ``osid.journaling.BranchReceiver``\n        :param journal_id: the ``Id`` of the journal\n        :type journal_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: ``a BranchNotificationSession``\n        :rtype: ``osid.journaling.BranchNotificationSession``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``journal_id`` not found\n        :raise: ``NullArgument`` -- ``branch_receiver`` or ``journal_id`` is ``null``\n        :raise: ``OperationFailed`` -- ``unable to complete request``\n        :raise: ``Unimplemented`` -- ``supports_branch_notification()`` or ``supports_visible_federation()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_branch_notfication()`` and ``supports_visible_federation()`` are ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.journaling.BranchReceiver", 
                     "var_name": "branch_receiver", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "journal_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.journaling.BranchReceiver", 
                  "osid.id.Id"
               ], 
               "return_type": "osid.journaling.BranchNotificationSession", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_branch_smart_journal_session", 
               "doc": {
                  "headline": "Gets the session for managing dynamic branch journals.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    journal_id (osid.id.Id): the ``Id`` of the journal\n", 
               "return_doc": "        return: (osid.journaling.BranchSmartJournalSession) - a\n                ``BranchSmartJournalSession``", 
               "error_doc": "        raise:  NotFound - ``journal_id`` not found\n        raise:  NullArgument - ``journal_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_branch_smart_journal()`` is\n                ``false``", 
               "sphinx_param_doc": "        :param journal_id: the ``Id`` of the journal\n        :type journal_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: a ``BranchSmartJournalSession``\n        :rtype: ``osid.journaling.BranchSmartJournalSession``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``journal_id`` not found\n        :raise: ``NullArgument`` -- ``journal_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_branch_smart_journal()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_branch_smart_journal()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "journal_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "osid.journaling.BranchSmartJournalSession", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_journal_lookup_session", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` associated with the journal lookup service.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.journaling.JournalLookupSession) - a\n                ``JournalLookupSession``", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_journal_lookup()`` is\n                ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: a ``JournalLookupSession``\n        :rtype: ``osid.journaling.JournalLookupSession``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_journal_lookup()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_journal_lookup()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.journaling.JournalLookupSession", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_journal_query_session", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` associated with the journal query service.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.journaling.JournalQuerySession) - a\n                ``JournalQuerySession``", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_journal_query()`` is\n                ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: a ``JournalQuerySession``\n        :rtype: ``osid.journaling.JournalQuerySession``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_journal_query()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_journal_query()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.journaling.JournalQuerySession", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_journal_search_session", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` associated with the journal search service.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.journaling.JournalSearchSession) - a\n                ``JournalSearchSession``", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_journal_search()`` is\n                ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: a ``JournalSearchSession``\n        :rtype: ``osid.journaling.JournalSearchSession``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_journal_search()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_journal_search()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.journaling.JournalSearchSession", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_journal_admin_session", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` associated with the journal administrative service.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.journaling.JournalAdminSession) - a\n                ``JournalAdminSession``", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_journal_admin()`` is\n                ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: a ``JournalAdminSession``\n        :rtype: ``osid.journaling.JournalAdminSession``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_journal_admin()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_journal_admin()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.journaling.JournalAdminSession", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_journal_notification_session", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` associated with the journal notification service.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    journal_receiver (osid.journaling.JournalReceiver): the\n                receiver\n", 
               "return_doc": "        return: (osid.journaling.JournalNotificationSession) - a\n                ``JournalNotificationSession``", 
               "error_doc": "        raise:  NullArgument - ``journal_receiver`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_journal_notification()`` is\n                ``false``", 
               "sphinx_param_doc": "        :param journal_receiver: the receiver\n        :type journal_receiver: ``osid.journaling.JournalReceiver``\n", 
               "sphinx_return_doc": "        :return: a ``JournalNotificationSession``\n        :rtype: ``osid.journaling.JournalNotificationSession``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``journal_receiver`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_journal_notification()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_journal_notification()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.journaling.JournalReceiver", 
                     "var_name": "journal_receiver", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.journaling.JournalReceiver"
               ], 
               "return_type": "osid.journaling.JournalNotificationSession", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_journal_hierarchy_session", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` associated with the journal hierarchy service.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.journaling.JournalHierarchySession) - a\n                ``JournalHierarchySession``", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_journal_hierarchy()`` is\n                ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: a ``JournalHierarchySession``\n        :rtype: ``osid.journaling.JournalHierarchySession``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_journal_hierarchy()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_journal_hierarchy()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.journaling.JournalHierarchySession", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_journal_hierarchy_design_session", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` associated with the journal hierarchy design service.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.journaling.JournalHierarchyDesignSession) - a\n                ``JournalHierarchyDesignSession``", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_journal_hierarchy_design()``\n                is ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: a ``JournalHierarchyDesignSession``\n        :rtype: ``osid.journaling.JournalHierarchyDesignSession``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_journal_hierarchy_design()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_journal_hierarchy_design()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.journaling.JournalHierarchyDesignSession", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_journaling_batch_manager", 
               "doc": {
                  "headline": "Gets a ``JournalingBatchManager``.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.journaling.batch.JournalingBatchManager) - a\n                ``JournalingBatchManager``", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_journaling_batch()`` is\n                ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: a ``JournalingBatchManager``\n        :rtype: ``osid.journaling.batch.JournalingBatchManager``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_journaling_batch()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_journaling_batch()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.journaling.batch.JournalingBatchManager", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.journaling.JournalingProxyManager", 
         "shortname": "JournalingProxyManager", 
         "category": "managers", 
         "doc": {
            "headline": "The journaling manager provides access to journaling sessions and provides interoperability tests for various aspects of this service.", 
            "body": "    Methods in this manager accept a ``Proxy`` for passing information\n    from a server environment. The sessions included in this manager\n    are:\n\n      * ``JournalEntryLookupSession:`` a session to lookup journal\n        entries\n      * ``JournalEntryQuerySession:`` a session to query journal entries\n      * ``JournalEntrySearchSession:`` a session to search journal\n        entries\n      * ``JournalEntryAdminSession:`` a session to manage journal\n        entries\n      * ``JournalEntryNotificationSession:`` a session to subscribe to\n        notifications of journal entry changes\n    \n      * ``BranchLookupSession:`` a session to retrieve branches\n      * ``BranchQuerySession:`` a session to query branches\n      * ``BranchSearchSession:`` a session to search for branches\n      * ``BranchAdminSession:`` a session to create and delete brancehs\n      * ``BranchNotificationSession:`` a session to receive\n        notifications pertaining to branch changes\n      * ``BranchSmartJournalSession:`` a session to manage smart branch\n        journals\n    \n      * ``JournalLookupSession:`` a session to retrieve journals\n      * ``JournalQuerySession`` : a session to query journals\n      * ``JournalSearchSession:`` a session to search for journals\n      * ``JournalAdminSession:`` a session to create, update and delete\n        journals\n      * ``JournalNotificationSession:`` a session to receive\n        notifications for changes in journals\n      * ``JournalHierarchyTraversalSession:`` a session to traverse\n        hierarchies of journals\n      * ``JournalHierarchyDesignSession:`` a session to manage\n        hierarchies of journals\n\n    \n    The journaling manager also provides a profile for determing the\n    supported search types supported by this service."
         }, 
         "inherit_fullnames": [
            "osid.OsidProxyManager", 
            "osid.journaling.JournalingProfile"
         ], 
         "inherit_shortnames": [
            "OsidProxyManager", 
            "JournalingProfile"
         ], 
         "inherit_pkg_names": [
            "osid", 
            "journaling"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidProxyManager"
            }, 
            {
               "pkg_name": "journaling", 
               "name": "JournalingProfile"
            }
         ], 
         "method_names": [
            "get_journal_entry_lookup_session", 
            "get_journal_entry_lookup_session_for_journal", 
            "get_journal_entry_query_session", 
            "get_journal_entry_query_session_for_journal", 
            "get_journal_entry_search_session", 
            "get_journal_entry_search_session_for_journal", 
            "get_journal_entry_admin_session", 
            "get_journal_entry_admin_session_for_journal", 
            "get_journal_entry_notification_session", 
            "get_journal_entry_notification_session_for_journal", 
            "get_branch_lookup_session", 
            "get_branch_lookup_session_for_journal", 
            "get_branch_query_session", 
            "get_branch_query_session_for_journal", 
            "get_branch_search_session", 
            "get_branch_search_session_for_journal", 
            "get_branch_admin_session", 
            "get_branch_admin_session_for_journal", 
            "get_branch_notification_session", 
            "get_branch_notification_session_for_journal", 
            "get_branch_smart_journal_session", 
            "get_journal_lookup_session", 
            "get_journal_query_session", 
            "get_journal_search_session", 
            "get_journal_admin_session", 
            "get_journal_notification_session", 
            "get_journal_hierarchy_session", 
            "get_journal_hierarchy_design_session", 
            "get_journaling_batch_proxy_manager"
         ], 
         "methods": [
            {
               "name": "get_journal_entry_lookup_session", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` associated with the journal entry lookup service.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    proxy (osid.proxy.Proxy): a proxy\n", 
               "return_doc": "        return: (osid.journaling.JournalEntryLookupSession) - a\n                ``JournalEntryLookupSession``", 
               "error_doc": "        raise:  NullArgument - ``proxy`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_journal_entry_lookup()`` is\n                ``false``", 
               "sphinx_param_doc": "        :param proxy: a proxy\n        :type proxy: ``osid.proxy.Proxy``\n", 
               "sphinx_return_doc": "        :return: a ``JournalEntryLookupSession``\n        :rtype: ``osid.journaling.JournalEntryLookupSession``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``proxy`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_journal_entry_lookup()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_journal_entry_lookup()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.proxy.Proxy", 
                     "var_name": "proxy", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.proxy.Proxy"
               ], 
               "return_type": "osid.journaling.JournalEntryLookupSession", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_journal_entry_lookup_session_for_journal", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` associated with the journal entry lookup service for the given journal.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    journal_id (osid.id.Id): the ``Id`` of the ``Journal``\n        arg:    proxy (osid.proxy.Proxy): a proxy\n", 
               "return_doc": "        return: (osid.journaling.JournalEntryLookupSession) - a\n                ``JournalEntryLookupSession``", 
               "error_doc": "        raise:  NotFound - no ``Journal`` found by the given ``Id``\n        raise:  NullArgument - ``journal_id`` or ``proxy`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_journal_entry_lookup()`` or\n                ``supports_visible_federation()`` is ``false``", 
               "sphinx_param_doc": "        :param journal_id: the ``Id`` of the ``Journal``\n        :type journal_id: ``osid.id.Id``\n        :param proxy: a proxy\n        :type proxy: ``osid.proxy.Proxy``\n", 
               "sphinx_return_doc": "        :return: a ``JournalEntryLookupSession``\n        :rtype: ``osid.journaling.JournalEntryLookupSession``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- no ``Journal`` found by the given ``Id``\n        :raise: ``NullArgument`` -- ``journal_id`` or ``proxy`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_journal_entry_lookup()`` or ``supports_visible_federation()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_journal_entry_lookup()`` and ``supports_visible_federation()`` are ``true``*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "journal_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.proxy.Proxy", 
                     "var_name": "proxy", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "osid.proxy.Proxy"
               ], 
               "return_type": "osid.journaling.JournalEntryLookupSession", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_journal_entry_query_session", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` associated with the journal entry query service.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    proxy (osid.proxy.Proxy): a proxy\n", 
               "return_doc": "        return: (osid.journaling.JournalEntryQuerySession) - a\n                ``JournalEntryQuerySession``", 
               "error_doc": "        raise:  NullArgument - ``proxy`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_journal_entry_query()`` is\n                ``false``", 
               "sphinx_param_doc": "        :param proxy: a proxy\n        :type proxy: ``osid.proxy.Proxy``\n", 
               "sphinx_return_doc": "        :return: a ``JournalEntryQuerySession``\n        :rtype: ``osid.journaling.JournalEntryQuerySession``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``proxy`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_journal_entry_query()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_journal_entry_query()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.proxy.Proxy", 
                     "var_name": "proxy", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.proxy.Proxy"
               ], 
               "return_type": "osid.journaling.JournalEntryQuerySession", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_journal_entry_query_session_for_journal", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` associated with the journal entry query service for the given journal.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    journal_id (osid.id.Id): the ``Id`` of the ``Journal``\n        arg:    proxy (osid.proxy.Proxy): a proxy\n", 
               "return_doc": "        return: (osid.journaling.JournalEntryQuerySession) - a\n                ``JournalEntryQuerySession``", 
               "error_doc": "        raise:  NotFound - no ``Journal`` found by the given ``Id``\n        raise:  NullArgument - ``journal_id`` or ``proxy`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_journal_entry_query()`` or\n                ``supports_visible_federation()`` is ``false``", 
               "sphinx_param_doc": "        :param journal_id: the ``Id`` of the ``Journal``\n        :type journal_id: ``osid.id.Id``\n        :param proxy: a proxy\n        :type proxy: ``osid.proxy.Proxy``\n", 
               "sphinx_return_doc": "        :return: a ``JournalEntryQuerySession``\n        :rtype: ``osid.journaling.JournalEntryQuerySession``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- no ``Journal`` found by the given ``Id``\n        :raise: ``NullArgument`` -- ``journal_id`` or ``proxy`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_journal_entry_query()`` or ``supports_visible_federation()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_journal_entry_query()`` and ``supports_visible_federation()`` are ``true``*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "journal_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.proxy.Proxy", 
                     "var_name": "proxy", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "osid.proxy.Proxy"
               ], 
               "return_type": "osid.journaling.JournalEntryQuerySession", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_journal_entry_search_session", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` associated with the journal entry search service.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    proxy (osid.proxy.Proxy): a proxy\n", 
               "return_doc": "        return: (osid.journaling.JournalEntrySearchSession) - a\n                ``JournalEntrySearchSession``", 
               "error_doc": "        raise:  NullArgument - ``proxy`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_journal_entry_search()`` is\n                ``false``", 
               "sphinx_param_doc": "        :param proxy: a proxy\n        :type proxy: ``osid.proxy.Proxy``\n", 
               "sphinx_return_doc": "        :return: a ``JournalEntrySearchSession``\n        :rtype: ``osid.journaling.JournalEntrySearchSession``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``proxy`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_journal_entry_search()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_journal_entry_search()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.proxy.Proxy", 
                     "var_name": "proxy", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.proxy.Proxy"
               ], 
               "return_type": "osid.journaling.JournalEntrySearchSession", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_journal_entry_search_session_for_journal", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` associated with the journal entry search service for the given journal.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    journal_id (osid.id.Id): the ``Id`` of the ``Journal``\n        arg:    proxy (osid.proxy.Proxy): a proxy\n", 
               "return_doc": "        return: (osid.journaling.JournalEntrySearchSession) - a\n                ``JournalEntrySearchSession``", 
               "error_doc": "        raise:  NotFound - no ``Journal`` found by the given ``Id``\n        raise:  NullArgument - ``journal_id`` or ``proxy`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_journal_entry_search()`` or\n                ``supports_visible_federation()`` is ``false``", 
               "sphinx_param_doc": "        :param journal_id: the ``Id`` of the ``Journal``\n        :type journal_id: ``osid.id.Id``\n        :param proxy: a proxy\n        :type proxy: ``osid.proxy.Proxy``\n", 
               "sphinx_return_doc": "        :return: a ``JournalEntrySearchSession``\n        :rtype: ``osid.journaling.JournalEntrySearchSession``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- no ``Journal`` found by the given ``Id``\n        :raise: ``NullArgument`` -- ``journal_id`` or ``proxy`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_journal_entry_search()`` or ``supports_visible_federation()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_journal_entry_search()`` and ``supports_visible_federation()`` are ``true``*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "journal_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.proxy.Proxy", 
                     "var_name": "proxy", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "osid.proxy.Proxy"
               ], 
               "return_type": "osid.journaling.JournalEntrySearchSession", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_journal_entry_admin_session", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` associated with the journal entry administration service.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    proxy (osid.proxy.Proxy): a proxy\n", 
               "return_doc": "        return: (osid.journaling.JournalEntryAdminSession) - a\n                ``JournalEntryAdminSession``", 
               "error_doc": "        raise:  NullArgument - ``proxy`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_journal_entry_admin()`` is\n                ``false``", 
               "sphinx_param_doc": "        :param proxy: a proxy\n        :type proxy: ``osid.proxy.Proxy``\n", 
               "sphinx_return_doc": "        :return: a ``JournalEntryAdminSession``\n        :rtype: ``osid.journaling.JournalEntryAdminSession``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``proxy`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_journal_entry_admin()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_journal_entry_admin()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.proxy.Proxy", 
                     "var_name": "proxy", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.proxy.Proxy"
               ], 
               "return_type": "osid.journaling.JournalEntryAdminSession", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_journal_entry_admin_session_for_journal", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` associated with the journal entry administration service for the given journal.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    journal_id (osid.id.Id): the ``Id`` of the ``Journal``\n        arg:    proxy (osid.proxy.Proxy): a proxy\n", 
               "return_doc": "        return: (osid.journaling.JournalEntryAdminSession) - a\n                ``JournalEntryAdminSession``", 
               "error_doc": "        raise:  NotFound - no ``Journal`` found by the given ``Id``\n        raise:  NullArgument - ``journal_id`` or ``proxy`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_journal_entry_admin()`` or\n                ``supports_visible_federation()`` is ``false``", 
               "sphinx_param_doc": "        :param journal_id: the ``Id`` of the ``Journal``\n        :type journal_id: ``osid.id.Id``\n        :param proxy: a proxy\n        :type proxy: ``osid.proxy.Proxy``\n", 
               "sphinx_return_doc": "        :return: a ``JournalEntryAdminSession``\n        :rtype: ``osid.journaling.JournalEntryAdminSession``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- no ``Journal`` found by the given ``Id``\n        :raise: ``NullArgument`` -- ``journal_id`` or ``proxy`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_journal_entry_admin()`` or ``supports_visible_federation()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_journal_entry_admin()`` and ``supports_visible_federation()`` are ``true``*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "journal_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.proxy.Proxy", 
                     "var_name": "proxy", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "osid.proxy.Proxy"
               ], 
               "return_type": "osid.journaling.JournalEntryAdminSession", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_journal_entry_notification_session", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` associated with the journal entry notification service.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    journal_entry_receiver\n                (osid.journaling.JournalEntryReceiver): the receiver\n        arg:    proxy (osid.proxy.Proxy): a proxy\n", 
               "return_doc": "        return: (osid.journaling.JournalEntryNotificationSession) - a\n                ``JournalEntryNotificationSession``", 
               "error_doc": "        raise:  NullArgument - ``journal_entry_receiver`` or ``proxy``\n                is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented -\n                ``supports_journal_entry_notification()`` is ``false``", 
               "sphinx_param_doc": "        :param journal_entry_receiver: the receiver\n        :type journal_entry_receiver: ``osid.journaling.JournalEntryReceiver``\n        :param proxy: a proxy\n        :type proxy: ``osid.proxy.Proxy``\n", 
               "sphinx_return_doc": "        :return: a ``JournalEntryNotificationSession``\n        :rtype: ``osid.journaling.JournalEntryNotificationSession``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``journal_entry_receiver`` or ``proxy`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_journal_entry_notification()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_journal_entry_notification()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.journaling.JournalEntryReceiver", 
                     "var_name": "journal_entry_receiver", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.proxy.Proxy", 
                     "var_name": "proxy", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.journaling.JournalEntryReceiver", 
                  "osid.proxy.Proxy"
               ], 
               "return_type": "osid.journaling.JournalEntryNotificationSession", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_journal_entry_notification_session_for_journal", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` associated with the journal entry notification service for the given journal.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    journal_entry_receiver\n                (osid.journaling.JournalEntryReceiver): the receiver\n        arg:    journal_id (osid.id.Id): the ``Id`` of the ``Journal``\n        arg:    proxy (osid.proxy.Proxy): a proxy\n", 
               "return_doc": "        return: (osid.journaling.JournalEntryNotificationSession) - a\n                ``JournalEntryNotificationSession``", 
               "error_doc": "        raise:  NotFound - no ``Journal`` found by the given ``Id``\n        raise:  NullArgument - ``journal_entry_receiver, journal_id`` or\n                ``proxy`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented -\n                ``supports_journal_entry_notification()`` or\n                ``supports_visible_federation()`` is ``false``", 
               "sphinx_param_doc": "        :param journal_entry_receiver: the receiver\n        :type journal_entry_receiver: ``osid.journaling.JournalEntryReceiver``\n        :param journal_id: the ``Id`` of the ``Journal``\n        :type journal_id: ``osid.id.Id``\n        :param proxy: a proxy\n        :type proxy: ``osid.proxy.Proxy``\n", 
               "sphinx_return_doc": "        :return: a ``JournalEntryNotificationSession``\n        :rtype: ``osid.journaling.JournalEntryNotificationSession``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- no ``Journal`` found by the given ``Id``\n        :raise: ``NullArgument`` -- ``journal_entry_receiver, journal_id`` or ``proxy`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_journal_entry_notification()`` or ``supports_visible_federation()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_journal_entry_notification()`` and ``supports_visible_federation()`` are ``true``*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.journaling.JournalEntryReceiver", 
                     "var_name": "journal_entry_receiver", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "journal_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.proxy.Proxy", 
                     "var_name": "proxy", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.journaling.JournalEntryReceiver", 
                  "osid.id.Id", 
                  "osid.proxy.Proxy"
               ], 
               "return_type": "osid.journaling.JournalEntryNotificationSession", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_branch_lookup_session", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` associated with the branch lookup service.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    proxy (osid.proxy.Proxy): a proxy\n", 
               "return_doc": "        return: (osid.journaling.BranchLookupSession) - ``a\n                BranchLookupSession``", 
               "error_doc": "        raise:  NullArgument - ``proxy`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_branch_lookup()`` is\n                ``false``", 
               "sphinx_param_doc": "        :param proxy: a proxy\n        :type proxy: ``osid.proxy.Proxy``\n", 
               "sphinx_return_doc": "        :return: ``a BranchLookupSession``\n        :rtype: ``osid.journaling.BranchLookupSession``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``proxy`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_branch_lookup()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_branch_lookup()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.proxy.Proxy", 
                     "var_name": "proxy", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.proxy.Proxy"
               ], 
               "return_type": "osid.journaling.BranchLookupSession", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_branch_lookup_session_for_journal", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` associated with the branch lookup service for the given journal.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    journal_id (osid.id.Id): the ``Id`` of the journal\n        arg:    proxy (osid.proxy.Proxy): ``a proxy``\n", 
               "return_doc": "        return: (osid.journaling.BranchLookupSession) - ``a\n                BranchLookupSession``", 
               "error_doc": "        raise:  NotFound - ``journal_id`` not found\n        raise:  NullArgument - ``journal_id`` or ``proxy`` is ``null``\n        raise:  OperationFailed - ``unable to complete request``\n        raise:  Unimplemented - ``supports_branch_lookup()`` or\n                ``supports_visible_federation()`` is ``false``", 
               "sphinx_param_doc": "        :param journal_id: the ``Id`` of the journal\n        :type journal_id: ``osid.id.Id``\n        :param proxy: ``a proxy``\n        :type proxy: ``osid.proxy.Proxy``\n", 
               "sphinx_return_doc": "        :return: ``a BranchLookupSession``\n        :rtype: ``osid.journaling.BranchLookupSession``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``journal_id`` not found\n        :raise: ``NullArgument`` -- ``journal_id`` or ``proxy`` is ``null``\n        :raise: ``OperationFailed`` -- ``unable to complete request``\n        :raise: ``Unimplemented`` -- ``supports_branch_lookup()`` or ``supports_visible_federation()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_branch_lookup()`` and ``supports_visible_federation()`` are ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "journal_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.proxy.Proxy", 
                     "var_name": "proxy", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "osid.proxy.Proxy"
               ], 
               "return_type": "osid.journaling.BranchLookupSession", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_branch_query_session", 
               "doc": {
                  "headline": "Gets a branch query session.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    proxy (osid.proxy.Proxy): a proxy\n", 
               "return_doc": "        return: (osid.journaling.BranchQuerySession) - ``a\n                BranchQuerySession``", 
               "error_doc": "        raise:  NullArgument - ``proxy`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_branch_query()`` is ``false``", 
               "sphinx_param_doc": "        :param proxy: a proxy\n        :type proxy: ``osid.proxy.Proxy``\n", 
               "sphinx_return_doc": "        :return: ``a BranchQuerySession``\n        :rtype: ``osid.journaling.BranchQuerySession``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``proxy`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_branch_query()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_branch_query()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.proxy.Proxy", 
                     "var_name": "proxy", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.proxy.Proxy"
               ], 
               "return_type": "osid.journaling.BranchQuerySession", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_branch_query_session_for_journal", 
               "doc": {
                  "headline": "Gets a branch query session for the given journal.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    journal_id (osid.id.Id): the ``Id`` of the journal\n        arg:    proxy (osid.proxy.Proxy): a proxy\n", 
               "return_doc": "        return: (osid.journaling.BranchQuerySession) - ``a\n                BranchQuerySession``", 
               "error_doc": "        raise:  NotFound - ``journal_id`` not found\n        raise:  NullArgument - ``journal_id`` or ``proxy`` is ``null``\n        raise:  OperationFailed - ``unable to complete request``\n        raise:  Unimplemented - ``supports_branch_query()`` or\n                ``supports_visible_federation()`` is ``false``", 
               "sphinx_param_doc": "        :param journal_id: the ``Id`` of the journal\n        :type journal_id: ``osid.id.Id``\n        :param proxy: a proxy\n        :type proxy: ``osid.proxy.Proxy``\n", 
               "sphinx_return_doc": "        :return: ``a BranchQuerySession``\n        :rtype: ``osid.journaling.BranchQuerySession``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``journal_id`` not found\n        :raise: ``NullArgument`` -- ``journal_id`` or ``proxy`` is ``null``\n        :raise: ``OperationFailed`` -- ``unable to complete request``\n        :raise: ``Unimplemented`` -- ``supports_branch_query()`` or ``supports_visible_federation()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_branch_query()`` and ``supports_visible_federation()`` are ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "journal_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.proxy.Proxy", 
                     "var_name": "proxy", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "osid.proxy.Proxy"
               ], 
               "return_type": "osid.journaling.BranchQuerySession", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_branch_search_session", 
               "doc": {
                  "headline": "Gets a branch search session.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    proxy (osid.proxy.Proxy): a proxy\n", 
               "return_doc": "        return: (osid.journaling.BranchSearchSession) - ``a\n                BranchSearchSession``", 
               "error_doc": "        raise:  NullArgument - ``proxy`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_branch_search()`` is\n                ``false``", 
               "sphinx_param_doc": "        :param proxy: a proxy\n        :type proxy: ``osid.proxy.Proxy``\n", 
               "sphinx_return_doc": "        :return: ``a BranchSearchSession``\n        :rtype: ``osid.journaling.BranchSearchSession``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``proxy`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_branch_search()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_branch_search()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.proxy.Proxy", 
                     "var_name": "proxy", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.proxy.Proxy"
               ], 
               "return_type": "osid.journaling.BranchSearchSession", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_branch_search_session_for_journal", 
               "doc": {
                  "headline": "Gets a branch search session for the given journal.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    journal_id (osid.id.Id): the ``Id`` of the journal\n        arg:    proxy (osid.proxy.Proxy): a proxy\n", 
               "return_doc": "        return: (osid.journaling.BranchSearchSession) - ``a\n                BranchSearchSession``", 
               "error_doc": "        raise:  NotFound - ``journal_id`` not found\n        raise:  NullArgument - ``journal_id`` or ``proxy`` is ``null``\n        raise:  OperationFailed - ``unable to complete request``\n        raise:  Unimplemented - ``supports_branch_search()`` or\n                ``supports_visible_federation()`` is ``false``", 
               "sphinx_param_doc": "        :param journal_id: the ``Id`` of the journal\n        :type journal_id: ``osid.id.Id``\n        :param proxy: a proxy\n        :type proxy: ``osid.proxy.Proxy``\n", 
               "sphinx_return_doc": "        :return: ``a BranchSearchSession``\n        :rtype: ``osid.journaling.BranchSearchSession``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``journal_id`` not found\n        :raise: ``NullArgument`` -- ``journal_id`` or ``proxy`` is ``null``\n        :raise: ``OperationFailed`` -- ``unable to complete request``\n        :raise: ``Unimplemented`` -- ``supports_branch_search()`` or ``supports_visible_federation()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_branch_search()`` and ``supports_visible_federation()`` are ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "journal_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.proxy.Proxy", 
                     "var_name": "proxy", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "osid.proxy.Proxy"
               ], 
               "return_type": "osid.journaling.BranchSearchSession", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_branch_admin_session", 
               "doc": {
                  "headline": "Gets a branch administration session for creating, updating and deleting branches.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    proxy (osid.proxy.Proxy): a proxy\n", 
               "return_doc": "        return: (osid.journaling.BranchAdminSession) - ``a\n                BranchAdminSession``", 
               "error_doc": "        raise:  NullArgument - ``proxy`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_branch_admin()`` is ``false``", 
               "sphinx_param_doc": "        :param proxy: a proxy\n        :type proxy: ``osid.proxy.Proxy``\n", 
               "sphinx_return_doc": "        :return: ``a BranchAdminSession``\n        :rtype: ``osid.journaling.BranchAdminSession``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``proxy`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_branch_admin()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_branch_admin()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.proxy.Proxy", 
                     "var_name": "proxy", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.proxy.Proxy"
               ], 
               "return_type": "osid.journaling.BranchAdminSession", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_branch_admin_session_for_journal", 
               "doc": {
                  "headline": "Gets a branch administration session for the given journal.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    journal_id (osid.id.Id): the ``Id`` of the journal\n        arg:    proxy (osid.proxy.Proxy): a proxy\n", 
               "return_doc": "        return: (osid.journaling.BranchAdminSession) - ``a\n                BranchAdminSession``", 
               "error_doc": "        raise:  NotFound - ``journal_id`` not found\n        raise:  NullArgument - ``journal_id`` or ``proxy`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_branch_admin()`` or\n                ``supports_visible_federation()`` is ``false``", 
               "sphinx_param_doc": "        :param journal_id: the ``Id`` of the journal\n        :type journal_id: ``osid.id.Id``\n        :param proxy: a proxy\n        :type proxy: ``osid.proxy.Proxy``\n", 
               "sphinx_return_doc": "        :return: ``a BranchAdminSession``\n        :rtype: ``osid.journaling.BranchAdminSession``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``journal_id`` not found\n        :raise: ``NullArgument`` -- ``journal_id`` or ``proxy`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_branch_admin()`` or ``supports_visible_federation()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_branch_admin()`` and ``supports_visible_federation()`` are ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "journal_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.proxy.Proxy", 
                     "var_name": "proxy", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "osid.proxy.Proxy"
               ], 
               "return_type": "osid.journaling.BranchAdminSession", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_branch_notification_session", 
               "doc": {
                  "headline": "Gets the branch notification session for the given journal.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    branch_receiver (osid.journaling.BranchReceiver):\n                notification callback\n        arg:    proxy (osid.proxy.Proxy): a proxy\n", 
               "return_doc": "        return: (osid.journaling.BranchNotificationSession) - ``a\n                BranchNotificationSession``", 
               "error_doc": "        raise:  NullArgument - ``branch_receiver`` or ``proxy`` is\n                ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_branch_notification()`` is\n                ``false``", 
               "sphinx_param_doc": "        :param branch_receiver: notification callback\n        :type branch_receiver: ``osid.journaling.BranchReceiver``\n        :param proxy: a proxy\n        :type proxy: ``osid.proxy.Proxy``\n", 
               "sphinx_return_doc": "        :return: ``a BranchNotificationSession``\n        :rtype: ``osid.journaling.BranchNotificationSession``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``branch_receiver`` or ``proxy`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_branch_notification()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_branch_notification()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.journaling.BranchReceiver", 
                     "var_name": "branch_receiver", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.proxy.Proxy", 
                     "var_name": "proxy", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.journaling.BranchReceiver", 
                  "osid.proxy.Proxy"
               ], 
               "return_type": "osid.journaling.BranchNotificationSession", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_branch_notification_session_for_journal", 
               "doc": {
                  "headline": "Gets the branch notification session for the given journal.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    branch_receiver (osid.journaling.BranchReceiver):\n                notification callback\n        arg:    journal_id (osid.id.Id): the ``Id`` of the journal\n        arg:    proxy (osid.proxy.Proxy): a proxy\n", 
               "return_doc": "        return: (osid.journaling.BranchNotificationSession) - ``a\n                BranchNotificationSession``", 
               "error_doc": "        raise:  NotFound - ``journal_id`` not found\n        raise:  NullArgument - ``branch_receiver, journal_id`` or\n                ``proxy`` is ``null``\n        raise:  OperationFailed - ``unable to complete request``\n        raise:  Unimplemented - ``supports_branch_notification()`` or\n                ``supports_visible_federation()`` is ``false``", 
               "sphinx_param_doc": "        :param branch_receiver: notification callback\n        :type branch_receiver: ``osid.journaling.BranchReceiver``\n        :param journal_id: the ``Id`` of the journal\n        :type journal_id: ``osid.id.Id``\n        :param proxy: a proxy\n        :type proxy: ``osid.proxy.Proxy``\n", 
               "sphinx_return_doc": "        :return: ``a BranchNotificationSession``\n        :rtype: ``osid.journaling.BranchNotificationSession``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``journal_id`` not found\n        :raise: ``NullArgument`` -- ``branch_receiver, journal_id`` or ``proxy`` is ``null``\n        :raise: ``OperationFailed`` -- ``unable to complete request``\n        :raise: ``Unimplemented`` -- ``supports_branch_notification()`` or ``supports_visible_federation()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_branch_notfication()`` and ``supports_visible_federation()`` are ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.journaling.BranchReceiver", 
                     "var_name": "branch_receiver", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "journal_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.proxy.Proxy", 
                     "var_name": "proxy", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.journaling.BranchReceiver", 
                  "osid.id.Id", 
                  "osid.proxy.Proxy"
               ], 
               "return_type": "osid.journaling.BranchNotificationSession", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_branch_smart_journal_session", 
               "doc": {
                  "headline": "Gets the session for managing dynamic branch journals.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    journal_id (osid.id.Id): the ``Id`` of the journal\n        arg:    proxy (osid.proxy.Proxy): a proxy\n", 
               "return_doc": "        return: (osid.journaling.BranchSmartJournalSession) - a\n                ``BranchSmartJournalSession``", 
               "error_doc": "        raise:  NotFound - ``journal_id`` not found\n        raise:  NullArgument - ``journal_id`` or ``proxy`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_branch_smart_journal()`` is\n                ``false``", 
               "sphinx_param_doc": "        :param journal_id: the ``Id`` of the journal\n        :type journal_id: ``osid.id.Id``\n        :param proxy: a proxy\n        :type proxy: ``osid.proxy.Proxy``\n", 
               "sphinx_return_doc": "        :return: a ``BranchSmartJournalSession``\n        :rtype: ``osid.journaling.BranchSmartJournalSession``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``journal_id`` not found\n        :raise: ``NullArgument`` -- ``journal_id`` or ``proxy`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_branch_smart_journal()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_branch_smart_journal()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "journal_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.proxy.Proxy", 
                     "var_name": "proxy", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "osid.proxy.Proxy"
               ], 
               "return_type": "osid.journaling.BranchSmartJournalSession", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_journal_lookup_session", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` associated with the journal lookup service.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    proxy (osid.proxy.Proxy): a proxy\n", 
               "return_doc": "        return: (osid.journaling.JournalLookupSession) - a\n                ``JournalLookupSession``", 
               "error_doc": "        raise:  NullArgument - ``proxy`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_journal_lookup()`` is\n                ``false``", 
               "sphinx_param_doc": "        :param proxy: a proxy\n        :type proxy: ``osid.proxy.Proxy``\n", 
               "sphinx_return_doc": "        :return: a ``JournalLookupSession``\n        :rtype: ``osid.journaling.JournalLookupSession``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``proxy`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_journal_lookup()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_journal_lookup()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.proxy.Proxy", 
                     "var_name": "proxy", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.proxy.Proxy"
               ], 
               "return_type": "osid.journaling.JournalLookupSession", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_journal_query_session", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` associated with the journal query service.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    proxy (osid.proxy.Proxy): a proxy\n", 
               "return_doc": "        return: (osid.journaling.JournalQuerySession) - a\n                ``JournalQuerySession``", 
               "error_doc": "        raise:  NullArgument - ``proxy`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_journal_query()`` is\n                ``false``", 
               "sphinx_param_doc": "        :param proxy: a proxy\n        :type proxy: ``osid.proxy.Proxy``\n", 
               "sphinx_return_doc": "        :return: a ``JournalQuerySession``\n        :rtype: ``osid.journaling.JournalQuerySession``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``proxy`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_journal_query()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_journal_query()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.proxy.Proxy", 
                     "var_name": "proxy", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.proxy.Proxy"
               ], 
               "return_type": "osid.journaling.JournalQuerySession", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_journal_search_session", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` associated with the journal search service.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    proxy (osid.proxy.Proxy): a proxy\n", 
               "return_doc": "        return: (osid.journaling.JournalSearchSession) - a\n                ``JournalSearchSession``", 
               "error_doc": "        raise:  NullArgument - ``proxy`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_journal_search()`` is\n                ``false``", 
               "sphinx_param_doc": "        :param proxy: a proxy\n        :type proxy: ``osid.proxy.Proxy``\n", 
               "sphinx_return_doc": "        :return: a ``JournalSearchSession``\n        :rtype: ``osid.journaling.JournalSearchSession``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``proxy`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_journal_search()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_journal_search()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.proxy.Proxy", 
                     "var_name": "proxy", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.proxy.Proxy"
               ], 
               "return_type": "osid.journaling.JournalSearchSession", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_journal_admin_session", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` associated with the journal administrative service.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    proxy (osid.proxy.Proxy): a proxy\n", 
               "return_doc": "        return: (osid.journaling.JournalAdminSession) - a\n                ``JournalAdminSession``", 
               "error_doc": "        raise:  NullArgument - ``proxy`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_journal_admin()`` is\n                ``false``", 
               "sphinx_param_doc": "        :param proxy: a proxy\n        :type proxy: ``osid.proxy.Proxy``\n", 
               "sphinx_return_doc": "        :return: a ``JournalAdminSession``\n        :rtype: ``osid.journaling.JournalAdminSession``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``proxy`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_journal_admin()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_journal_admin()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.proxy.Proxy", 
                     "var_name": "proxy", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.proxy.Proxy"
               ], 
               "return_type": "osid.journaling.JournalAdminSession", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_journal_notification_session", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` associated with the journal notification service.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    journal_receiver (osid.journaling.JournalReceiver): the\n                receiver\n        arg:    proxy (osid.proxy.Proxy): a proxy\n", 
               "return_doc": "        return: (osid.journaling.JournalNotificationSession) - a\n                ``JournalNotificationSession``", 
               "error_doc": "        raise:  NullArgument - ``journal_receiver`` or ``proxy`` is\n                ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_journal_notification()`` is\n                ``false``", 
               "sphinx_param_doc": "        :param journal_receiver: the receiver\n        :type journal_receiver: ``osid.journaling.JournalReceiver``\n        :param proxy: a proxy\n        :type proxy: ``osid.proxy.Proxy``\n", 
               "sphinx_return_doc": "        :return: a ``JournalNotificationSession``\n        :rtype: ``osid.journaling.JournalNotificationSession``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``journal_receiver`` or ``proxy`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_journal_notification()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_journal_notification()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.journaling.JournalReceiver", 
                     "var_name": "journal_receiver", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.proxy.Proxy", 
                     "var_name": "proxy", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.journaling.JournalReceiver", 
                  "osid.proxy.Proxy"
               ], 
               "return_type": "osid.journaling.JournalNotificationSession", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_journal_hierarchy_session", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` associated with the journal hierarchy service.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    proxy (osid.proxy.Proxy): a proxy\n", 
               "return_doc": "        return: (osid.journaling.JournalHierarchySession) - a\n                ``JournalHierarchySession``", 
               "error_doc": "        raise:  NullArgument - ``proxy`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_journal_hierarchy()`` is\n                ``false``", 
               "sphinx_param_doc": "        :param proxy: a proxy\n        :type proxy: ``osid.proxy.Proxy``\n", 
               "sphinx_return_doc": "        :return: a ``JournalHierarchySession``\n        :rtype: ``osid.journaling.JournalHierarchySession``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``proxy`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_journal_hierarchy()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_journal_hierarchy()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.proxy.Proxy", 
                     "var_name": "proxy", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.proxy.Proxy"
               ], 
               "return_type": "osid.journaling.JournalHierarchySession", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_journal_hierarchy_design_session", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` associated with the journal hierarchy design service.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    proxy (osid.proxy.Proxy): a proxy\n", 
               "return_doc": "        return: (osid.journaling.JournalHierarchyDesignSession) - a\n                ``JournalHierarchyDesignSession``", 
               "error_doc": "        raise:  NullArgument - ``proxy`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_journal_hierarchy_design()``\n                is ``false``", 
               "sphinx_param_doc": "        :param proxy: a proxy\n        :type proxy: ``osid.proxy.Proxy``\n", 
               "sphinx_return_doc": "        :return: a ``JournalHierarchyDesignSession``\n        :rtype: ``osid.journaling.JournalHierarchyDesignSession``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``proxy`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_journal_hierarchy_design()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_journal_hierarchy_design()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.proxy.Proxy", 
                     "var_name": "proxy", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.proxy.Proxy"
               ], 
               "return_type": "osid.journaling.JournalHierarchyDesignSession", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_journaling_batch_proxy_manager", 
               "doc": {
                  "headline": "Gets a ``JournalingBatchProxyManager``.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.journaling.batch.JournalingBatchProxyManager) - a\n                ``JournalingBatchProxyManager``", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_journaling_batch()`` is\n                ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: a ``JournalingBatchProxyManager``\n        :rtype: ``osid.journaling.batch.JournalingBatchProxyManager``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_journaling_batch()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_journaling_batch()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.journaling.batch.JournalingBatchProxyManager", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.journaling.JournalEntryLookupSession", 
         "shortname": "JournalEntryLookupSession", 
         "category": "sessions", 
         "doc": {
            "headline": "This session defines methods for retrieving journal entries.", 
            "body": "    A ``JournalEntry`` is a version entry for an OSID ``Id``.\n\n    This lookup session defines several views:\n    \n      * comparative view: elements may be silently omitted or re-ordered\n      * plenary view: provides a complete result set or is an error\n        condition\n      * isolated journal view: All journal entry methods in this session\n        operate, retrieve and pertain to journal entries defined\n        explicitly in the current journal. Using an isolated view is\n        useful for managing journal entries with the\n        ``JournalEntryAdminSession.``\n      * federated journal view: All journal entry lookup methods in this\n        session operate, retrieve and pertain to all journal entries\n        defined in this journal and any other journals implicitly\n        available in this journal through journal inheritence.\n\n    \n    The methods ``use_federated_journal_view()`` and\n    ``use_isolated_journal_view()`` behave as a radio group and one\n    should be selected before invoking any lookup methods."
         }, 
         "inherit_fullnames": [
            "osid.OsidSession"
         ], 
         "inherit_shortnames": [
            "OsidSession"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidSession"
            }
         ], 
         "method_names": [
            "get_journal_id", 
            "get_journal", 
            "can_read_journal", 
            "use_comparative_journal_entry_view", 
            "use_plenary_journal_entry_view", 
            "use_federated_journal_view", 
            "use_isolated_journal_view", 
            "get_journal_entry", 
            "get_journal_entries_by_ids", 
            "get_journal_entries_by_genus_type", 
            "get_journal_entries_by_parent_genus_type", 
            "get_journal_entries_by_record_type", 
            "get_journal_entries_for_branch", 
            "get_journal_entries_by_date_for_branch", 
            "get_journal_entries_by_date_range_for_branch", 
            "get_journal_entries_for_source", 
            "get_journal_entries_by_date_for_source", 
            "get_journal_entries_by_date_range_for_source", 
            "get_journal_entries_for_branch_and_source", 
            "get_journal_entries_by_date_for_branch_and_source", 
            "get_journal_entries_by_date_range_for_branch_and_source", 
            "get_journal_entries_for_resource", 
            "get_journal_entries_by_date_for_resource", 
            "get_journal_entries_by_date_range_for_resource", 
            "get_journal_entries"
         ], 
         "methods": [
            {
               "name": "get_journal_id", 
               "doc": {
                  "headline": "Gets the ``Journal``  ``Id`` associated with this session.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.id.Id) - the ``Journal Id`` associated with this\n                session", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the ``Journal Id`` associated with this session\n        :rtype: ``osid.id.Id``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.id.Id", 
               "errors": {}
            }, 
            {
               "name": "get_journal", 
               "doc": {
                  "headline": "Gets the ``Journal`` associated with this session.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.journaling.Journal) - the journal", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the journal\n        :rtype: ``osid.journaling.Journal``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.journaling.Journal", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "can_read_journal", 
               "doc": {
                  "headline": "Tests if this user can examine this journal.", 
                  "body": "        A return of true does not guarantee successful authorization. A\n        return of false indicates that it is known all methods in this\n        session will result in a ``PermissionDenied``. This is intended\n        as a hint to an application that may opt not to offer these\n        operations."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``false`` if journal reading methods are not\n                authorized, ``true`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``false`` if journal reading methods are not authorized, ``true`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "use_comparative_journal_entry_view", 
               "doc": {
                  "headline": "The returns from the lookup methods may omit or translate elements based on this session, such as authorization, and not result in an error.", 
                  "body": "        This view is used when greater interoperability is desired at\n        the expense of precision."
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "use_plenary_journal_entry_view", 
               "doc": {
                  "headline": "A complete view of the ``JournalEntry`` returns is desired.", 
                  "body": "        Methods will return what is requested or result in an error.\n        This view is used when greater precision is desired at the\n        expense of interoperability."
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "use_federated_journal_view", 
               "doc": {
                  "headline": "Federates the view for methods in this session.", 
                  "body": "        A federated view will include entries in journals which are\n        children of this journal in the journal hierarchy."
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "use_isolated_journal_view", 
               "doc": {
                  "headline": "Isolates the view for methods in this session.", 
                  "body": "        An isolated view restricts retrievals to this journal only."
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "get_journal_entry", 
               "doc": {
                  "headline": "Gets the ``JournalEntry`` specified by its ``Id``.", 
                  "body": "        In plenary mode, the exact ``Id`` is found or a ``NotFound``\n        results. Otherwise, the returned ``JournalEntry`` may have a\n        different ``Id`` than requested, such as the case where a\n        duplicate ``Id`` was assigned to a ``JournalEntry`` and retained\n        for compatibility."
               }, 
               "arg_doc": "        arg:    journal_entry_id (osid.id.Id): the ``Id`` of the\n                ``JournalEntry`` to retrieve\n", 
               "return_doc": "        return: (osid.journaling.JournalEntry) - the returned\n                ``JournalEntry``", 
               "error_doc": "        raise:  NotFound - no ``JournalEntry`` found with the given\n                ``Id``\n        raise:  NullArgument - ``journal_entry_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param journal_entry_id: the ``Id`` of the ``JournalEntry`` to retrieve\n        :type journal_entry_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: the returned ``JournalEntry``\n        :rtype: ``osid.journaling.JournalEntry``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- no ``JournalEntry`` found with the given ``Id``\n        :raise: ``NullArgument`` -- ``journal_entry_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "journal_entry_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "osid.journaling.JournalEntry", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_journal_entries_by_ids", 
               "doc": {
                  "headline": "Gets a ``JournalEntryList`` corresponding to the given ``IdList``.", 
                  "body": "        In plenary mode, the returned list contains all of the entries\n        specified in the ``Id`` list, in the order of the list,\n        including duplicates, or an error results if an ``Id`` in the\n        supplied list is not found or inaccessible. Otherwise,\n        inaccessible entries may be omitted from the list and may\n        present the elements in any order including returning a unique\n        set."
               }, 
               "arg_doc": "        arg:    journal_entry_ids (osid.id.IdList): the list of ``Ids``\n                to retrieve\n", 
               "return_doc": "        return: (osid.journaling.JournalEntryList) - the returned\n                ``JournalEntry list``", 
               "error_doc": "        raise:  NotFound - an ``Id was`` not found\n        raise:  NullArgument - ``journal_entry_ids`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param journal_entry_ids: the list of ``Ids`` to retrieve\n        :type journal_entry_ids: ``osid.id.IdList``\n", 
               "sphinx_return_doc": "        :return: the returned ``JournalEntry list``\n        :rtype: ``osid.journaling.JournalEntryList``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- an ``Id was`` not found\n        :raise: ``NullArgument`` -- ``journal_entry_ids`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.IdList", 
                     "var_name": "journal_entry_ids", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.IdList"
               ], 
               "return_type": "osid.journaling.JournalEntryList", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_journal_entries_by_genus_type", 
               "doc": {
                  "headline": "Gets a ``JournalEntryList`` corresponding to the given journal entry genus ``Type`` which does not include journal entries of genus types derived from the specified ``Type``.", 
                  "body": "        In plenary mode, the returned list contains all known journal\n        entries or an error results. Otherwise, the returned list may\n        contain only those journal entries that are accessible through\n        this session."
               }, 
               "arg_doc": "        arg:    journal_entry_genus_type (osid.type.Type): a journal\n                entry genus type\n", 
               "return_doc": "        return: (osid.journaling.JournalEntryList) - the returned\n                ``JournalEntry`` list", 
               "error_doc": "        raise:  NullArgument - ``journal_entry_genus_type`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param journal_entry_genus_type: a journal entry genus type\n        :type journal_entry_genus_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "        :return: the returned ``JournalEntry`` list\n        :rtype: ``osid.journaling.JournalEntryList``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``journal_entry_genus_type`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "journal_entry_genus_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "osid.journaling.JournalEntryList", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_journal_entries_by_parent_genus_type", 
               "doc": {
                  "headline": "Gets a ``JournalEntryList`` corresponding to the given journal entry genus ``Type`` and include any additional journal entries with genus types derived from the specified ``Type``.", 
                  "body": "        In plenary mode, the returned list contains all known journal\n        entries or an error results. Otherwise, the returned list may\n        contain only those journal entries that are accessible through\n        this session."
               }, 
               "arg_doc": "        arg:    journal_entry_genus_type (osid.type.Type): a journal\n                entry genus type\n", 
               "return_doc": "        return: (osid.journaling.JournalEntryList) - the returned\n                ``JournalEntry`` list", 
               "error_doc": "        raise:  NullArgument - ``journal_entry_genus_type`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param journal_entry_genus_type: a journal entry genus type\n        :type journal_entry_genus_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "        :return: the returned ``JournalEntry`` list\n        :rtype: ``osid.journaling.JournalEntryList``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``journal_entry_genus_type`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "journal_entry_genus_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "osid.journaling.JournalEntryList", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_journal_entries_by_record_type", 
               "doc": {
                  "headline": "Gets a ``JournalEntryList`` containing the given journal entry record ``Type``.", 
                  "body": "        In plenary mode, the returned list contains all known journal\n        entries or an error results. Otherwise, the returned list may\n        contain only those journal entries that are accessible through\n        this session."
               }, 
               "arg_doc": "        arg:    journal_entry_record_type (osid.type.Type): a journal\n                entry record type\n", 
               "return_doc": "        return: (osid.journaling.JournalEntryList) - the returned\n                ``JournalEntry`` list", 
               "error_doc": "        raise:  NullArgument - ``journal_entry_record_type`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param journal_entry_record_type: a journal entry record type\n        :type journal_entry_record_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "        :return: the returned ``JournalEntry`` list\n        :rtype: ``osid.journaling.JournalEntryList``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``journal_entry_record_type`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "journal_entry_record_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "osid.journaling.JournalEntryList", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_journal_entries_for_branch", 
               "doc": {
                  "headline": "Gets a list of journal entries corresponding to a branch ``Id``.", 
                  "body": "        In plenary mode, the returned list contains all known journal\n        entries or an error results. Otherwise, the returned list may\n        contain only those journal entries that are accessible through\n        this session."
               }, 
               "arg_doc": "        arg:    branch_id (osid.id.Id): the ``Id`` of the branch\n", 
               "return_doc": "        return: (osid.journaling.JournalEntryList) - the returned\n                ``JournalEntryList``", 
               "error_doc": "        raise:  NullArgument - ``branch_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param branch_id: the ``Id`` of the branch\n        :type branch_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: the returned ``JournalEntryList``\n        :rtype: ``osid.journaling.JournalEntryList``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``branch_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "branch_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "osid.journaling.JournalEntryList", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_journal_entries_by_date_for_branch", 
               "doc": {
                  "headline": "Gets the journal entry corresponding to a resource ``Id`` and date.", 
                  "body": "        The entries returned have a date equal to or more recent than\n        the requested date. In plenary mode, the returned list contains\n        all known journal entries or an error results. Otherwise, the\n        returned list may contain only those journal entries that are\n        accessible through this session."
               }, 
               "arg_doc": "        arg:    branch_id (osid.id.Id): the ``Id`` of the branch\n        arg:    date (osid.calendaring.DateTime): from date\n", 
               "return_doc": "        return: (osid.journaling.JournalEntryList) - the returned\n                ``JournalEntryList``", 
               "error_doc": "        raise:  NullArgument - ``branch_id`` or ``date`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param branch_id: the ``Id`` of the branch\n        :type branch_id: ``osid.id.Id``\n        :param date: from date\n        :type date: ``osid.calendaring.DateTime``\n", 
               "sphinx_return_doc": "        :return: the returned ``JournalEntryList``\n        :rtype: ``osid.journaling.JournalEntryList``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``branch_id`` or ``date`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "branch_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.calendaring.DateTime", 
                     "var_name": "date", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "osid.calendaring.DateTime"
               ], 
               "return_type": "osid.journaling.JournalEntryList", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_journal_entries_by_date_range_for_branch", 
               "doc": {
                  "headline": "Gets a list of journal entries corresponding to a branch ``Id`` and date range.", 
                  "body": "        Entries are returned with dates that fall between the requested\n        dates inclusive. In plenary mode, the returned list contains all\n        known journal entries or an error results. Otherwise, the\n        returned list may contain only those journal entries that are\n        accessible through this session."
               }, 
               "arg_doc": "        arg:    branch_id (osid.id.Id): the ``Id`` of the branch\n        arg:    from (osid.calendaring.DateTime): from date\n        arg:    to (osid.calendaring.DateTime): to date\n", 
               "return_doc": "        return: (osid.journaling.JournalEntryList) - the returned\n                ``JournalEntryList``", 
               "error_doc": "        raise:  InvalidArgument - ``to`` is less than ``from``\n        raise:  NullArgument - ``branch_id, from`` or ``to`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param branch_id: the ``Id`` of the branch\n        :type branch_id: ``osid.id.Id``\n        :param from: from date\n        :type from: ``osid.calendaring.DateTime``\n        :param to: to date\n        :type to: ``osid.calendaring.DateTime``\n", 
               "sphinx_return_doc": "        :return: the returned ``JournalEntryList``\n        :rtype: ``osid.journaling.JournalEntryList``", 
               "sphinx_error_doc": "        :raise: ``InvalidArgument`` -- ``to`` is less than ``from``\n        :raise: ``NullArgument`` -- ``branch_id, from`` or ``to`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "branch_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.calendaring.DateTime", 
                     "var_name": "from_", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.calendaring.DateTime", 
                     "var_name": "to", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "osid.calendaring.DateTime", 
                  "osid.calendaring.DateTime"
               ], 
               "return_type": "osid.journaling.JournalEntryList", 
               "errors": {
                  "INVALID_ARGUMENT": "ConsumerContract", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_journal_entries_for_source", 
               "doc": {
                  "headline": "Gets a list of journal entries corresponding to a source ``Id``.", 
                  "body": "        A source ``Id`` of any version may be requested. In plenary\n        mode, the returned list contains all known journal entries or an\n        error results. Otherwise, the returned list may contain only\n        those journal entries that are accessible through this session."
               }, 
               "arg_doc": "        arg:    source_id (osid.id.Id): the ``Id`` of the source\n", 
               "return_doc": "        return: (osid.journaling.JournalEntryList) - the returned\n                ``JournalEntryList``", 
               "error_doc": "        raise:  NullArgument - ``source_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param source_id: the ``Id`` of the source\n        :type source_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: the returned ``JournalEntryList``\n        :rtype: ``osid.journaling.JournalEntryList``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``source_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "source_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "osid.journaling.JournalEntryList", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_journal_entries_by_date_for_source", 
               "doc": {
                  "headline": "Gets the journal entry corresponding to a source ``Id`` and date.", 
                  "body": "        The entry returned has a date equal to or more recent than the\n        requested date. The ``source_id`` may correspond to any version.\n        In plenary mode, the returned list contains all known journal\n        entries or an error results. Otherwise, the returned list may\n        contain only those journal entries that are accessible through\n        this session."
               }, 
               "arg_doc": "        arg:    source_id (osid.id.Id): a source ``Id``\n        arg:    date (osid.calendaring.DateTime): from date\n", 
               "return_doc": "        return: (osid.journaling.JournalEntryList) - the returned\n                ``JournalEntryList``", 
               "error_doc": "        raise:  NullArgument - ``source_id`` or ``to`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param source_id: a source ``Id``\n        :type source_id: ``osid.id.Id``\n        :param date: from date\n        :type date: ``osid.calendaring.DateTime``\n", 
               "sphinx_return_doc": "        :return: the returned ``JournalEntryList``\n        :rtype: ``osid.journaling.JournalEntryList``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``source_id`` or ``to`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "source_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.calendaring.DateTime", 
                     "var_name": "date", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "osid.calendaring.DateTime"
               ], 
               "return_type": "osid.journaling.JournalEntryList", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_journal_entries_by_date_range_for_source", 
               "doc": {
                  "headline": "Gets a list of journal entries corresponding to a source ``Id`` and date range.", 
                  "body": "        Entries are returned with dates that fall between the requested\n        dates inclusive. The ``source_id`` may correspond to any\n        version. In plenary mode, the returned list contains all known\n        journal entries or an error results. Otherwise, the returned\n        list may contain only those journal entries that are accessible\n        through this session."
               }, 
               "arg_doc": "        arg:    source_id (osid.id.Id): a source ``Id``\n        arg:    from (osid.calendaring.DateTime): from date\n        arg:    to (osid.calendaring.DateTime): to date\n", 
               "return_doc": "        return: (osid.journaling.JournalEntryList) - the returned\n                ``JournalEntryList``", 
               "error_doc": "        raise:  InvalidArgument - ``to`` is less than ``from``\n        raise:  NullArgument - ``source_id, from`` or ``to`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param source_id: a source ``Id``\n        :type source_id: ``osid.id.Id``\n        :param from: from date\n        :type from: ``osid.calendaring.DateTime``\n        :param to: to date\n        :type to: ``osid.calendaring.DateTime``\n", 
               "sphinx_return_doc": "        :return: the returned ``JournalEntryList``\n        :rtype: ``osid.journaling.JournalEntryList``", 
               "sphinx_error_doc": "        :raise: ``InvalidArgument`` -- ``to`` is less than ``from``\n        :raise: ``NullArgument`` -- ``source_id, from`` or ``to`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "source_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.calendaring.DateTime", 
                     "var_name": "from_", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.calendaring.DateTime", 
                     "var_name": "to", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "osid.calendaring.DateTime", 
                  "osid.calendaring.DateTime"
               ], 
               "return_type": "osid.journaling.JournalEntryList", 
               "errors": {
                  "INVALID_ARGUMENT": "ConsumerContract", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_journal_entries_for_branch_and_source", 
               "doc": {
                  "headline": "Gets a list of journal entries corresponding to a branch and source ``Id``.", 
                  "body": "        A source ``Id`` of any version may be requested.In plenary mode,\n        the returned list contains all known journal entries or an error\n        results. Otherwise, the returned list may contain only those\n        journal entries that are accessible through this session."
               }, 
               "arg_doc": "        arg:    branch_id (osid.id.Id): the ``Id`` of the branch\n        arg:    source_id (osid.id.Id): the ``Id`` of the source\n", 
               "return_doc": "        return: (osid.journaling.JournalEntryList) - the returned\n                ``JournalEntryList``", 
               "error_doc": "        raise:  NullArgument - ``branch_id`` or ``source_id`` is\n                ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param branch_id: the ``Id`` of the branch\n        :type branch_id: ``osid.id.Id``\n        :param source_id: the ``Id`` of the source\n        :type source_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: the returned ``JournalEntryList``\n        :rtype: ``osid.journaling.JournalEntryList``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``branch_id`` or ``source_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "branch_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "source_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "osid.id.Id"
               ], 
               "return_type": "osid.journaling.JournalEntryList", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_journal_entries_by_date_for_branch_and_source", 
               "doc": {
                  "headline": "Gets the journal entry corresponding to a branch and source ``Id`` and date.", 
                  "body": "        The entry returned has a date equal to or more recent than the\n        requested date. The ``source_id`` may correspond to any version.\n        In plenary mode, the returned list contains all known journal\n        entries or an error results. Otherwise, the returned list may\n        contain only those journal entries that are accessible through\n        this session."
               }, 
               "arg_doc": "        arg:    branch_id (osid.id.Id): a branch ``Id``\n        arg:    source_id (osid.id.Id): the ``Id`` of the source\n        arg:    date (osid.calendaring.DateTime): from date\n", 
               "return_doc": "        return: (osid.journaling.JournalEntryList) - the returned\n                ``JournalEntryList``", 
               "error_doc": "        raise:  NullArgument - ``branch_id, source_id`` or ``date`` is\n                ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param branch_id: a branch ``Id``\n        :type branch_id: ``osid.id.Id``\n        :param source_id: the ``Id`` of the source\n        :type source_id: ``osid.id.Id``\n        :param date: from date\n        :type date: ``osid.calendaring.DateTime``\n", 
               "sphinx_return_doc": "        :return: the returned ``JournalEntryList``\n        :rtype: ``osid.journaling.JournalEntryList``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``branch_id, source_id`` or ``date`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "branch_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "source_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.calendaring.DateTime", 
                     "var_name": "date", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "osid.id.Id", 
                  "osid.calendaring.DateTime"
               ], 
               "return_type": "osid.journaling.JournalEntryList", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_journal_entries_by_date_range_for_branch_and_source", 
               "doc": {
                  "headline": "Gets a list of journal entries corresponding to a branch and source ``Id`` and date range.", 
                  "body": "        Entries are returned with dates that fall between the requested\n        dates inclusive. The ``source_id`` may correspond to any version\n        In plenary mode, the returned list contains all known journal\n        entries or an error results. Otherwise, the returned list may\n        contain only those journal entries that are accessible through\n        this session."
               }, 
               "arg_doc": "        arg:    branch_id (osid.id.Id): a branch ``Id``\n        arg:    source_id (osid.id.Id): the ``Id`` of the source\n        arg:    from (osid.calendaring.DateTime): from date\n        arg:    to (osid.calendaring.DateTime): to date\n", 
               "return_doc": "        return: (osid.journaling.JournalEntryList) - the returned\n                ``JournalEntryList``", 
               "error_doc": "        raise:  InvalidArgument - ``to`` is less than ``from``\n        raise:  NullArgument - ``branch_id, source_id, from`` or ``to``\n                is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param branch_id: a branch ``Id``\n        :type branch_id: ``osid.id.Id``\n        :param source_id: the ``Id`` of the source\n        :type source_id: ``osid.id.Id``\n        :param from: from date\n        :type from: ``osid.calendaring.DateTime``\n        :param to: to date\n        :type to: ``osid.calendaring.DateTime``\n", 
               "sphinx_return_doc": "        :return: the returned ``JournalEntryList``\n        :rtype: ``osid.journaling.JournalEntryList``", 
               "sphinx_error_doc": "        :raise: ``InvalidArgument`` -- ``to`` is less than ``from``\n        :raise: ``NullArgument`` -- ``branch_id, source_id, from`` or ``to`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "branch_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "source_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.calendaring.DateTime", 
                     "var_name": "from_", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.calendaring.DateTime", 
                     "var_name": "to", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "osid.id.Id", 
                  "osid.calendaring.DateTime", 
                  "osid.calendaring.DateTime"
               ], 
               "return_type": "osid.journaling.JournalEntryList", 
               "errors": {
                  "INVALID_ARGUMENT": "ConsumerContract", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_journal_entries_for_resource", 
               "doc": {
                  "headline": "Gets a list of journal entries corresponding to a resource ``Id``.", 
                  "body": "        In plenary mode, the returned list contains all known journal\n        entries or an error results. Otherwise, the returned list may\n        contain only those journal entries that are accessible through\n        this session."
               }, 
               "arg_doc": "        arg:    resource_id (osid.id.Id): the ``Id`` of the resource\n", 
               "return_doc": "        return: (osid.journaling.JournalEntryList) - the returned\n                ``JournalEntryList``", 
               "error_doc": "        raise:  NullArgument - ``resource_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param resource_id: the ``Id`` of the resource\n        :type resource_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: the returned ``JournalEntryList``\n        :rtype: ``osid.journaling.JournalEntryList``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``resource_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "resource_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "osid.journaling.JournalEntryList", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_journal_entries_by_date_for_resource", 
               "doc": {
                  "headline": "Gets the journal entry corresponding to a resource ``Id`` and date.", 
                  "body": "        The entry returned has a date equal to or more recent than the\n        requested date. In plenary mode, the returned list contains all\n        known journal entries or an error results. Otherwise, the\n        returned list may contain only those journal entries that are\n        accessible through this session."
               }, 
               "arg_doc": "        arg:    resource_id (osid.id.Id): the ``Id`` of the resource\n        arg:    date (osid.calendaring.DateTime): from date\n", 
               "return_doc": "        return: (osid.journaling.JournalEntryList) - the returned\n                ``JournalEntryList``", 
               "error_doc": "        raise:  NullArgument - ``resource_id`` or ``date`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param resource_id: the ``Id`` of the resource\n        :type resource_id: ``osid.id.Id``\n        :param date: from date\n        :type date: ``osid.calendaring.DateTime``\n", 
               "sphinx_return_doc": "        :return: the returned ``JournalEntryList``\n        :rtype: ``osid.journaling.JournalEntryList``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``resource_id`` or ``date`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "resource_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.calendaring.DateTime", 
                     "var_name": "date", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "osid.calendaring.DateTime"
               ], 
               "return_type": "osid.journaling.JournalEntryList", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_journal_entries_by_date_range_for_resource", 
               "doc": {
                  "headline": "Gets a list of journal entries corresponding to a resource ``Id`` and date range.", 
                  "body": "        Entries are returned with dates that fall between the requested\n        dates inclusive. In plenary mode, the returned list contains all\n        known journal entries or an error results. Otherwise, the\n        returned list may contain only those journal entries that are\n        accessible through this session."
               }, 
               "arg_doc": "        arg:    resource_id (osid.id.Id): the ``Id`` of the resource\n        arg:    from (osid.calendaring.DateTime): from date\n        arg:    to (osid.calendaring.DateTime): to date\n", 
               "return_doc": "        return: (osid.journaling.JournalEntryList) - the returned\n                ``JournalEntryList``", 
               "error_doc": "        raise:  InvalidArgument - ``to`` is less than ``from``\n        raise:  NullArgument - ``resource_id, from`` or ``to`` is\n                ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param resource_id: the ``Id`` of the resource\n        :type resource_id: ``osid.id.Id``\n        :param from: from date\n        :type from: ``osid.calendaring.DateTime``\n        :param to: to date\n        :type to: ``osid.calendaring.DateTime``\n", 
               "sphinx_return_doc": "        :return: the returned ``JournalEntryList``\n        :rtype: ``osid.journaling.JournalEntryList``", 
               "sphinx_error_doc": "        :raise: ``InvalidArgument`` -- ``to`` is less than ``from``\n        :raise: ``NullArgument`` -- ``resource_id, from`` or ``to`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "resource_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.calendaring.DateTime", 
                     "var_name": "from_", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.calendaring.DateTime", 
                     "var_name": "to", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "osid.calendaring.DateTime", 
                  "osid.calendaring.DateTime"
               ], 
               "return_type": "osid.journaling.JournalEntryList", 
               "errors": {
                  "INVALID_ARGUMENT": "ConsumerContract", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_journal_entries", 
               "doc": {
                  "headline": "Gets all journal entries.", 
                  "body": "        In plenary mode, the returned list contains all known entries or\n        an error results. Otherwise, the returned list may contain only\n        those entries that are accessible through this session. In both\n        cases, the order of the set is not specifed. In plenary mode,\n        the returned list contains all known journal entries or an error\n        results. Otherwise, the returned list may contain only those\n        journal entries that are accessible through this session."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.journaling.JournalEntryList) - a list of journal\n                entries", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: a list of journal entries\n        :rtype: ``osid.journaling.JournalEntryList``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.journaling.JournalEntryList", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.journaling.JournalEntryQuerySession", 
         "shortname": "JournalEntryQuerySession", 
         "category": "sessions", 
         "doc": {
            "headline": "This session provides methods for searching ``JournalEntry`` objects.", 
            "body": "    The search query is constructed using the ``JournalEntryQuery``. The\n    journal record ``Type`` also specifies the interface for the journal\n    query.\n\n    Journal entries may have a query record indicated by their\n    respective record types. The query record is accessed via the\n    ``JournalEntryQuery``. The returns in this session may not be cast\n    directly to these interfaces."
         }, 
         "inherit_fullnames": [
            "osid.OsidSession"
         ], 
         "inherit_shortnames": [
            "OsidSession"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidSession"
            }
         ], 
         "method_names": [
            "get_journal_id", 
            "get_journal", 
            "can_search_journal_entries", 
            "use_federated_journal_view", 
            "use_isolated_journal_view", 
            "get_journal_entry_query", 
            "get_journal_entries_by_query"
         ], 
         "methods": [
            {
               "name": "get_journal_id", 
               "doc": {
                  "headline": "Gets the ``Journal``  ``Id`` associated with this session.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.id.Id) - the ``Journal Id`` associated with this\n                session", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the ``Journal Id`` associated with this session\n        :rtype: ``osid.id.Id``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.id.Id", 
               "errors": {}
            }, 
            {
               "name": "get_journal", 
               "doc": {
                  "headline": "Gets the ``Journal`` associated with this session.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.journaling.Journal) - the journal", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the journal\n        :rtype: ``osid.journaling.Journal``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.journaling.Journal", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "can_search_journal_entries", 
               "doc": {
                  "headline": "Tests if this user can perform ``Journal`` searches.", 
                  "body": "        A return of true does not guarantee successful authorization. A\n        return of false indicates that it is known all methods in this\n        session will result in a ``PermissionDenied``. This is intended\n        as a hint to an application that may wish not to offer search\n        operations to unauthorized users."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``false`` if search methods are not\n                authorized, ``true`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``false`` if search methods are not authorized, ``true`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "use_federated_journal_view", 
               "doc": {
                  "headline": "Federates the view for methods in this session.", 
                  "body": "        A federated view will include entries in journals which are\n        children of this journal in the journal hierarchy."
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "use_isolated_journal_view", 
               "doc": {
                  "headline": "Isolates the view for methods in this session.", 
                  "body": "        An isolated view restricts searches to this journal only."
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "get_journal_entry_query", 
               "doc": {
                  "headline": "Gets a journal entry query.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.journaling.JournalEntryQuery) - the journal entry\n                query", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the journal entry query\n        :rtype: ``osid.journaling.JournalEntryQuery``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.journaling.JournalEntryQuery", 
               "errors": {}
            }, 
            {
               "name": "get_journal_entries_by_query", 
               "doc": {
                  "headline": "Gets a list of journal entries matching the given journal entry query.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    journal_entry_query (osid.journaling.JournalEntryQuery):\n                the journal entry query\n", 
               "return_doc": "        return: (osid.journaling.JournalEntryList) - the returned\n                ``JournalEntryList``", 
               "error_doc": "        raise:  NullArgument - ``journal_entry_query`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        raise:  Unsupported - ``journal_query`` is not of this service", 
               "sphinx_param_doc": "        :param journal_entry_query: the journal entry query\n        :type journal_entry_query: ``osid.journaling.JournalEntryQuery``\n", 
               "sphinx_return_doc": "        :return: the returned ``JournalEntryList``\n        :rtype: ``osid.journaling.JournalEntryList``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``journal_entry_query`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure\n        :raise: ``Unsupported`` -- ``journal_query`` is not of this service", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.journaling.JournalEntryQuery", 
                     "var_name": "journal_entry_query", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.journaling.JournalEntryQuery"
               ], 
               "return_type": "osid.journaling.JournalEntryList", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.journaling.JournalEntrySearchSession", 
         "shortname": "JournalEntrySearchSession", 
         "category": "sessions", 
         "doc": {
            "headline": "This session provides methods for searching ``JournalEntry`` objects.", 
            "body": "    The search query is constructed using the ``JournalEntryQuery``. The\n    journal record ``Type`` also specifies the record for the journal\n    query.\n\n    ``get_journal_entries_by_query()`` is the basic search method and\n    returns a list of ``Journal`` elements. A more advanced search may\n    be performed with ``getJournalEntriesBySearch()``. It accepts a\n    ``JournalEntrySearch`` in addition to the query for the purpose of\n    specifying additional options affecting the entire search, such as\n    ordering. ``get_journal_entries_by_search()`` returns a\n    ``JournalEntrySearchResults`` that can be used to access the\n    resulting ``JournalEntryList`` or be used to perform a search within\n    the result set through ``JournalEntrySearch``.\n    \n    Journal entries may have a query record indicated by their\n    respective record types. The query record is accessed via the\n    ``JournalEntryQuery``. The returns in this session may not be cast\n    directly to these interfaces."
         }, 
         "inherit_fullnames": [
            "osid.journaling.JournalEntryQuerySession"
         ], 
         "inherit_shortnames": [
            "JournalEntryQuerySession"
         ], 
         "inherit_pkg_names": [
            "journaling"
         ], 
         "inheritance": [
            {
               "pkg_name": "journaling", 
               "name": "JournalEntryQuerySession"
            }
         ], 
         "method_names": [
            "get_journal_entry_search", 
            "get_journal_entry_search_order", 
            "get_journal_entries_by_search", 
            "get_journal_entry_query_from_inspector"
         ], 
         "methods": [
            {
               "name": "get_journal_entry_search", 
               "doc": {
                  "headline": "Gets a journal entry search.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.journaling.JournalEntrySearch) - the journal entry\n                search", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the journal entry search\n        :rtype: ``osid.journaling.JournalEntrySearch``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.journaling.JournalEntrySearch", 
               "errors": {}
            }, 
            {
               "name": "get_journal_entry_search_order", 
               "doc": {
                  "headline": "Gets a journal entry search order.", 
                  "body": "        The ``JournalEntrySearchOrder`` is supplied to a\n        ``JournalEntrySearch`` to specify the ordering of results."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.journaling.JournalEntrySearchOrder) - the journal\n                entry search order", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the journal entry search order\n        :rtype: ``osid.journaling.JournalEntrySearchOrder``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.journaling.JournalEntrySearchOrder", 
               "errors": {}
            }, 
            {
               "name": "get_journal_entries_by_search", 
               "doc": {
                  "headline": "Gets the search results matching the given search.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    journal_entry_query (osid.journaling.JournalEntryQuery):\n                the journal entry query\n        arg:    journal_entry_search\n                (osid.journaling.JournalEntrySearch): the journal entry\n                search\n", 
               "return_doc": "        return: (osid.journaling.JournalEntrySearchResults) - the search\n                results", 
               "error_doc": "        raise:  NullArgument - ``journal_entry_query`` or\n                ``journal_entry_search`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        raise:  Unsupported - ``journal_entry_query`` or\n                ``journal_entry_search`` is not of this service", 
               "sphinx_param_doc": "        :param journal_entry_query: the journal entry query\n        :type journal_entry_query: ``osid.journaling.JournalEntryQuery``\n        :param journal_entry_search: the journal entry search\n        :type journal_entry_search: ``osid.journaling.JournalEntrySearch``\n", 
               "sphinx_return_doc": "        :return: the search results\n        :rtype: ``osid.journaling.JournalEntrySearchResults``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``journal_entry_query`` or ``journal_entry_search`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure\n        :raise: ``Unsupported`` -- ``journal_entry_query`` or ``journal_entry_search`` is not of this service", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.journaling.JournalEntryQuery", 
                     "var_name": "journal_entry_query", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.journaling.JournalEntrySearch", 
                     "var_name": "journal_entry_search", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.journaling.JournalEntryQuery", 
                  "osid.journaling.JournalEntrySearch"
               ], 
               "return_type": "osid.journaling.JournalEntrySearchResults", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_journal_entry_query_from_inspector", 
               "doc": {
                  "headline": "Gets a journal entry query from an inspector.", 
                  "body": "        The inspector is available from a ``JournalEntrySearchResults``."
               }, 
               "arg_doc": "        arg:    journal_entry_query_inspector\n                (osid.journaling.JournalEntryQueryInspector): a journal\n                entry query inspector\n", 
               "return_doc": "        return: (osid.journaling.JournalEntryQuery) - the journal entry\n                query", 
               "error_doc": "        raise:  NullArgument - ``journal_entry_query_inspector`` is\n                ``null``\n        raise:  Unsupported - ``journal_entry_query_inspector`` is not\n                of this service", 
               "sphinx_param_doc": "        :param journal_entry_query_inspector: a journal entry query inspector\n        :type journal_entry_query_inspector: ``osid.journaling.JournalEntryQueryInspector``\n", 
               "sphinx_return_doc": "        :return: the journal entry query\n        :rtype: ``osid.journaling.JournalEntryQuery``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``journal_entry_query_inspector`` is ``null``\n        :raise: ``Unsupported`` -- ``journal_entry_query_inspector`` is not of this service", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.journaling.JournalEntryQueryInspector", 
                     "var_name": "journal_entry_query_inspector", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.journaling.JournalEntryQueryInspector"
               ], 
               "return_type": "osid.journaling.JournalEntryQuery", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.journaling.JournalEntryAdminSession", 
         "shortname": "JournalEntryAdminSession", 
         "category": "sessions", 
         "doc": {
            "headline": "This session creates, updates, and deletes ``JournalEntries``.", 
            "body": "    The data for create and update is provided by the consumer via the\n    form object. ``OsidForms`` are requested for each create or update\n    and may not be reused.\n\n    Create and update operations differ in their usage. To create a\n    ``JournalEntry,`` a ``JournalEntryForm`` is requested using\n    ``get_journal_entry_form_for_create()`` specifying the desired\n    record ``Types`` or none if no record ``Types`` are needed. The\n    returned ``JournalEntryForm`` will indicate that it is to be used\n    with a create operation and can be used to examine metdata or\n    validate data prior to creation. Once the ``JournalEntryForm`` is\n    submiited to a create operation, it cannot be reused with another\n    create operation unless the first operation was unsuccessful. Each\n    ``JournalEntryForm`` corresponds to an attempted transaction.\n    \n    For updates, ``JournalEntryForms`` are requested to the\n    ``JournalEntry``  ``Id`` that is to be updated using\n    ``getJournalEntryFormForUpdate()``. Similarly, the\n    ``JournalEntryForm`` has metadata about the data that can be updated\n    and it can perform validation before submitting the update. The\n    ``JournalEntryForm`` can only be used once for a successful update\n    and cannot be reused.\n    \n    The delete operations delete ``JournalEntries``.\n    \n    This session includes an ``Id`` aliasing mechanism to assign an\n    external ``Id`` to an internally assigned Id."
         }, 
         "inherit_fullnames": [
            "osid.OsidSession"
         ], 
         "inherit_shortnames": [
            "OsidSession"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidSession"
            }
         ], 
         "method_names": [
            "get_journal_id", 
            "get_journal", 
            "can_create_journal_entries", 
            "can_create_journal_entry_with_record_types", 
            "get_journal_entry_form_for_create", 
            "create_journal_entry", 
            "can_update_journal_entries", 
            "get_journal_entry_form_for_update", 
            "update_journal_entry", 
            "can_delete_journal_entries", 
            "delete_journal_entry", 
            "can_manage_journal_entry_aliases", 
            "alias_journal_entry"
         ], 
         "methods": [
            {
               "name": "get_journal_id", 
               "doc": {
                  "headline": "Gets the ``Journal``  ``Id`` associated with this session.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.id.Id) - the ``Journal Id`` associated with this\n                session", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the ``Journal Id`` associated with this session\n        :rtype: ``osid.id.Id``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.id.Id", 
               "errors": {}
            }, 
            {
               "name": "get_journal", 
               "doc": {
                  "headline": "Gets the ``Journal`` associated with this session.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.journaling.Journal) - the journal", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the journal\n        :rtype: ``osid.journaling.Journal``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.journaling.Journal", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "can_create_journal_entries", 
               "doc": {
                  "headline": "Tests if this user can create journal entries.", 
                  "body": "        A return of true does not guarantee successful authorization. A\n        return of false indicates that it is known creating a\n        ``JournalEntry`` will result in a ``PermissionDenied``. This is\n        intended as a hint to an application that may not wish to offer\n        create operations to unauthorized users."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``false`` if ``JournalEntry`` creation is\n                not authorized, ``true`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``false`` if ``JournalEntry`` creation is not authorized, ``true`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "can_create_journal_entry_with_record_types", 
               "doc": {
                  "headline": "Tests if this user can create a single ``JournalEntry`` using the desired record interface types.", 
                  "body": "        While ``JournalingManager.getJournalEntryRecordTypes()`` can be\n        used to examine which record interfaces are supported, this\n        method tests which record(s) are required for creating a\n        specific ``JournalEntry``. Providing an empty array tests if a\n        ``JournalEntry`` can be created with no records."
               }, 
               "arg_doc": "        arg:    journal_entry_record_types (osid.type.Type[]): array of\n                journal entry record types\n", 
               "return_doc": "        return: (boolean) - ``true`` if ``JournalEntry`` creation using\n                the specified record ``Types`` is supported, ``false``\n                otherwise", 
               "error_doc": "        raise:  NullArgument - ``journal_entry_record_types`` is\n                ``null``", 
               "sphinx_param_doc": "        :param journal_entry_record_types: array of journal entry record types\n        :type journal_entry_record_types: ``osid.type.Type[]``\n", 
               "sphinx_return_doc": "        :return: ``true`` if ``JournalEntry`` creation using the specified record ``Types`` is supported, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``journal_entry_record_types`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type[]", 
                     "var_name": "journal_entry_record_types", 
                     "array": true
                  }
               ], 
               "arg_types": [
                  "osid.type.Type[]"
               ], 
               "return_type": "boolean", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "get_journal_entry_form_for_create", 
               "doc": {
                  "headline": "Gets the journal entry form for creating new entries.", 
                  "body": "        A new form should be requested for each create transaction."
               }, 
               "arg_doc": "        arg:    branch_id (osid.id.Id): the ``Id`` for the branch\n        arg:    source_id (osid.id.Id): the ``Id`` for the journaled\n                object\n        arg:    journal_entry_record_types (osid.type.Type[]): array of\n                journal entry record types\n", 
               "return_doc": "        return: (osid.journaling.JournalEntryForm) - the journal entry\n                form", 
               "error_doc": "        raise:  NotFound - ``branch_id`` is not found\n        raise:  NullArgument - ``branch_id, source_id,`` or\n                ``journal_entry_record_types`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        raise:  Unsupported - unable to get form for requested record\n                types", 
               "sphinx_param_doc": "        :param branch_id: the ``Id`` for the branch\n        :type branch_id: ``osid.id.Id``\n        :param source_id: the ``Id`` for the journaled object\n        :type source_id: ``osid.id.Id``\n        :param journal_entry_record_types: array of journal entry record types\n        :type journal_entry_record_types: ``osid.type.Type[]``\n", 
               "sphinx_return_doc": "        :return: the journal entry form\n        :rtype: ``osid.journaling.JournalEntryForm``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``branch_id`` is not found\n        :raise: ``NullArgument`` -- ``branch_id, source_id,`` or ``journal_entry_record_types`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure\n        :raise: ``Unsupported`` -- unable to get form for requested record types", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "branch_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "source_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.type.Type[]", 
                     "var_name": "journal_entry_record_types", 
                     "array": true
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "osid.id.Id", 
                  "osid.type.Type[]"
               ], 
               "return_type": "osid.journaling.JournalEntryForm", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }, 
            {
               "name": "create_journal_entry", 
               "doc": {
                  "headline": "Creates a new ``JournalEntry``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    journal_entry_form (osid.journaling.JournalEntryForm):\n                the form for this ``JournalEntry``\n", 
               "return_doc": "        return: (osid.journaling.JournalEntry) - the new\n                ``JournalEntry``", 
               "error_doc": "        raise:  IllegalState - ``journal_entry_form`` already used in a\n                create transaction\n        raise:  InvalidArgument - one or more of the form elements is\n                invalid\n        raise:  NullArgument - ``journal_entry_form`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        raise:  Unsupported - ``journal_entry_form`` did not originate\n                from ``get_journal_entry_form_for_create()``", 
               "sphinx_param_doc": "        :param journal_entry_form: the form for this ``JournalEntry``\n        :type journal_entry_form: ``osid.journaling.JournalEntryForm``\n", 
               "sphinx_return_doc": "        :return: the new ``JournalEntry``\n        :rtype: ``osid.journaling.JournalEntry``", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- ``journal_entry_form`` already used in a create transaction\n        :raise: ``InvalidArgument`` -- one or more of the form elements is invalid\n        :raise: ``NullArgument`` -- ``journal_entry_form`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure\n        :raise: ``Unsupported`` -- ``journal_entry_form`` did not originate from ``get_journal_entry_form_for_create()``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.journaling.JournalEntryForm", 
                     "var_name": "journal_entry_form", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.journaling.JournalEntryForm"
               ], 
               "return_type": "osid.journaling.JournalEntry", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract", 
                  "INVALID_ARGUMENT": "ConsumerContract", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }, 
            {
               "name": "can_update_journal_entries", 
               "doc": {
                  "headline": "Tests if this user can update journal entries.", 
                  "body": "        A return of true does not guarantee successful authorization. A\n        return of false indicates that it is known updating a\n        ``JournalEntry`` will result in a ``PermissionDenied``. This is\n        intended as a hint to an application that may not wish to offer\n        update operations to unauthorized users."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``false`` if ``JournalEntry`` modification\n                is not authorized, ``true`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``false`` if ``JournalEntry`` modification is not authorized, ``true`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "get_journal_entry_form_for_update", 
               "doc": {
                  "headline": "Gets the journal entry form for updating an existing entry.", 
                  "body": "        A new journal entry form should be requested for each update\n        transaction."
               }, 
               "arg_doc": "        arg:    journal_entry_id (osid.id.Id): the ``Id`` of the\n                ``JournalEntry``\n", 
               "return_doc": "        return: (osid.journaling.JournalEntryForm) - the entry form", 
               "error_doc": "        raise:  NotFound - ``journal_entry_id`` is not found\n        raise:  NullArgument - ``journal_entry_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param journal_entry_id: the ``Id`` of the ``JournalEntry``\n        :type journal_entry_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: the entry form\n        :rtype: ``osid.journaling.JournalEntryForm``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``journal_entry_id`` is not found\n        :raise: ``NullArgument`` -- ``journal_entry_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "journal_entry_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "osid.journaling.JournalEntryForm", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "update_journal_entry", 
               "doc": {
                  "headline": "Updates an existing journal entry.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    journal_entry_form (osid.journaling.JournalEntryForm):\n                the form containing the elements to be updated\n", 
               "return_doc": "", 
               "error_doc": "        raise:  IllegalState - ``journal_entry_form`` already used in an\n                update transaction\n        raise:  InvalidArgument - the form contains an invalid value\n        raise:  NullArgument - ``journal_entry_form`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        raise:  Unsupported - ``journal_entry_form`` did not originate\n                from ``get_journal_entry_form_for_update()``", 
               "sphinx_param_doc": "        :param journal_entry_form: the form containing the elements to be updated\n        :type journal_entry_form: ``osid.journaling.JournalEntryForm``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- ``journal_entry_form`` already used in an update transaction\n        :raise: ``InvalidArgument`` -- the form contains an invalid value\n        :raise: ``NullArgument`` -- ``journal_entry_form`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure\n        :raise: ``Unsupported`` -- ``journal_entry_form`` did not originate from ``get_journal_entry_form_for_update()``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.journaling.JournalEntryForm", 
                     "var_name": "journal_entry_form", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.journaling.JournalEntryForm"
               ], 
               "return_type": "", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract", 
                  "INVALID_ARGUMENT": "ConsumerContract", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }, 
            {
               "name": "can_delete_journal_entries", 
               "doc": {
                  "headline": "Tests if this user can delete journal entries.", 
                  "body": "        A return of true does not guarantee successful authorization. A\n        return of false indicates that it is known deleting a\n        ``JournalEntry`` will result in a ``PermissionDenied``. This is\n        intended as a hint to an application that may not wish to offer\n        delete operations to unauthorized users."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``false`` if ``JournalEntry`` deletion is\n                not authorized, ``true`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``false`` if ``JournalEntry`` deletion is not authorized, ``true`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "delete_journal_entry", 
               "doc": {
                  "headline": "Deletes a ``JournalEntry``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    journal_entry_id (osid.id.Id): the ``Id`` of the\n                ``JournalEntry`` to remove\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NotFound - ``journal_entry_id`` not found\n        raise:  NullArgument - ``journal_entry_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param journal_entry_id: the ``Id`` of the ``JournalEntry`` to remove\n        :type journal_entry_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``journal_entry_id`` not found\n        :raise: ``NullArgument`` -- ``journal_entry_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "journal_entry_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "can_manage_journal_entry_aliases", 
               "doc": {
                  "headline": "Tests if this user can manage ``Id`` aliases for journal entries.", 
                  "body": "        A return of true does not guarantee successful authorization. A\n        return of false indicates that it is known changing an alias\n        will result in a ``PermissionDenied``. This is intended as a\n        hint to an application that may opt not to offer alias\n        operations to an unauthorized user."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``false`` if ``JournalEntry`` aliasing is\n                not authorized, ``true`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``false`` if ``JournalEntry`` aliasing is not authorized, ``true`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "alias_journal_entry", 
               "doc": {
                  "headline": "Adds an ``Id`` to a ``JournalEntry`` for the purpose of creating compatibility.", 
                  "body": "        The primary ``Id`` of the ``JournalEntry`` is determined by the\n        provider. The new ``Id`` performs as an alias to the primary\n        ``Id``. If the alias is a pointer to another journal entry it is\n        reassigned to the given journal entry ``Id``."
               }, 
               "arg_doc": "        arg:    journal_entry_id (osid.id.Id): the ``Id`` of a\n                ``JournalEntry``\n        arg:    alias_id (osid.id.Id): the alias ``Id``\n", 
               "return_doc": "", 
               "error_doc": "        raise:  AlreadyExists - ``alias_id`` is already assigned\n        raise:  NotFound - ``journal_entry_id`` not found\n        raise:  NullArgument - ``journal_entry_id`` or ``alias_id`` is\n                ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param journal_entry_id: the ``Id`` of a ``JournalEntry``\n        :type journal_entry_id: ``osid.id.Id``\n        :param alias_id: the alias ``Id``\n        :type alias_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``AlreadyExists`` -- ``alias_id`` is already assigned\n        :raise: ``NotFound`` -- ``journal_entry_id`` not found\n        :raise: ``NullArgument`` -- ``journal_entry_id`` or ``alias_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "journal_entry_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "alias_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {
                  "ALREADY_EXISTS": "User", 
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.journaling.JournalEntryNotificationSession", 
         "shortname": "JournalEntryNotificationSession", 
         "category": "sessions", 
         "doc": {
            "headline": "This session defines methods to receive notifications on adds/changes to ``JournalEntry`` objects.", 
            "body": "    This session is intended for consumers needing to synchronize their\n    state with this service without the use of polling. Notifications\n    are cancelled when this session is closed."
         }, 
         "inherit_fullnames": [
            "osid.OsidSession"
         ], 
         "inherit_shortnames": [
            "OsidSession"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidSession"
            }
         ], 
         "method_names": [
            "get_journal_id", 
            "get_journal", 
            "can_register_for_journal_entry_notifications", 
            "use_federated_journal_view", 
            "use_isolated_journal_view", 
            "register_for_new_journal_entries", 
            "register_for_new_journal_entries_for_branch", 
            "register_for_new_journal_entries_for_source", 
            "register_for_new_journal_entries_for_resource", 
            "register_for_changed_journal_entries", 
            "register_for_changed_journal_entries_for_branch", 
            "register_for_changed_journal_entries_for_source", 
            "register_for_changed_journal_entries_for_resource", 
            "register_for_changed_journal_entry", 
            "register_for_deleted_journal_entries", 
            "register_for_deleted_journal_entries_for_branch", 
            "register_for_deleted_journal_entries_for_source", 
            "register_for_deleted_journal_entries_for_resource", 
            "register_for_deleted_journal_entry"
         ], 
         "methods": [
            {
               "name": "get_journal_id", 
               "doc": {
                  "headline": "Gets the ``Journal``  ``Id`` associated with this session.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.id.Id) - the ``Journal Id`` associated with this\n                session", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the ``Journal Id`` associated with this session\n        :rtype: ``osid.id.Id``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.id.Id", 
               "errors": {}
            }, 
            {
               "name": "get_journal", 
               "doc": {
                  "headline": "Gets the ``Journal`` associated with this session.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.journaling.Journal) - the journal", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the journal\n        :rtype: ``osid.journaling.Journal``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.journaling.Journal", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "can_register_for_journal_entry_notifications", 
               "doc": {
                  "headline": "Tests if this user can register for ``JournalEntry`` notifications.", 
                  "body": "        A return of true does not guarantee successful authorization. A\n        return of false indicates that it is known all methods in this\n        session will result in a ``PermissionDenied``. This is intended\n        as a hint to an application that may opt not to offer\n        notification operations."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``false`` if notification methods are not\n                authorized, ``true`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``false`` if notification methods are not authorized, ``true`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "use_federated_journal_view", 
               "doc": {
                  "headline": "Federates the view for methods in this session.", 
                  "body": "        A federated view will include notifications for entries in\n        journals which are children of this journal in the journal\n        hierarchy."
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "use_isolated_journal_view", 
               "doc": {
                  "headline": "Isolates the view for methods in this session.", 
                  "body": "        An isolated view restricts notifications to this journal only."
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "register_for_new_journal_entries", 
               "doc": {
                  "headline": "Register for notifications of new journal entries.", 
                  "body": "        ``JournalEntryReceiver.newJournalEntry()`` is invoked when a new\n        ``JournalEntry`` is created."
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "register_for_new_journal_entries_for_branch", 
               "doc": {
                  "headline": "Register for notifications of new journal entries for the given branch ``Id``.", 
                  "body": "        ``JournalEntryReceiver.newJournalEntry()`` is invoked when a new\n        ``JournalEntry`` is created."
               }, 
               "arg_doc": "        arg:    branch_id (osid.id.Id): the ``Id`` of the branch to\n                monitor\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``branch_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param branch_id: the ``Id`` of the branch to monitor\n        :type branch_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``branch_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "branch_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "register_for_new_journal_entries_for_source", 
               "doc": {
                  "headline": "Register for notifications of new journal entries for the given source ``Id``.", 
                  "body": "        ``JournalEntryReceiver.newJournalEntry()`` is invoked when a new\n        ``JournalEntry`` is created."
               }, 
               "arg_doc": "        arg:    source_id (osid.id.Id): the ``Id`` of the source to\n                monitor\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``source_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param source_id: the ``Id`` of the source to monitor\n        :type source_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``source_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "source_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "register_for_new_journal_entries_for_resource", 
               "doc": {
                  "headline": "Register for notifications of new journal entries for the given resource ``Id``.", 
                  "body": "        ``JournalEntryReceiver.newJournalEntry()`` is invoked when a new\n        ``JournalEntry`` is created."
               }, 
               "arg_doc": "        arg:    resource_id (osid.id.Id): the ``Id`` of the resource to\n                monitor\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``resource_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param resource_id: the ``Id`` of the resource to monitor\n        :type resource_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``resource_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "resource_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "register_for_changed_journal_entries", 
               "doc": {
                  "headline": "Registers for notification of updated journal entries.", 
                  "body": "        ``JournalEntryReceiver.changedJournalEntry()`` is invoked when a\n        journal entry is changed."
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "register_for_changed_journal_entries_for_branch", 
               "doc": {
                  "headline": "Register for notifications of changed journal entries for the given branch ``Id``.", 
                  "body": "        ``JournalEntryReceiver.changedJournalEntry()`` is invoked when a\n        ``JournalEntry`` for the branch is changed."
               }, 
               "arg_doc": "        arg:    branch_id (osid.id.Id): the ``Id`` of the branch to\n                monitor\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``branch_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param branch_id: the ``Id`` of the branch to monitor\n        :type branch_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``branch_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "branch_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "register_for_changed_journal_entries_for_source", 
               "doc": {
                  "headline": "Register for notifications of changed journal entries for the given source ``Id``.", 
                  "body": "        ``JournalEntryReceiver.changedJournalEntry()`` is invoked when a\n        ``JournalEntry`` for the source is changed."
               }, 
               "arg_doc": "        arg:    source_id (osid.id.Id): the ``Id`` of the source to\n                monitor\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``source_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param source_id: the ``Id`` of the source to monitor\n        :type source_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``source_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "source_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "register_for_changed_journal_entries_for_resource", 
               "doc": {
                  "headline": "Register for notifications of changed journal entries for the given resource ``Id``.", 
                  "body": "        ``JournalEntryReceiver.changedJournalEntry()`` is invoked when a\n        ``JournalEntry`` for the source is changed."
               }, 
               "arg_doc": "        arg:    resource_id (osid.id.Id): the ``Id`` of the resource to\n                monitor\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``resource_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param resource_id: the ``Id`` of the resource to monitor\n        :type resource_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``resource_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "resource_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "register_for_changed_journal_entry", 
               "doc": {
                  "headline": "Registers for notification of an updated journal entry.", 
                  "body": "        ``JournalEntryReceiver.changedJournalEntry()`` is invoked when\n        the specified journal entry is changed."
               }, 
               "arg_doc": "        arg:    journal_entry_id (osid.id.Id): the ``Id`` of the\n                ``JournalEntry`` to monitor\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``journal_entry_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param journal_entry_id: the ``Id`` of the ``JournalEntry`` to monitor\n        :type journal_entry_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``journal_entry_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "journal_entry_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "register_for_deleted_journal_entries", 
               "doc": {
                  "headline": "Registers for notification of deleted journal entries.", 
                  "body": "        ``JournalEntryReceiver.deletedJournalEntry()`` is invoked when a\n        journal entry is deleted."
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "register_for_deleted_journal_entries_for_branch", 
               "doc": {
                  "headline": "Register for notifications of deleted journal entries for the given source ``Id``.", 
                  "body": "        ``JournalEntryReceiver.deletedJournalEntry()`` is invoked when a\n        ``JournalEntry`` for the branch is deleted."
               }, 
               "arg_doc": "        arg:    branch_id (osid.id.Id): the ``Id`` of the branch to\n                monitor\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``branch_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param branch_id: the ``Id`` of the branch to monitor\n        :type branch_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``branch_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "branch_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "register_for_deleted_journal_entries_for_source", 
               "doc": {
                  "headline": "Register for notifications of deleted journal entries for the given source ``Id``.", 
                  "body": "        ``JournalEntryReceiver.deletedJournalEntry()`` is invoked when a\n        ``JournalEntry`` for the source is deleted."
               }, 
               "arg_doc": "        arg:    source_id (osid.id.Id): the ``Id`` of the source to\n                monitor\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``source_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param source_id: the ``Id`` of the source to monitor\n        :type source_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``source_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "source_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "register_for_deleted_journal_entries_for_resource", 
               "doc": {
                  "headline": "Register for notifications of deleted journal entries for the given resource ``Id``.", 
                  "body": "        ``JournalEntryReceiver.deletedJournalEntry()`` is invoked when a\n        ``JournalEntry`` for the source is deleted."
               }, 
               "arg_doc": "        arg:    resource_id (osid.id.Id): the ``Id`` of the resource to\n                monitor\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``resource_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param resource_id: the ``Id`` of the resource to monitor\n        :type resource_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``resource_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "resource_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "register_for_deleted_journal_entry", 
               "doc": {
                  "headline": "Registers for notification of a deleted journal entry.", 
                  "body": "        ``JournalEntryReceiver.deletedJournalEntry()`` is invoked when\n        the specified journal entry is deleted."
               }, 
               "arg_doc": "        arg:    journal_entry_id (osid.id.Id): the ``Id`` of the\n                ``JournalEntry`` to monitor\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``journal_entry_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param journal_entry_id: the ``Id`` of the ``JournalEntry`` to monitor\n        :type journal_entry_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``journal_entry_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "journal_entry_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.journaling.BranchLookupSession", 
         "shortname": "BranchLookupSession", 
         "category": "sessions", 
         "doc": {
            "headline": "This session defines methods for retrieving branches.", 
            "body": "    A ``Branch`` is an arbitrary entity that may represent a person,\n    place or thing used to identify an object used in various services.\n\n    This lookup session defines several views:\n    \n      * comparative view: elements may be silently omitted or re-ordered\n      * plenary view: provides a complete result set or is an error\n        condition\n      * isolated journal view: All branch methods in this session\n        operate, retrieve and pertain to branches defined explicitly in\n        the current journal. Using an isolated view is useful for\n        managing ``Branches`` with the ``BranchAdminSession.``\n      * federated journal view: All branch methods in this session\n        operate, retrieve and pertain to all branches defined in this\n        journal and any other branches implicitly available in this\n        journal through journal inheritence.\n      * active branch view: Active brcnhes are returned in this session.\n      * any status branch view: Active and inactive branches are\n        returned in this session.\n\n    \n    The methods ``use_federated_journal_view()`` and\n    ``use_isolated_journal_view()`` behave as a radio group and one\n    should be selected before invoking any lookup methods.\n    \n    Branches may have an additional records indicated by their\n    respective record types. The record may not be accessed through a\n    cast of the ``Branch``."
         }, 
         "inherit_fullnames": [
            "osid.OsidSession"
         ], 
         "inherit_shortnames": [
            "OsidSession"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidSession"
            }
         ], 
         "method_names": [
            "get_journal_id", 
            "get_journal", 
            "can_lookup_branches", 
            "use_comparative_branch_view", 
            "use_plenary_branch_view", 
            "use_federated_journal_view", 
            "use_isolated_journal_view", 
            "use_active_branch_view", 
            "use_any_status_branch_view", 
            "get_branch", 
            "get_branches_by_ids", 
            "get_branches_by_genus_type", 
            "get_branches_by_parent_genus_type", 
            "get_branches_by_record_type", 
            "get_branches"
         ], 
         "methods": [
            {
               "name": "get_journal_id", 
               "doc": {
                  "headline": "Gets the ``Journal``  ``Id`` associated with this session.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.id.Id) - the ``Journal Id`` associated with this\n                session", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the ``Journal Id`` associated with this session\n        :rtype: ``osid.id.Id``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.id.Id", 
               "errors": {}
            }, 
            {
               "name": "get_journal", 
               "doc": {
                  "headline": "Gets the ``Journal`` associated with this session.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.journaling.Journal) - the ``Journal`` associated\n                with this session", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the ``Journal`` associated with this session\n        :rtype: ``osid.journaling.Journal``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.journaling.Journal", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "can_lookup_branches", 
               "doc": {
                  "headline": "Tests if this user can perform ``Branch`` lookups.", 
                  "body": "        A return of true does not guarantee successful authorization. A\n        return of false indicates that it is known all methods in this\n        session will result in a ``PermissionDenied``. This is intended\n        as a hint to an application that may opt not to offer lookup\n        operations."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``false`` if lookup methods are not\n                authorized, ``true`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``false`` if lookup methods are not authorized, ``true`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "use_comparative_branch_view", 
               "doc": {
                  "headline": "The returns from the lookup methods may omit or translate elements based on this session, such as authorization, and not result in an error.", 
                  "body": "        This view is used when greater interoperability is desired at\n        the expense of precision."
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "use_plenary_branch_view", 
               "doc": {
                  "headline": "A complete view of the ``Branch`` returns is desired.", 
                  "body": "        Methods will return what is requested or result in an error.\n        This view is used when greater precision is desired at the\n        expense of interoperability."
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "use_federated_journal_view", 
               "doc": {
                  "headline": "Federates the view for methods in this session.", 
                  "body": "        A federated view will include branches in journals which are\n        children of this journal in the journal hierarchy."
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "use_isolated_journal_view", 
               "doc": {
                  "headline": "Isolates the view for methods in this session.", 
                  "body": "        An isolated view restricts lookups to this journal only."
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "use_active_branch_view", 
               "doc": {
                  "headline": "Methods return only branches that are active.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "use_any_status_branch_view", 
               "doc": {
                  "headline": "Actuve and inactive branches are returned from lookup methods in this session.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "get_branch", 
               "doc": {
                  "headline": "Gets the ``Branch`` specified by its ``Id``.", 
                  "body": "        In plenary mode, the exact ``Id`` is found or a ``NotFound``\n        results. Otherwise, the returned ``Branch`` may have a different\n        ``Id`` than requested, such as the case where a duplicate ``Id``\n        was assigned to a ``Branch`` and retained for compatibility."
               }, 
               "arg_doc": "        arg:    branch_id (osid.id.Id): the ``Id`` of the ``Branch`` to\n                retrieve\n", 
               "return_doc": "        return: (osid.journaling.Branch) - the returned ``Branch``", 
               "error_doc": "        raise:  NotFound - no ``Branch`` found with the given ``Id``\n        raise:  NullArgument - ``branch_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param branch_id: the ``Id`` of the ``Branch`` to retrieve\n        :type branch_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: the returned ``Branch``\n        :rtype: ``osid.journaling.Branch``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- no ``Branch`` found with the given ``Id``\n        :raise: ``NullArgument`` -- ``branch_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "branch_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "osid.journaling.Branch", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_branches_by_ids", 
               "doc": {
                  "headline": "Gets a ``BranchList`` corresponding to the given ``IdList``.", 
                  "body": "        In plenary mode, the returned list contains all of the branches\n        specified in the ``Id`` list, in the order of the list,\n        including duplicates, or an error results if an ``Id`` in the\n        supplied list is not found or inaccessible. Otherwise,\n        inaccessible ``Branches`` may be omitted from the list and may\n        present the elements in any order including returning a unique\n        set."
               }, 
               "arg_doc": "        arg:    branch_ids (osid.id.IdList): the list of ``Ids`` to\n                retrieve\n", 
               "return_doc": "        return: (osid.journaling.BranchList) - the returned ``Branch``\n                list", 
               "error_doc": "        raise:  NotFound - an ``Id was`` not found\n        raise:  NullArgument - ``branch_ids`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param branch_ids: the list of ``Ids`` to retrieve\n        :type branch_ids: ``osid.id.IdList``\n", 
               "sphinx_return_doc": "        :return: the returned ``Branch`` list\n        :rtype: ``osid.journaling.BranchList``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- an ``Id was`` not found\n        :raise: ``NullArgument`` -- ``branch_ids`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.IdList", 
                     "var_name": "branch_ids", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.IdList"
               ], 
               "return_type": "osid.journaling.BranchList", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_branches_by_genus_type", 
               "doc": {
                  "headline": "Gets a ``BranchList`` corresponding to the given branch genus ``Type`` which does not include branches of types derived from the specified ``Type``.", 
                  "body": "        In plenary mode, the returned list contains all known branches\n        or an error results. Otherwise, the returned list may contain\n        only those branches that are accessible through this session."
               }, 
               "arg_doc": "        arg:    branch_genus_type (osid.type.Type): a branch genus type\n", 
               "return_doc": "        return: (osid.journaling.BranchList) - the returned ``Branch``\n                list", 
               "error_doc": "        raise:  NullArgument - ``branch_genus_type`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param branch_genus_type: a branch genus type\n        :type branch_genus_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "        :return: the returned ``Branch`` list\n        :rtype: ``osid.journaling.BranchList``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``branch_genus_type`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "branch_genus_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "osid.journaling.BranchList", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_branches_by_parent_genus_type", 
               "doc": {
                  "headline": "Gets a ``BranchList`` corresponding to the given branch genus ``Type`` and include any additional branches with genus types derived from the specified ``Type``.", 
                  "body": "        In plenary mode, the returned list contains all known branches\n        or an error results. Otherwise, the returned list may contain\n        only those branches that are accessible through this session."
               }, 
               "arg_doc": "        arg:    branch_genus_type (osid.type.Type): a branch genus type\n", 
               "return_doc": "        return: (osid.journaling.BranchList) - the returned ``Branch``\n                list", 
               "error_doc": "        raise:  NullArgument - ``branch_genus_type`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param branch_genus_type: a branch genus type\n        :type branch_genus_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "        :return: the returned ``Branch`` list\n        :rtype: ``osid.journaling.BranchList``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``branch_genus_type`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "branch_genus_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "osid.journaling.BranchList", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_branches_by_record_type", 
               "doc": {
                  "headline": "Gets a ``BranchList`` containing the given branch record ``Type``.", 
                  "body": "        In plenary mode, the returned list contains all known branches\n        or an error results. Otherwise, the returned list may contain\n        only those branches that are accessible through this session."
               }, 
               "arg_doc": "        arg:    branch_record_type (osid.type.Type): a branch record\n                type\n", 
               "return_doc": "        return: (osid.journaling.BranchList) - the returned ``Branch``\n                list", 
               "error_doc": "        raise:  NullArgument - ``branch_record_type`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param branch_record_type: a branch record type\n        :type branch_record_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "        :return: the returned ``Branch`` list\n        :rtype: ``osid.journaling.BranchList``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``branch_record_type`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "branch_record_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "osid.journaling.BranchList", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_branches", 
               "doc": {
                  "headline": "Gets all ``Branches``.", 
                  "body": "        In plenary mode, the returned list contains all known branches\n        or an error results. Otherwise, the returned list may contain\n        only those branches that are accessible through this session."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.journaling.BranchList) - a list of ``Branches``", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: a list of ``Branches``\n        :rtype: ``osid.journaling.BranchList``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.journaling.BranchList", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.journaling.BranchQuerySession", 
         "shortname": "BranchQuerySession", 
         "category": "sessions", 
         "doc": {
            "headline": "This session provides methods for searching among ``Branch`` objects.", 
            "body": "    The search query is constructed using the ``BranchQuery``.\n\n    This session defines views that offer differing behaviors for\n    searching.\n    \n      * federated journal view: searches include branches in journals of\n        which this journal is a ancestor in the journal hierarchy\n      * isolated journal view: searches are restricted to branches in\n        this journal\n\n    \n    Branches may have a query record indicated by their respective\n    record types. The query record is accessed via the ``BranchQuery``."
         }, 
         "inherit_fullnames": [
            "osid.OsidSession"
         ], 
         "inherit_shortnames": [
            "OsidSession"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidSession"
            }
         ], 
         "method_names": [
            "get_journal_id", 
            "get_journal", 
            "can_search_branches", 
            "use_federated_journal_view", 
            "use_isolated_journal_view", 
            "get_branch_query", 
            "get_branches_by_query"
         ], 
         "methods": [
            {
               "name": "get_journal_id", 
               "doc": {
                  "headline": "Gets the ``Journal``  ``Id`` associated with this session.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.id.Id) - the ``Journal Id`` associated with this\n                session", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the ``Journal Id`` associated with this session\n        :rtype: ``osid.id.Id``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.id.Id", 
               "errors": {}
            }, 
            {
               "name": "get_journal", 
               "doc": {
                  "headline": "Gets the ``Journal`` associated with this session.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.journaling.Journal) - the ``Journal`` associated\n                with this session", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the ``Journal`` associated with this session\n        :rtype: ``osid.journaling.Journal``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.journaling.Journal", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "can_search_branches", 
               "doc": {
                  "headline": "Tests if this user can perform ``Branch`` searches.", 
                  "body": "        A return of true does not guarantee successful authorization. A\n        return of false indicates that it is known all methods in this\n        session will result in a ``PermissionDenied``. This is intended\n        as a hint to an application that may opt not to offer search\n        operations to unauthorized users."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``false`` if search methods are not\n                authorized, ``true`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``false`` if search methods are not authorized, ``true`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "use_federated_journal_view", 
               "doc": {
                  "headline": "Federates the view for methods in this session.", 
                  "body": "        A federated view will include branches in journals which are\n        children of this journal in the journal hierarchy."
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "use_isolated_journal_view", 
               "doc": {
                  "headline": "Isolates the view for methods in this session.", 
                  "body": "        An isolated view restricts lookups to this journal only."
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "get_branch_query", 
               "doc": {
                  "headline": "Gets a branch query.", 
                  "body": "        The returned query will not have an extension query."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.journaling.BranchQuery) - the branch query", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the branch query\n        :rtype: ``osid.journaling.BranchQuery``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.journaling.BranchQuery", 
               "errors": {}
            }, 
            {
               "name": "get_branches_by_query", 
               "doc": {
                  "headline": "Gets a list of ``Branches`` matching the given branch query.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    branch_query (osid.journaling.BranchQuery): the branch\n                query\n", 
               "return_doc": "        return: (osid.journaling.BranchList) - the returned\n                ``BranchList``", 
               "error_doc": "        raise:  NullArgument - ``branch_query`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        raise:  Unsupported - ``branch_query`` is not of this service", 
               "sphinx_param_doc": "        :param branch_query: the branch query\n        :type branch_query: ``osid.journaling.BranchQuery``\n", 
               "sphinx_return_doc": "        :return: the returned ``BranchList``\n        :rtype: ``osid.journaling.BranchList``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``branch_query`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure\n        :raise: ``Unsupported`` -- ``branch_query`` is not of this service", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.journaling.BranchQuery", 
                     "var_name": "branch_query", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.journaling.BranchQuery"
               ], 
               "return_type": "osid.journaling.BranchList", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.journaling.BranchSearchSession", 
         "shortname": "BranchSearchSession", 
         "category": "sessions", 
         "doc": {
            "headline": "This session provides methods for searching among ``Branch`` objects.", 
            "body": "    The search query is constructed using the ``BranchQuery``.\n\n    ``get_branchs_by_query()`` is the basic search method and returns a\n    list of ``Branches``. A more advanced search may be performed with\n    ``getBranchesBySearch()``. It accepts an ``BranchSearch`` in\n    addition to the query for the purpose of specifying additional\n    options affecting the entire search, such as ordering.\n    ``get_branches_by_search()`` returns an ``BranchSearchResults`` that\n    can be used to access the resulting ``BranchList`` or be used to\n    perform a search within the result set through ``BranchList``.\n    \n    This session defines views that offer differing behaviors for\n    searching.\n    \n      * federated journal view: searches include branches in journals of\n        which this journal is a ancestor in the journal hierarchy\n      * isolated journal view: searches are restricted to branches in\n        this journal\n\n    \n    Branches may have a query record indicated by their respective recod\n    types. The query record is accessed via the ``BranchQuery``."
         }, 
         "inherit_fullnames": [
            "osid.journaling.BranchQuerySession"
         ], 
         "inherit_shortnames": [
            "BranchQuerySession"
         ], 
         "inherit_pkg_names": [
            "journaling"
         ], 
         "inheritance": [
            {
               "pkg_name": "journaling", 
               "name": "BranchQuerySession"
            }
         ], 
         "method_names": [
            "get_branch_search", 
            "get_branch_search_order", 
            "get_branches_by_search", 
            "get_branch_query_from_inspector"
         ], 
         "methods": [
            {
               "name": "get_branch_search", 
               "doc": {
                  "headline": "Gets a branch search.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.journaling.BranchSearch) - the branch search", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the branch search\n        :rtype: ``osid.journaling.BranchSearch``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.journaling.BranchSearch", 
               "errors": {}
            }, 
            {
               "name": "get_branch_search_order", 
               "doc": {
                  "headline": "Gets a branch search order.", 
                  "body": "        The ``BranchSearchOrder`` is supplied to a ``BranchSearch`` to\n        specify the ordering of results."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.journaling.BranchSearchOrder) - the branch search\n                order", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the branch search order\n        :rtype: ``osid.journaling.BranchSearchOrder``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.journaling.BranchSearchOrder", 
               "errors": {}
            }, 
            {
               "name": "get_branches_by_search", 
               "doc": {
                  "headline": "Gets the search results matching the given search query using the given search.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    branch_query (osid.journaling.BranchQuery): the branch\n                query\n        arg:    branch_search (osid.journaling.BranchSearch): the branch\n                search\n", 
               "return_doc": "        return: (osid.journaling.BranchSearchResults) - the returned\n                search results", 
               "error_doc": "        raise:  NullArgument - ``branch_query`` or ``branch_search`` is\n                ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        raise:  Unsupported - ``branch_query`` or ``branch_search`` is\n                not of this service", 
               "sphinx_param_doc": "        :param branch_query: the branch query\n        :type branch_query: ``osid.journaling.BranchQuery``\n        :param branch_search: the branch search\n        :type branch_search: ``osid.journaling.BranchSearch``\n", 
               "sphinx_return_doc": "        :return: the returned search results\n        :rtype: ``osid.journaling.BranchSearchResults``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``branch_query`` or ``branch_search`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure\n        :raise: ``Unsupported`` -- ``branch_query`` or ``branch_search`` is not of this service", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.journaling.BranchQuery", 
                     "var_name": "branch_query", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.journaling.BranchSearch", 
                     "var_name": "branch_search", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.journaling.BranchQuery", 
                  "osid.journaling.BranchSearch"
               ], 
               "return_type": "osid.journaling.BranchSearchResults", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_branch_query_from_inspector", 
               "doc": {
                  "headline": "Gets a branch query from an inspector.", 
                  "body": "        The inspector is available from a ``BranchSearchResults``."
               }, 
               "arg_doc": "        arg:    branch_query_inspector\n                (osid.journaling.BranchQueryInspector): a branch query\n                inspector\n", 
               "return_doc": "        return: (osid.journaling.BranchQuery) - the branch query", 
               "error_doc": "        raise:  NullArgument - ``branch_query_inspector`` is ``null``\n        raise:  Unsupported - ``branch_query_inspector`` is not of this\n                service", 
               "sphinx_param_doc": "        :param branch_query_inspector: a branch query inspector\n        :type branch_query_inspector: ``osid.journaling.BranchQueryInspector``\n", 
               "sphinx_return_doc": "        :return: the branch query\n        :rtype: ``osid.journaling.BranchQuery``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``branch_query_inspector`` is ``null``\n        :raise: ``Unsupported`` -- ``branch_query_inspector`` is not of this service", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.journaling.BranchQueryInspector", 
                     "var_name": "branch_query_inspector", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.journaling.BranchQueryInspector"
               ], 
               "return_type": "osid.journaling.BranchQuery", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.journaling.BranchAdminSession", 
         "shortname": "BranchAdminSession", 
         "category": "sessions", 
         "doc": {
            "headline": "This session creates, updates, and deletes ``Branches``.", 
            "body": "    The data for create and update is provided by the consumer via the\n    form object. ``OsidForms`` are requested for each create or update\n    and may not be reused.\n\n    Create and update operations differ in their usage. To create a\n    ``Branch,`` a ``BranchForm`` is requested using\n    ``get_branch_form_for_create()`` specifying the desired record\n    ``Types`` or none if no record ``Types`` are needed. The returned\n    ``BranchForm`` will indicate that it is to be used with a create\n    operation and can be used to examine metdata or validate data prior\n    to creation. Once the ``BranchForm`` is submiited to a create\n    operation, it cannot be reused with another create operation unless\n    the first operation was unsuccessful. Each ``BranchForm``\n    corresponds to an attempted transaction.\n    \n    For updates, ``BranchForms`` are requested to the ``Branch``  ``Id``\n    that is to be updated using ``getBranchFormForUpdate()``. Similarly,\n    the ``BranchForm`` has metadata about the data that can be updated\n    and it can perform validation before submitting the update. The\n    ``BranchForm`` can only be used once for a successful update and\n    cannot be reused.\n    \n    The delete operations delete ``Branches``.\n    \n    This session includes an ``Id`` aliasing mechanism to assign an\n    external ``Id`` to an internally assigned Id."
         }, 
         "inherit_fullnames": [
            "osid.OsidSession"
         ], 
         "inherit_shortnames": [
            "OsidSession"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidSession"
            }
         ], 
         "method_names": [
            "get_journal_id", 
            "get_journal", 
            "can_create_branches", 
            "can_create_branch", 
            "can_create_branch_with_record_types", 
            "get_branch_form_for_create", 
            "create_branch", 
            "can_update_branches", 
            "get_branch_form_for_update", 
            "update_branch", 
            "can_merge_branches", 
            "merge_branches", 
            "can_supersede_branches", 
            "supersede_branch", 
            "can_delete_branches", 
            "delete_branch", 
            "can_manage_branch_aliases", 
            "alias_branch"
         ], 
         "methods": [
            {
               "name": "get_journal_id", 
               "doc": {
                  "headline": "Gets the ``Journal``  ``Id`` associated with this session.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.id.Id) - the ``Journal Id`` associated with this\n                session", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the ``Journal Id`` associated with this session\n        :rtype: ``osid.id.Id``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.id.Id", 
               "errors": {}
            }, 
            {
               "name": "get_journal", 
               "doc": {
                  "headline": "Gets the ``Journal`` associated with this session.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.journaling.Journal) - the journal", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the journal\n        :rtype: ``osid.journaling.Journal``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.journaling.Journal", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "can_create_branches", 
               "doc": {
                  "headline": "Tests if this user can branch a version chain.", 
                  "body": "        A return of true does not guarantee successful authorization. A\n        return of false indicates that it is known branching will result\n        in a ``PermissionDenied``. This is intended as a hint to an\n        application that may not wish to offer create operations to\n        unauthorized users."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``false`` if journal branching is not\n                authorized, ``true`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``false`` if journal branching is not authorized, ``true`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "can_create_branch", 
               "doc": {
                  "headline": "Tests if this user can branch a specified ``JournalEntry``.", 
                  "body": "        A return of true does not guarantee successful authorization. A\n        return of false indicates that it is known branching the\n        ``JournalEntry`` will result in a ``PermissionDenied``. This is\n        intended as a hint to an application that may not wish to offer\n        update operations to unauthorized users."
               }, 
               "arg_doc": "        arg:    journal_entry_id (osid.id.Id): the ``Id`` of the\n                ``JournalEntry``\n", 
               "return_doc": "        return: (boolean) - ``false`` if branching is not authorized,\n                ``true`` otherwise", 
               "error_doc": "        raise:  NullArgument - ``journal_entry_id`` is ``null``", 
               "sphinx_param_doc": "        :param journal_entry_id: the ``Id`` of the ``JournalEntry``\n        :type journal_entry_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: ``false`` if branching is not authorized, ``true`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``journal_entry_id`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "        *implementation notes*: If the ``journal_entry_id`` is not\n        found, then it is acceptable to return false to indicate the\n        lack of branching available.\n", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "journal_entry_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "boolean", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "can_create_branch_with_record_types", 
               "doc": {
                  "headline": "Tests if this user can create a single ``Branch`` using the desired record types.", 
                  "body": "        While ``JournalingManager.getBranchRecordTypes()`` can be used\n        to examine which records are supported, this method tests which\n        record(s) are required for creating a specific ``Branch``.\n        Providing an empty array tests if a ``Branch`` can be created\n        with no records."
               }, 
               "arg_doc": "        arg:    branch_record_types (osid.type.Type[]): array of branch\n                record types\n", 
               "return_doc": "        return: (boolean) - ``true`` if ``Branch`` creation using the\n                specified record ``Types`` is supported, ``false``\n                otherwise", 
               "error_doc": "        raise:  NullArgument - ``branchy_record_types`` is ``null``", 
               "sphinx_param_doc": "        :param branch_record_types: array of branch record types\n        :type branch_record_types: ``osid.type.Type[]``\n", 
               "sphinx_return_doc": "        :return: ``true`` if ``Branch`` creation using the specified record ``Types`` is supported, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``branchy_record_types`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type[]", 
                     "var_name": "branch_record_types", 
                     "array": true
                  }
               ], 
               "arg_types": [
                  "osid.type.Type[]"
               ], 
               "return_type": "boolean", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "get_branch_form_for_create", 
               "doc": {
                  "headline": "Gets the branch form for creating new entries.", 
                  "body": "        A new form should be requested for each create transaction."
               }, 
               "arg_doc": "        arg:    journal_entry_id (osid.id.Id): the ``Id`` of the\n                ``JournalEntry``\n        arg:    branch_record_types (osid.type.Type[]): array of branch\n                record types\n", 
               "return_doc": "        return: (osid.journaling.BranchForm) - the branch form", 
               "error_doc": "        raise:  NotFound - ``journal_entry_id`` is not found\n        raise:  NullArgument - ``journal_entry_id`` or\n                ``branch_record_types`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        raise:  Unsupported - unable to get form for requested record\n                types", 
               "sphinx_param_doc": "        :param journal_entry_id: the ``Id`` of the ``JournalEntry``\n        :type journal_entry_id: ``osid.id.Id``\n        :param branch_record_types: array of branch record types\n        :type branch_record_types: ``osid.type.Type[]``\n", 
               "sphinx_return_doc": "        :return: the branch form\n        :rtype: ``osid.journaling.BranchForm``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``journal_entry_id`` is not found\n        :raise: ``NullArgument`` -- ``journal_entry_id`` or ``branch_record_types`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure\n        :raise: ``Unsupported`` -- unable to get form for requested record types", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "journal_entry_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.type.Type[]", 
                     "var_name": "branch_record_types", 
                     "array": true
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "osid.type.Type[]"
               ], 
               "return_type": "osid.journaling.BranchForm", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }, 
            {
               "name": "create_branch", 
               "doc": {
                  "headline": "Creates a branch.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    branch_form (osid.journaling.BranchForm): the branch\n                form\n", 
               "return_doc": "        return: (osid.journaling.Branch) - a the new branch", 
               "error_doc": "        raise:  IllegalState - ``branch_form`` already used in a create\n                transaction\n        raise:  InvalidArgument - the form contains an invalid value\n        raise:  NullArgument - ``branch_form`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        raise:  Unsupported - ``branch_form`` did not originate from\n                ``get_branch_form_for_create()``", 
               "sphinx_param_doc": "        :param branch_form: the branch form\n        :type branch_form: ``osid.journaling.BranchForm``\n", 
               "sphinx_return_doc": "        :return: a the new branch\n        :rtype: ``osid.journaling.Branch``", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- ``branch_form`` already used in a create transaction\n        :raise: ``InvalidArgument`` -- the form contains an invalid value\n        :raise: ``NullArgument`` -- ``branch_form`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure\n        :raise: ``Unsupported`` -- ``branch_form`` did not originate from ``get_branch_form_for_create()``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.journaling.BranchForm", 
                     "var_name": "branch_form", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.journaling.BranchForm"
               ], 
               "return_type": "osid.journaling.Branch", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract", 
                  "INVALID_ARGUMENT": "ConsumerContract", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }, 
            {
               "name": "can_update_branches", 
               "doc": {
                  "headline": "Tests if this user can update branches.", 
                  "body": "        A return of true does not guarantee successful authorization. A\n        return of false indicates that it is known updating a ``Branch``\n        will result in a ``PermissionDenied``. This is intended as a\n        hint to an application that may not wish to offer update\n        operations to unauthorized users."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``false`` if ``Branch`` modification is not\n                authorized, ``true`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``false`` if ``Branch`` modification is not authorized, ``true`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "get_branch_form_for_update", 
               "doc": {
                  "headline": "Gets the branch form for updating an existing branch.", 
                  "body": "        A new journal entry form should be requested for each update\n        transaction."
               }, 
               "arg_doc": "        arg:    branch_id (osid.id.Id): the ``Id`` of the ``Branch``\n", 
               "return_doc": "        return: (osid.journaling.BranchForm) - the branch form", 
               "error_doc": "        raise:  NotFound - ``branch_id`` is not found\n        raise:  NullArgument - ``branch_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param branch_id: the ``Id`` of the ``Branch``\n        :type branch_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: the branch form\n        :rtype: ``osid.journaling.BranchForm``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``branch_id`` is not found\n        :raise: ``NullArgument`` -- ``branch_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "branch_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "osid.journaling.BranchForm", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "update_branch", 
               "doc": {
                  "headline": "Updates an existing branch.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    branch_form (osid.journaling.BranchForm): the form\n                containing the elements to be updated\n", 
               "return_doc": "", 
               "error_doc": "        raise:  IllegalState - ``branch_form`` already used in an update\n                transaction\n        raise:  InvalidArgument - the form contains an invalid value\n        raise:  NullArgument - ``branch_form`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        raise:  Unsupported - ``branch_form`` did not originate from\n                ``get_branch_form_for_update()``", 
               "sphinx_param_doc": "        :param branch_form: the form containing the elements to be updated\n        :type branch_form: ``osid.journaling.BranchForm``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- ``branch_form`` already used in an update transaction\n        :raise: ``InvalidArgument`` -- the form contains an invalid value\n        :raise: ``NullArgument`` -- ``branch_form`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure\n        :raise: ``Unsupported`` -- ``branch_form`` did not originate from ``get_branch_form_for_update()``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.journaling.BranchForm", 
                     "var_name": "branch_form", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.journaling.BranchForm"
               ], 
               "return_type": "", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract", 
                  "INVALID_ARGUMENT": "ConsumerContract", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }, 
            {
               "name": "can_merge_branches", 
               "doc": {
                  "headline": "Tests if this user can merge branches.", 
                  "body": "        A return of true does not guarantee successful authorization. A\n        return of false indicates that it is known merging ``Branches``\n        will result in a ``PermissionDenied``. This is intended as a\n        hint to an application that may not wish to offer merging\n        operations to unauthorized users."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``false`` if ``Branch`` merging is not\n                authorized, ``true`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``false`` if ``Branch`` merging is not authorized, ``true`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "merge_branches", 
               "doc": {
                  "headline": "Merges the source branch into the destination branch.", 
                  "body": "        A new journal entry is created to join the two branches."
               }, 
               "arg_doc": "        arg:    src_branch_id (osid.id.Id): the ``Id`` of the ``Branch``\n                to merge from\n        arg:    dst_branch_id (osid.id.Id): the ``Id`` of the ``Branch``\n                to merge into\n", 
               "return_doc": "        return: (osid.journaling.JournalEntry) - a the new journal entry", 
               "error_doc": "        raise:  NotFound - ``branch_id`` not found\n        raise:  NullArgument - ``branch_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param src_branch_id: the ``Id`` of the ``Branch`` to merge from\n        :type src_branch_id: ``osid.id.Id``\n        :param dst_branch_id: the ``Id`` of the ``Branch`` to merge into\n        :type dst_branch_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: a the new journal entry\n        :rtype: ``osid.journaling.JournalEntry``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``branch_id`` not found\n        :raise: ``NullArgument`` -- ``branch_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "src_branch_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "dst_branch_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "osid.id.Id"
               ], 
               "return_type": "osid.journaling.JournalEntry", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "can_supersede_branches", 
               "doc": {
                  "headline": "Tests if this user can supersede branches.", 
                  "body": "        A return of true does not guarantee successful authorization. A\n        return of false indicates that it is known merging ``Branches``\n        will result in a ``PermissionDenied``. This is intended as a\n        hint to an application that may not wish to offer superseding\n        operations to unauthorized users."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``false`` if ``Branch`` superseding is not\n                authorized, ``true`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``false`` if ``Branch`` superseding is not authorized, ``true`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "supersede_branch", 
               "doc": {
                  "headline": "Joins the source branch to the destination branch by creating a new journal entry.", 
                  "body": "        The most recent version of the source branch supsrsedes the most\n        recent versiuon of the desitination branch."
               }, 
               "arg_doc": "        arg:    src_branch_id (osid.id.Id): the ``Id`` of the\n                superseding ``Branch``\n        arg:    dst_branch_id (osid.id.Id): the ``Id`` of the ``Branch``\n                to override\n", 
               "return_doc": "        return: (osid.journaling.JournalEntry) - a the new journal entry", 
               "error_doc": "        raise:  NotFound - ``branch_id`` not found\n        raise:  NullArgument - ``branch_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param src_branch_id: the ``Id`` of the superseding ``Branch``\n        :type src_branch_id: ``osid.id.Id``\n        :param dst_branch_id: the ``Id`` of the ``Branch`` to override\n        :type dst_branch_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: a the new journal entry\n        :rtype: ``osid.journaling.JournalEntry``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``branch_id`` not found\n        :raise: ``NullArgument`` -- ``branch_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "src_branch_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "dst_branch_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "osid.id.Id"
               ], 
               "return_type": "osid.journaling.JournalEntry", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "can_delete_branches", 
               "doc": {
                  "headline": "Tests if this user can delete branches.", 
                  "body": "        A return of true does not guarantee successful authorization. A\n        return of false indicates that it is known deleting a ``Branch``\n        will result in a ``PermissionDenied``. This is intended as a\n        hint to an application that may not wish to offer delete\n        operations to unauthorized users."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``false`` if ``Branch`` deletion is not\n                authorized, ``true`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``false`` if ``Branch`` deletion is not authorized, ``true`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "delete_branch", 
               "doc": {
                  "headline": "Deletes a branch and all associated versions.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    branch_id (osid.id.Id): the ``Id`` of the ``Branch`` to\n                remove\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NotFound - ``branch_id`` not found\n        raise:  NullArgument - ``branch_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param branch_id: the ``Id`` of the ``Branch`` to remove\n        :type branch_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``branch_id`` not found\n        :raise: ``NullArgument`` -- ``branch_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "branch_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "can_manage_branch_aliases", 
               "doc": {
                  "headline": "Tests if this user can manage ``Id`` aliases for branches.", 
                  "body": "        A return of true does not guarantee successful authorization. A\n        return of false indicates that it is known changing an alias\n        will result in a ``PermissionDenied``. This is intended as a\n        hint to an application that may opt not to offer alias\n        operations to an unauthorized user."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``false`` if ``Branch`` aliasing is not\n                authorized, ``true`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``false`` if ``Branch`` aliasing is not authorized, ``true`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "alias_branch", 
               "doc": {
                  "headline": "Adds an ``Id`` to a ``Branch`` for the purpose of creating compatibility.", 
                  "body": "        The primary ``Id`` of the ``Branch`` is determined by the\n        provider. The new ``Id`` performs as an alias to the primary\n        ``Id``. If the alias is a pointer to another branch it is\n        reassigned to the given branch ``Id``."
               }, 
               "arg_doc": "        arg:    branch_id (osid.id.Id): the ``Id`` of a ``Branch``\n        arg:    alias_id (osid.id.Id): the alias ``Id``\n", 
               "return_doc": "", 
               "error_doc": "        raise:  AlreadyExists - ``alias_id`` is already assigned\n        raise:  NotFound - ``branch_id`` not found\n        raise:  NullArgument - ``branch_id`` or ``alias_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param branch_id: the ``Id`` of a ``Branch``\n        :type branch_id: ``osid.id.Id``\n        :param alias_id: the alias ``Id``\n        :type alias_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``AlreadyExists`` -- ``alias_id`` is already assigned\n        :raise: ``NotFound`` -- ``branch_id`` not found\n        :raise: ``NullArgument`` -- ``branch_id`` or ``alias_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "branch_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "alias_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {
                  "ALREADY_EXISTS": "User", 
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.journaling.BranchNotificationSession", 
         "shortname": "BranchNotificationSession", 
         "category": "sessions", 
         "doc": {
            "headline": "This session defines methods to receive notifications on adds/changes to ``Branch`` objects in this ``Journal``.", 
            "body": "    This also includes existing branches that may appear or disappear\n    due to changes in the ``Journal`` hierarchy, This session is\n    intended for consumers needing to synchronize their state with this\n    service without the use of polling. Notifications are cancelled when\n    this session is closed.\n\n    The two views defined in this session correspond to the views in the\n    ``BranchLookupSession``."
         }, 
         "inherit_fullnames": [
            "osid.OsidSession"
         ], 
         "inherit_shortnames": [
            "OsidSession"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidSession"
            }
         ], 
         "method_names": [
            "get_journal_id", 
            "get_journal", 
            "can_register_for_branch_notifications", 
            "use_federated_journal_view", 
            "use_isolated_journal_view", 
            "register_for_new_branches", 
            "register_for_changed_branches", 
            "register_for_changed_branch", 
            "register_for_deleted_branches", 
            "register_for_deleted_branch"
         ], 
         "methods": [
            {
               "name": "get_journal_id", 
               "doc": {
                  "headline": "Gets the ``Journal``  ``Id`` associated with this session.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.id.Id) - the ``Journal Id`` associated with this\n                session", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the ``Journal Id`` associated with this session\n        :rtype: ``osid.id.Id``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.id.Id", 
               "errors": {}
            }, 
            {
               "name": "get_journal", 
               "doc": {
                  "headline": "Gets the ``Journal`` associated with this session.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.journaling.Journal) - the ``Journal`` associated\n                with this session", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the ``Journal`` associated with this session\n        :rtype: ``osid.journaling.Journal``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.journaling.Journal", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "can_register_for_branch_notifications", 
               "doc": {
                  "headline": "Tests if this user can register for ``Branch`` notifications.", 
                  "body": "        A return of true does not guarantee successful authorization. A\n        return of false indicates that it is known all methods in this\n        session will result in a ``PermissionDenied``. This is intended\n        as a hint to an application that may opt not to offer\n        notification operations."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``false`` if notification methods are not\n                authorized, ``true`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``false`` if notification methods are not authorized, ``true`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "use_federated_journal_view", 
               "doc": {
                  "headline": "Federates the view for methods in this session.", 
                  "body": "        A federated view will include branches in journals which are\n        children of this journal in the journal hierarchy."
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "use_isolated_journal_view", 
               "doc": {
                  "headline": "Isolates the view for methods in this session.", 
                  "body": "        An isolated view restricts notifications to this journal only."
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "register_for_new_branches", 
               "doc": {
                  "headline": "Register for notifications of new branches.", 
                  "body": "        ``BranchReceiver.newBranch()`` is invoked when a new ``Branch``\n        is appears in this journal."
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "register_for_changed_branches", 
               "doc": {
                  "headline": "Registers for notification of updated branches.", 
                  "body": "        ``BranchReceiver.changedBranch()`` is invoked when a branch in\n        this journal is changed."
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "register_for_changed_branch", 
               "doc": {
                  "headline": "Registers for notification of an updated branch.", 
                  "body": "        ``BranchReceiver.changedBranch()`` is invoked when the specified\n        branch in this journal is changed."
               }, 
               "arg_doc": "        arg:    branch_id (osid.id.Id): the ``Id`` of the ``Branch`` to\n                monitor\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``branch_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param branch_id: the ``Id`` of the ``Branch`` to monitor\n        :type branch_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``branch_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "branch_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "register_for_deleted_branches", 
               "doc": {
                  "headline": "Registers for notification of deleted branches.", 
                  "body": "        ``BranchReceiver.deletedBranch()`` is invoked when a branch is\n        deleted or removed from this journal."
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "register_for_deleted_branch", 
               "doc": {
                  "headline": "Registers for notification of a deleted branch.", 
                  "body": "        ``BranchReceiver.deletedBranch()`` is invoked when the specified\n        branch is deleted or removed from this journal."
               }, 
               "arg_doc": "        arg:    branch_id (osid.id.Id): the ``Id`` of the ``Branch`` to\n                monitor\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``branch_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param branch_id: the ``Id`` of the ``Branch`` to monitor\n        :type branch_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``branch_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "branch_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.journaling.BranchSmartJournalSession", 
         "shortname": "BranchSmartJournalSession", 
         "category": "sessions", 
         "doc": {
            "headline": "This session manages queries and sequencing to create \"smart\" dynamic catalogs.", 
            "body": "    A ``BranchQuery`` can be retrieved from this session and mapped to\n    this ``Journal`` to create a virtual collection of ``Branches``. The\n    branches may be sequenced using the ``BranchSearchOrder`` from this\n    session.\n\n    This ``Journal`` has a default query that matches any branch and a\n    default search order that specifies no sequencing. The queries may\n    be examined using a ``BranchQueryInspector``. The query may be\n    modified by converting the inspector back to a ``BranchQuery``."
         }, 
         "inherit_fullnames": [
            "osid.OsidSession"
         ], 
         "inherit_shortnames": [
            "OsidSession"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidSession"
            }
         ], 
         "method_names": [
            "get_journal_id", 
            "get_journal", 
            "can_manage_smart_journals", 
            "get_branch_query", 
            "get_branch_search_order", 
            "apply_branch_query", 
            "inspect_branch_query", 
            "apply_branch_sequencing", 
            "get_branch_query_from_inspector"
         ], 
         "methods": [
            {
               "name": "get_journal_id", 
               "doc": {
                  "headline": "Gets the ``Journal``  ``Id`` associated with this session.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.id.Id) - the ``Journal Id`` associated with this\n                session", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the ``Journal Id`` associated with this session\n        :rtype: ``osid.id.Id``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.id.Id", 
               "errors": {}
            }, 
            {
               "name": "get_journal", 
               "doc": {
                  "headline": "Gets the ``Journal`` associated with this session.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.journaling.Journal) - the ``Journal`` associated\n                with this session", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the ``Journal`` associated with this session\n        :rtype: ``osid.journaling.Journal``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.journaling.Journal", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "can_manage_smart_journals", 
               "doc": {
                  "headline": "Tests if this user can manage smart journals.", 
                  "body": "        A return of true does not guarantee successful authorization. A\n        return of false indicates that it is known methods in this\n        session will result in a ``PermissionDenied``. This is intended\n        as a hint to an application that may opt not to offer operations\n        to unauthorized users."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``false`` if smart journal management is not\n                authorized, ``true`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``false`` if smart journal management is not authorized, ``true`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "get_branch_query", 
               "doc": {
                  "headline": "Gets a branch query.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.journaling.BranchQuery) - the branch query", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the branch query\n        :rtype: ``osid.journaling.BranchQuery``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.journaling.BranchQuery", 
               "errors": {}
            }, 
            {
               "name": "get_branch_search_order", 
               "doc": {
                  "headline": "Gets a branch search order.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.journaling.BranchSearchOrder) - the branch search\n                order", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the branch search order\n        :rtype: ``osid.journaling.BranchSearchOrder``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.journaling.BranchSearchOrder", 
               "errors": {}
            }, 
            {
               "name": "apply_branch_query", 
               "doc": {
                  "headline": "Applies a branch query to this journal.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    branch_query (osid.journaling.BranchQuery): the branch\n                query\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``branch_query`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure occurred\n        raise:  Unsupported - ``branch_query`` not of this service", 
               "sphinx_param_doc": "        :param branch_query: the branch query\n        :type branch_query: ``osid.journaling.BranchQuery``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``branch_query`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure occurred\n        :raise: ``Unsupported`` -- ``branch_query`` not of this service", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.journaling.BranchQuery", 
                     "var_name": "branch_query", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.journaling.BranchQuery"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }, 
            {
               "name": "inspect_branch_query", 
               "doc": {
                  "headline": "Gets a branch query inspector for this journal.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.journaling.BranchQueryInspector) - the branch\n                query inspector", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure occurred", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the branch query inspector\n        :rtype: ``osid.journaling.BranchQueryInspector``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure occurred", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.journaling.BranchQueryInspector", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "apply_branch_sequencing", 
               "doc": {
                  "headline": "Applies a branch search order to this journal.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    branch_search_order (osid.journaling.BranchSearchOrder):\n                the branch search order\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``branch_search_order`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure occurred\n        raise:  Unsupported - ``branch_search_order`` not of this\n                service", 
               "sphinx_param_doc": "        :param branch_search_order: the branch search order\n        :type branch_search_order: ``osid.journaling.BranchSearchOrder``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``branch_search_order`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure occurred\n        :raise: ``Unsupported`` -- ``branch_search_order`` not of this service", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.journaling.BranchSearchOrder", 
                     "var_name": "branch_search_order", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.journaling.BranchSearchOrder"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_branch_query_from_inspector", 
               "doc": {
                  "headline": "Gets a branch query from an inspector.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    branch_query_inspector\n                (osid.journaling.BranchQueryInspector): a branch query\n                inspector\n", 
               "return_doc": "        return: (osid.journaling.BranchQuery) - the branch query", 
               "error_doc": "        raise:  NullArgument - ``branch_query_inspector`` is ``null``\n        raise:  Unsupported - ``branch_query_inspector`` is not of this\n                service", 
               "sphinx_param_doc": "        :param branch_query_inspector: a branch query inspector\n        :type branch_query_inspector: ``osid.journaling.BranchQueryInspector``\n", 
               "sphinx_return_doc": "        :return: the branch query\n        :rtype: ``osid.journaling.BranchQuery``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``branch_query_inspector`` is ``null``\n        :raise: ``Unsupported`` -- ``branch_query_inspector`` is not of this service", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.journaling.BranchQueryInspector", 
                     "var_name": "branch_query_inspector", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.journaling.BranchQueryInspector"
               ], 
               "return_type": "osid.journaling.BranchQuery", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.journaling.JournalLookupSession", 
         "shortname": "JournalLookupSession", 
         "category": "sessions", 
         "doc": {
            "headline": "This session provides methods for retrieving ``Journal`` objects.", 
            "body": "    The ``Journal`` represents a collection of journal entries.\n\n    This session defines views that offer differing behaviors when\n    retrieving multiple objects.\n    \n      * comparative view: elements may be silently omitted or re-ordered\n      * plenary view: provides a complete set or is an error condition\n"
         }, 
         "inherit_fullnames": [
            "osid.OsidSession"
         ], 
         "inherit_shortnames": [
            "OsidSession"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidSession"
            }
         ], 
         "method_names": [
            "can_lookup_journals", 
            "use_comparative_journal_view", 
            "use_plenary_journal_view", 
            "get_journal", 
            "get_journals_by_ids", 
            "get_journals_by_genus_type", 
            "get_journals_by_parent_genus_type", 
            "get_journals_by_record_type", 
            "get_journals_by_provider", 
            "get_journals"
         ], 
         "methods": [
            {
               "name": "can_lookup_journals", 
               "doc": {
                  "headline": "Tests if this user can perform ``Journal`` lookups.", 
                  "body": "        A return of true does not guarantee successful authorization. A\n        return of false indicates that it is known all methods in this\n        session will result in a ``PermissionDenied``. This is intended\n        as a hint to an application that may not offer lookup operations\n        to unauthorized users."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``false`` if lookup methods are not\n                authorized, ``true`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``false`` if lookup methods are not authorized, ``true`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "use_comparative_journal_view", 
               "doc": {
                  "headline": "The returns from the lookup methods may omit or translate elements based on this session, such as authorization, and not result in an error.", 
                  "body": "        This view is used when greater interoperability is desired at\n        the expense of precision."
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "use_plenary_journal_view", 
               "doc": {
                  "headline": "A complete view of the ``Journal`` returns is desired.", 
                  "body": "        Methods will return what is requested or result in an error.\n        This view is used when greater precision is desired at the\n        expense of interoperability."
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "get_journal", 
               "doc": {
                  "headline": "Gets the ``Journal`` specified by its ``Id``.", 
                  "body": "        In plenary mode, the exact ``Id`` is found or a ``NotFound``\n        results. Otherwise, the returned ``Journal`` may have a\n        different ``Id`` than requested, such as the case where a\n        duplicate ``Id`` was assigned to a ``Journal`` and retained for\n        compatibility."
               }, 
               "arg_doc": "        arg:    journal_id (osid.id.Id): ``Id`` of the ``Journal``\n", 
               "return_doc": "        return: (osid.journaling.Journal) - the journal", 
               "error_doc": "        raise:  NotFound - ``journal_id`` not found\n        raise:  NullArgument - ``journal_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param journal_id: ``Id`` of the ``Journal``\n        :type journal_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: the journal\n        :rtype: ``osid.journaling.Journal``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``journal_id`` not found\n        :raise: ``NullArgument`` -- ``journal_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "journal_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "osid.journaling.Journal", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_journals_by_ids", 
               "doc": {
                  "headline": "Gets a ``JournalList`` corresponding to the given ``IdList``.", 
                  "body": "        In plenary mode, the returned list contains all of the journals\n        specified in the ``Id`` list, in the order of the list,\n        including duplicates, or an error results if an ``Id`` in the\n        supplied list is not found or inaccessible. Otherwise,\n        inaccessible ``Journals`` may be omitted from the list and may\n        present the elements in any order including returning a unique\n        set."
               }, 
               "arg_doc": "        arg:    journal_ids (osid.id.IdList): the list of ``Ids`` to\n                retrieve\n", 
               "return_doc": "        return: (osid.journaling.JournalList) - the returned ``Journal``\n                list", 
               "error_doc": "        raise:  NotFound - an ``Id was`` not found\n        raise:  NullArgument - ``journal_ids`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param journal_ids: the list of ``Ids`` to retrieve\n        :type journal_ids: ``osid.id.IdList``\n", 
               "sphinx_return_doc": "        :return: the returned ``Journal`` list\n        :rtype: ``osid.journaling.JournalList``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- an ``Id was`` not found\n        :raise: ``NullArgument`` -- ``journal_ids`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.IdList", 
                     "var_name": "journal_ids", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.IdList"
               ], 
               "return_type": "osid.journaling.JournalList", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_journals_by_genus_type", 
               "doc": {
                  "headline": "Gets a ``JournalList`` corresponding to the given journal genus ``Type`` which does not include journals of genus types derived from the specified ``Type``.", 
                  "body": "        In plenary mode, the returned list contains all known journals\n        or an error results. Otherwise, the returned list may contain\n        only those journals that are accessible through this session."
               }, 
               "arg_doc": "        arg:    journal_genus_type (osid.type.Type): a journal genus\n                type\n", 
               "return_doc": "        return: (osid.journaling.JournalList) - the returned ``Journal``\n                list", 
               "error_doc": "        raise:  NullArgument - ``journal_genus_type`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param journal_genus_type: a journal genus type\n        :type journal_genus_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "        :return: the returned ``Journal`` list\n        :rtype: ``osid.journaling.JournalList``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``journal_genus_type`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "journal_genus_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "osid.journaling.JournalList", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_journals_by_parent_genus_type", 
               "doc": {
                  "headline": "Gets a ``JournalList`` corresponding to the given journal genus ``Type`` and include any additional journals with genus types derived from the specified ``Type``.", 
                  "body": "        In plenary mode, the returned list contains all known journals\n        or an error results. Otherwise, the returned list may contain\n        only those journals that are accessible through this session."
               }, 
               "arg_doc": "        arg:    journal_genus_type (osid.type.Type): a journal genus\n                type\n", 
               "return_doc": "        return: (osid.journaling.JournalList) - the returned ``Journal``\n                list", 
               "error_doc": "        raise:  NullArgument - ``journal_genus_type`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param journal_genus_type: a journal genus type\n        :type journal_genus_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "        :return: the returned ``Journal`` list\n        :rtype: ``osid.journaling.JournalList``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``journal_genus_type`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "journal_genus_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "osid.journaling.JournalList", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_journals_by_record_type", 
               "doc": {
                  "headline": "Gets a ``JournalList`` containing the given journal record ``Type``.", 
                  "body": "        In plenary mode, the returned list contains all known journals\n        or an error results. Otherwise, the returned list may contain\n        only those journals that are accessible through this session."
               }, 
               "arg_doc": "        arg:    journal_record_type (osid.type.Type): a journal record\n                type\n", 
               "return_doc": "        return: (osid.journaling.JournalList) - the returned ``Journal``\n                list", 
               "error_doc": "        raise:  NullArgument - ``journal_record_type`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param journal_record_type: a journal record type\n        :type journal_record_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "        :return: the returned ``Journal`` list\n        :rtype: ``osid.journaling.JournalList``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``journal_record_type`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "journal_record_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "osid.journaling.JournalList", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_journals_by_provider", 
               "doc": {
                  "headline": "Gets a ``JournalList`` for the given provider.", 
                  "body": "        In plenary mode, the returned list contains all known journals\n        or an error results. Otherwise, the returned list may contain\n        only those journals that are accessible through this session."
               }, 
               "arg_doc": "        arg:    resource_id (osid.id.Id): a resource ``Id``\n", 
               "return_doc": "        return: (osid.journaling.JournalList) - the returned ``Journal``\n                list", 
               "error_doc": "        raise:  NullArgument - ``resource_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param resource_id: a resource ``Id``\n        :type resource_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: the returned ``Journal`` list\n        :rtype: ``osid.journaling.JournalList``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``resource_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "resource_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "osid.journaling.JournalList", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_journals", 
               "doc": {
                  "headline": "Gets all ``Journals``.", 
                  "body": "        In plenary mode, the returned list contains all known journals\n        or an error results. Otherwise, the returned list may contain\n        only those journals that are accessible through this session."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.journaling.JournalList) - a list of ``Journals``", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: a list of ``Journals``\n        :rtype: ``osid.journaling.JournalList``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.journaling.JournalList", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.journaling.JournalQuerySession", 
         "shortname": "JournalQuerySession", 
         "category": "sessions", 
         "doc": {
            "headline": "This session provides methods for searching ``Journal`` objects.", 
            "body": "    The search query is constructed using the ``JournalQuery``. The\n    journal record ``Type`` also specifies the for the journal query.\n\n    Journals may have a query record indicated by their respective\n    record types. The query record is accessed via the ``JournalQuery``.\n    The returns in this session may not be cast directly to these\n    interfaces."
         }, 
         "inherit_fullnames": [
            "osid.OsidSession"
         ], 
         "inherit_shortnames": [
            "OsidSession"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidSession"
            }
         ], 
         "method_names": [
            "can_search_journals", 
            "get_journal_query", 
            "get_journals_by_query"
         ], 
         "methods": [
            {
               "name": "can_search_journals", 
               "doc": {
                  "headline": "Tests if this user can perform ``Journal`` searches.", 
                  "body": "        A return of true does not guarantee successful authorization. A\n        return of false indicates that it is known all methods in this\n        session will result in a ``PermissionDenied``. This is intended\n        as a hint to an application that may opt not to offer search\n        operations to unauthorized users."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``false`` if search methods are not\n                authorized, ``true`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``false`` if search methods are not authorized, ``true`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "get_journal_query", 
               "doc": {
                  "headline": "Gets a journal query.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.journaling.JournalQuery) - the journal query", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the journal query\n        :rtype: ``osid.journaling.JournalQuery``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.journaling.JournalQuery", 
               "errors": {}
            }, 
            {
               "name": "get_journals_by_query", 
               "doc": {
                  "headline": "Gets a list of ``Journals`` matching the given search.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    journal_query (osid.journaling.JournalQuery): the\n                journal query\n", 
               "return_doc": "        return: (osid.journaling.JournalList) - the returned\n                ``JournalList``", 
               "error_doc": "        raise:  NullArgument - ``journal_query`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        raise:  Unsupported - ``journal_query`` is not of this service", 
               "sphinx_param_doc": "        :param journal_query: the journal query\n        :type journal_query: ``osid.journaling.JournalQuery``\n", 
               "sphinx_return_doc": "        :return: the returned ``JournalList``\n        :rtype: ``osid.journaling.JournalList``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``journal_query`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure\n        :raise: ``Unsupported`` -- ``journal_query`` is not of this service", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.journaling.JournalQuery", 
                     "var_name": "journal_query", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.journaling.JournalQuery"
               ], 
               "return_type": "osid.journaling.JournalList", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.journaling.JournalSearchSession", 
         "shortname": "JournalSearchSession", 
         "category": "sessions", 
         "doc": {
            "headline": "This session provides methods for searching ``Journal`` objects.", 
            "body": "    The search query is constructed using the ``JournalQuery``. The\n    journal record ``Type`` also specifies the record for the journal\n    query.\n\n    ``get_journals_by_query()`` is the basic search method and returns a\n    list of ``Journal`` elements. A more advanced search may be\n    performed with ``getJournalsBySearch()``. It accepts a\n    ``JournalSearch`` in addition to the query for the purpose of\n    specifying additional options affecting the entire search, such as\n    ordering. ``get_journals_by_search()`` returns a\n    ``JournalSearchResults`` that can be used to access the resulting\n    ``JournalList`` or be used to perform a search within the result set\n    through ``JournalSearch``.\n    \n    Journals may have a query record indicated by their respective\n    record types. The query record is accessed via the ``JournalQuery``.\n    The returns in this session may not be cast directly to these\n    interfaces."
         }, 
         "inherit_fullnames": [
            "osid.journaling.JournalQuerySession"
         ], 
         "inherit_shortnames": [
            "JournalQuerySession"
         ], 
         "inherit_pkg_names": [
            "journaling"
         ], 
         "inheritance": [
            {
               "pkg_name": "journaling", 
               "name": "JournalQuerySession"
            }
         ], 
         "method_names": [
            "get_journal_search", 
            "get_journal_search_order", 
            "get_journals_by_search", 
            "get_journal_query_from_inspector"
         ], 
         "methods": [
            {
               "name": "get_journal_search", 
               "doc": {
                  "headline": "Gets a journal search.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.journaling.JournalSearch) - the journal search", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the journal search\n        :rtype: ``osid.journaling.JournalSearch``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.journaling.JournalSearch", 
               "errors": {}
            }, 
            {
               "name": "get_journal_search_order", 
               "doc": {
                  "headline": "Gets a journal search order.", 
                  "body": "        The ``JournalSearchOrder`` is supplied to a ``JournalSearch`` to\n        specify the ordering of results."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.journaling.JournalSearchOrder) - the journal\n                search order", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the journal search order\n        :rtype: ``osid.journaling.JournalSearchOrder``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.journaling.JournalSearchOrder", 
               "errors": {}
            }, 
            {
               "name": "get_journals_by_search", 
               "doc": {
                  "headline": "Gets the search results matching the given search.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    journal_query (osid.journaling.JournalQuery): the\n                journal query\n        arg:    journal_search (osid.journaling.JournalSearch): the\n                journal search\n", 
               "return_doc": "        return: (osid.journaling.JournalSearchResults) - the journal\n                search results", 
               "error_doc": "        raise:  NullArgument - ``journal_query`` or ``journal_search``\n                is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        raise:  Unsupported - ``journal_query`` or ``journal_search`` is\n                not of this service", 
               "sphinx_param_doc": "        :param journal_query: the journal query\n        :type journal_query: ``osid.journaling.JournalQuery``\n        :param journal_search: the journal search\n        :type journal_search: ``osid.journaling.JournalSearch``\n", 
               "sphinx_return_doc": "        :return: the journal search results\n        :rtype: ``osid.journaling.JournalSearchResults``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``journal_query`` or ``journal_search`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure\n        :raise: ``Unsupported`` -- ``journal_query`` or ``journal_search`` is not of this service", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.journaling.JournalQuery", 
                     "var_name": "journal_query", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.journaling.JournalSearch", 
                     "var_name": "journal_search", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.journaling.JournalQuery", 
                  "osid.journaling.JournalSearch"
               ], 
               "return_type": "osid.journaling.JournalSearchResults", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_journal_query_from_inspector", 
               "doc": {
                  "headline": "Gets a journal query from an inspector.", 
                  "body": "        The inspector is available from a ``JournalSearchResults``."
               }, 
               "arg_doc": "        arg:    journal_query_inspector\n                (osid.journaling.JournalQueryInspector): a journal query\n                inspector\n", 
               "return_doc": "        return: (osid.journaling.JournalQuery) - the journal query", 
               "error_doc": "        raise:  NullArgument - ``journal_query_inspector`` is ``null``\n        raise:  Unsupported - ``journal_query_inspector`` is not of this\n                service", 
               "sphinx_param_doc": "        :param journal_query_inspector: a journal query inspector\n        :type journal_query_inspector: ``osid.journaling.JournalQueryInspector``\n", 
               "sphinx_return_doc": "        :return: the journal query\n        :rtype: ``osid.journaling.JournalQuery``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``journal_query_inspector`` is ``null``\n        :raise: ``Unsupported`` -- ``journal_query_inspector`` is not of this service", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.journaling.JournalQueryInspector", 
                     "var_name": "journal_query_inspector", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.journaling.JournalQueryInspector"
               ], 
               "return_type": "osid.journaling.JournalQuery", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.journaling.JournalAdminSession", 
         "shortname": "JournalAdminSession", 
         "category": "sessions", 
         "doc": {
            "headline": "This session creates, updates, and deletes ``Journals``.", 
            "body": "    The data for create and update is provided by the consumer via the\n    form object. ``OsidForms`` are requested for each create or update\n    and may not be reused.\n\n    Create and update operations differ in their usage. To create a\n    ``Journal,`` a ``JournalForm`` is requested using\n    ``get_journal_form_for_create()`` specifying the desired record\n    ``Types`` or none if no record ``Types`` are needed. The returned\n    ``JournalForm`` will indicate that it is to be used with a create\n    operation and can be used to examine metdata or validate data prior\n    to creation. Once the ``JournalForm`` is submiited to a create\n    operation, it cannot be reused with another create operation unless\n    the first operation was unsuccessful. Each ``JournalForm``\n    corresponds to an attempted transaction.\n    \n    For updates, ``JournalForms`` are requested to the ``Journal``\n    ``Id`` that is to be updated using ``getJournalFormForUpdate()``.\n    Similarly, the ``JournalForm`` has metadata about the data that can\n    be updated and it can perform validation before submitting the\n    update. The ``JournalForm`` can only be used once for a successful\n    update and cannot be reused.\n    \n    The delete operations delete ``Journals``.\n    \n    This session includes an ``Id`` aliasing mechanism to assign an\n    external ``Id`` to an internally assigned Id."
         }, 
         "inherit_fullnames": [
            "osid.OsidSession"
         ], 
         "inherit_shortnames": [
            "OsidSession"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidSession"
            }
         ], 
         "method_names": [
            "can_create_journals", 
            "can_create_journal_with_record_types", 
            "get_journal_form_for_create", 
            "create_journal", 
            "can_update_journals", 
            "get_journal_form_for_update", 
            "update_journal", 
            "can_delete_journals", 
            "delete_journal", 
            "can_manage_journal_aliases", 
            "alias_journal"
         ], 
         "methods": [
            {
               "name": "can_create_journals", 
               "doc": {
                  "headline": "Tests if this user can create ``Journals``.", 
                  "body": "        A return of true does not guarantee successful authorization. A\n        return of false indicates that it is known creating a\n        ``Journal`` will result in a ``PermissionDenied``. This is\n        intended as a hint to an application that may not wish to offer\n        create operations to unauthorized users."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``false`` if ``Journal`` creation is not\n                authorized, ``true`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``false`` if ``Journal`` creation is not authorized, ``true`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "can_create_journal_with_record_types", 
               "doc": {
                  "headline": "Tests if this user can create a single ``Journal`` using the desired record interface types.", 
                  "body": "        While ``JournalingManager.getJournalRecordTypes()`` can be used\n        to examine which record interfaces are supported, this method\n        tests which record(s) are required for creating a specific\n        ``Journal``. Providing an empty array tests if a ``Journal`` can\n        be created with no records."
               }, 
               "arg_doc": "        arg:    journal_record_types (osid.type.Type[]): array of\n                journal record types\n", 
               "return_doc": "        return: (boolean) - ``true`` if ``Journal`` creation using the\n                specified record ``Types`` is supported, ``false``\n                otherwise", 
               "error_doc": "        raise:  NullArgument - ``journal_record_types`` is ``null``", 
               "sphinx_param_doc": "        :param journal_record_types: array of journal record types\n        :type journal_record_types: ``osid.type.Type[]``\n", 
               "sphinx_return_doc": "        :return: ``true`` if ``Journal`` creation using the specified record ``Types`` is supported, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``journal_record_types`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type[]", 
                     "var_name": "journal_record_types", 
                     "array": true
                  }
               ], 
               "arg_types": [
                  "osid.type.Type[]"
               ], 
               "return_type": "boolean", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "get_journal_form_for_create", 
               "doc": {
                  "headline": "Gets the journal form for creating new journals.", 
                  "body": "        A new form should be requested for each create transaction."
               }, 
               "arg_doc": "        arg:    journal_record_types (osid.type.Type[]): array of\n                journal record types\n", 
               "return_doc": "        return: (osid.journaling.JournalForm) - the journal form", 
               "error_doc": "        raise:  NullArgument - ``journal_record_types`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        raise:  Unsupported - unable to get form for requested record\n                types", 
               "sphinx_param_doc": "        :param journal_record_types: array of journal record types\n        :type journal_record_types: ``osid.type.Type[]``\n", 
               "sphinx_return_doc": "        :return: the journal form\n        :rtype: ``osid.journaling.JournalForm``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``journal_record_types`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure\n        :raise: ``Unsupported`` -- unable to get form for requested record types", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type[]", 
                     "var_name": "journal_record_types", 
                     "array": true
                  }
               ], 
               "arg_types": [
                  "osid.type.Type[]"
               ], 
               "return_type": "osid.journaling.JournalForm", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }, 
            {
               "name": "create_journal", 
               "doc": {
                  "headline": "Creates a new ``Journal``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    journal_form (osid.journaling.JournalForm): the form for\n                this ``Journal``\n", 
               "return_doc": "        return: (osid.journaling.Journal) - the new ``Journal``", 
               "error_doc": "        raise:  IllegalState - ``journal_form`` already used in a create\n                transaction\n        raise:  InvalidArgument - one or more of the form elements is\n                invalid\n        raise:  NullArgument - ``journal_form`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        raise:  Unsupported - ``journal_form`` did not originate from\n                ``get_journal_form_for_create()``", 
               "sphinx_param_doc": "        :param journal_form: the form for this ``Journal``\n        :type journal_form: ``osid.journaling.JournalForm``\n", 
               "sphinx_return_doc": "        :return: the new ``Journal``\n        :rtype: ``osid.journaling.Journal``", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- ``journal_form`` already used in a create transaction\n        :raise: ``InvalidArgument`` -- one or more of the form elements is invalid\n        :raise: ``NullArgument`` -- ``journal_form`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure\n        :raise: ``Unsupported`` -- ``journal_form`` did not originate from ``get_journal_form_for_create()``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.journaling.JournalForm", 
                     "var_name": "journal_form", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.journaling.JournalForm"
               ], 
               "return_type": "osid.journaling.Journal", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract", 
                  "INVALID_ARGUMENT": "ConsumerContract", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }, 
            {
               "name": "can_update_journals", 
               "doc": {
                  "headline": "Tests if this user can update ``Journals``.", 
                  "body": "        A return of true does not guarantee successful authorization. A\n        return of false indicates that it is known updating a\n        ``Journal`` will result in a ``PermissionDenied``. This is\n        intended as a hint to an application that may not wish to offer\n        update operations to unauthorized users."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``false`` if ``Journal`` modification is not\n                authorized, ``true`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``false`` if ``Journal`` modification is not authorized, ``true`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "get_journal_form_for_update", 
               "doc": {
                  "headline": "Gets the journal form for updating an existing journal.", 
                  "body": "        A new journal form should be requested for each update\n        transaction."
               }, 
               "arg_doc": "        arg:    journal_id (osid.id.Id): the ``Id`` of the ``Journal``\n", 
               "return_doc": "        return: (osid.journaling.JournalForm) - the journal form", 
               "error_doc": "        raise:  NullArgument - ``journal_id`` is ``null``", 
               "sphinx_param_doc": "        :param journal_id: the ``Id`` of the ``Journal``\n        :type journal_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: the journal form\n        :rtype: ``osid.journaling.JournalForm``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``journal_id`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "journal_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "osid.journaling.JournalForm", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "update_journal", 
               "doc": {
                  "headline": "Updates an existing journal.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    journal_form (osid.journaling.JournalForm): the form\n                containing the elements to be updated\n", 
               "return_doc": "", 
               "error_doc": "        raise:  IllegalState - ``journal_form`` already used in an\n                update transaction\n        raise:  InvalidArgument - the form contains an invalid value\n        raise:  NullArgument - ``journal_form`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        raise:  Unsupported - ``journal_form`` did not originate from\n                ``get_journal_form_for_update()``", 
               "sphinx_param_doc": "        :param journal_form: the form containing the elements to be updated\n        :type journal_form: ``osid.journaling.JournalForm``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- ``journal_form`` already used in an update transaction\n        :raise: ``InvalidArgument`` -- the form contains an invalid value\n        :raise: ``NullArgument`` -- ``journal_form`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure\n        :raise: ``Unsupported`` -- ``journal_form`` did not originate from ``get_journal_form_for_update()``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.journaling.JournalForm", 
                     "var_name": "journal_form", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.journaling.JournalForm"
               ], 
               "return_type": "", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract", 
                  "INVALID_ARGUMENT": "ConsumerContract", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }, 
            {
               "name": "can_delete_journals", 
               "doc": {
                  "headline": "Tests if this user can delete ``Journals`` A return of true does not guarantee successful authorization.", 
                  "body": "        A return of false indicates that it is known deleting a\n        ``Journal`` will result in a ``PermissionDenied``. This is\n        intended as a hint to an application that may not wish to offer\n        delete operations to unauthorized users."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``false`` if ``Journal`` deletion is not\n                authorized, ``true`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``false`` if ``Journal`` deletion is not authorized, ``true`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "delete_journal", 
               "doc": {
                  "headline": "Deletes a ``Journal``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    journal_id (osid.id.Id): the ``Id`` of the ``Journal``\n                to remove\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NotFound - ``journal_id`` not found\n        raise:  NullArgument - ``journal_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param journal_id: the ``Id`` of the ``Journal`` to remove\n        :type journal_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``journal_id`` not found\n        :raise: ``NullArgument`` -- ``journal_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "journal_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "can_manage_journal_aliases", 
               "doc": {
                  "headline": "Tests if this user can manage ``Id`` aliases for ``Journals``.", 
                  "body": "        A return of true does not guarantee successful authorization. A\n        return of false indicates that it is known changing an alias\n        will result in a ``PermissionDenied``. This is intended as a\n        hint to an application that may opt not to offer alias\n        operations to an unauthorized user."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``false`` if ``Journal`` aliasing is not\n                authorized, ``true`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``false`` if ``Journal`` aliasing is not authorized, ``true`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "alias_journal", 
               "doc": {
                  "headline": "Adds an ``Id`` to a ``Journal`` for the purpose of creating compatibility.", 
                  "body": "        The primary ``Id`` of the ``Journal`` is determined by the\n        provider. The new ``Id`` performs as an alias to the primary\n        ``Id`` . If the alias is a pointer to another journal it is\n        reassigned to the given journal ``Id``."
               }, 
               "arg_doc": "        arg:    journal_id (osid.id.Id): the ``Id`` of a ``Journal``\n        arg:    alias_id (osid.id.Id): the alias ``Id``\n", 
               "return_doc": "", 
               "error_doc": "        raise:  AlreadyExists - ``alias_id`` is already assigned\n        raise:  NotFound - ``journal_id`` not found\n        raise:  NullArgument - ``journal_id`` or ``alias_id`` is\n                ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param journal_id: the ``Id`` of a ``Journal``\n        :type journal_id: ``osid.id.Id``\n        :param alias_id: the alias ``Id``\n        :type alias_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``AlreadyExists`` -- ``alias_id`` is already assigned\n        :raise: ``NotFound`` -- ``journal_id`` not found\n        :raise: ``NullArgument`` -- ``journal_id`` or ``alias_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "journal_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "alias_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {
                  "ALREADY_EXISTS": "User", 
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.journaling.JournalNotificationSession", 
         "shortname": "JournalNotificationSession", 
         "category": "sessions", 
         "doc": {
            "headline": "This session defines methods to receive notifications on adds/changes to ``Journal`` objects.", 
            "body": "    This session is intended for consumers needing to synchronize their\n    state with this service without the use of polling. Notifications\n    are cancelled when this session is closed.\n\n    Notifications are triggered with changes to the ``Journal`` object\n    itself. Adding and removing entries result in notifications\n    available from the notification session for journal entries."
         }, 
         "inherit_fullnames": [
            "osid.OsidSession"
         ], 
         "inherit_shortnames": [
            "OsidSession"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidSession"
            }
         ], 
         "method_names": [
            "can_register_for_journal_notifications", 
            "register_for_new_journals", 
            "register_for_new_journal_ancestors", 
            "register_for_new_journal_descendants", 
            "register_for_changed_journals", 
            "register_for_changed_journal", 
            "register_for_deleted_journals", 
            "register_for_deleted_journal", 
            "register_for_deleted_journal_ancestors", 
            "register_for_deleted_journal_descendants"
         ], 
         "methods": [
            {
               "name": "can_register_for_journal_notifications", 
               "doc": {
                  "headline": "Tests if this user can register for ``Journal`` notifications.", 
                  "body": "        A return of true does not guarantee successful authorization. A\n        return of false indicates that it is known all methods in this\n        session will result in a ``PermissionDenied``. This is intended\n        as a hint to an application that may opt not to offer\n        notification operations."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``false`` if notification methods are not\n                authorized, ``true`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``false`` if notification methods are not authorized, ``true`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "register_for_new_journals", 
               "doc": {
                  "headline": "Register for notifications of new journals.", 
                  "body": "        ``JournalReceiver.newJournal()`` is invoked when a new\n        ``Journal`` is created."
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "register_for_new_journal_ancestors", 
               "doc": {
                  "headline": "Registers for notification of an updated hierarchy structure that introduces a new ancestor of the specified journal.", 
                  "body": "        ``JournalReceiver.newAncestorJournal()`` is invoked when the\n        specified journal node gets a new ancestor."
               }, 
               "arg_doc": "        arg:    journal_id (osid.id.Id): the ``Id`` of the ``Journal``\n                node to monitor\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``journal_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param journal_id: the ``Id`` of the ``Journal`` node to monitor\n        :type journal_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``journal_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "journal_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "register_for_new_journal_descendants", 
               "doc": {
                  "headline": "Registers for notification of an updated hierarchy structure that introduces a new descendant of the specified journal.", 
                  "body": "        ``JournalReceiver.newDescendantJournal()`` is invoked when the\n        specified journal node gets a new descendant."
               }, 
               "arg_doc": "        arg:    journal_id (osid.id.Id): the ``Id`` of the ``Journal``\n                node to monitor\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``journal_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param journal_id: the ``Id`` of the ``Journal`` node to monitor\n        :type journal_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``journal_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "journal_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "register_for_changed_journals", 
               "doc": {
                  "headline": "Registers for notification of updated journals.", 
                  "body": "        ``JournalReceiver.changedJournal()`` is invoked when a journal\n        is changed."
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "register_for_changed_journal", 
               "doc": {
                  "headline": "Registers for notification of an updated journal.", 
                  "body": "        ``JournalReceiver.changedJournal()`` is invoked when the\n        specified journal is changed."
               }, 
               "arg_doc": "        arg:    journal_id (osid.id.Id): the ``Id`` of the ``Journal``\n                to monitor\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``journal_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param journal_id: the ``Id`` of the ``Journal`` to monitor\n        :type journal_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``journal_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "journal_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "register_for_deleted_journals", 
               "doc": {
                  "headline": "Registers for notification of deleted journals.", 
                  "body": "        ``JournalReceiver.deletedJournal()`` is invoked when a journal\n        is deleted."
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "register_for_deleted_journal", 
               "doc": {
                  "headline": "Registers for notification of a deleted journal.", 
                  "body": "        ``JournalReceiver.deletedJournal()`` is invoked when the\n        specified journal is deleted."
               }, 
               "arg_doc": "        arg:    journal_id (osid.id.Id): the ``Id`` of the ``Journal``\n                to monitor\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``journal_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param journal_id: the ``Id`` of the ``Journal`` to monitor\n        :type journal_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``journal_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "journal_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "register_for_deleted_journal_ancestors", 
               "doc": {
                  "headline": "Registers for notification of an updated hierarchy structure that removes an ancestor of the specified journal ``JournalReceiver.", 
                  "body": "        deletedAncestor()`` is invoked when the specified journal node\n        loses an ancestor."
               }, 
               "arg_doc": "        arg:    journal_id (osid.id.Id): the ``Id`` of the ``Journal``\n                to monitor\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``journal_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param journal_id: the ``Id`` of the ``Journal`` to monitor\n        :type journal_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``journal_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "journal_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "register_for_deleted_journal_descendants", 
               "doc": {
                  "headline": "Registers for notification of an updated hierarchy structure that removes a descendant of the specified journal.", 
                  "body": "        ``JournalReceiver.deletedDescendant()`` is invoked when the\n        specified journal node loses a descendant."
               }, 
               "arg_doc": "        arg:    journal_id (osid.id.Id): the ``Id`` of the ``Journal``\n                to monitor\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``journal_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param journal_id: the ``Id`` of the ``Journal`` to monitor\n        :type journal_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``journal_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "journal_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.journaling.JournalHierarchySession", 
         "shortname": "JournalHierarchySession", 
         "category": "sessions", 
         "doc": {
            "headline": "This session defines methods for traversing a hierarchy of ``Journal`` objects.", 
            "body": "    Each node in the hierarchy is a unique ``Journal``. The hierarchy\n    may be traversed recursively to establish the tree structure through\n    ``get_parent_journals()`` and ``getChildJournals()``. To relate\n    these ``Ids`` to another OSID, ``get_journal_nodes()`` can be used\n    for retrievals that can be used for bulk lookups in other OSIDs. Any\n    ``Journal`` available in the Journaling OSID is known to this\n    hierarchy but does not appear in the hierarchy traversal until added\n    as a root node or a child of another node.\n\n    A user may not be authorized to traverse the entire hierarchy. Parts\n    of the hierarchy may be made invisible through omission from the\n    returns of ``get_parent_journals()`` or ``get_child_journals()`` in\n    lieu of a ``PermissionDenied`` error that may disrupt the traversal\n    through authorized pathways.\n    \n    This session defines views that offer differing behaviors when\n    retrieving multiple objects.\n    \n      * comparative view: journal elements may be silently omitted or\n        re-ordered\n      * plenary view: provides a complete set or is an error condition\n"
         }, 
         "inherit_fullnames": [
            "osid.OsidSession"
         ], 
         "inherit_shortnames": [
            "OsidSession"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidSession"
            }
         ], 
         "method_names": [
            "get_journal_hierarchy_id", 
            "get_journal_hierarchy", 
            "can_access_journal_hierarchy", 
            "use_comparative_journal_view", 
            "use_plenary_journal_view", 
            "get_root_journal_ids", 
            "get_root_journals", 
            "has_parent_journals", 
            "is_parent_of_journal", 
            "get_parent_journal_ids", 
            "get_parent_journals", 
            "is_ancestor_of_journal", 
            "has_child_journals", 
            "is_child_of_journal", 
            "get_child_journal_ids", 
            "get_child_journals", 
            "is_descendant_of_journal", 
            "get_journal_node_ids", 
            "get_journal_nodes"
         ], 
         "methods": [
            {
               "name": "get_journal_hierarchy_id", 
               "doc": {
                  "headline": "Gets the hierarchy ``Id`` associated with this session.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.id.Id) - the hierarchy ``Id`` associated with this\n                session", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the hierarchy ``Id`` associated with this session\n        :rtype: ``osid.id.Id``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.id.Id", 
               "errors": {}
            }, 
            {
               "name": "get_journal_hierarchy", 
               "doc": {
                  "headline": "Gets the hierarchy associated with this session.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.hierarchy.Hierarchy) - the hierarchy associated\n                with this session", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the hierarchy associated with this session\n        :rtype: ``osid.hierarchy.Hierarchy``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.hierarchy.Hierarchy", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "can_access_journal_hierarchy", 
               "doc": {
                  "headline": "Tests if this user can perform hierarchy queries.", 
                  "body": "        A return of true does not guarantee successful authorization. A\n        return of false indicates that it is known all methods in this\n        session will result in a ``PermissionDenied``. This is intended\n        as a hint to an application that may opt not to offer lookup\n        operations."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``false`` if hierarchy traversal methods are\n                not authorized, ``true`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``false`` if hierarchy traversal methods are not authorized, ``true`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "use_comparative_journal_view", 
               "doc": {
                  "headline": "The returns from the journal methods may omit or translate elements based on this session, such as authorization, and not result in an error.", 
                  "body": "        This view is used when greater interoperability is desired at\n        the expense of precision."
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "use_plenary_journal_view", 
               "doc": {
                  "headline": "A complete view of the ``Journal`` returns is desired.", 
                  "body": "        Methods will return what is requested or result in an error.\n        This view is used when greater precision is desired at the\n        expense of interoperability."
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "get_root_journal_ids", 
               "doc": {
                  "headline": "Gets the root journal ``Ids`` in this hierarchy.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.id.IdList) - the root journal ``Ids``", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the root journal ``Ids``\n        :rtype: ``osid.id.IdList``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.id.IdList", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_root_journals", 
               "doc": {
                  "headline": "Gets the root journals in the journal hierarchy.", 
                  "body": "        A node with no parents is an orphan. While all journal ``Ids``\n        are known to the hierarchy, an orphan does not appear in the\n        hierarchy unless explicitly added as a root node or child of\n        another node."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.journaling.JournalList) - the root journals", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the root journals\n        :rtype: ``osid.journaling.JournalList``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.journaling.JournalList", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "has_parent_journals", 
               "doc": {
                  "headline": "Tests if the ``Journal`` has any parents.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    journal_id (osid.id.Id): a journal ``Id``\n", 
               "return_doc": "        return: (boolean) - ``true`` if the journal has parents, f\n                ``alse`` otherwise", 
               "error_doc": "        raise:  NotFound - ``journal_id`` is not found\n        raise:  NullArgument - ``journal_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param journal_id: a journal ``Id``\n        :type journal_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: ``true`` if the journal has parents, f ``alse`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``journal_id`` is not found\n        :raise: ``NullArgument`` -- ``journal_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "journal_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "boolean", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "is_parent_of_journal", 
               "doc": {
                  "headline": "Tests if an ``Id`` is a direct parent of journal.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    id (osid.id.Id): an ``Id``\n        arg:    journal_id (osid.id.Id): the ``Id`` of a journal\n", 
               "return_doc": "        return: (boolean) - ``true`` if this ``id`` is a parent of\n                ``journal_id,`` f ``alse`` otherwise", 
               "error_doc": "        raise:  NotFound - ``journal_id`` is not found\n        raise:  NullArgument - ``id`` or ``journal_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param id: an ``Id``\n        :type id: ``osid.id.Id``\n        :param journal_id: the ``Id`` of a journal\n        :type journal_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: ``true`` if this ``id`` is a parent of ``journal_id,`` f ``alse`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``journal_id`` is not found\n        :raise: ``NullArgument`` -- ``id`` or ``journal_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "        *implementation notes*: If ``id`` not found return ``false``.\n", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "id_", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "journal_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "osid.id.Id"
               ], 
               "return_type": "boolean", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_parent_journal_ids", 
               "doc": {
                  "headline": "Gets the parent ``Ids`` of the given journal.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    journal_id (osid.id.Id): a journal ``Id``\n", 
               "return_doc": "        return: (osid.id.IdList) - the parent ``Ids`` of the journal", 
               "error_doc": "        raise:  NotFound - ``journal_id`` is not found\n        raise:  NullArgument - ``journal_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param journal_id: a journal ``Id``\n        :type journal_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: the parent ``Ids`` of the journal\n        :rtype: ``osid.id.IdList``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``journal_id`` is not found\n        :raise: ``NullArgument`` -- ``journal_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "journal_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "osid.id.IdList", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_parent_journals", 
               "doc": {
                  "headline": "Gets the parent journals of the given ``id``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    journal_id (osid.id.Id): the ``Id`` of the ``Journal``\n                to query\n", 
               "return_doc": "        return: (osid.journaling.JournalList) - the parent journals of\n                the ``id``", 
               "error_doc": "        raise:  NotFound - a ``Journal`` identified by ``Id is`` not\n                found\n        raise:  NullArgument - ``journal_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param journal_id: the ``Id`` of the ``Journal`` to query\n        :type journal_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: the parent journals of the ``id``\n        :rtype: ``osid.journaling.JournalList``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- a ``Journal`` identified by ``Id is`` not found\n        :raise: ``NullArgument`` -- ``journal_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "journal_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "osid.journaling.JournalList", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "is_ancestor_of_journal", 
               "doc": {
                  "headline": "Tests if an ``Id`` is an ancestor of a journal.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    id (osid.id.Id): an ``Id``\n        arg:    journal_id (osid.id.Id): the ``Id`` of a journal\n", 
               "return_doc": "        return: (boolean) - ``tru`` e if this ``id`` is an ancestor of\n                ``journal_id,``  ``false`` otherwise", 
               "error_doc": "        raise:  NotFound - ``journal_id`` is not found\n        raise:  NullArgument - ``id`` or ``journal_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param id: an ``Id``\n        :type id: ``osid.id.Id``\n        :param journal_id: the ``Id`` of a journal\n        :type journal_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: ``tru`` e if this ``id`` is an ancestor of ``journal_id,``  ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``journal_id`` is not found\n        :raise: ``NullArgument`` -- ``id`` or ``journal_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "        *implementation notes*: If ``id`` not found return ``false``.\n", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "id_", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "journal_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "osid.id.Id"
               ], 
               "return_type": "boolean", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "has_child_journals", 
               "doc": {
                  "headline": "Tests if a journal has any children.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    journal_id (osid.id.Id): a journal ``Id``\n", 
               "return_doc": "        return: (boolean) - ``true`` if the ``journal_id`` has children,\n                ``false`` otherwise", 
               "error_doc": "        raise:  NotFound - ``journal_id`` is not found\n        raise:  NullArgument - ``journal_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param journal_id: a journal ``Id``\n        :type journal_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: ``true`` if the ``journal_id`` has children, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``journal_id`` is not found\n        :raise: ``NullArgument`` -- ``journal_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "journal_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "boolean", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "is_child_of_journal", 
               "doc": {
                  "headline": "Tests if a journal is a direct child of another.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    id (osid.id.Id): an ``Id``\n        arg:    journal_id (osid.id.Id): the ``Id`` of a journal\n", 
               "return_doc": "        return: (boolean) - ``true`` if the ``id`` is a child of\n                ``journal_id,``  ``false`` otherwise", 
               "error_doc": "        raise:  NotFound - ``journal_id`` is not found\n        raise:  NullArgument - ``id`` or ``journal_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param id: an ``Id``\n        :type id: ``osid.id.Id``\n        :param journal_id: the ``Id`` of a journal\n        :type journal_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: ``true`` if the ``id`` is a child of ``journal_id,``  ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``journal_id`` is not found\n        :raise: ``NullArgument`` -- ``id`` or ``journal_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "        *implementation notes*: If ``id`` not found return ``false``.\n", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "id_", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "journal_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "osid.id.Id"
               ], 
               "return_type": "boolean", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_child_journal_ids", 
               "doc": {
                  "headline": "Gets the child ``Ids`` of the given journal.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    journal_id (osid.id.Id): the ``Id`` to query\n", 
               "return_doc": "        return: (osid.id.IdList) - the children of the journal", 
               "error_doc": "        raise:  NotFound - ``journal_id`` is not found\n        raise:  NullArgument - ``journal_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param journal_id: the ``Id`` to query\n        :type journal_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: the children of the journal\n        :rtype: ``osid.id.IdList``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``journal_id`` is not found\n        :raise: ``NullArgument`` -- ``journal_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "journal_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "osid.id.IdList", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_child_journals", 
               "doc": {
                  "headline": "Gets the child journals of the given ``id``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    journal_id (osid.id.Id): the ``Id`` of the ``Journal``\n                to query\n", 
               "return_doc": "        return: (osid.journaling.JournalList) - the child journals of\n                the ``id``", 
               "error_doc": "        raise:  NotFound - a ``Journal`` identified by ``Id is`` not\n                found\n        raise:  NullArgument - ``journal_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param journal_id: the ``Id`` of the ``Journal`` to query\n        :type journal_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: the child journals of the ``id``\n        :rtype: ``osid.journaling.JournalList``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- a ``Journal`` identified by ``Id is`` not found\n        :raise: ``NullArgument`` -- ``journal_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "journal_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "osid.journaling.JournalList", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "is_descendant_of_journal", 
               "doc": {
                  "headline": "Tests if an ``Id`` is a descendant of a journal.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    id (osid.id.Id): an ``Id``\n        arg:    journal_id (osid.id.Id): the ``Id`` of a journal\n", 
               "return_doc": "        return: (boolean) - ``true`` if the ``id`` is a descendant of\n                the ``journal_id,``  ``false`` otherwise", 
               "error_doc": "        raise:  NotFound - ``journal_id`` is not found\n        raise:  NullArgument - ``id`` or ``journal_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param id: an ``Id``\n        :type id: ``osid.id.Id``\n        :param journal_id: the ``Id`` of a journal\n        :type journal_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: ``true`` if the ``id`` is a descendant of the ``journal_id,``  ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``journal_id`` is not found\n        :raise: ``NullArgument`` -- ``id`` or ``journal_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "        *implementation notes*: If ``id`` is not found return ``false``.\n", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "id_", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "journal_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "osid.id.Id"
               ], 
               "return_type": "boolean", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_journal_node_ids", 
               "doc": {
                  "headline": "Gets a portion of the hierarchy for the given journal.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    journal_id (osid.id.Id): the ``Id`` to query\n        arg:    ancestor_levels (cardinal): the maximum number of\n                ancestor levels to include. A value of 0 returns no\n                parents in the node.\n        arg:    descendant_levels (cardinal): the maximum number of\n                descendant levels to include. A value of 0 returns no\n                children in the node.\n        arg:    include_siblings (boolean): ``true`` to include the\n                siblings of the given node, ``false`` to omit the\n                siblings\n", 
               "return_doc": "        return: (osid.hierarchy.Node) - a journal node", 
               "error_doc": "        raise:  NotFound - ``journal_id`` is not found\n        raise:  NullArgument - ``journal_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param journal_id: the ``Id`` to query\n        :type journal_id: ``osid.id.Id``\n        :param ancestor_levels: the maximum number of ancestor levels to include. A value of 0 returns no parents in the node.\n        :type ancestor_levels: ``cardinal``\n        :param descendant_levels: the maximum number of descendant levels to include. A value of 0 returns no children in the node.\n        :type descendant_levels: ``cardinal``\n        :param include_siblings: ``true`` to include the siblings of the given node, ``false`` to omit the siblings\n        :type include_siblings: ``boolean``\n", 
               "sphinx_return_doc": "        :return: a journal node\n        :rtype: ``osid.hierarchy.Node``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``journal_id`` is not found\n        :raise: ``NullArgument`` -- ``journal_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "journal_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "cardinal", 
                     "var_name": "ancestor_levels", 
                     "array": false
                  }, 
                  {
                     "arg_type": "cardinal", 
                     "var_name": "descendant_levels", 
                     "array": false
                  }, 
                  {
                     "arg_type": "boolean", 
                     "var_name": "include_siblings", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "cardinal", 
                  "cardinal", 
                  "boolean"
               ], 
               "return_type": "osid.hierarchy.Node", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_journal_nodes", 
               "doc": {
                  "headline": "Gets a portion of the hierarchy for the given journal.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    journal_id (osid.id.Id): the ``Id`` to query\n        arg:    ancestor_levels (cardinal): the maximum number of\n                ancestor levels to include. A value of 0 returns no\n                parents in the node.\n        arg:    descendant_levels (cardinal): the maximum number of\n                descendant levels to include. A value of 0 returns no\n                children in the node.\n        arg:    include_siblings (boolean): ``true`` to include the\n                siblings of the given node, ``false`` to omit the\n                siblings\n", 
               "return_doc": "        return: (osid.journaling.JournalNode) - a journal node", 
               "error_doc": "        raise:  NotFound - ``journal_id`` is not found\n        raise:  NullArgument - ``journal_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param journal_id: the ``Id`` to query\n        :type journal_id: ``osid.id.Id``\n        :param ancestor_levels: the maximum number of ancestor levels to include. A value of 0 returns no parents in the node.\n        :type ancestor_levels: ``cardinal``\n        :param descendant_levels: the maximum number of descendant levels to include. A value of 0 returns no children in the node.\n        :type descendant_levels: ``cardinal``\n        :param include_siblings: ``true`` to include the siblings of the given node, ``false`` to omit the siblings\n        :type include_siblings: ``boolean``\n", 
               "sphinx_return_doc": "        :return: a journal node\n        :rtype: ``osid.journaling.JournalNode``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``journal_id`` is not found\n        :raise: ``NullArgument`` -- ``journal_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "journal_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "cardinal", 
                     "var_name": "ancestor_levels", 
                     "array": false
                  }, 
                  {
                     "arg_type": "cardinal", 
                     "var_name": "descendant_levels", 
                     "array": false
                  }, 
                  {
                     "arg_type": "boolean", 
                     "var_name": "include_siblings", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "cardinal", 
                  "cardinal", 
                  "boolean"
               ], 
               "return_type": "osid.journaling.JournalNode", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.journaling.JournalHierarchyDesignSession", 
         "shortname": "JournalHierarchyDesignSession", 
         "category": "sessions", 
         "doc": {
            "headline": "This session manages a hierarchy of journals.", 
            "body": "    Journals may be organized into a hierarchy for organizing or\n    federating. A parent ``Journal`` includes all of the journal entries\n    of its children such that a single root node contains all of the\n    journal entries of the federation."
         }, 
         "inherit_fullnames": [
            "osid.OsidSession"
         ], 
         "inherit_shortnames": [
            "OsidSession"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidSession"
            }
         ], 
         "method_names": [
            "get_journal_hierarchy_id", 
            "get_journal_hierarchy", 
            "can_modify_journal_hierarchy", 
            "add_root_journal", 
            "remove_root_journal", 
            "add_child_journal", 
            "remove_child_journal", 
            "remove_child_journals"
         ], 
         "methods": [
            {
               "name": "get_journal_hierarchy_id", 
               "doc": {
                  "headline": "Gets the hierarchy ``Id`` associated with this session.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.id.Id) - the hierarchy ``Id`` associated with this\n                session", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the hierarchy ``Id`` associated with this session\n        :rtype: ``osid.id.Id``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.id.Id", 
               "errors": {}
            }, 
            {
               "name": "get_journal_hierarchy", 
               "doc": {
                  "headline": "Gets the hierarchy associated with this session.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.hierarchy.Hierarchy) - the hierarchy associated\n                with this session", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the hierarchy associated with this session\n        :rtype: ``osid.hierarchy.Hierarchy``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.hierarchy.Hierarchy", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "can_modify_journal_hierarchy", 
               "doc": {
                  "headline": "Tests if this user can change the hierarchy.", 
                  "body": "        A return of true does not guarantee successful authorization. A\n        return of false indicates that it is known performing any update\n        will result in a ``PermissionDenied``. This is intended as a\n        hint to an application that may opt not to offer these\n        operations to an unauthorized user."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``false`` if changing this hierarchy is not\n                authorized, ``true`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``false`` if changing this hierarchy is not authorized, ``true`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "add_root_journal", 
               "doc": {
                  "headline": "Adds a root journal.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    journal_id (osid.id.Id): the ``Id`` of a journal\n", 
               "return_doc": "", 
               "error_doc": "        raise:  AlreadyExists - ``journal_id`` is already in hierarchy\n        raise:  NotFound - ``journal_id`` is not found\n        raise:  NullArgument - ``journal_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param journal_id: the ``Id`` of a journal\n        :type journal_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``AlreadyExists`` -- ``journal_id`` is already in hierarchy\n        :raise: ``NotFound`` -- ``journal_id`` is not found\n        :raise: ``NullArgument`` -- ``journal_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "journal_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {
                  "ALREADY_EXISTS": "User", 
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "remove_root_journal", 
               "doc": {
                  "headline": "Removes a root journal.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    journal_id (osid.id.Id): the ``Id`` of a journal\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NotFound - ``journal_id`` is not a root\n        raise:  NullArgument - ``journal_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param journal_id: the ``Id`` of a journal\n        :type journal_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``journal_id`` is not a root\n        :raise: ``NullArgument`` -- ``journal_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "journal_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "add_child_journal", 
               "doc": {
                  "headline": "Adds a child to a journal.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    journal_id (osid.id.Id): the ``Id`` of a journal\n        arg:    child_id (osid.id.Id): the ``Id`` of the new child\n", 
               "return_doc": "", 
               "error_doc": "        raise:  AlreadyExists - ``journal_id`` is already a parent of\n                ``child_id``\n        raise:  NotFound - ``journal_id`` or ``child_id`` not found\n        raise:  NullArgument - ``journal_id`` or ``child_id`` is\n                ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param journal_id: the ``Id`` of a journal\n        :type journal_id: ``osid.id.Id``\n        :param child_id: the ``Id`` of the new child\n        :type child_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``AlreadyExists`` -- ``journal_id`` is already a parent of ``child_id``\n        :raise: ``NotFound`` -- ``journal_id`` or ``child_id`` not found\n        :raise: ``NullArgument`` -- ``journal_id`` or ``child_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "journal_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "child_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {
                  "ALREADY_EXISTS": "User", 
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "remove_child_journal", 
               "doc": {
                  "headline": "Removes a child from a journal.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    journal_id (osid.id.Id): the ``Id`` of a journal\n        arg:    child_id (osid.id.Id): the ``Id`` of the new child\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NotFound - ``journal_id`` not a parent of ``child_id``\n        raise:  NullArgument - ``journal_id`` or ``child_id`` is\n                ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param journal_id: the ``Id`` of a journal\n        :type journal_id: ``osid.id.Id``\n        :param child_id: the ``Id`` of the new child\n        :type child_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``journal_id`` not a parent of ``child_id``\n        :raise: ``NullArgument`` -- ``journal_id`` or ``child_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "journal_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "child_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "remove_child_journals", 
               "doc": {
                  "headline": "Removes all children from a journal.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    journal_id (osid.id.Id): the ``Id`` of a journal\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NotFound - ``journal_id`` not found\n        raise:  NullArgument - ``journal_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param journal_id: the ``Id`` of a journal\n        :type journal_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``journal_id`` not found\n        :raise: ``NullArgument`` -- ``journal_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "journal_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.journaling.JournalEntry", 
         "shortname": "JournalEntry", 
         "category": "objects", 
         "doc": {
            "headline": "A ``JournalEntry`` represents an entry in a journal.", 
            "body": ""
         }, 
         "inherit_fullnames": [
            "osid.OsidObject", 
            "osid.Subjugateable"
         ], 
         "inherit_shortnames": [
            "OsidObject", 
            "Subjugateable"
         ], 
         "inherit_pkg_names": [
            "osid", 
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidObject"
            }, 
            {
               "pkg_name": "osid", 
               "name": "Subjugateable"
            }
         ], 
         "method_names": [
            "get_branch_id", 
            "get_branch", 
            "get_source_id", 
            "get_version_id", 
            "get_timestamp", 
            "get_resource_id", 
            "get_resource", 
            "get_agent_id", 
            "get_agent", 
            "get_journal_entry_record"
         ], 
         "methods": [
            {
               "name": "get_branch_id", 
               "doc": {
                  "headline": "Gets the branch ``Id`` for this entry.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.id.Id) - the branch ``Id``", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the branch ``Id``\n        :rtype: ``osid.id.Id``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.id.Id", 
               "errors": {}
            }, 
            {
               "name": "get_branch", 
               "doc": {
                  "headline": "Gets the branch for this entry.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.journaling.Branch) - the branch", 
               "error_doc": "        raise:  OperationFailed - unable to complete request", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the branch\n        :rtype: ``osid.journaling.Branch``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.journaling.Branch", 
               "errors": {
                  "OPERATION_FAILED": "Operational"
               }
            }, 
            {
               "name": "get_source_id", 
               "doc": {
                  "headline": "Gets the principal ``Id`` of the journaled object.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.id.Id) - the source ``Id``", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the source ``Id``\n        :rtype: ``osid.id.Id``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.id.Id", 
               "errors": {}
            }, 
            {
               "name": "get_version_id", 
               "doc": {
                  "headline": "Gets the version ``Id`` of the journaled object.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.id.Id) - the version ``Id``", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the version ``Id``\n        :rtype: ``osid.id.Id``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.id.Id", 
               "errors": {}
            }, 
            {
               "name": "get_timestamp", 
               "doc": {
                  "headline": "Gets the ``timestamp`` of this journal entry.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.DateTime) - the time of this entry", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the time of this entry\n        :rtype: ``osid.calendaring.DateTime``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.DateTime", 
               "errors": {}
            }, 
            {
               "name": "get_resource_id", 
               "doc": {
                  "headline": "Gets the Id of the resource who created this entry.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.id.Id) - the ``Resource``  ``Id``", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the ``Resource``  ``Id``\n        :rtype: ``osid.id.Id``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.id.Id", 
               "errors": {}
            }, 
            {
               "name": "get_resource", 
               "doc": {
                  "headline": "Gets the resource who created this entry.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.resource.Resource) - the ``Resource``", 
               "error_doc": "        raise:  OperationFailed - unable to complete request", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the ``Resource``\n        :rtype: ``osid.resource.Resource``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.resource.Resource", 
               "errors": {
                  "OPERATION_FAILED": "Operational"
               }
            }, 
            {
               "name": "get_agent_id", 
               "doc": {
                  "headline": "Gets the Id of the agent who created this entry.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.id.Id) - the ``Agent``  ``Id``", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the ``Agent``  ``Id``\n        :rtype: ``osid.id.Id``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.id.Id", 
               "errors": {}
            }, 
            {
               "name": "get_agent", 
               "doc": {
                  "headline": "Gets the agent who created this entry.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.authentication.Agent) - the ``Agent``", 
               "error_doc": "        raise:  OperationFailed - unable to complete request", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the ``Agent``\n        :rtype: ``osid.authentication.Agent``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.authentication.Agent", 
               "errors": {
                  "OPERATION_FAILED": "Operational"
               }
            }, 
            {
               "name": "get_journal_entry_record", 
               "doc": {
                  "headline": "Gets the journal entry record corresponding to the given ``JournalEntry`` record ``Type``.", 
                  "body": "        This method is used to retrieve an object implementing the\n        requested record. The ``journal_entry_record_type`` may be the\n        ``Type`` returned in ``get_record_types()`` or any of its\n        parents in a ``Type`` hierarchy where\n        ``has_record_type(journal_entry_record_type)`` is ``true`` ."
               }, 
               "arg_doc": "        arg:    journal_entry_record_type (osid.type.Type): the type of\n                journal entry record to retrieve\n", 
               "return_doc": "        return: (osid.journaling.records.JournalEntryRecord) - the\n                journal entry record", 
               "error_doc": "        raise:  NullArgument - ``journal_entry_record_type`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unsupported -\n                ``has_record_type(journal_entry_record_type)`` is\n                ``false``", 
               "sphinx_param_doc": "        :param journal_entry_record_type: the type of journal entry record to retrieve\n        :type journal_entry_record_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "        :return: the journal entry record\n        :rtype: ``osid.journaling.records.JournalEntryRecord``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``journal_entry_record_type`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unsupported`` -- ``has_record_type(journal_entry_record_type)`` is ``false``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "journal_entry_record_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "osid.journaling.records.JournalEntryRecord", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.journaling.records.JournalEntryRecord", 
         "shortname": "JournalEntryRecord", 
         "category": "records", 
         "doc": {
            "headline": "A record for a ``JournalEntry``.", 
            "body": "    The methods specified by the record type are available through the\n    underlying object."
         }, 
         "inherit_fullnames": [
            "osid.OsidRecord"
         ], 
         "inherit_shortnames": [
            "OsidRecord"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidRecord"
            }
         ], 
         "method_names": [], 
         "methods": []
      }, 
      {
         "fullname": "osid.journaling.JournalEntryQuery", 
         "shortname": "JournalEntryQuery", 
         "category": "queries", 
         "doc": {
            "headline": "This is the query for searching journal entries.", 
            "body": "    Each method specifies an ``AND`` term while multiple invocations of\n    the same method produce a nested ``OR``."
         }, 
         "inherit_fullnames": [
            "osid.OsidObjectQuery", 
            "osid.OsidSubjugateableQuery"
         ], 
         "inherit_shortnames": [
            "OsidObjectQuery", 
            "OsidSubjugateableQuery"
         ], 
         "inherit_pkg_names": [
            "osid", 
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidObjectQuery"
            }, 
            {
               "pkg_name": "osid", 
               "name": "OsidSubjugateableQuery"
            }
         ], 
         "method_names": [
            "match_branch_id", 
            "clear_branch_id_terms", 
            "supports_branch_query", 
            "get_branch_query", 
            "clear_branch_terms", 
            "match_source_id", 
            "clear_source_id_terms", 
            "match_version_id", 
            "clear_version_id_terms", 
            "match_timestamp", 
            "clear_timestamp_terms", 
            "match_entries_since", 
            "clear_entries_since_terms", 
            "match_resource_id", 
            "clear_resource_id_terms", 
            "supports_resource_query", 
            "get_resource_query", 
            "clear_resource_terms", 
            "match_agent_id", 
            "clear_agent_id_terms", 
            "supports_agent_query", 
            "get_agent_query", 
            "clear_agent_terms", 
            "match_journal_id", 
            "clear_journal_id_terms", 
            "supports_journal_query", 
            "get_journal_query", 
            "clear_journal_terms", 
            "get_journal_entry_query_record"
         ], 
         "methods": [
            {
               "name": "match_branch_id", 
               "doc": {
                  "headline": "Sets the branch ``Id`` for this query to match branches assigned to journals.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    branch_id (osid.id.Id): a branch ``Id``\n        arg:    match (boolean): ``true`` for a positive match,\n                ``false`` for a negative match\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``branch_id`` is ``null``", 
               "sphinx_param_doc": "        :param branch_id: a branch ``Id``\n        :type branch_id: ``osid.id.Id``\n        :param match: ``true`` for a positive match, ``false`` for a negative match\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``branch_id`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "branch_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "clear_branch_id_terms", 
               "doc": {
                  "headline": "Clears the branch ``Id`` terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "supports_branch_query", 
               "doc": {
                  "headline": "Tests if a branch query is available.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if a branch query is available,\n                ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if a branch query is available, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "get_branch_query", 
               "doc": {
                  "headline": "Gets the query for a branch.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.journaling.BranchQuery) - the branch query", 
               "error_doc": "        raise:  Unimplemented - ``supports_branch_query()`` is ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the branch query\n        :rtype: ``osid.journaling.BranchQuery``", 
               "sphinx_error_doc": "        :raise: ``Unimplemented`` -- ``supports_branch_query()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_branch_query()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.journaling.BranchQuery", 
               "errors": {
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "clear_branch_terms", 
               "doc": {
                  "headline": "Clears the branch terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "match_source_id", 
               "doc": {
                  "headline": "Sets the source ``Id``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    source_id (osid.id.Id): a source ``Id``\n        arg:    match (boolean): ``true`` for a positive match,\n                ``false`` for a negative match\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``source_id`` is ``null``", 
               "sphinx_param_doc": "        :param source_id: a source ``Id``\n        :type source_id: ``osid.id.Id``\n        :param match: ``true`` for a positive match, ``false`` for a negative match\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``source_id`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "source_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "clear_source_id_terms", 
               "doc": {
                  "headline": "Clears the source ``Id`` terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "match_version_id", 
               "doc": {
                  "headline": "Sets the version ``Id``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    version_id (osid.id.Id): a version ``Id``\n        arg:    match (boolean): ``true`` for a positive match,\n                ``false`` for a negative match\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``version_id`` is ``null``", 
               "sphinx_param_doc": "        :param version_id: a version ``Id``\n        :type version_id: ``osid.id.Id``\n        :param match: ``true`` for a positive match, ``false`` for a negative match\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``version_id`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "version_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "clear_version_id_terms", 
               "doc": {
                  "headline": "Clears the version ``Id`` terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "match_timestamp", 
               "doc": {
                  "headline": "Matches entries falling between the given times inclusive.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    from (osid.calendaring.DateTime): start time\n        arg:    to (osid.calendaring.DateTime): end time\n        arg:    match (boolean): ``true`` for a positive match,\n                ``false`` for a negative match\n", 
               "return_doc": "", 
               "error_doc": "        raise:  InvalidArgument - ``to`` is less than ``from``\n        raise:  NullArgument - ``from`` or ``to`` is ``null``", 
               "sphinx_param_doc": "        :param from: start time\n        :type from: ``osid.calendaring.DateTime``\n        :param to: end time\n        :type to: ``osid.calendaring.DateTime``\n        :param match: ``true`` for a positive match, ``false`` for a negative match\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``InvalidArgument`` -- ``to`` is less than ``from``\n        :raise: ``NullArgument`` -- ``from`` or ``to`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.calendaring.DateTime", 
                     "var_name": "from_", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.calendaring.DateTime", 
                     "var_name": "to", 
                     "array": false
                  }, 
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.calendaring.DateTime", 
                  "osid.calendaring.DateTime", 
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {
                  "INVALID_ARGUMENT": "ConsumerContract", 
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "clear_timestamp_terms", 
               "doc": {
                  "headline": "Clears the timestamp terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "match_entries_since", 
               "doc": {
                  "headline": "Matches entries following the given timestamp inclusive.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    from (osid.calendaring.DateTime): start time\n        arg:    match (boolean): ``true`` for a positive match,\n                ``false`` for a negative match\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``from`` is ``null``", 
               "sphinx_param_doc": "        :param from: start time\n        :type from: ``osid.calendaring.DateTime``\n        :param match: ``true`` for a positive match, ``false`` for a negative match\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``from`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.calendaring.DateTime", 
                     "var_name": "from_", 
                     "array": false
                  }, 
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.calendaring.DateTime", 
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "clear_entries_since_terms", 
               "doc": {
                  "headline": "Clears the entries since terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "match_resource_id", 
               "doc": {
                  "headline": "Sets a resource ``Id``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    resource_id (osid.id.Id): a resource ``Id``\n        arg:    match (boolean): ``true`` for a positive match,\n                ``false`` for a negative match\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``resource_id`` is ``null``", 
               "sphinx_param_doc": "        :param resource_id: a resource ``Id``\n        :type resource_id: ``osid.id.Id``\n        :param match: ``true`` for a positive match, ``false`` for a negative match\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``resource_id`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "resource_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "clear_resource_id_terms", 
               "doc": {
                  "headline": "Clears the resource ``Id`` terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "supports_resource_query", 
               "doc": {
                  "headline": "Tests if a ``ResourceQuery`` is available.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if a resource query is available,\n                ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if a resource query is available, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "get_resource_query", 
               "doc": {
                  "headline": "Gets the query for a resource query.", 
                  "body": "        Multiple retrievals produce a nested ``OR`` term."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.resource.ResourceQuery) - the resource query", 
               "error_doc": "        raise:  Unimplemented - ``supports_resource_query()`` is\n                ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the resource query\n        :rtype: ``osid.resource.ResourceQuery``", 
               "sphinx_error_doc": "        :raise: ``Unimplemented`` -- ``supports_resource_query()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_resource_query()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.resource.ResourceQuery", 
               "errors": {
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "clear_resource_terms", 
               "doc": {
                  "headline": "Clears the resource terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "match_agent_id", 
               "doc": {
                  "headline": "Sets an agent ``Id``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    agent_id (osid.id.Id): an agent ``Id``\n        arg:    match (boolean): ``true`` for a positive match,\n                ``false`` for a negative match\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``agent_id`` is ``null``", 
               "sphinx_param_doc": "        :param agent_id: an agent ``Id``\n        :type agent_id: ``osid.id.Id``\n        :param match: ``true`` for a positive match, ``false`` for a negative match\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``agent_id`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "agent_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "clear_agent_id_terms", 
               "doc": {
                  "headline": "Clears the agent ``Id`` terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "supports_agent_query", 
               "doc": {
                  "headline": "Tests if an ``AgentQuery`` is available.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if an agent query is available,\n                ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if an agent query is available, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "get_agent_query", 
               "doc": {
                  "headline": "Gets the query for an agent query.", 
                  "body": "        Multiple retrievals produce a nested ``OR`` term."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.authentication.AgentQuery) - the agent query", 
               "error_doc": "        raise:  Unimplemented - ``supports_agent_query()`` is ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the agent query\n        :rtype: ``osid.authentication.AgentQuery``", 
               "sphinx_error_doc": "        :raise: ``Unimplemented`` -- ``supports_agent_query()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_agent_query()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.authentication.AgentQuery", 
               "errors": {
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "clear_agent_terms", 
               "doc": {
                  "headline": "Clears the agent terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "match_journal_id", 
               "doc": {
                  "headline": "Sets the journal ``Id`` for this query to match entries assigned to journals.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    journal_id (osid.id.Id): a journal ``Id``\n        arg:    match (boolean): ``true`` for a positive match,\n                ``false`` for a negative match\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``journal_id`` is ``null``", 
               "sphinx_param_doc": "        :param journal_id: a journal ``Id``\n        :type journal_id: ``osid.id.Id``\n        :param match: ``true`` for a positive match, ``false`` for a negative match\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``journal_id`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "journal_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "clear_journal_id_terms", 
               "doc": {
                  "headline": "Clears the journal ``Id`` terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "supports_journal_query", 
               "doc": {
                  "headline": "Tests if a ``JournalQuery`` is available.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if a journal query is available,\n                ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if a journal query is available, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "get_journal_query", 
               "doc": {
                  "headline": "Gets the query for a journal query.", 
                  "body": "        Multiple retrievals produce a nested ``OR`` term."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.journaling.JournalQuery) - the journal query", 
               "error_doc": "        raise:  Unimplemented - ``supports_journal_query()`` is\n                ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the journal query\n        :rtype: ``osid.journaling.JournalQuery``", 
               "sphinx_error_doc": "        :raise: ``Unimplemented`` -- ``supports_journal_query()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_journal_query()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.journaling.JournalQuery", 
               "errors": {
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "clear_journal_terms", 
               "doc": {
                  "headline": "Clears the journal terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "get_journal_entry_query_record", 
               "doc": {
                  "headline": "Gets the journal entry query record corresponding to the given ``JournalEntry`` record ``Type``.", 
                  "body": "        Multiple record retrievals produce a nested ``OR`` term."
               }, 
               "arg_doc": "        arg:    journal_entry_record_type (osid.type.Type): a journal\n                entry record type\n", 
               "return_doc": "        return: (osid.journaling.records.JournalEntryQueryRecord) - the\n                journal entry query record", 
               "error_doc": "        raise:  NullArgument - ``journal_entry_record_type`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unsupported -\n                ``has_record_type(journal_entry_record_type)`` is\n                ``false``", 
               "sphinx_param_doc": "        :param journal_entry_record_type: a journal entry record type\n        :type journal_entry_record_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "        :return: the journal entry query record\n        :rtype: ``osid.journaling.records.JournalEntryQueryRecord``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``journal_entry_record_type`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unsupported`` -- ``has_record_type(journal_entry_record_type)`` is ``false``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "journal_entry_record_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "osid.journaling.records.JournalEntryQueryRecord", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.journaling.records.JournalEntryQueryRecord", 
         "shortname": "JournalEntryQueryRecord", 
         "category": "records", 
         "doc": {
            "headline": "A record for a ``JournalEntryQuery``.", 
            "body": "    The methods specified by the record type are available through the\n    underlying object."
         }, 
         "inherit_fullnames": [
            "osid.OsidRecord"
         ], 
         "inherit_shortnames": [
            "OsidRecord"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidRecord"
            }
         ], 
         "method_names": [], 
         "methods": []
      }, 
      {
         "fullname": "osid.journaling.JournalEntryQueryInspector", 
         "shortname": "JournalEntryQueryInspector", 
         "category": "query_inspectors", 
         "doc": {
            "headline": "This is the query inspector for examining journal entry queries.", 
            "body": ""
         }, 
         "inherit_fullnames": [
            "osid.OsidObjectQueryInspector", 
            "osid.OsidSubjugateableQueryInspector"
         ], 
         "inherit_shortnames": [
            "OsidObjectQueryInspector", 
            "OsidSubjugateableQueryInspector"
         ], 
         "inherit_pkg_names": [
            "osid", 
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidObjectQueryInspector"
            }, 
            {
               "pkg_name": "osid", 
               "name": "OsidSubjugateableQueryInspector"
            }
         ], 
         "method_names": [
            "get_branch_id_terms", 
            "get_branch_terms", 
            "get_source_id_terms", 
            "get_version_id_terms", 
            "get_timestamp_terms", 
            "get_entries_since_terms", 
            "get_resource_id_terms", 
            "get_resource_terms", 
            "get_agent_id_terms", 
            "get_agent_terms", 
            "get_journal_id_terms", 
            "get_journal_terms", 
            "get_journal_entry_query_inspector_record"
         ], 
         "methods": [
            {
               "name": "get_branch_id_terms", 
               "doc": {
                  "headline": "Gets the branch ``Id`` query terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.search.terms.IdTerm) - the query terms", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the query terms\n        :rtype: ``osid.search.terms.IdTerm``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.search.terms.IdTerm", 
               "errors": {}
            }, 
            {
               "name": "get_branch_terms", 
               "doc": {
                  "headline": "Gets the branch query terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.journaling.BranchQueryInspector) - the query terms", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the query terms\n        :rtype: ``osid.journaling.BranchQueryInspector``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.journaling.BranchQueryInspector", 
               "errors": {}
            }, 
            {
               "name": "get_source_id_terms", 
               "doc": {
                  "headline": "Gets the source ``Id`` query terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.search.terms.IdTerm) - the query terms", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the query terms\n        :rtype: ``osid.search.terms.IdTerm``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.search.terms.IdTerm", 
               "errors": {}
            }, 
            {
               "name": "get_version_id_terms", 
               "doc": {
                  "headline": "Gets the version ``Id`` query terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.search.terms.IdTerm) - the query terms", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the query terms\n        :rtype: ``osid.search.terms.IdTerm``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.search.terms.IdTerm", 
               "errors": {}
            }, 
            {
               "name": "get_timestamp_terms", 
               "doc": {
                  "headline": "Gets the timestamp query terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.search.terms.DateTimeRangeTerm) - the query terms", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the query terms\n        :rtype: ``osid.search.terms.DateTimeRangeTerm``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.search.terms.DateTimeRangeTerm", 
               "errors": {}
            }, 
            {
               "name": "get_entries_since_terms", 
               "doc": {
                  "headline": "Gets the entries since query terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.search.terms.DateTimeTerm) - the query terms", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the query terms\n        :rtype: ``osid.search.terms.DateTimeTerm``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.search.terms.DateTimeTerm", 
               "errors": {}
            }, 
            {
               "name": "get_resource_id_terms", 
               "doc": {
                  "headline": "Gets the resource ``Id`` query terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.search.terms.IdTerm) - the query terms", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the query terms\n        :rtype: ``osid.search.terms.IdTerm``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.search.terms.IdTerm", 
               "errors": {}
            }, 
            {
               "name": "get_resource_terms", 
               "doc": {
                  "headline": "Gets the resource query terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.resource.ResourceQueryInspector) - the query terms", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the query terms\n        :rtype: ``osid.resource.ResourceQueryInspector``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.resource.ResourceQueryInspector", 
               "errors": {}
            }, 
            {
               "name": "get_agent_id_terms", 
               "doc": {
                  "headline": "Gets the agent ``Id`` query terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.search.terms.IdTerm) - the query terms", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the query terms\n        :rtype: ``osid.search.terms.IdTerm``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.search.terms.IdTerm", 
               "errors": {}
            }, 
            {
               "name": "get_agent_terms", 
               "doc": {
                  "headline": "Gets the agent query terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.authentication.AgentQueryInspector) - the query\n                terms", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the query terms\n        :rtype: ``osid.authentication.AgentQueryInspector``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.authentication.AgentQueryInspector", 
               "errors": {}
            }, 
            {
               "name": "get_journal_id_terms", 
               "doc": {
                  "headline": "Gets the journal ``Id`` query terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.search.terms.IdTerm) - the query terms", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the query terms\n        :rtype: ``osid.search.terms.IdTerm``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.search.terms.IdTerm", 
               "errors": {}
            }, 
            {
               "name": "get_journal_terms", 
               "doc": {
                  "headline": "Gets the journal query terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.journaling.JournalQueryInspector) - the query\n                terms", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the query terms\n        :rtype: ``osid.journaling.JournalQueryInspector``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.journaling.JournalQueryInspector", 
               "errors": {}
            }, 
            {
               "name": "get_journal_entry_query_inspector_record", 
               "doc": {
                  "headline": "Gets the journal entry query inspector record corresponding to the given ``JournalEntry`` record ``Type``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    journal_entry_record_type (osid.type.Type): a journal\n                entry record type\n", 
               "return_doc": "        return:\n                (osid.journaling.records.JournalEntryQueryInspectorRecor\n                d) - the journal entry query inspector record", 
               "error_doc": "        raise:  NullArgument - ``journal_entry_record_type`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unsupported -\n                ``has_record_type(journal_entry_record_type)`` is\n                ``false``", 
               "sphinx_param_doc": "        :param journal_entry_record_type: a journal entry record type\n        :type journal_entry_record_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "        :return: the journal entry query inspector record\n        :rtype: ``osid.journaling.records.JournalEntryQueryInspectorRecord``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``journal_entry_record_type`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unsupported`` -- ``has_record_type(journal_entry_record_type)`` is ``false``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "journal_entry_record_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "osid.journaling.records.JournalEntryQueryInspectorRecord", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.journaling.records.JournalEntryQueryInspectorRecord", 
         "shortname": "JournalEntryQueryInspectorRecord", 
         "category": "records", 
         "doc": {
            "headline": "A record for a ``JournalEntryQueryInspector``.", 
            "body": "    The methods specified by the record type are available through the\n    underlying object."
         }, 
         "inherit_fullnames": [
            "osid.OsidRecord"
         ], 
         "inherit_shortnames": [
            "OsidRecord"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidRecord"
            }
         ], 
         "method_names": [], 
         "methods": []
      }, 
      {
         "fullname": "osid.journaling.JournalEntryForm", 
         "shortname": "JournalEntryForm", 
         "category": "objects", 
         "doc": {
            "headline": "This is the form for creating and updating ``JournalEntry`` objects.", 
            "body": "    Like all ``OsidForm`` objects, various data elements may be set here\n    for use in the create and update methods in the\n    ``JournalEntryAdminSession``. For each data element that may be set,\n    metadata may be examined to provide display hints or data\n    constraints."
         }, 
         "inherit_fullnames": [
            "osid.OsidObjectForm", 
            "osid.OsidSubjugateableForm"
         ], 
         "inherit_shortnames": [
            "OsidObjectForm", 
            "OsidSubjugateableForm"
         ], 
         "inherit_pkg_names": [
            "osid", 
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidObjectForm"
            }, 
            {
               "pkg_name": "osid", 
               "name": "OsidSubjugateableForm"
            }
         ], 
         "method_names": [
            "get_journal_entry_form_record"
         ], 
         "methods": [
            {
               "name": "get_journal_entry_form_record", 
               "doc": {
                  "headline": "Gets the ``JournalEntryFormRecord`` corresponding to the given journal entry record ``Type``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    journal_entry_record_type (osid.type.Type): the journal\n                entry record type\n", 
               "return_doc": "        return: (osid.journaling.records.JournalEntryFormRecord) - the\n                journal entry form record", 
               "error_doc": "        raise:  NullArgument - ``journal_entry_record_type`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unsupported -\n                ``has_record_type(journal_entry_record_type)`` is\n                ``false``", 
               "sphinx_param_doc": "        :param journal_entry_record_type: the journal entry record type\n        :type journal_entry_record_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "        :return: the journal entry form record\n        :rtype: ``osid.journaling.records.JournalEntryFormRecord``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``journal_entry_record_type`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unsupported`` -- ``has_record_type(journal_entry_record_type)`` is ``false``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "journal_entry_record_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "osid.journaling.records.JournalEntryFormRecord", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.journaling.records.JournalEntryFormRecord", 
         "shortname": "JournalEntryFormRecord", 
         "category": "records", 
         "doc": {
            "headline": "A record for a ``JournalEntryForm``.", 
            "body": "    The methods specified by the record type are available through the\n    underlying object."
         }, 
         "inherit_fullnames": [
            "osid.OsidRecord"
         ], 
         "inherit_shortnames": [
            "OsidRecord"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidRecord"
            }
         ], 
         "method_names": [], 
         "methods": []
      }, 
      {
         "fullname": "osid.journaling.JournalEntrySearchOrder", 
         "shortname": "JournalEntrySearchOrder", 
         "category": "search_orders", 
         "doc": {
            "headline": "An interface for specifying the ordering of search results.", 
            "body": ""
         }, 
         "inherit_fullnames": [
            "osid.OsidObjectSearchOrder", 
            "osid.OsidSubjugateableSearchOrder"
         ], 
         "inherit_shortnames": [
            "OsidObjectSearchOrder", 
            "OsidSubjugateableSearchOrder"
         ], 
         "inherit_pkg_names": [
            "osid", 
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidObjectSearchOrder"
            }, 
            {
               "pkg_name": "osid", 
               "name": "OsidSubjugateableSearchOrder"
            }
         ], 
         "method_names": [
            "order_by_branch", 
            "supports_branch_search_order", 
            "get_branch_search_order", 
            "order_by_source", 
            "order_by_timestamp", 
            "order_by_resource", 
            "supports_resource_search_order", 
            "get_resource_search_order", 
            "order_by_agent", 
            "supports_agent_search_order", 
            "get_agent_search_order", 
            "get_journal_entry_search_order_record"
         ], 
         "methods": [
            {
               "name": "order_by_branch", 
               "doc": {
                  "headline": "Specifies a preference for ordering the result set by the branch.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    style (osid.SearchOrderStyle): search order style\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``style`` is ``null``", 
               "sphinx_param_doc": "        :param style: search order style\n        :type style: ``osid.SearchOrderStyle``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``style`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.SearchOrderStyle", 
                     "var_name": "style", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.SearchOrderStyle"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "supports_branch_search_order", 
               "doc": {
                  "headline": "Tests if a branch search order is available.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if a branch order is available,\n                ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if a branch order is available, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "get_branch_search_order", 
               "doc": {
                  "headline": "Gets the branch search order.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.journaling.BranchSearchOrder) - the branch search\n                order", 
               "error_doc": "        raise:  Unimplemented - ``supports_branch_search_order()`` is\n                ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the branch search order\n        :rtype: ``osid.journaling.BranchSearchOrder``", 
               "sphinx_error_doc": "        :raise: ``Unimplemented`` -- ``supports_branch_search_order()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_branch_search_order()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.journaling.BranchSearchOrder", 
               "errors": {
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "order_by_source", 
               "doc": {
                  "headline": "Specifies a preference for ordering the result set by the source.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    style (osid.SearchOrderStyle): search order style\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``style`` is ``null``", 
               "sphinx_param_doc": "        :param style: search order style\n        :type style: ``osid.SearchOrderStyle``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``style`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.SearchOrderStyle", 
                     "var_name": "style", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.SearchOrderStyle"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "order_by_timestamp", 
               "doc": {
                  "headline": "Specifies a preference for ordering the result set by the timestamp.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    style (osid.SearchOrderStyle): search order style\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``style`` is ``null``", 
               "sphinx_param_doc": "        :param style: search order style\n        :type style: ``osid.SearchOrderStyle``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``style`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.SearchOrderStyle", 
                     "var_name": "style", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.SearchOrderStyle"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "order_by_resource", 
               "doc": {
                  "headline": "Specifies a preference for ordering the result set by the resource.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    style (osid.SearchOrderStyle): search order style\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``style`` is ``null``", 
               "sphinx_param_doc": "        :param style: search order style\n        :type style: ``osid.SearchOrderStyle``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``style`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.SearchOrderStyle", 
                     "var_name": "style", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.SearchOrderStyle"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "supports_resource_search_order", 
               "doc": {
                  "headline": "Tests if a resource order is available.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if a resource order is available,\n                ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if a resource order is available, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "get_resource_search_order", 
               "doc": {
                  "headline": "Gets the resource order.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.resource.ResourceSearchOrder) - the resource\n                search order", 
               "error_doc": "        raise:  Unimplemented - ``supports_resource_search_order()`` is\n                ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the resource search order\n        :rtype: ``osid.resource.ResourceSearchOrder``", 
               "sphinx_error_doc": "        :raise: ``Unimplemented`` -- ``supports_resource_search_order()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_agent_search_order()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.resource.ResourceSearchOrder", 
               "errors": {
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "order_by_agent", 
               "doc": {
                  "headline": "Specifies a preference for ordering the result set by the agent.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    style (osid.SearchOrderStyle): search order style\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``style`` is ``null``", 
               "sphinx_param_doc": "        :param style: search order style\n        :type style: ``osid.SearchOrderStyle``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``style`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.SearchOrderStyle", 
                     "var_name": "style", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.SearchOrderStyle"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "supports_agent_search_order", 
               "doc": {
                  "headline": "Tests if an agent order is available.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if an agent order is available,\n                ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if an agent order is available, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "get_agent_search_order", 
               "doc": {
                  "headline": "Gets the agent order.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.authentication.AgentSearchOrder) - the agent\n                search order", 
               "error_doc": "        raise:  Unimplemented - ``supports_agent_search_order()`` is\n                ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the agent search order\n        :rtype: ``osid.authentication.AgentSearchOrder``", 
               "sphinx_error_doc": "        :raise: ``Unimplemented`` -- ``supports_agent_search_order()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_agent_search_order()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.authentication.AgentSearchOrder", 
               "errors": {
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_journal_entry_search_order_record", 
               "doc": {
                  "headline": "Gets the journal entry search order record corresponding to the given journal entry record ``Type``.", 
                  "body": "        Multiple retrievals return the same underlying object."
               }, 
               "arg_doc": "        arg:    journal_entry_record_type (osid.type.Type): a journal\n                entry record type\n", 
               "return_doc": "        return: (osid.journaling.records.JournalEntrySearchOrderRecord)\n                - the journal entry search order record", 
               "error_doc": "        raise:  NullArgument - ``journal_entry_record_type`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unsupported -\n                ``has_record_type(journal_entry_record_type)`` is\n                ``false``", 
               "sphinx_param_doc": "        :param journal_entry_record_type: a journal entry record type\n        :type journal_entry_record_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "        :return: the journal entry search order record\n        :rtype: ``osid.journaling.records.JournalEntrySearchOrderRecord``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``journal_entry_record_type`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unsupported`` -- ``has_record_type(journal_entry_record_type)`` is ``false``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "journal_entry_record_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "osid.journaling.records.JournalEntrySearchOrderRecord", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.journaling.records.JournalEntrySearchOrderRecord", 
         "shortname": "JournalEntrySearchOrderRecord", 
         "category": "records", 
         "doc": {
            "headline": "A record for a ``JournalEntrySearchOrder``.", 
            "body": "    The methods specified by the record type are available through the\n    underlying object."
         }, 
         "inherit_fullnames": [
            "osid.OsidRecord"
         ], 
         "inherit_shortnames": [
            "OsidRecord"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidRecord"
            }
         ], 
         "method_names": [], 
         "methods": []
      }, 
      {
         "fullname": "osid.journaling.JournalEntrySearch", 
         "shortname": "JournalEntrySearch", 
         "category": "searches", 
         "doc": {
            "headline": "The search interface for governing journal entry searches.", 
            "body": ""
         }, 
         "inherit_fullnames": [
            "osid.OsidSearch"
         ], 
         "inherit_shortnames": [
            "OsidSearch"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidSearch"
            }
         ], 
         "method_names": [
            "search_among_journal_entries", 
            "order_journal_entry_results", 
            "get_journal_entry_search_record"
         ], 
         "methods": [
            {
               "name": "search_among_journal_entries", 
               "doc": {
                  "headline": "Execute this search among the given list of journal entries.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    journal_entry_ids (osid.id.IdList): list of journal\n                entries\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``journal_entry_ids`` is ``null``", 
               "sphinx_param_doc": "        :param journal_entry_ids: list of journal entries\n        :type journal_entry_ids: ``osid.id.IdList``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``journal_entry_ids`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.IdList", 
                     "var_name": "journal_entry_ids", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.IdList"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "order_journal_entry_results", 
               "doc": {
                  "headline": "Specify an ordering to the search results.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    journal_entry_search_order\n                (osid.journaling.JournalEntrySearchOrder): journal entry\n                search order\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``journal_entry_search_order`` is\n                ``null``\n        raise:  Unsupported - ``journal_entry_search_order`` is not of\n                this service", 
               "sphinx_param_doc": "        :param journal_entry_search_order: journal entry search order\n        :type journal_entry_search_order: ``osid.journaling.JournalEntrySearchOrder``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``journal_entry_search_order`` is ``null``\n        :raise: ``Unsupported`` -- ``journal_entry_search_order`` is not of this service", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.journaling.JournalEntrySearchOrder", 
                     "var_name": "journal_entry_search_order", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.journaling.JournalEntrySearchOrder"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_journal_entry_search_record", 
               "doc": {
                  "headline": "Gets the journal entry search record corresponding to the given journal entry search record ``Type``.", 
                  "body": "        This method is used to retrieve an object implementing the\n        requested record."
               }, 
               "arg_doc": "        arg:    journal_entry_search_record_type (osid.type.Type): a\n                journal entry search record type\n", 
               "return_doc": "        return: (osid.journaling.records.JournalEntrySearchRecord) - the\n                journal entry search record", 
               "error_doc": "        raise:  NullArgument - ``journal_entry_search_record_type`` is\n                ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unsupported -\n                ``has_record_type(journal_entry_search_record_type)`` is\n                ``false``", 
               "sphinx_param_doc": "        :param journal_entry_search_record_type: a journal entry search record type\n        :type journal_entry_search_record_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "        :return: the journal entry search record\n        :rtype: ``osid.journaling.records.JournalEntrySearchRecord``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``journal_entry_search_record_type`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unsupported`` -- ``has_record_type(journal_entry_search_record_type)`` is ``false``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "journal_entry_search_record_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "osid.journaling.records.JournalEntrySearchRecord", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.journaling.records.JournalEntrySearchRecord", 
         "shortname": "JournalEntrySearchRecord", 
         "category": "records", 
         "doc": {
            "headline": "A record for a ``JournalEntrySearch``.", 
            "body": "    The methods specified by the record type are available through the\n    underlying object."
         }, 
         "inherit_fullnames": [
            "osid.OsidRecord"
         ], 
         "inherit_shortnames": [
            "OsidRecord"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidRecord"
            }
         ], 
         "method_names": [], 
         "methods": []
      }, 
      {
         "fullname": "osid.journaling.JournalEntrySearchResults", 
         "shortname": "JournalEntrySearchResults", 
         "category": "searches", 
         "doc": {
            "headline": "This interface provides a means to capture results of a search.", 
            "body": ""
         }, 
         "inherit_fullnames": [
            "osid.OsidSearchResults"
         ], 
         "inherit_shortnames": [
            "OsidSearchResults"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidSearchResults"
            }
         ], 
         "method_names": [
            "get_journal_entries", 
            "get_journal_entry_query_inspector", 
            "get_journal_entry_search_results_record"
         ], 
         "methods": [
            {
               "name": "get_journal_entries", 
               "doc": {
                  "headline": "Gets the journal entry list resulting from a search.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.journaling.JournalEntryList) - the journal entry\n                list", 
               "error_doc": "        raise:  IllegalState - list already retrieved", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the journal entry list\n        :rtype: ``osid.journaling.JournalEntryList``", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- list already retrieved", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.journaling.JournalEntryList", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract"
               }
            }, 
            {
               "name": "get_journal_entry_query_inspector", 
               "doc": {
                  "headline": "Gets the inspector for the query to examine the terms used in the search.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.journaling.JournalEntryQueryInspector) - the\n                journal entry query inspector", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the journal entry query inspector\n        :rtype: ``osid.journaling.JournalEntryQueryInspector``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.journaling.JournalEntryQueryInspector", 
               "errors": {}
            }, 
            {
               "name": "get_journal_entry_search_results_record", 
               "doc": {
                  "headline": "Gets the journal entry search results record corresponding to the given journal entry search record ``Type``.", 
                  "body": "        This method is used to retrieve an object implementing the\n        requested record."
               }, 
               "arg_doc": "        arg:    journal_entry_search_record_type (osid.type.Type): a\n                journal entry search record type\n", 
               "return_doc": "        return:\n                (osid.journaling.records.JournalEntrySearchResultsRecord\n                ) - the journal entry search results record", 
               "error_doc": "        raise:  NullArgument - ``journal_entry_search_record_type`` is\n                ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unsupported -\n                ``has_record_type(journal_entry_search_record_type)`` is\n                ``false``", 
               "sphinx_param_doc": "        :param journal_entry_search_record_type: a journal entry search record type\n        :type journal_entry_search_record_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "        :return: the journal entry search results record\n        :rtype: ``osid.journaling.records.JournalEntrySearchResultsRecord``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``journal_entry_search_record_type`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unsupported`` -- ``has_record_type(journal_entry_search_record_type)`` is ``false``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "journal_entry_search_record_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "osid.journaling.records.JournalEntrySearchResultsRecord", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.journaling.records.JournalEntrySearchResultsRecord", 
         "shortname": "JournalEntrySearchResultsRecord", 
         "category": "records", 
         "doc": {
            "headline": "A record for a ``JournalEntrySearchResults``.", 
            "body": "    The methods specified by the record type are available through the\n    underlying object."
         }, 
         "inherit_fullnames": [
            "osid.OsidRecord"
         ], 
         "inherit_shortnames": [
            "OsidRecord"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidRecord"
            }
         ], 
         "method_names": [], 
         "methods": []
      }, 
      {
         "fullname": "osid.journaling.JournalEntryReceiver", 
         "shortname": "JournalEntryReceiver", 
         "category": "receivers", 
         "doc": {
            "headline": "The journal entry receiver is the consumer supplied interface for receiving notifications pertaining to new or deleted journal entries.", 
            "body": ""
         }, 
         "inherit_fullnames": [
            "osid.OsidReceiver"
         ], 
         "inherit_shortnames": [
            "OsidReceiver"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidReceiver"
            }
         ], 
         "method_names": [
            "new_journal_entry", 
            "changed_journal_entry", 
            "deleted_journal_entry"
         ], 
         "methods": [
            {
               "name": "new_journal_entry", 
               "doc": {
                  "headline": "The callback for notifications of new journal entries.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    journal_entry_id (osid.id.Id): the ``Id`` of the new\n                journal entry\n", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "        :param journal_entry_id: the ``Id`` of the new journal entry\n        :type journal_entry_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "journal_entry_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "changed_journal_entry", 
               "doc": {
                  "headline": "The callback for notifications of updated journal entries.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    journal_entry_id (osid.id.Id): the ``Id`` of the updated\n                journal entry\n", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "        :param journal_entry_id: the ``Id`` of the updated journal entry\n        :type journal_entry_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "journal_entry_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "deleted_journal_entry", 
               "doc": {
                  "headline": "the callback for notification of deleted journal entries.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    journal_entry_id (osid.id.Id): the ``Id`` of the deleted\n                journal entry\n", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "        :param journal_entry_id: the ``Id`` of the deleted journal entry\n        :type journal_entry_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "journal_entry_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {}
            }
         ]
      }, 
      {
         "fullname": "osid.journaling.JournalEntryList", 
         "shortname": "JournalEntryList", 
         "category": "objects", 
         "doc": {
            "headline": "Like all ``OsidLists,``  ``JournalEntryList`` provides a means for accessing ``JournalEntry`` elements sequentially either one at a time or many at a time.", 
            "body": "    Examples: while (jel.hasNext()) { JournalEntry entry =\n    jel.getNextJournalEntry(); }\n\n    or\n      while (jel.hasNext()) {\n           JournalEntry[] entries = jel.getNextJournalEntries(jel.available());\n      }\n    \n"
         }, 
         "inherit_fullnames": [
            "osid.OsidList"
         ], 
         "inherit_shortnames": [
            "OsidList"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidList"
            }
         ], 
         "method_names": [
            "get_next_journal_entry", 
            "get_next_journal_entries"
         ], 
         "methods": [
            {
               "name": "get_next_journal_entry", 
               "doc": {
                  "headline": "Gets the next ``JournalEntry`` in this list.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.journaling.JournalEntry) - the next\n                ``JournalEntry`` in this list. The ``has_next()`` method\n                should be used to test that a next ``JournalEntry`` is\n                available before calling this method.", 
               "error_doc": "        raise:  IllegalState - no more elements available in this list\n        raise:  OperationFailed - unable to complete request", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the next ``JournalEntry`` in this list. The ``has_next()`` method should be used to test that a next ``JournalEntry`` is available before calling this method.\n        :rtype: ``osid.journaling.JournalEntry``", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- no more elements available in this list\n        :raise: ``OperationFailed`` -- unable to complete request", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.journaling.JournalEntry", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational"
               }
            }, 
            {
               "name": "get_next_journal_entries", 
               "doc": {
                  "headline": "Gets the next set of ``JournalEntry`` elements in this list.", 
                  "body": "        The specified amount must be less than or equal to the return\n        from ``available()``."
               }, 
               "arg_doc": "        arg:    n (cardinal): the number of ``JournalEntry`` elements\n                requested which must be less than or equal to\n                ``available()``\n", 
               "return_doc": "        return: (osid.journaling.JournalEntry) - an array of\n                ``JournalEntry`` elements.The length of the array is\n                less than or equal to the number specified.", 
               "error_doc": "        raise:  IllegalState - no more elements available in this list\n        raise:  OperationFailed - unable to complete request", 
               "sphinx_param_doc": "        :param n: the number of ``JournalEntry`` elements requested which must be less than or equal to ``available()``\n        :type n: ``cardinal``\n", 
               "sphinx_return_doc": "        :return: an array of ``JournalEntry`` elements.The length of the array is less than or equal to the number specified.\n        :rtype: ``osid.journaling.JournalEntry``", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- no more elements available in this list\n        :raise: ``OperationFailed`` -- unable to complete request", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "cardinal", 
                     "var_name": "n", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "cardinal"
               ], 
               "return_type": "osid.journaling.JournalEntry", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.journaling.Branch", 
         "shortname": "Branch", 
         "category": "objects", 
         "doc": {
            "headline": "A ``Branch`` is a new version chain from an existing version chain.", 
            "body": ""
         }, 
         "inherit_fullnames": [
            "osid.OsidObject", 
            "osid.Operable"
         ], 
         "inherit_shortnames": [
            "OsidObject", 
            "Operable"
         ], 
         "inherit_pkg_names": [
            "osid", 
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidObject"
            }, 
            {
               "pkg_name": "osid", 
               "name": "Operable"
            }
         ], 
         "method_names": [
            "get_origin_journal_entry_id", 
            "get_origin_journal_entry", 
            "get_latest_journal_entry_id", 
            "get_latest_journal_entry", 
            "get_branch_record"
         ], 
         "methods": [
            {
               "name": "get_origin_journal_entry_id", 
               "doc": {
                  "headline": "Gets the journal entry ``Id`` from which this branch was started.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.id.Id) - the journal entry ``Id``", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the journal entry ``Id``\n        :rtype: ``osid.id.Id``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.id.Id", 
               "errors": {}
            }, 
            {
               "name": "get_origin_journal_entry", 
               "doc": {
                  "headline": "Gets the journal entry from which this branch was started.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.journaling.JournalEntry) - the journal entry", 
               "error_doc": "        raise:  OperationFailed - unable to complete request", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the journal entry\n        :rtype: ``osid.journaling.JournalEntry``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.journaling.JournalEntry", 
               "errors": {
                  "OPERATION_FAILED": "Operational"
               }
            }, 
            {
               "name": "get_latest_journal_entry_id", 
               "doc": {
                  "headline": "Gets the latest journal entry ``Id`` in this branch.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.id.Id) - the journal entry ``Id``", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the journal entry ``Id``\n        :rtype: ``osid.id.Id``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.id.Id", 
               "errors": {}
            }, 
            {
               "name": "get_latest_journal_entry", 
               "doc": {
                  "headline": "Gets the latest journal entry in this branch.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.journaling.JournalEntry) - the journal entry", 
               "error_doc": "        raise:  OperationFailed - unable to complete request", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the journal entry\n        :rtype: ``osid.journaling.JournalEntry``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.journaling.JournalEntry", 
               "errors": {
                  "OPERATION_FAILED": "Operational"
               }
            }, 
            {
               "name": "get_branch_record", 
               "doc": {
                  "headline": "Gets the branch record corresponding to the given ``Pollstem`` record ``Type``.", 
                  "body": "        This method is used to retrieve an object implementing the\n        requested record. The ``branch_record_type`` may be the ``Type``\n        returned in ``get_record_types()`` or any of its parents in a\n        ``Type`` hierarchy where ``has_record_type(branch_record_type)``\n        is ``true`` ."
               }, 
               "arg_doc": "        arg:    branch_record_type (osid.type.Type): the branch record\n                type\n", 
               "return_doc": "        return: (osid.journaling.records.BranchRecord) - the branch\n                record", 
               "error_doc": "        raise:  NullArgument - ``branch_record_type`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unsupported - ``has_record_type(branch_record_type)`` is\n                ``false``", 
               "sphinx_param_doc": "        :param branch_record_type: the branch record type\n        :type branch_record_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "        :return: the branch record\n        :rtype: ``osid.journaling.records.BranchRecord``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``branch_record_type`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unsupported`` -- ``has_record_type(branch_record_type)`` is ``false``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "branch_record_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "osid.journaling.records.BranchRecord", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.journaling.records.BranchRecord", 
         "shortname": "BranchRecord", 
         "category": "records", 
         "doc": {
            "headline": "A record for a ``Branch``.", 
            "body": "    The methods specified by the record type are available through the\n    underlying object."
         }, 
         "inherit_fullnames": [
            "osid.OsidRecord"
         ], 
         "inherit_shortnames": [
            "OsidRecord"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidRecord"
            }
         ], 
         "method_names": [], 
         "methods": []
      }, 
      {
         "fullname": "osid.journaling.BranchQuery", 
         "shortname": "BranchQuery", 
         "category": "queries", 
         "doc": {
            "headline": "This is the query for searching branches Each method specifies an ``AND`` term while multiple invocations of the same method produce a nested ``OR``.", 
            "body": ""
         }, 
         "inherit_fullnames": [
            "osid.OsidObjectQuery", 
            "osid.OsidOperableQuery"
         ], 
         "inherit_shortnames": [
            "OsidObjectQuery", 
            "OsidOperableQuery"
         ], 
         "inherit_pkg_names": [
            "osid", 
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidObjectQuery"
            }, 
            {
               "pkg_name": "osid", 
               "name": "OsidOperableQuery"
            }
         ], 
         "method_names": [
            "match_origin_journal_entry_id", 
            "clear_origin_journal_entry_id_terms", 
            "supports_origin_journal_entry_query", 
            "get_origin_journal_entry_query", 
            "clear_origin_journal_entry_terms", 
            "match_latest_journal_entry_id", 
            "clear_latest_journal_entry_id_terms", 
            "supports_latest_journal_entry_query", 
            "get_latest_journal_entry_query", 
            "clear_latest_journal_entry_terms", 
            "get_branch_query_record"
         ], 
         "methods": [
            {
               "name": "match_origin_journal_entry_id", 
               "doc": {
                  "headline": "Sets the origin journal entry ``Id`` for this query.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    journal_entry_id (osid.id.Id): a journal entry Id ``Id``\n        arg:    match (boolean): ``true`` for a positive match,\n                ``false`` for a negative match\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``journal_entry_id`` is ``null``", 
               "sphinx_param_doc": "        :param journal_entry_id: a journal entry Id ``Id``\n        :type journal_entry_id: ``osid.id.Id``\n        :param match: ``true`` for a positive match, ``false`` for a negative match\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``journal_entry_id`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "journal_entry_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "clear_origin_journal_entry_id_terms", 
               "doc": {
                  "headline": "Clears the origin journal entry ``Id`` terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "supports_origin_journal_entry_query", 
               "doc": {
                  "headline": "Tests if a ``JournalEntryQuery`` is available.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if a journal entry query is\n                available, ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if a journal entry query is available, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "get_origin_journal_entry_query", 
               "doc": {
                  "headline": "Gets the query for an origin journal entry.", 
                  "body": "        Multiple retrievals produce a nested ``OR`` term."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.journaling.JournalEntryQuery) - the origin journal\n                entry query", 
               "error_doc": "        raise:  Unimplemented -\n                ``supports_origin_journal_entry_query()`` is ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the origin journal entry query\n        :rtype: ``osid.journaling.JournalEntryQuery``", 
               "sphinx_error_doc": "        :raise: ``Unimplemented`` -- ``supports_origin_journal_entry_query()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_origin_journal_entry_query()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.journaling.JournalEntryQuery", 
               "errors": {
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "clear_origin_journal_entry_terms", 
               "doc": {
                  "headline": "Clears the origin journal entry terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "match_latest_journal_entry_id", 
               "doc": {
                  "headline": "Sets the latest journal entry ``Id`` for this query.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    journal_entry_id (osid.id.Id): a journal entry Id ``Id``\n        arg:    match (boolean): ``true`` for a positive match,\n                ``false`` for a negative match\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``journal_entry_id`` is ``null``", 
               "sphinx_param_doc": "        :param journal_entry_id: a journal entry Id ``Id``\n        :type journal_entry_id: ``osid.id.Id``\n        :param match: ``true`` for a positive match, ``false`` for a negative match\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``journal_entry_id`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "journal_entry_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "clear_latest_journal_entry_id_terms", 
               "doc": {
                  "headline": "Clears the latest journal entry ``Id`` terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "supports_latest_journal_entry_query", 
               "doc": {
                  "headline": "Tests if a ``JournalEntryQuery`` is available.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if a journal entry query is\n                available, ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if a journal entry query is available, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "get_latest_journal_entry_query", 
               "doc": {
                  "headline": "Gets the query for a latest journal entry.", 
                  "body": "        Multiple retrievals produce a nested ``OR`` term."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.journaling.JournalEntryQuery) - the latest journal\n                entry query", 
               "error_doc": "        raise:  Unimplemented -\n                ``supports_origin_journal_entry_query()`` is ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the latest journal entry query\n        :rtype: ``osid.journaling.JournalEntryQuery``", 
               "sphinx_error_doc": "        :raise: ``Unimplemented`` -- ``supports_origin_journal_entry_query()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_origin_journal_entry_query()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.journaling.JournalEntryQuery", 
               "errors": {
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "clear_latest_journal_entry_terms", 
               "doc": {
                  "headline": "Clears the latest journal entry terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "get_branch_query_record", 
               "doc": {
                  "headline": "Gets the branch query record corresponding to the given ``Branch`` record ``Type``.", 
                  "body": "        Multiple retrievals produce a nested ``OR`` term."
               }, 
               "arg_doc": "        arg:    branch_record_type (osid.type.Type): a branch record\n                type\n", 
               "return_doc": "        return: (osid.journaling.records.BranchQueryRecord) - the branch\n                query record", 
               "error_doc": "        raise:  NullArgument - ``branch_record_type`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unsupported - ``has_record_type(branch_record_type)`` is\n                ``false``", 
               "sphinx_param_doc": "        :param branch_record_type: a branch record type\n        :type branch_record_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "        :return: the branch query record\n        :rtype: ``osid.journaling.records.BranchQueryRecord``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``branch_record_type`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unsupported`` -- ``has_record_type(branch_record_type)`` is ``false``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "branch_record_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "osid.journaling.records.BranchQueryRecord", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.journaling.records.BranchQueryRecord", 
         "shortname": "BranchQueryRecord", 
         "category": "records", 
         "doc": {
            "headline": "A record for a ``BranchQuery``.", 
            "body": "    The methods specified by the record type are available through the\n    underlying object."
         }, 
         "inherit_fullnames": [
            "osid.OsidRecord"
         ], 
         "inherit_shortnames": [
            "OsidRecord"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidRecord"
            }
         ], 
         "method_names": [], 
         "methods": []
      }, 
      {
         "fullname": "osid.journaling.BranchQueryInspector", 
         "shortname": "BranchQueryInspector", 
         "category": "query_inspectors", 
         "doc": {
            "headline": "This is the query inspector for examining branch queries.", 
            "body": ""
         }, 
         "inherit_fullnames": [
            "osid.OsidObjectQueryInspector", 
            "osid.OsidOperableQueryInspector"
         ], 
         "inherit_shortnames": [
            "OsidObjectQueryInspector", 
            "OsidOperableQueryInspector"
         ], 
         "inherit_pkg_names": [
            "osid", 
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidObjectQueryInspector"
            }, 
            {
               "pkg_name": "osid", 
               "name": "OsidOperableQueryInspector"
            }
         ], 
         "method_names": [
            "get_origin_journal_entry_id_terms", 
            "get_origin_journal_entry_terms", 
            "get_latest_journal_entry_id_terms", 
            "get_latest_journal_entry_terms", 
            "get_branch_query_inspector_record"
         ], 
         "methods": [
            {
               "name": "get_origin_journal_entry_id_terms", 
               "doc": {
                  "headline": "Gets the origin journal entry ``Id`` query terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.search.terms.IdTerm) - the query terms", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the query terms\n        :rtype: ``osid.search.terms.IdTerm``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.search.terms.IdTerm", 
               "errors": {}
            }, 
            {
               "name": "get_origin_journal_entry_terms", 
               "doc": {
                  "headline": "Gets the origin journal entry query terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.journaling.JournalEntryQueryInspector) - the query\n                terms", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the query terms\n        :rtype: ``osid.journaling.JournalEntryQueryInspector``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.journaling.JournalEntryQueryInspector", 
               "errors": {}
            }, 
            {
               "name": "get_latest_journal_entry_id_terms", 
               "doc": {
                  "headline": "Gets the latest journal entry ``Id`` query terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.search.terms.IdTerm) - the query terms", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the query terms\n        :rtype: ``osid.search.terms.IdTerm``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.search.terms.IdTerm", 
               "errors": {}
            }, 
            {
               "name": "get_latest_journal_entry_terms", 
               "doc": {
                  "headline": "Gets the latest journal entry query terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.journaling.JournalEntryQueryInspector) - the query\n                terms", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the query terms\n        :rtype: ``osid.journaling.JournalEntryQueryInspector``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.journaling.JournalEntryQueryInspector", 
               "errors": {}
            }, 
            {
               "name": "get_branch_query_inspector_record", 
               "doc": {
                  "headline": "Gets the branch query inspector record corresponding to the given ``Branch`` record ``Type``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    branch_record_type (osid.type.Type): a branch record\n                type\n", 
               "return_doc": "        return: (osid.journaling.records.BranchQueryInspectorRecord) -\n                the branch query inspector record", 
               "error_doc": "        raise:  NullArgument - ``branch_record_type`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unsupported - ``has_record_type(branch_record_type)`` is\n                ``false``", 
               "sphinx_param_doc": "        :param branch_record_type: a branch record type\n        :type branch_record_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "        :return: the branch query inspector record\n        :rtype: ``osid.journaling.records.BranchQueryInspectorRecord``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``branch_record_type`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unsupported`` -- ``has_record_type(branch_record_type)`` is ``false``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "branch_record_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "osid.journaling.records.BranchQueryInspectorRecord", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.journaling.records.BranchQueryInspectorRecord", 
         "shortname": "BranchQueryInspectorRecord", 
         "category": "records", 
         "doc": {
            "headline": "A record for a ``BranchQueryInspector``.", 
            "body": "    The methods specified by the record type are available through the\n    underlying object."
         }, 
         "inherit_fullnames": [
            "osid.OsidRecord"
         ], 
         "inherit_shortnames": [
            "OsidRecord"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidRecord"
            }
         ], 
         "method_names": [], 
         "methods": []
      }, 
      {
         "fullname": "osid.journaling.BranchForm", 
         "shortname": "BranchForm", 
         "category": "objects", 
         "doc": {
            "headline": "This is the form for creating and updating branchesLike all ``OsidForm`` objects, various data elements may be set here for use in the create and update methods in the ``BranchAdminSession``.", 
            "body": "    For each data element that may be set, metadata may be examined to\n    provide display hints or data constraints."
         }, 
         "inherit_fullnames": [
            "osid.OsidObjectForm", 
            "osid.OsidOperableForm"
         ], 
         "inherit_shortnames": [
            "OsidObjectForm", 
            "OsidOperableForm"
         ], 
         "inherit_pkg_names": [
            "osid", 
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidObjectForm"
            }, 
            {
               "pkg_name": "osid", 
               "name": "OsidOperableForm"
            }
         ], 
         "method_names": [
            "get_branch_form_record"
         ], 
         "methods": [
            {
               "name": "get_branch_form_record", 
               "doc": {
                  "headline": "Gets the ``BranchFormRecord`` corresponding to the given branch record ``Type``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    branch_record_type (osid.type.Type): the branch record\n                type\n", 
               "return_doc": "        return: (osid.journaling.records.BranchFormRecord) - the branch\n                form record", 
               "error_doc": "        raise:  NullArgument - ``branch_record_type`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unsupported - ``has_record_type(branch_record_type)`` is\n                ``false``", 
               "sphinx_param_doc": "        :param branch_record_type: the branch record type\n        :type branch_record_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "        :return: the branch form record\n        :rtype: ``osid.journaling.records.BranchFormRecord``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``branch_record_type`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unsupported`` -- ``has_record_type(branch_record_type)`` is ``false``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "branch_record_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "osid.journaling.records.BranchFormRecord", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.journaling.records.BranchFormRecord", 
         "shortname": "BranchFormRecord", 
         "category": "records", 
         "doc": {
            "headline": "A record for a ``BranchForm``.", 
            "body": "    The methods specified by the record type are available through the\n    underlying object."
         }, 
         "inherit_fullnames": [
            "osid.OsidRecord"
         ], 
         "inherit_shortnames": [
            "OsidRecord"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidRecord"
            }
         ], 
         "method_names": [], 
         "methods": []
      }, 
      {
         "fullname": "osid.journaling.BranchSearchOrder", 
         "shortname": "BranchSearchOrder", 
         "category": "search_orders", 
         "doc": {
            "headline": "An interface for specifying the ordering of search results.", 
            "body": ""
         }, 
         "inherit_fullnames": [
            "osid.OsidObjectSearchOrder", 
            "osid.OsidOperableSearchOrder"
         ], 
         "inherit_shortnames": [
            "OsidObjectSearchOrder", 
            "OsidOperableSearchOrder"
         ], 
         "inherit_pkg_names": [
            "osid", 
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidObjectSearchOrder"
            }, 
            {
               "pkg_name": "osid", 
               "name": "OsidOperableSearchOrder"
            }
         ], 
         "method_names": [
            "order_by_origin_journal_entry", 
            "supports_origin_journal_entry_search_order", 
            "get_origin_journal_entry_search_order", 
            "order_by_latest_journal_entry", 
            "supports_latest_journal_entry_search_order", 
            "get_latest_journal_entry_search_order", 
            "get_branch_search_order_record"
         ], 
         "methods": [
            {
               "name": "order_by_origin_journal_entry", 
               "doc": {
                  "headline": "Specified a preference for ordering results by the origin journal entry.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    style (osid.SearchOrderStyle): search order style\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``style`` is ``null``", 
               "sphinx_param_doc": "        :param style: search order style\n        :type style: ``osid.SearchOrderStyle``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``style`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.SearchOrderStyle", 
                     "var_name": "style", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.SearchOrderStyle"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "supports_origin_journal_entry_search_order", 
               "doc": {
                  "headline": "Tests if a ``JournalEntrySearchOrder`` is available.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if a journal entry search order is\n                available, ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if a journal entry search order is available, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "get_origin_journal_entry_search_order", 
               "doc": {
                  "headline": "Gets the search order for the origin journal entry.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.journaling.JournalEntrySearchOrder) - the journal\n                entry search order", 
               "error_doc": "        raise:  Unimplemented -\n                ``supports_origin_journal_entry_search_order()`` is\n                ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the journal entry search order\n        :rtype: ``osid.journaling.JournalEntrySearchOrder``", 
               "sphinx_error_doc": "        :raise: ``Unimplemented`` -- ``supports_origin_journal_entry_search_order()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_origin_journal_entry_search_order()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.journaling.JournalEntrySearchOrder", 
               "errors": {
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "order_by_latest_journal_entry", 
               "doc": {
                  "headline": "Specified a preference for ordering results by the latest journal entry.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    style (osid.SearchOrderStyle): search order style\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``style`` is ``null``", 
               "sphinx_param_doc": "        :param style: search order style\n        :type style: ``osid.SearchOrderStyle``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``style`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.SearchOrderStyle", 
                     "var_name": "style", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.SearchOrderStyle"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "supports_latest_journal_entry_search_order", 
               "doc": {
                  "headline": "Tests if a ``JournalEntrySearchOrder`` is available.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if a journal entry search order is\n                available, ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if a journal entry search order is available, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "get_latest_journal_entry_search_order", 
               "doc": {
                  "headline": "Gets the search order for the latest journal entry.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.journaling.JournalEntrySearchOrder) - the journal\n                entry search order", 
               "error_doc": "        raise:  Unimplemented -\n                ``supports_latest_journal_entry_search_order()`` is\n                ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the journal entry search order\n        :rtype: ``osid.journaling.JournalEntrySearchOrder``", 
               "sphinx_error_doc": "        :raise: ``Unimplemented`` -- ``supports_latest_journal_entry_search_order()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_latest_journal_entry_search_order()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.journaling.JournalEntrySearchOrder", 
               "errors": {
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_branch_search_order_record", 
               "doc": {
                  "headline": "Gets the branch search order record corresponding to the given branch record ``Type``.", 
                  "body": "        Multiple retrievals return the same underlying object."
               }, 
               "arg_doc": "        arg:    branch_record_type (osid.type.Type): a branch record\n                type\n", 
               "return_doc": "        return: (osid.journaling.records.BranchSearchOrderRecord) - the\n                branch search order record", 
               "error_doc": "        raise:  NullArgument - ``branch_record_type`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unsupported - ``has_record_type(branch_record_type)`` is\n                ``false``", 
               "sphinx_param_doc": "        :param branch_record_type: a branch record type\n        :type branch_record_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "        :return: the branch search order record\n        :rtype: ``osid.journaling.records.BranchSearchOrderRecord``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``branch_record_type`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unsupported`` -- ``has_record_type(branch_record_type)`` is ``false``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "branch_record_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "osid.journaling.records.BranchSearchOrderRecord", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.journaling.records.BranchSearchOrderRecord", 
         "shortname": "BranchSearchOrderRecord", 
         "category": "records", 
         "doc": {
            "headline": "A record for a ``BranchSearchOrder``.", 
            "body": "    The methods specified by the record type are available through the\n    underlying object."
         }, 
         "inherit_fullnames": [
            "osid.OsidRecord"
         ], 
         "inherit_shortnames": [
            "OsidRecord"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidRecord"
            }
         ], 
         "method_names": [], 
         "methods": []
      }, 
      {
         "fullname": "osid.journaling.BranchSearch", 
         "shortname": "BranchSearch", 
         "category": "searches", 
         "doc": {
            "headline": "The search interface for governing branch searches.", 
            "body": ""
         }, 
         "inherit_fullnames": [
            "osid.OsidSearch"
         ], 
         "inherit_shortnames": [
            "OsidSearch"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidSearch"
            }
         ], 
         "method_names": [
            "search_among_branches", 
            "order_branch_results", 
            "get_branch_search_record"
         ], 
         "methods": [
            {
               "name": "search_among_branches", 
               "doc": {
                  "headline": "Execute this search among the given list of branches.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    branch_ids (osid.id.IdList): list of branch ``Ids``\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``branch_ids`` is ``null``", 
               "sphinx_param_doc": "        :param branch_ids: list of branch ``Ids``\n        :type branch_ids: ``osid.id.IdList``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``branch_ids`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.IdList", 
                     "var_name": "branch_ids", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.IdList"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "order_branch_results", 
               "doc": {
                  "headline": "Specify an ordering to the search results.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    branch_search_order (osid.journaling.BranchSearchOrder):\n                branch search order\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``order`` is ``null``\n        raise:  Unsupported - ``order`` is not of this service", 
               "sphinx_param_doc": "        :param branch_search_order: branch search order\n        :type branch_search_order: ``osid.journaling.BranchSearchOrder``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``order`` is ``null``\n        :raise: ``Unsupported`` -- ``order`` is not of this service", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.journaling.BranchSearchOrder", 
                     "var_name": "branch_search_order", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.journaling.BranchSearchOrder"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_branch_search_record", 
               "doc": {
                  "headline": "Gets the branch search record corresponding to the given branch search record ``Type``.", 
                  "body": "        This method is used to retrieve an object implementing the\n        requested record."
               }, 
               "arg_doc": "        arg:    branch_search_record_type (osid.type.Type): a branch\n                search record type\n", 
               "return_doc": "        return: (osid.journaling.records.BranchSearchRecord) - the\n                branch search record", 
               "error_doc": "        raise:  NullArgument - ``branch_search_record_type`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unsupported -\n                ``has_record_type_type(branch_search_record_type)`` is\n                ``false``", 
               "sphinx_param_doc": "        :param branch_search_record_type: a branch search record type\n        :type branch_search_record_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "        :return: the branch search record\n        :rtype: ``osid.journaling.records.BranchSearchRecord``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``branch_search_record_type`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unsupported`` -- ``has_record_type_type(branch_search_record_type)`` is ``false``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "branch_search_record_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "osid.journaling.records.BranchSearchRecord", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.journaling.records.BranchSearchRecord", 
         "shortname": "BranchSearchRecord", 
         "category": "records", 
         "doc": {
            "headline": "A record for a ``BranchSearch``.", 
            "body": "    The methods specified by the record type are available through the\n    underlying object."
         }, 
         "inherit_fullnames": [
            "osid.OsidRecord"
         ], 
         "inherit_shortnames": [
            "OsidRecord"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidRecord"
            }
         ], 
         "method_names": [], 
         "methods": []
      }, 
      {
         "fullname": "osid.journaling.BranchSearchResults", 
         "shortname": "BranchSearchResults", 
         "category": "searches", 
         "doc": {
            "headline": "This interface provides a means to capture results of a search.", 
            "body": ""
         }, 
         "inherit_fullnames": [
            "osid.OsidSearchResults"
         ], 
         "inherit_shortnames": [
            "OsidSearchResults"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidSearchResults"
            }
         ], 
         "method_names": [
            "get_branches", 
            "get_branch_query_inspector", 
            "get_branch_search_results_record"
         ], 
         "methods": [
            {
               "name": "get_branches", 
               "doc": {
                  "headline": "Gets the branch list resulting from a search.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.journaling.BranchList) - the branch list", 
               "error_doc": "        raise:  IllegalState - list already retrieved", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the branch list\n        :rtype: ``osid.journaling.BranchList``", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- list already retrieved", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.journaling.BranchList", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract"
               }
            }, 
            {
               "name": "get_branch_query_inspector", 
               "doc": {
                  "headline": "Gets the inspector for the query to examine the terms used in the search.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.journaling.BranchQueryInspector) - the branch\n                query inspector", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the branch query inspector\n        :rtype: ``osid.journaling.BranchQueryInspector``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.journaling.BranchQueryInspector", 
               "errors": {}
            }, 
            {
               "name": "get_branch_search_results_record", 
               "doc": {
                  "headline": "Gets the branch search results record corresponding to the given branch search record ``Type``.", 
                  "body": "        This method is used to retrieve an object implementing the\n        requested record."
               }, 
               "arg_doc": "        arg:    branch_search_record_type (osid.type.Type): a branch\n                search record type\n", 
               "return_doc": "        return: (osid.journaling.records.BranchSearchResultsRecord) -\n                the branch search results record", 
               "error_doc": "        raise:  NullArgument - ``branch_search_record_type`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure occurred\n        raise:  Unsupported -\n                ``has_record_type_type(branch_search_record_type)`` is\n                ``false``", 
               "sphinx_param_doc": "        :param branch_search_record_type: a branch search record type\n        :type branch_search_record_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "        :return: the branch search results record\n        :rtype: ``osid.journaling.records.BranchSearchResultsRecord``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``branch_search_record_type`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure occurred\n        :raise: ``Unsupported`` -- ``has_record_type_type(branch_search_record_type)`` is ``false``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "branch_search_record_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "osid.journaling.records.BranchSearchResultsRecord", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.journaling.records.BranchSearchResultsRecord", 
         "shortname": "BranchSearchResultsRecord", 
         "category": "records", 
         "doc": {
            "headline": "A record for a ``BranchSearchResults``.", 
            "body": "    The methods specified by the record type are available through the\n    underlying object."
         }, 
         "inherit_fullnames": [
            "osid.OsidRecord"
         ], 
         "inherit_shortnames": [
            "OsidRecord"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidRecord"
            }
         ], 
         "method_names": [], 
         "methods": []
      }, 
      {
         "fullname": "osid.journaling.BranchReceiver", 
         "shortname": "BranchReceiver", 
         "category": "receivers", 
         "doc": {
            "headline": "The branch receiver is the consumer supplied interface for receiving notifications pertaining to new, updated or deleted ``Branch`` objects.", 
            "body": ""
         }, 
         "inherit_fullnames": [
            "osid.OsidReceiver"
         ], 
         "inherit_shortnames": [
            "OsidReceiver"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidReceiver"
            }
         ], 
         "method_names": [
            "new_branch", 
            "changed_branch", 
            "deleted_branch"
         ], 
         "methods": [
            {
               "name": "new_branch", 
               "doc": {
                  "headline": "The callback for notifications of new branches.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    branch_id (osid.id.Id): the ``Id`` of the new ``Branch``\n", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "        :param branch_id: the ``Id`` of the new ``Branch``\n        :type branch_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "branch_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "changed_branch", 
               "doc": {
                  "headline": "The callback for notification of updated branches.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    branch_id (osid.id.Id): the ``Id`` of the updated\n                ``Branch``\n", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "        :param branch_id: the ``Id`` of the updated ``Branch``\n        :type branch_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "branch_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "deleted_branch", 
               "doc": {
                  "headline": "the callback for notification of deleted branches.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    branch_id (osid.id.Id): the ``Id`` of the deleted\n                ``Branch``\n", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "        :param branch_id: the ``Id`` of the deleted ``Branch``\n        :type branch_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "branch_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {}
            }
         ]
      }, 
      {
         "fullname": "osid.journaling.BranchList", 
         "shortname": "BranchList", 
         "category": "objects", 
         "doc": {
            "headline": "Like all ``OsidLists,``  ``BranchList`` provides a means for accessing ``Branch`` elements sequentially either one at a time or many at a time.", 
            "body": "    Examples: while (bl.hasNext()) { Branch branch = bl.getNextBranch();\n    }\n\n    or\n      while (rl.hasNext()) {\n           Branch[] branches = bl.getNextBranches(bl.available());\n      }\n    \n"
         }, 
         "inherit_fullnames": [
            "osid.OsidList"
         ], 
         "inherit_shortnames": [
            "OsidList"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidList"
            }
         ], 
         "method_names": [
            "get_next_branch", 
            "get_next_branches"
         ], 
         "methods": [
            {
               "name": "get_next_branch", 
               "doc": {
                  "headline": "Gets the next ``Branch`` in this list.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.journaling.Branch) - the next ``Branch`` in this\n                list. The ``has_next()`` method should be used to test\n                that a next ``Branch`` is available before calling this\n                method.", 
               "error_doc": "        raise:  IllegalState - no more elements available in this list\n        raise:  OperationFailed - unable to complete request", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the next ``Branch`` in this list. The ``has_next()`` method should be used to test that a next ``Branch`` is available before calling this method.\n        :rtype: ``osid.journaling.Branch``", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- no more elements available in this list\n        :raise: ``OperationFailed`` -- unable to complete request", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.journaling.Branch", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational"
               }
            }, 
            {
               "name": "get_next_branches", 
               "doc": {
                  "headline": "Gets the next set of ``Branches`` in this list which must be less than or equal to the return from ``available()``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    n (cardinal): the number of ``Branch`` elements\n                requested which must be less than or equal to\n                ``available()``\n", 
               "return_doc": "        return: (osid.journaling.Branch) - an array of ``Branch``\n                elements.The length of the array is less than or equal\n                to the number specified.", 
               "error_doc": "        raise:  IllegalState - no more elements available in this list\n        raise:  OperationFailed - unable to complete request", 
               "sphinx_param_doc": "        :param n: the number of ``Branch`` elements requested which must be less than or equal to ``available()``\n        :type n: ``cardinal``\n", 
               "sphinx_return_doc": "        :return: an array of ``Branch`` elements.The length of the array is less than or equal to the number specified.\n        :rtype: ``osid.journaling.Branch``", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- no more elements available in this list\n        :raise: ``OperationFailed`` -- unable to complete request", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "cardinal", 
                     "var_name": "n", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "cardinal"
               ], 
               "return_type": "osid.journaling.Branch", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.journaling.Journal", 
         "shortname": "Journal", 
         "category": "objects", 
         "doc": {
            "headline": "A ``Journal`` represents a collection of entries.", 
            "body": "    Like all OSID objects, a ``Journal`` is identified by its ``Id`` and\n    any persisted references should use the ``Id``."
         }, 
         "inherit_fullnames": [
            "osid.OsidCatalog"
         ], 
         "inherit_shortnames": [
            "OsidCatalog"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidCatalog"
            }
         ], 
         "method_names": [
            "get_journal_record"
         ], 
         "methods": [
            {
               "name": "get_journal_record", 
               "doc": {
                  "headline": "Gets the journal record corresponding to the given ``Journal`` record ``Type``.", 
                  "body": "        This method is used to retrieve an object implementing the\n        requested record. The ``journal_record_type`` may be the\n        ``Type`` returned in ``get_record_types()`` or any of its\n        parents in a ``Type`` hierarchy where\n        ``has_record_type(journal_record_type)`` is ``true`` ."
               }, 
               "arg_doc": "        arg:    journal_record_type (osid.type.Type): the type of\n                journal record to retrieve\n", 
               "return_doc": "        return: (osid.journaling.records.JournalRecord) - the journal\n                record", 
               "error_doc": "        raise:  NullArgument - ``journal_record_type`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unsupported - ``has_record_type(journal_record_type)``\n                is ``false``", 
               "sphinx_param_doc": "        :param journal_record_type: the type of journal record to retrieve\n        :type journal_record_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "        :return: the journal record\n        :rtype: ``osid.journaling.records.JournalRecord``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``journal_record_type`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unsupported`` -- ``has_record_type(journal_record_type)`` is ``false``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "journal_record_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "osid.journaling.records.JournalRecord", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.journaling.records.JournalRecord", 
         "shortname": "JournalRecord", 
         "category": "records", 
         "doc": {
            "headline": "A record for a ``Journal``.", 
            "body": "    The methods specified by the record type are available through the\n    underlying object."
         }, 
         "inherit_fullnames": [
            "osid.OsidRecord"
         ], 
         "inherit_shortnames": [
            "OsidRecord"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidRecord"
            }
         ], 
         "method_names": [], 
         "methods": []
      }, 
      {
         "fullname": "osid.journaling.JournalQuery", 
         "shortname": "JournalQuery", 
         "category": "queries", 
         "doc": {
            "headline": "This is the query for searching for journals.", 
            "body": "    Each method specifies an ``AND`` term while multiple invocations of\n    the same method produce a nested ``OR``."
         }, 
         "inherit_fullnames": [
            "osid.OsidCatalogQuery"
         ], 
         "inherit_shortnames": [
            "OsidCatalogQuery"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidCatalogQuery"
            }
         ], 
         "method_names": [
            "match_journal_entry_id", 
            "clear_journal_entry_id_terms", 
            "supports_journal_entry_query", 
            "get_journal_entry_query", 
            "match_any_journal_entry", 
            "clear_journal_entry_terms", 
            "match_branch_id", 
            "clear_branch_id_terms", 
            "supports_branch_query", 
            "get_branch_query", 
            "match_any_branch", 
            "clear_branch_terms", 
            "match_ancestor_journal_id", 
            "clear_ancestor_journal_id_terms", 
            "supports_ancestor_journal_query", 
            "get_ancestor_journal_query", 
            "match_any_ancestor_journal", 
            "clear_ancestor_journal_terms", 
            "match_descendant_journal_id", 
            "clear_descendant_journal_id_terms", 
            "supports_descendant_journal_query", 
            "get_descendant_journal_query", 
            "match_any_descendant_journal", 
            "clear_descendant_journal_terms", 
            "get_journal_query_record"
         ], 
         "methods": [
            {
               "name": "match_journal_entry_id", 
               "doc": {
                  "headline": "Sets the journal entry ``Id`` for this query to match entries assigned to journals.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    journal_entry_id (osid.id.Id): a journal entry ``Id``\n        arg:    match (boolean): ``true`` for a positive match,\n                ``false`` for a negative match\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``journal_entry_id`` is ``null``", 
               "sphinx_param_doc": "        :param journal_entry_id: a journal entry ``Id``\n        :type journal_entry_id: ``osid.id.Id``\n        :param match: ``true`` for a positive match, ``false`` for a negative match\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``journal_entry_id`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "journal_entry_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "clear_journal_entry_id_terms", 
               "doc": {
                  "headline": "Clears the journal entry ``Id`` terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "supports_journal_entry_query", 
               "doc": {
                  "headline": "Tests if a journal entry query is available.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if a journal entry query is\n                available, ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if a journal entry query is available, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "get_journal_entry_query", 
               "doc": {
                  "headline": "Gets the query for a journal.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.journaling.JournalEntryQuery) - the journal entry\n                query", 
               "error_doc": "        raise:  Unimplemented - ``supports_journal_entry_query()`` is\n                ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the journal entry query\n        :rtype: ``osid.journaling.JournalEntryQuery``", 
               "sphinx_error_doc": "        :raise: ``Unimplemented`` -- ``supports_journal_entry_query()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_journal_entry_query()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.journaling.JournalEntryQuery", 
               "errors": {
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "match_any_journal_entry", 
               "doc": {
                  "headline": "Matches journals with any journal entry.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    match (boolean): ``true`` to match journals with any\n                journal entry, ``false`` to match journals with no\n                entries\n", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "        :param match: ``true`` to match journals with any journal entry, ``false`` to match journals with no entries\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "clear_journal_entry_terms", 
               "doc": {
                  "headline": "Clears the journal entry terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "match_branch_id", 
               "doc": {
                  "headline": "Sets the branch ``Id`` for this query to match branches assigned to journals.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    branch_id (osid.id.Id): a branch ``Id``\n        arg:    match (boolean): ``true`` for a positive match,\n                ``false`` for a negative match\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``branch_id`` is ``null``", 
               "sphinx_param_doc": "        :param branch_id: a branch ``Id``\n        :type branch_id: ``osid.id.Id``\n        :param match: ``true`` for a positive match, ``false`` for a negative match\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``branch_id`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "branch_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "clear_branch_id_terms", 
               "doc": {
                  "headline": "Clears the branch ``Id`` terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "supports_branch_query", 
               "doc": {
                  "headline": "Tests if a branch query is available.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if a branch query is available,\n                ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if a branch query is available, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "get_branch_query", 
               "doc": {
                  "headline": "Gets the query for a branch.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.journaling.BranchQuery) - the branch query", 
               "error_doc": "        raise:  Unimplemented - ``supports_branch_query()`` is ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the branch query\n        :rtype: ``osid.journaling.BranchQuery``", 
               "sphinx_error_doc": "        :raise: ``Unimplemented`` -- ``supports_branch_query()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_branch_query()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.journaling.BranchQuery", 
               "errors": {
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "match_any_branch", 
               "doc": {
                  "headline": "Matches journals with any branches.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    match (boolean): ``true`` to match journals with any\n                branch, ``false`` to match journals with no branches\n", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "        :param match: ``true`` to match journals with any branch, ``false`` to match journals with no branches\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "clear_branch_terms", 
               "doc": {
                  "headline": "Clears the branch terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "match_ancestor_journal_id", 
               "doc": {
                  "headline": "Sets the journal ``Id`` for this query to match journals that have the specified journal as an ancestor.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    journal_id (osid.id.Id): a journal ``Id``\n        arg:    match (boolean): ``true`` for a positive match,\n                ``false`` for a negative match\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``journal_id`` is ``null``", 
               "sphinx_param_doc": "        :param journal_id: a journal ``Id``\n        :type journal_id: ``osid.id.Id``\n        :param match: ``true`` for a positive match, ``false`` for a negative match\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``journal_id`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "journal_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "clear_ancestor_journal_id_terms", 
               "doc": {
                  "headline": "Clears the ancestor journal ``Id`` terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "supports_ancestor_journal_query", 
               "doc": {
                  "headline": "Tests if a ``JournalQuery`` is available.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if a journal query is available,\n                ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if a journal query is available, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "get_ancestor_journal_query", 
               "doc": {
                  "headline": "Gets the query for a journal.", 
                  "body": "        Multiple retrievals produce a nested ``OR`` term."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.journaling.JournalQuery) - the journal query", 
               "error_doc": "        raise:  Unimplemented - ``supports_ancestor_journal_query()`` is\n                ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the journal query\n        :rtype: ``osid.journaling.JournalQuery``", 
               "sphinx_error_doc": "        :raise: ``Unimplemented`` -- ``supports_ancestor_journal_query()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_ancestor_journal_query()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.journaling.JournalQuery", 
               "errors": {
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "match_any_ancestor_journal", 
               "doc": {
                  "headline": "Matches journals with any ancestor.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    match (boolean): ``true`` to match journals with any\n                ancestor, ``false`` to match root journals\n", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "        :param match: ``true`` to match journals with any ancestor, ``false`` to match root journals\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "clear_ancestor_journal_terms", 
               "doc": {
                  "headline": "Clears the ancestor journal terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "match_descendant_journal_id", 
               "doc": {
                  "headline": "Sets the journal ``Id`` for this query to match journals that have the specified journal as a descendant.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    journal_id (osid.id.Id): a journal ``Id``\n        arg:    match (boolean): ``true`` for a positive match,\n                ``false`` for a negative match\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``journal_id`` is ``null``", 
               "sphinx_param_doc": "        :param journal_id: a journal ``Id``\n        :type journal_id: ``osid.id.Id``\n        :param match: ``true`` for a positive match, ``false`` for a negative match\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``journal_id`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "journal_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "clear_descendant_journal_id_terms", 
               "doc": {
                  "headline": "Clears the descendant journal ``Id`` terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "supports_descendant_journal_query", 
               "doc": {
                  "headline": "Tests if a ``JournalQuery`` is available.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if a journal query is available,\n                ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if a journal query is available, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "get_descendant_journal_query", 
               "doc": {
                  "headline": "Gets the query for a journal.", 
                  "body": "        Multiple retrievals produce a nested ``OR`` term."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.journaling.JournalQuery) - the journal query", 
               "error_doc": "        raise:  Unimplemented - ``supports_descendant_journal_query()``\n                is ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the journal query\n        :rtype: ``osid.journaling.JournalQuery``", 
               "sphinx_error_doc": "        :raise: ``Unimplemented`` -- ``supports_descendant_journal_query()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_descendant_journal_query()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.journaling.JournalQuery", 
               "errors": {
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "match_any_descendant_journal", 
               "doc": {
                  "headline": "Matches journals with any descendant.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    match (boolean): ``true`` to match journals with any\n                descendant, ``false`` to match leaf journals\n", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "        :param match: ``true`` to match journals with any descendant, ``false`` to match leaf journals\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "clear_descendant_journal_terms", 
               "doc": {
                  "headline": "Clears the descendant journal terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "get_journal_query_record", 
               "doc": {
                  "headline": "Gets the journal query record corresponding to the given ``Journal`` record ``Type``.", 
                  "body": "        Multiple record retrievals produce a nested boolean ``OR`` term."
               }, 
               "arg_doc": "        arg:    journal_record_type (osid.type.Type): a journal record\n                type\n", 
               "return_doc": "        return: (osid.journaling.records.JournalQueryRecord) - the\n                journal query record", 
               "error_doc": "        raise:  NullArgument - ``journal_record_type`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unsupported - ``has_record_type(journal_record_type)``\n                is ``false``", 
               "sphinx_param_doc": "        :param journal_record_type: a journal record type\n        :type journal_record_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "        :return: the journal query record\n        :rtype: ``osid.journaling.records.JournalQueryRecord``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``journal_record_type`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unsupported`` -- ``has_record_type(journal_record_type)`` is ``false``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "journal_record_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "osid.journaling.records.JournalQueryRecord", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.journaling.records.JournalQueryRecord", 
         "shortname": "JournalQueryRecord", 
         "category": "records", 
         "doc": {
            "headline": "A record for a ``JournalQuery``.", 
            "body": "    The methods specified by the record type are available through the\n    underlying object."
         }, 
         "inherit_fullnames": [
            "osid.OsidRecord"
         ], 
         "inherit_shortnames": [
            "OsidRecord"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidRecord"
            }
         ], 
         "method_names": [], 
         "methods": []
      }, 
      {
         "fullname": "osid.journaling.JournalQueryInspector", 
         "shortname": "JournalQueryInspector", 
         "category": "query_inspectors", 
         "doc": {
            "headline": "This is the query inspector for examining journal searches.", 
            "body": ""
         }, 
         "inherit_fullnames": [
            "osid.OsidCatalogQueryInspector"
         ], 
         "inherit_shortnames": [
            "OsidCatalogQueryInspector"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidCatalogQueryInspector"
            }
         ], 
         "method_names": [
            "get_journal_entry_id_terms", 
            "get_journal_entry_terms", 
            "get_branch_id_terms", 
            "get_branch_terms", 
            "get_ancestor_journal_id_terms", 
            "get_ancestor_journal_terms", 
            "get_descendant_journal_id_terms", 
            "get_descendant_journal_terms", 
            "get_journal_query_inspector_record"
         ], 
         "methods": [
            {
               "name": "get_journal_entry_id_terms", 
               "doc": {
                  "headline": "Gets the journal entry ``Id`` query terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.search.terms.IdTerm) - the query terms", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the query terms\n        :rtype: ``osid.search.terms.IdTerm``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.search.terms.IdTerm", 
               "errors": {}
            }, 
            {
               "name": "get_journal_entry_terms", 
               "doc": {
                  "headline": "Gets the journal entry query terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.journaling.JournalEntryQueryInspector) - the query\n                terms", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the query terms\n        :rtype: ``osid.journaling.JournalEntryQueryInspector``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.journaling.JournalEntryQueryInspector", 
               "errors": {}
            }, 
            {
               "name": "get_branch_id_terms", 
               "doc": {
                  "headline": "Gets the branch ``Id`` query terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.search.terms.IdTerm) - the query terms", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the query terms\n        :rtype: ``osid.search.terms.IdTerm``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.search.terms.IdTerm", 
               "errors": {}
            }, 
            {
               "name": "get_branch_terms", 
               "doc": {
                  "headline": "Gets the branch query terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.journaling.BranchQueryInspector) - the query terms", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the query terms\n        :rtype: ``osid.journaling.BranchQueryInspector``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.journaling.BranchQueryInspector", 
               "errors": {}
            }, 
            {
               "name": "get_ancestor_journal_id_terms", 
               "doc": {
                  "headline": "Gets the ancestor journal ``Id`` query terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.search.terms.IdTerm) - the query terms", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the query terms\n        :rtype: ``osid.search.terms.IdTerm``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.search.terms.IdTerm", 
               "errors": {}
            }, 
            {
               "name": "get_ancestor_journal_terms", 
               "doc": {
                  "headline": "Gets the ancestor journal query terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.journaling.JournalQueryInspector) - the query\n                terms", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the query terms\n        :rtype: ``osid.journaling.JournalQueryInspector``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.journaling.JournalQueryInspector", 
               "errors": {}
            }, 
            {
               "name": "get_descendant_journal_id_terms", 
               "doc": {
                  "headline": "Gets the descendant journal ``Id`` query terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.search.terms.IdTerm) - the query terms", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the query terms\n        :rtype: ``osid.search.terms.IdTerm``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.search.terms.IdTerm", 
               "errors": {}
            }, 
            {
               "name": "get_descendant_journal_terms", 
               "doc": {
                  "headline": "Gets the descendant journal query terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.journaling.JournalQueryInspector) - the query\n                terms", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the query terms\n        :rtype: ``osid.journaling.JournalQueryInspector``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.journaling.JournalQueryInspector", 
               "errors": {}
            }, 
            {
               "name": "get_journal_query_inspector_record", 
               "doc": {
                  "headline": "Gets the journal query inspector record corresponding to the given ``Journal`` record ``Type``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    journal_record_type (osid.type.Type): a journal record\n                type\n", 
               "return_doc": "        return: (osid.journaling.records.JournalQueryInspectorRecord) -\n                the journal query inspector record", 
               "error_doc": "        raise:  NullArgument - ``journal_record_type`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unsupported - ``has_record_type(journal_record_type)``\n                is ``false``", 
               "sphinx_param_doc": "        :param journal_record_type: a journal record type\n        :type journal_record_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "        :return: the journal query inspector record\n        :rtype: ``osid.journaling.records.JournalQueryInspectorRecord``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``journal_record_type`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unsupported`` -- ``has_record_type(journal_record_type)`` is ``false``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "journal_record_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "osid.journaling.records.JournalQueryInspectorRecord", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.journaling.records.JournalQueryInspectorRecord", 
         "shortname": "JournalQueryInspectorRecord", 
         "category": "records", 
         "doc": {
            "headline": "A record for a ``JournalQueryInspector``.", 
            "body": "    The methods specified by the record type are available through the\n    underlying object."
         }, 
         "inherit_fullnames": [
            "osid.OsidRecord"
         ], 
         "inherit_shortnames": [
            "OsidRecord"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidRecord"
            }
         ], 
         "method_names": [], 
         "methods": []
      }, 
      {
         "fullname": "osid.journaling.JournalForm", 
         "shortname": "JournalForm", 
         "category": "objects", 
         "doc": {
            "headline": "This is the form for creating and updating ``Journals``.", 
            "body": "    Like all ``OsidForm`` objects, various data elements may be set here\n    for use in the create and update methods in the\n    ``JournalAdminSession``. For each data element that may be set,\n    metadata may be examined to provide display hints or data\n    constraints."
         }, 
         "inherit_fullnames": [
            "osid.OsidCatalogForm"
         ], 
         "inherit_shortnames": [
            "OsidCatalogForm"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidCatalogForm"
            }
         ], 
         "method_names": [
            "get_journal_form_record"
         ], 
         "methods": [
            {
               "name": "get_journal_form_record", 
               "doc": {
                  "headline": "Gets the ``JournalFormRecord`` corresponding to the given journal record ``Type``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    journal_record_type (osid.type.Type): the journal record\n                type\n", 
               "return_doc": "        return: (osid.journaling.records.JournalFormRecord) - the\n                journal form record", 
               "error_doc": "        raise:  NullArgument - ``journal_record_type`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unsupported - ``has_record_type(journal_record_type)``\n                is ``false``", 
               "sphinx_param_doc": "        :param journal_record_type: the journal record type\n        :type journal_record_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "        :return: the journal form record\n        :rtype: ``osid.journaling.records.JournalFormRecord``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``journal_record_type`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unsupported`` -- ``has_record_type(journal_record_type)`` is ``false``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "journal_record_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "osid.journaling.records.JournalFormRecord", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.journaling.records.JournalFormRecord", 
         "shortname": "JournalFormRecord", 
         "category": "records", 
         "doc": {
            "headline": "A record for a ``JournalForm``.", 
            "body": "    The methods specified by the record type are available through the\n    underlying object."
         }, 
         "inherit_fullnames": [
            "osid.OsidRecord"
         ], 
         "inherit_shortnames": [
            "OsidRecord"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidRecord"
            }
         ], 
         "method_names": [], 
         "methods": []
      }, 
      {
         "fullname": "osid.journaling.JournalSearchOrder", 
         "shortname": "JournalSearchOrder", 
         "category": "search_orders", 
         "doc": {
            "headline": "An interface for specifying the ordering of search results.", 
            "body": ""
         }, 
         "inherit_fullnames": [
            "osid.OsidCatalogSearchOrder"
         ], 
         "inherit_shortnames": [
            "OsidCatalogSearchOrder"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidCatalogSearchOrder"
            }
         ], 
         "method_names": [
            "get_journal_search_order_record"
         ], 
         "methods": [
            {
               "name": "get_journal_search_order_record", 
               "doc": {
                  "headline": "Gets the journal search order record corresponding to the given journal record Type.", 
                  "body": "        Multiple retrievals return the same underlying object."
               }, 
               "arg_doc": "        arg:    journal_record_type (osid.type.Type): a journal record\n                type\n", 
               "return_doc": "        return: (osid.journaling.records.JournalSearchOrderRecord) - the\n                journal search order record", 
               "error_doc": "        raise:  NullArgument - ``journal_record_type`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unsupported - ``has_record_type(journal_record_type)``\n                is ``false``", 
               "sphinx_param_doc": "        :param journal_record_type: a journal record type\n        :type journal_record_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "        :return: the journal search order record\n        :rtype: ``osid.journaling.records.JournalSearchOrderRecord``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``journal_record_type`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unsupported`` -- ``has_record_type(journal_record_type)`` is ``false``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "journal_record_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "osid.journaling.records.JournalSearchOrderRecord", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.journaling.records.JournalSearchOrderRecord", 
         "shortname": "JournalSearchOrderRecord", 
         "category": "records", 
         "doc": {
            "headline": "A record for a ``JournalSearchOrder``.", 
            "body": "    The methods specified by the record type are available through the\n    underlying object."
         }, 
         "inherit_fullnames": [
            "osid.OsidRecord"
         ], 
         "inherit_shortnames": [
            "OsidRecord"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidRecord"
            }
         ], 
         "method_names": [], 
         "methods": []
      }, 
      {
         "fullname": "osid.journaling.JournalSearch", 
         "shortname": "JournalSearch", 
         "category": "searches", 
         "doc": {
            "headline": "The search interface for governing journal searches.", 
            "body": ""
         }, 
         "inherit_fullnames": [
            "osid.OsidSearch"
         ], 
         "inherit_shortnames": [
            "OsidSearch"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidSearch"
            }
         ], 
         "method_names": [
            "search_among_journals", 
            "order_journal_results", 
            "get_journal_search_record"
         ], 
         "methods": [
            {
               "name": "search_among_journals", 
               "doc": {
                  "headline": "Execute this search among the given list of journals.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    journal_ids (osid.id.IdList): list of journals\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``journal_ids`` is ``null``", 
               "sphinx_param_doc": "        :param journal_ids: list of journals\n        :type journal_ids: ``osid.id.IdList``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``journal_ids`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.IdList", 
                     "var_name": "journal_ids", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.IdList"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "order_journal_results", 
               "doc": {
                  "headline": "Specify an ordering to the search results.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    journal_search_order\n                (osid.journaling.JournalSearchOrder): journal search\n                order\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``journal_search_order`` is ``null``\n        raise:  Unsupported - ``journal_search_order`` is not of this\n                service", 
               "sphinx_param_doc": "        :param journal_search_order: journal search order\n        :type journal_search_order: ``osid.journaling.JournalSearchOrder``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``journal_search_order`` is ``null``\n        :raise: ``Unsupported`` -- ``journal_search_order`` is not of this service", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.journaling.JournalSearchOrder", 
                     "var_name": "journal_search_order", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.journaling.JournalSearchOrder"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_journal_search_record", 
               "doc": {
                  "headline": "Gets the journal search record corresponding to the given journal search record ``Type``.", 
                  "body": "        This method is used to retrieve an object implementing the\n        requested record."
               }, 
               "arg_doc": "        arg:    journal_search_record_type (osid.type.Type): a journal\n                search record type\n", 
               "return_doc": "        return: (osid.journaling.records.JournalSearchRecord) - the\n                journal search record", 
               "error_doc": "        raise:  NullArgument - ``journal_search_record_type`` is\n                ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unsupported -\n                ``has_record_type(journal_search_record_type)`` is\n                ``false``", 
               "sphinx_param_doc": "        :param journal_search_record_type: a journal search record type\n        :type journal_search_record_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "        :return: the journal search record\n        :rtype: ``osid.journaling.records.JournalSearchRecord``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``journal_search_record_type`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unsupported`` -- ``has_record_type(journal_search_record_type)`` is ``false``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "journal_search_record_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "osid.journaling.records.JournalSearchRecord", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.journaling.records.JournalSearchRecord", 
         "shortname": "JournalSearchRecord", 
         "category": "records", 
         "doc": {
            "headline": "A record for a ``JournalSearch``.", 
            "body": "    The methods specified by the record type are available through the\n    underlying object."
         }, 
         "inherit_fullnames": [
            "osid.OsidRecord"
         ], 
         "inherit_shortnames": [
            "OsidRecord"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidRecord"
            }
         ], 
         "method_names": [], 
         "methods": []
      }, 
      {
         "fullname": "osid.journaling.JournalSearchResults", 
         "shortname": "JournalSearchResults", 
         "category": "searches", 
         "doc": {
            "headline": "This interface provides a means to capture results of a search.", 
            "body": ""
         }, 
         "inherit_fullnames": [
            "osid.OsidSearchResults"
         ], 
         "inherit_shortnames": [
            "OsidSearchResults"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidSearchResults"
            }
         ], 
         "method_names": [
            "get_journals", 
            "get_journal_query_inspector", 
            "get_journal_search_results_record"
         ], 
         "methods": [
            {
               "name": "get_journals", 
               "doc": {
                  "headline": "Gets the journal list resulting from a search.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.journaling.JournalList) - the journal list", 
               "error_doc": "        raise:  IllegalState - list already retrieved", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the journal list\n        :rtype: ``osid.journaling.JournalList``", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- list already retrieved", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.journaling.JournalList", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract"
               }
            }, 
            {
               "name": "get_journal_query_inspector", 
               "doc": {
                  "headline": "Gets the inspector for the query to examine the terms used in the search.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.journaling.JournalQueryInspector) - the journal\n                query inspector", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the journal query inspector\n        :rtype: ``osid.journaling.JournalQueryInspector``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.journaling.JournalQueryInspector", 
               "errors": {}
            }, 
            {
               "name": "get_journal_search_results_record", 
               "doc": {
                  "headline": "Gets the journal search results record corresponding to the given journal search record Type.", 
                  "body": "        This method is used to retrieve an object implementing the\n        requested record."
               }, 
               "arg_doc": "        arg:    journal_search_record_type (osid.type.Type): a journal\n                search record type\n", 
               "return_doc": "        return: (osid.journaling.records.JournalSearchResultsRecord) -\n                the journal search results record", 
               "error_doc": "        raise:  NullArgument - ``JournalSearchRecordType`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unsupported -\n                ``has_record_type(journal_search_record_type)`` is\n                ``false``", 
               "sphinx_param_doc": "        :param journal_search_record_type: a journal search record type\n        :type journal_search_record_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "        :return: the journal search results record\n        :rtype: ``osid.journaling.records.JournalSearchResultsRecord``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``JournalSearchRecordType`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unsupported`` -- ``has_record_type(journal_search_record_type)`` is ``false``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "journal_search_record_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "osid.journaling.records.JournalSearchResultsRecord", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.journaling.records.JournalSearchResultsRecord", 
         "shortname": "JournalSearchResultsRecord", 
         "category": "records", 
         "doc": {
            "headline": "A record for a ``JournalSearchResults``.", 
            "body": "    The methods specified by the record type are available through the\n    underlying object."
         }, 
         "inherit_fullnames": [
            "osid.OsidRecord"
         ], 
         "inherit_shortnames": [
            "OsidRecord"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidRecord"
            }
         ], 
         "method_names": [], 
         "methods": []
      }, 
      {
         "fullname": "osid.journaling.JournalReceiver", 
         "shortname": "JournalReceiver", 
         "category": "receivers", 
         "doc": {
            "headline": "The journal receiver is the consumer supplied interface for receiving notifications pertaining to new, updated or deleted ``Journal`` objects.", 
            "body": ""
         }, 
         "inherit_fullnames": [
            "osid.OsidReceiver"
         ], 
         "inherit_shortnames": [
            "OsidReceiver"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidReceiver"
            }
         ], 
         "method_names": [
            "new_journal", 
            "new_ancestor_journal", 
            "new_descendant_journal", 
            "changed_journal", 
            "deleted_journal", 
            "deleted_ancestor_journal", 
            "deleted_descendant_journal"
         ], 
         "methods": [
            {
               "name": "new_journal", 
               "doc": {
                  "headline": "The callback for notifications of new journals.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    journal_id (osid.id.Id): the ``Id`` of the new\n                ``Journal``\n", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "        :param journal_id: the ``Id`` of the new ``Journal``\n        :type journal_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "journal_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "new_ancestor_journal", 
               "doc": {
                  "headline": "The callback for notifications of new ancestors of a journal.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    journal_id (osid.id.Id): the ``Id`` of the registered\n                ``Journal``\n        arg:    ancestor_id (osid.id.Id): the Id of the new ancestor\n                journal\n", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "        :param journal_id: the ``Id`` of the registered ``Journal``\n        :type journal_id: ``osid.id.Id``\n        :param ancestor_id: the Id of the new ancestor journal\n        :type ancestor_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "journal_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "ancestor_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "new_descendant_journal", 
               "doc": {
                  "headline": "The callback for notifications of new descendant of a journal.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    journal_id (osid.id.Id): the ``Id`` of the registered\n                ``Journal``\n        arg:    descendant_id (osid.id.Id): the Id of the new descendant\n                journal\n", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "        :param journal_id: the ``Id`` of the registered ``Journal``\n        :type journal_id: ``osid.id.Id``\n        :param descendant_id: the Id of the new descendant journal\n        :type descendant_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "journal_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "descendant_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "changed_journal", 
               "doc": {
                  "headline": "The callback for notification of updated journals.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    journal_id (osid.id.Id): the ``Id`` of the updated\n                ``Journal``\n", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "        :param journal_id: the ``Id`` of the updated ``Journal``\n        :type journal_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "journal_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "deleted_journal", 
               "doc": {
                  "headline": "the callback for notification of deleted journals.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    journal_id (osid.id.Id): the ``Id`` of the registered\n                ``Journal``\n", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "        :param journal_id: the ``Id`` of the registered ``Journal``\n        :type journal_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "journal_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "deleted_ancestor_journal", 
               "doc": {
                  "headline": "The callback for notifications of deleted ancestors of a journal.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    journal_id (osid.id.Id): the ``Id`` of the registered\n                ``Journal``\n        arg:    ancestor_id (osid.id.Id): the Id of the removed ancestor\n                journal\n", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "        :param journal_id: the ``Id`` of the registered ``Journal``\n        :type journal_id: ``osid.id.Id``\n        :param ancestor_id: the Id of the removed ancestor journal\n        :type ancestor_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "journal_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "ancestor_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "deleted_descendant_journal", 
               "doc": {
                  "headline": "The callback for notifications of deleted descendants of a journal.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    journal_id (osid.id.Id): the ``Id`` of the registered\n                ``Journal``\n        arg:    descendant_id (osid.id.Id): the Id of the deleted\n                descendant journal\n", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "        :param journal_id: the ``Id`` of the registered ``Journal``\n        :type journal_id: ``osid.id.Id``\n        :param descendant_id: the Id of the deleted descendant journal\n        :type descendant_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "journal_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "descendant_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {}
            }
         ]
      }, 
      {
         "fullname": "osid.journaling.JournalList", 
         "shortname": "JournalList", 
         "category": "objects", 
         "doc": {
            "headline": "Like all ``OsidLists,``  ``JournalList`` provides a means for accessing ``Journal`` elements sequentially either one at a time or many at a time.", 
            "body": "    Examples: while (jl.hasNext()) { Journal journal =\n    jl.getNextJournal(); }\n\n    or\n      while (jl.hasNext()) {\n           Journal[] journal = jl.getNextJournals(jl.available());\n      }\n    \n"
         }, 
         "inherit_fullnames": [
            "osid.OsidList"
         ], 
         "inherit_shortnames": [
            "OsidList"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidList"
            }
         ], 
         "method_names": [
            "get_next_journal", 
            "get_next_journals"
         ], 
         "methods": [
            {
               "name": "get_next_journal", 
               "doc": {
                  "headline": "Gets the next ``Journal`` in this list.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.journaling.Journal) - the next ``Journal`` in this\n                list. The ``has_next()`` method should be used to test\n                that a next ``Journal`` is available before calling this\n                method.", 
               "error_doc": "        raise:  IllegalState - no more elements available in this list\n        raise:  OperationFailed - unable to complete request", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the next ``Journal`` in this list. The ``has_next()`` method should be used to test that a next ``Journal`` is available before calling this method.\n        :rtype: ``osid.journaling.Journal``", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- no more elements available in this list\n        :raise: ``OperationFailed`` -- unable to complete request", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.journaling.Journal", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational"
               }
            }, 
            {
               "name": "get_next_journals", 
               "doc": {
                  "headline": "Gets the next set of ``Journal`` elements in this list.", 
                  "body": "        The specified amount must be less than or equal to the return\n        from ``available()``."
               }, 
               "arg_doc": "        arg:    n (cardinal): the number of ``Journal`` elements\n                requested which must be less than or equal to\n                ``available()``\n", 
               "return_doc": "        return: (osid.journaling.Journal) - an array of ``Journal``\n                elements.The length of the array is less than or equal\n                to the number specified.", 
               "error_doc": "        raise:  IllegalState - no more elements available in this list\n        raise:  OperationFailed - unable to complete request", 
               "sphinx_param_doc": "        :param n: the number of ``Journal`` elements requested which must be less than or equal to ``available()``\n        :type n: ``cardinal``\n", 
               "sphinx_return_doc": "        :return: an array of ``Journal`` elements.The length of the array is less than or equal to the number specified.\n        :rtype: ``osid.journaling.Journal``", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- no more elements available in this list\n        :raise: ``OperationFailed`` -- unable to complete request", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "cardinal", 
                     "var_name": "n", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "cardinal"
               ], 
               "return_type": "osid.journaling.Journal", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.journaling.JournalNode", 
         "shortname": "JournalNode", 
         "category": "objects", 
         "doc": {
            "headline": "This interface is a container for a partial hierarchy retrieval.", 
            "body": "    The number of hierarchy levels traversable through this interface\n    depend on the number of levels requested in the\n    ``JournalHierarchySession``."
         }, 
         "inherit_fullnames": [
            "osid.OsidNode"
         ], 
         "inherit_shortnames": [
            "OsidNode"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidNode"
            }
         ], 
         "method_names": [
            "get_journal", 
            "get_parent_journal_nodes", 
            "get_child_journal_nodes"
         ], 
         "methods": [
            {
               "name": "get_journal", 
               "doc": {
                  "headline": "Gets the ``Journal`` at this node.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.journaling.Journal) - the journal represented by\n                this node", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the journal represented by this node\n        :rtype: ``osid.journaling.Journal``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.journaling.Journal", 
               "errors": {}
            }, 
            {
               "name": "get_parent_journal_nodes", 
               "doc": {
                  "headline": "Gets the parents of this journal.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.journaling.JournalNodeList) - the parents of this\n                journal", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the parents of this journal\n        :rtype: ``osid.journaling.JournalNodeList``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.journaling.JournalNodeList", 
               "errors": {}
            }, 
            {
               "name": "get_child_journal_nodes", 
               "doc": {
                  "headline": "Gets the children of this journal.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.journaling.JournalNodeList) - the children of this\n                journal", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the children of this journal\n        :rtype: ``osid.journaling.JournalNodeList``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.journaling.JournalNodeList", 
               "errors": {}
            }
         ]
      }, 
      {
         "fullname": "osid.journaling.JournalNodeList", 
         "shortname": "JournalNodeList", 
         "category": "objects", 
         "doc": {
            "headline": "Like all ``OsidLists,``  ``JournalNodeList`` provides a means for accessing ``JournalNode`` elements sequentially either one at a time or many at a time.", 
            "body": "    Examples: while (jnl.hasNext()) { JournalNode node =\n    jnl.getNextJournalNode(); }\n\n    or\n      while (jnl.hasNext()) {\n           JournalNode[] nodes = jnl.getNextJournalNodes(jnl.available());\n      }\n    \n"
         }, 
         "inherit_fullnames": [
            "osid.OsidList"
         ], 
         "inherit_shortnames": [
            "OsidList"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidList"
            }
         ], 
         "method_names": [
            "get_next_journal_node", 
            "get_next_journal_nodes"
         ], 
         "methods": [
            {
               "name": "get_next_journal_node", 
               "doc": {
                  "headline": "Gets the next ``JournalNode`` in this list.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.journaling.JournalNode) - the next ``JournalNode``\n                in this list. The ``has_next()`` method should be used\n                to test that a next ``JournalNode`` is available before\n                calling this method.", 
               "error_doc": "        raise:  IllegalState - no more elements available in this list\n        raise:  OperationFailed - unable to complete request", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the next ``JournalNode`` in this list. The ``has_next()`` method should be used to test that a next ``JournalNode`` is available before calling this method.\n        :rtype: ``osid.journaling.JournalNode``", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- no more elements available in this list\n        :raise: ``OperationFailed`` -- unable to complete request", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.journaling.JournalNode", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational"
               }
            }, 
            {
               "name": "get_next_journal_nodes", 
               "doc": {
                  "headline": "Gets the next set of ``JournalNode`` elements in this list.", 
                  "body": "        The specified amount must be less than or equal to the return\n        from ``available()``."
               }, 
               "arg_doc": "        arg:    n (cardinal): the number of ``JournalNode`` elements\n                requested which must be less than or equal to\n                ``available()``\n", 
               "return_doc": "        return: (osid.journaling.JournalNode) - an array of\n                ``JournalNode`` elements.The length of the array is less\n                than or equal to the number specified.", 
               "error_doc": "        raise:  IllegalState - no more elements available in this list\n        raise:  OperationFailed - unable to complete request", 
               "sphinx_param_doc": "        :param n: the number of ``JournalNode`` elements requested which must be less than or equal to ``available()``\n        :type n: ``cardinal``\n", 
               "sphinx_return_doc": "        :return: an array of ``JournalNode`` elements.The length of the array is less than or equal to the number specified.\n        :rtype: ``osid.journaling.JournalNode``", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- no more elements available in this list\n        :raise: ``OperationFailed`` -- unable to complete request", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "cardinal", 
                     "var_name": "n", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "cardinal"
               ], 
               "return_type": "osid.journaling.JournalNode", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational"
               }
            }
         ]
      }
   ], 
   "full_name": "osid.journaling"
}
{
   "name": "calendaring", 
   "version": "3.0.0", 
   "title": "Calendaring Open Service Interface Definitions", 
   "copyright": "Copyright (c) 2002-2004 Massachusetts Institute of Technology.\n\nCopyright (c) 2008-2011 Ingenescus. All Rights Reserved.", 
   "license": "This Work is being provided by the copyright holder(s) subject to the\nfollowing license. By obtaining, using and/or copying this Work, you\nagree that you have read, understand, and will comply with the following\nterms and conditions.\n\nPermission to use, copy and distribute unmodified versions of this Work,\nfor any purpose, without fee or royalty is hereby granted, provided that\nyou include the above copyright notices and the terms of this license on\nALL copies of the Work or portions thereof.\n\nYou may modify or create Derivatives of this Work only for your internal\npurposes. You shall not distribute or transfer any such Derivative of\nthis Work to any location or to any third party. For the purposes of\nthis license, \"Derivative\" shall mean any derivative of the Work as\ndefined in the United States Copyright Act of 1976, such as a\ntranslation or modification.\n\nThis Work and the information contained herein is provided on an \"AS IS\"\nbasis WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT\nNOT LIMITED TO WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR\nPURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\nHOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN\nAN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\nCONNECTION WITH THE WORK OR THE USE OR OTHER DEALINGS IN THE WORK.\n\nThe export of software employing encryption technology may require a\nspecific license from the United States Government. It is the\nresponsibility of any person or organization contemplating export to\nobtain such a license before exporting this Work.", 
   "summary": "The Calendaring OSID manages events, commitments and calendars. The\nCalendaring OSID offers a rich set of event management services.\n\nEvent\n\nAn ``Event`` is range of time associated with a ``Location`` and event\nsponsors. ``Events`` may be managed singularly, or be generated of of\none of the typs of events listed below.\n\nOffset Events\n\nAn ``OffSetEvent`` is an ``OsidRule`` for generating an ``Event`` off of\nanother Event. An ``OffsetEvent`` may be offset by a fixed period of\ntime, a weekday, or include an external ``Rule`` to determine the\noffset. Example ``OffsetEvents`` are \"the first Tuesday after Labor Day\"\nor \"24 hours before a due date.\"\n\nSuperseding Events\n\nA ``SupersedingEvent`` is an ``OsidRule`` for replacing another\n``Event``. Typically, ``SupersedingEvents`` are used for replacing a\ngenerated ``Event`` from a recurring event series. ``Events`` may be\nsuperseded by date or position in a recruring even seriest. Examples are\n\"replace the event on 12/25 with an event scheduled for 12/26\" or\n\"replace the 10th event in a course schedule with an exam.\"\n\nRecurring Events\n\nA ``RecurringEvent`` generates a series of ``Events`` from a Schedule. A\n``Schedule`` is a series of times and locations.\n\nA RecurringEvent may include ``SupersedingEvents`` to replace specific\nevents in the series with another ``Event`` which may, in turn, be\nanother RecurringEvent. ``RecurringEvents`` may also have a set of\nblackout dates in which ``Event`` generation is suuppressed.\n\nSchedules\n\nA ``Schedule`` describes a repeating time and Location. ``Schedules``\nmay be bounded by dates or by using a ``TimePeriod``. A ``TimePeriod``\nis a reusable date range and may include a set of exception ``Events``\nto define a set of time ranges that any ``RecurringEvent`` mapped to the\n``TimePeriod`` may not occur.\n\n``Schedules`` are composed of ``ScheduleSlots``.  ``ScheduleSlots`` are\nnormalized weekly time slots. A ``ScheduleSlot`` may be composed of\nother ``ScheduleSlots``.\n\nTo make a ``RecurringEvent`` for MWF 3pm in room 26-100 during the\nsummer except July 4th:\n\n  * A ``ScheduleSlot`` for MWF 3pm is created.\n  * A ``Schedule`` is created using the ScheduleSlot for room 10-250 in\n    the summer ``TimePeriod.``\n  * A ``RecurringEvent`` is created using the Schedule.\n  * A blackout date for Independence Day is added to the\n    ``RecurringEvent.``\n\n\nCommitments\n\n``Commitments`` are ``OsidRelationships`` between ``Resources`` and\nEvents. ``Commitments`` may include any data specific to the\nrelationship.\n\nCalendaring Catalogging\n\n``Events`` and ``Schedules`` are cataloged into ``Calendars``. The\n``Calendar`` is simply an ``OsidCatalog`` representing a collection of\n``Events`` that may be federated using the OSID hierarchy pattern to\ncreate virtual calendars.\n\nCalendaring Rules\n\nThe Calendaring OSID includes a rules package for managing the behavior\nof ``Commitments`` and ``Events. It also includes`` a Calendaring Cycle\nOSID for managing canonical events and time periods as well as a\nCalendaring Mason OSID for defining rules for building events and time\nperiods. The Calendaring Batch OSID manages ``Events,``\n``Commitments,`` and ``TimePeriods`` in bulk.", 
   "interfaces": [
      {
         "fullname": "osid.calendaring.CalendaringProfile", 
         "shortname": "CalendaringProfile", 
         "category": "managers", 
         "doc": {
            "headline": "The ``CalendaringProfile`` describes the interoperability among calendaring services.", 
            "body": ""
         }, 
         "inherit_fullnames": [
            "osid.OsidProfile"
         ], 
         "inherit_shortnames": [
            "OsidProfile"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidProfile"
            }
         ], 
         "method_names": [
            "supports_visible_federation", 
            "supports_event_lookup", 
            "supports_event_query", 
            "supports_event_search", 
            "supports_event_admin", 
            "supports_event_notification", 
            "supports_event_calendar", 
            "supports_event_calendar_assignment", 
            "supports_event_smart_calendar", 
            "supports_recurring_event_lookup", 
            "supports_recurring_event_unravelling", 
            "supports_recurring_event_query", 
            "supports_recurring_event_search", 
            "supports_recurring_event_admin", 
            "supports_recurring_event_notification", 
            "supports_recurring_event_calendar", 
            "supports_recurring_event_calendar_assignment", 
            "supports_recurring_event_smart_calendar", 
            "supports_superseding_event_lookup", 
            "supports_superseding_event_query", 
            "supports_superseding_event_search", 
            "supports_superseding_event_admin", 
            "supports_superseding_event_notification", 
            "supports_superseding_event_calendar", 
            "supports_superseding_event_calendar_assignment", 
            "supports_superseding_event_smart_calendar", 
            "supports_offset_event_lookup", 
            "supports_offset_event_query", 
            "supports_offset_event_search", 
            "supports_offset_event_admin", 
            "supports_offset_event_notification", 
            "supports_offset_event_calendar", 
            "supports_offset_event_calendar_assignment", 
            "supports_offset_event_smart_calendar", 
            "supports_schedule_lookup", 
            "supports_schedule_query", 
            "supports_schedule_search", 
            "supports_schedule_admin", 
            "supports_schedule_notification", 
            "supports_schedule_calendar", 
            "supports_schedule_calendar_assignment", 
            "supports_schedule_smart_calendar", 
            "supports_schedule_slot_lookup", 
            "supports_schedule_slot_query", 
            "supports_schedule_slot_search", 
            "supports_schedule_slot_admin", 
            "supports_schedule_slot_notification", 
            "supports_schedule_slot_calendar", 
            "supports_schedule_slot_calendar_assignment", 
            "supports_schedule_slot_smart_calendar", 
            "supports_commitment_lookup", 
            "supports_commitment_query", 
            "supports_commitment_search", 
            "supports_commitment_admin", 
            "supports_commitment_notification", 
            "supports_commitment_calendar", 
            "supports_commitment_calendar_assignment", 
            "supports_commitment_smart_calendar", 
            "supports_time_period_lookup", 
            "supports_time_period_search", 
            "supports_time_period_admin", 
            "supports_time_period_notification", 
            "supports_time_period_calendar", 
            "supports_time_period_calendar_assignment", 
            "supports_time_period_smart_calendar", 
            "supports_calendar_lookup", 
            "supports_calendar_search", 
            "supports_calendar_admin", 
            "supports_calendar_notification", 
            "supports_calendar_hierarchy", 
            "supports_calendar_hierarchy_design", 
            "supports_calendaring_batch", 
            "supports_calendaring_cycle", 
            "supports_calendaring_rules", 
            "get_event_record_types", 
            "supports_event_record_type", 
            "get_event_search_record_types", 
            "supports_event_search_record_type", 
            "get_recurring_event_record_types", 
            "supports_recurring_event_record_type", 
            "get_recurring_event_search_record_types", 
            "supports_recurring_event_search_record_type", 
            "get_superseding_event_record_types", 
            "supports_superseding_event_record_type", 
            "get_superseding_event_search_record_types", 
            "supports_superseding_event_search_record_type", 
            "get_offset_event_record_types", 
            "supports_offset_event_record_type", 
            "get_offset_event_search_record_types", 
            "supports_offset_event_search_record_type", 
            "get_schedule_record_types", 
            "supports_schedule_record_type", 
            "get_schedule_search_record_types", 
            "supports_schedule_search_record_type", 
            "get_schedule_slot_record_types", 
            "supports_schedule_slot_record_type", 
            "get_schedule_slot_search_record_types", 
            "supports_schedule_slot_search_record_type", 
            "get_time_period_record_types", 
            "supports_time_period_record_type", 
            "get_time_period_search_record_types", 
            "supports_time_period_search_record_type", 
            "get_commitment_record_types", 
            "supports_commitment_record_type", 
            "get_commitment_search_record_types", 
            "supports_commitment_search_record_type", 
            "get_calendar_record_types", 
            "supports_calendar_record_type", 
            "get_calendar_search_record_types", 
            "supports_calendar_search_record_type", 
            "get_spatial_unit_record_types", 
            "supports_spatial_unit_record_type", 
            "get_coordinate_record_types", 
            "supports_coordinate_record_type"
         ], 
         "methods": [
            {
               "name": "supports_visible_federation", 
               "doc": {
                  "headline": "Tests if federation is visible.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if visible federation is supported\n                ``,``  ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if visible federation is supported ``,``  ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "supports_event_lookup", 
               "doc": {
                  "headline": "Tests if an event lookup service is supported.", 
                  "body": "        An event lookup service defines methods to access events."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - true if event lookup is supported, false\n                otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: true if event lookup is supported, false otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "supports_event_query", 
               "doc": {
                  "headline": "Tests if an event query service is supported.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if event query is supported,\n                ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if event query is supported, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "supports_event_search", 
               "doc": {
                  "headline": "Tests if an event search service is supported.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if event search is supported,\n                ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if event search is supported, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "supports_event_admin", 
               "doc": {
                  "headline": "Tests if an event administrative service is supported.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if event admin is supported,\n                ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if event admin is supported, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "supports_event_notification", 
               "doc": {
                  "headline": "Tests if event notification is supported.", 
                  "body": "        Messages may be sent when events are created, modified, or\n        deleted."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if event notification is supported,\n                ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if event notification is supported, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "supports_event_calendar", 
               "doc": {
                  "headline": "Tests if an event to calendar lookup session is available.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if event calendar lookup session is\n                supported, ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if event calendar lookup session is supported, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "supports_event_calendar_assignment", 
               "doc": {
                  "headline": "Tests if an event to calendar assignment session is available.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if event calendar assignment is\n                supported, ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if event calendar assignment is supported, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "supports_event_smart_calendar", 
               "doc": {
                  "headline": "Tests if event smart calendaring is available.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if event smart calendaring is\n                supported, ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if event smart calendaring is supported, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "supports_recurring_event_lookup", 
               "doc": {
                  "headline": "Tests if a recurring event lookup service is supported.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - true if recurring event lookup is supported,\n                false otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: true if recurring event lookup is supported, false otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "supports_recurring_event_unravelling", 
               "doc": {
                  "headline": "Tests if a recurring event unravelling service is supported.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - true if recurring event unravelling is\n                supported, false otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: true if recurring event unravelling is supported, false otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "supports_recurring_event_query", 
               "doc": {
                  "headline": "Tests if a recurring event query service is supported.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if recurring event query is\n                supported, ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if recurring event query is supported, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "supports_recurring_event_search", 
               "doc": {
                  "headline": "Tests if a recurring event search service is supported.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if recurring event search is\n                supported, ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if recurring event search is supported, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "supports_recurring_event_admin", 
               "doc": {
                  "headline": "Tests if a recurring event administrative service is supported.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if recurring event admin is\n                supported, ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if recurring event admin is supported, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "supports_recurring_event_notification", 
               "doc": {
                  "headline": "Tests if recurring event notification is supported.", 
                  "body": "        Messages may be sent when recurring events are created,\n        modified, or deleted."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if recurring event notification is\n                supported, ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if recurring event notification is supported, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "supports_recurring_event_calendar", 
               "doc": {
                  "headline": "Tests if a recurring event to calendar lookup session is available.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if recurring event calendar lookup\n                session is supported, ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if recurring event calendar lookup session is supported, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "supports_recurring_event_calendar_assignment", 
               "doc": {
                  "headline": "Tests if a recurring event to calendar assignment session is available.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if recurring event calendar\n                assignment is supported, ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if recurring event calendar assignment is supported, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "supports_recurring_event_smart_calendar", 
               "doc": {
                  "headline": "Tests if recurring event smart calendaring is available.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if recurring event smart\n                calendaring is supported, ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if recurring event smart calendaring is supported, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "supports_superseding_event_lookup", 
               "doc": {
                  "headline": "Tests if a superseding event lookup service is supported.", 
                  "body": "        A superseding event lookup service defines methods to access\n        superseding events."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - true if superseding event lookup is\n                supported, false otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: true if superseding event lookup is supported, false otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "supports_superseding_event_query", 
               "doc": {
                  "headline": "Tests if a superseding event query service is supported.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if superseding event query is\n                supported, ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if superseding event query is supported, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "supports_superseding_event_search", 
               "doc": {
                  "headline": "Tests if a superseding event search service is supported.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if superseding event search is\n                supported, ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if superseding event search is supported, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "supports_superseding_event_admin", 
               "doc": {
                  "headline": "Tests if a superseding event administrative service is supported.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if superseding event admin is\n                supported, ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if superseding event admin is supported, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "supports_superseding_event_notification", 
               "doc": {
                  "headline": "Tests if superseding event notification is supported.", 
                  "body": "        Messages may be sent when supsreding events are created,\n        modified, or deleted."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if superseding event notification\n                is supported, ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if superseding event notification is supported, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "supports_superseding_event_calendar", 
               "doc": {
                  "headline": "Tests if superseding event to calendar lookup session is available.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if superseding event calendar\n                lookup session is supported, ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if superseding event calendar lookup session is supported, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "supports_superseding_event_calendar_assignment", 
               "doc": {
                  "headline": "Tests if a superseding event to calendar assignment session is available.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if superseding event calendar\n                assignment is supported, ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if superseding event calendar assignment is supported, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "supports_superseding_event_smart_calendar", 
               "doc": {
                  "headline": "Tests if supsreding event smart calendaring is available.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if superseding smart calendaring is\n                supported, ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if superseding smart calendaring is supported, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "supports_offset_event_lookup", 
               "doc": {
                  "headline": "Tests if an offset event lookup service is supported.", 
                  "body": "        An offset event lookup service defines methods to access events."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - true if offset event lookup is supported,\n                false otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: true if offset event lookup is supported, false otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "supports_offset_event_query", 
               "doc": {
                  "headline": "Tests if an offset event query service is supported.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if offset event query is supported,\n                ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if offset event query is supported, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "supports_offset_event_search", 
               "doc": {
                  "headline": "Tests if an offset event search service is supported.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if offset event search is\n                supported, ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if offset event search is supported, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "supports_offset_event_admin", 
               "doc": {
                  "headline": "Tests if an offset event administrative service is supported.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if offset event admin is supported,\n                ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if offset event admin is supported, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "supports_offset_event_notification", 
               "doc": {
                  "headline": "Tests if offset event notification is supported.", 
                  "body": "        Messages may be sent when events are created, modified, or\n        deleted."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if offset event notification is\n                supported, ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if offset event notification is supported, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "supports_offset_event_calendar", 
               "doc": {
                  "headline": "Tests if an offset event to calendar lookup session is available.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if event calendar lookup session is\n                supported, ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if event calendar lookup session is supported, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "supports_offset_event_calendar_assignment", 
               "doc": {
                  "headline": "Tests if an offset event to calendar assignment session is available.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if offset event calendar assignment\n                is supported, ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if offset event calendar assignment is supported, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "supports_offset_event_smart_calendar", 
               "doc": {
                  "headline": "Tests if offset event smart calendaring is available.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if offset event smart calendaring\n                is supported, ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if offset event smart calendaring is supported, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "supports_schedule_lookup", 
               "doc": {
                  "headline": "Tests if a schedule lookup service is supported.", 
                  "body": "        A schedule lookup service defines methods to access schedules."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - true if schedule lookup is supported, false\n                otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: true if schedule lookup is supported, false otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "supports_schedule_query", 
               "doc": {
                  "headline": "Tests if a schedule query service is supported.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if schedule query is supported,\n                ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if schedule query is supported, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "supports_schedule_search", 
               "doc": {
                  "headline": "Tests if a schedule search service is supported.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if schedule search is supported,\n                ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if schedule search is supported, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "supports_schedule_admin", 
               "doc": {
                  "headline": "Tests if a schedule administrative service is supported.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if schedule admin is supported,\n                ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if schedule admin is supported, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "supports_schedule_notification", 
               "doc": {
                  "headline": "Tests if schedule notification is supported.", 
                  "body": "        Messages may be sent when schedules are created, modified, or\n        deleted."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if schedule notification is\n                supported, ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if schedule notification is supported, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "supports_schedule_calendar", 
               "doc": {
                  "headline": "Tests if a schedule to calendar lookup session is available.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if schedule calendar lookup session\n                is supported, ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if schedule calendar lookup session is supported, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "supports_schedule_calendar_assignment", 
               "doc": {
                  "headline": "Tests if a schedule to calendar assignment session is available.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if schedule calendar assignment is\n                supported, ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if schedule calendar assignment is supported, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "supports_schedule_smart_calendar", 
               "doc": {
                  "headline": "Tests if schedule smart calendaring is available.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if schedule smart calendaring is\n                supported, ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if schedule smart calendaring is supported, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "supports_schedule_slot_lookup", 
               "doc": {
                  "headline": "Tests if a schedule slot lookup service is supported.", 
                  "body": "        A schedule sot lookup service defines methods to access schedule\n        slots."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - true if schedule slot lookup is supported,\n                false otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: true if schedule slot lookup is supported, false otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "supports_schedule_slot_query", 
               "doc": {
                  "headline": "Tests if a schedule slot query service is supported.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if schedule slot query is\n                supported, ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if schedule slot query is supported, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "supports_schedule_slot_search", 
               "doc": {
                  "headline": "Tests if a schedule slot search service is supported.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if schedule slots search is\n                supported, ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if schedule slots search is supported, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "supports_schedule_slot_admin", 
               "doc": {
                  "headline": "Tests if a schedule slot administrative service is supported.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if schedule slot admin is\n                supported, ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if schedule slot admin is supported, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "supports_schedule_slot_notification", 
               "doc": {
                  "headline": "Tests if schedule slot notification is supported.", 
                  "body": "        Messages may be sent when schedule slots are created, modified,\n        or deleted."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if schedule slot notification is\n                supported, ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if schedule slot notification is supported, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "supports_schedule_slot_calendar", 
               "doc": {
                  "headline": "Tests if a schedule slot to calendar lookup session is available.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if schedule slot calendar lookup\n                session is supported, ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if schedule slot calendar lookup session is supported, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "supports_schedule_slot_calendar_assignment", 
               "doc": {
                  "headline": "Tests if a schedule slot to calendar assignment session is available.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if schedule slot calendar\n                assignment is supported, ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if schedule slot calendar assignment is supported, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "supports_schedule_slot_smart_calendar", 
               "doc": {
                  "headline": "Tests if schedule slot smart calendaring is available.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if schedule slot smart calendaring\n                is supported, ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if schedule slot smart calendaring is supported, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "supports_commitment_lookup", 
               "doc": {
                  "headline": "Tests if an event commitment lookup service is supported.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if commitment lookup is supported,\n                ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if commitment lookup is supported, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "supports_commitment_query", 
               "doc": {
                  "headline": "Tests if a commitment query service is supported.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if commitment query is supported,\n                ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if commitment query is supported, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "supports_commitment_search", 
               "doc": {
                  "headline": "Tests if a commitment search service is supported.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if commitment search is supported,\n                ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if commitment search is supported, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "supports_commitment_admin", 
               "doc": {
                  "headline": "Tests if a commitment administrative service is supported.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if commitment admin is supported,\n                ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if commitment admin is supported, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "supports_commitment_notification", 
               "doc": {
                  "headline": "Tests if commitment notification is supported.", 
                  "body": "        Messages may be sent when commitments are created, modified, or\n        deleted."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if commitment notification is\n                supported ``,``  ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if commitment notification is supported ``,``  ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "supports_commitment_calendar", 
               "doc": {
                  "headline": "Tests if a commitment to calendar lookup session is available.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if commitment calendar lookup\n                session is supported, ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if commitment calendar lookup session is supported, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "supports_commitment_calendar_assignment", 
               "doc": {
                  "headline": "Tests if a commitment to calendar assignment session is available.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if commitment calendar assignment\n                is supported, ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if commitment calendar assignment is supported, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "supports_commitment_smart_calendar", 
               "doc": {
                  "headline": "Tests if commitment smart calendaring is available.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if commitment smart calendaring is\n                supported, ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if commitment smart calendaring is supported, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "supports_time_period_lookup", 
               "doc": {
                  "headline": "Tests if a time period lookup service is supported.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if time period lookup is supported,\n                ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if time period lookup is supported, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "supports_time_period_search", 
               "doc": {
                  "headline": "Tests if a time period search service is supported.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if time period search is supported,\n                ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if time period search is supported, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "supports_time_period_admin", 
               "doc": {
                  "headline": "Tests if a time period administrative service is supported.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if time period admin is supported,\n                ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if time period admin is supported, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "supports_time_period_notification", 
               "doc": {
                  "headline": "Tests if time period notification is supported.", 
                  "body": "        Messages may be sent when time periods are created, modified, or\n        deleted."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if time period notification is\n                supported ``,``  ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if time period notification is supported ``,``  ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "supports_time_period_calendar", 
               "doc": {
                  "headline": "Tests if a time period to calendar lookup session is available.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if time period calendar lookup\n                session is supported, ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if time period calendar lookup session is supported, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "supports_time_period_calendar_assignment", 
               "doc": {
                  "headline": "Tests if a time period to calendar assignment session is available.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if time period calendar assignment\n                is supported, ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if time period calendar assignment is supported, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "supports_time_period_smart_calendar", 
               "doc": {
                  "headline": "Tests if time period smart calendaring is available.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if time period smart calendaring is\n                supported, ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if time period smart calendaring is supported, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "supports_calendar_lookup", 
               "doc": {
                  "headline": "Tests if a calendar lookup service is supported.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if calendar lookup is supported,\n                ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if calendar lookup is supported, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "supports_calendar_search", 
               "doc": {
                  "headline": "Tests if a calendar search service is supported.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if calendar search is supported,\n                ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if calendar search is supported, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "supports_calendar_admin", 
               "doc": {
                  "headline": "Tests if a calendar administrative service is supported.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if calendar admin is supported,\n                ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if calendar admin is supported, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "supports_calendar_notification", 
               "doc": {
                  "headline": "Tests if calendar notification is supported.", 
                  "body": "        Messages may be sent when calendars are created, modified, or\n        deleted."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if calendar notification is\n                supported ``,``  ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if calendar notification is supported ``,``  ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "supports_calendar_hierarchy", 
               "doc": {
                  "headline": "Tests if a calendar hierarchy traversal is supported.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if a calendar hierarchy traversal\n                is supported, ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if a calendar hierarchy traversal is supported, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "supports_calendar_hierarchy_design", 
               "doc": {
                  "headline": "Tests if calendar hierarchy design is supported.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if a calendar hierarchy design is\n                supported, ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if a calendar hierarchy design is supported, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "supports_calendaring_batch", 
               "doc": {
                  "headline": "Tests if a calendaring batch subpackage is supported.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if a calendar batch package is\n                supported, ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if a calendar batch package is supported, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "supports_calendaring_cycle", 
               "doc": {
                  "headline": "Tests if a calendaring cycle subpackage is supported.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if a calendar cycle package is\n                supported, ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if a calendar cycle package is supported, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "supports_calendaring_rules", 
               "doc": {
                  "headline": "Tests if a calendaring rules subpackage is supported.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if a calendar rules package is\n                supported, ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if a calendar rules package is supported, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "get_event_record_types", 
               "doc": {
                  "headline": "Gets the supported ``Event`` record types.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.type.TypeList) - a list containing the supported\n                ``Event`` record types", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: a list containing the supported ``Event`` record types\n        :rtype: ``osid.type.TypeList``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.type.TypeList", 
               "errors": {}
            }, 
            {
               "name": "supports_event_record_type", 
               "doc": {
                  "headline": "Tests if the given ``Event`` record type is supported.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    event_record_type (osid.type.Type): a ``Type``\n                indicating an ``Event`` record type\n", 
               "return_doc": "        return: (boolean) - ``true`` if the given Type is supported,\n                ``false`` otherwise", 
               "error_doc": "        raise:  NullArgument - ``event_record_type`` is ``null``", 
               "sphinx_param_doc": "        :param event_record_type: a ``Type`` indicating an ``Event`` record type\n        :type event_record_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "        :return: ``true`` if the given Type is supported, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``event_record_type`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "event_record_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "boolean", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "get_event_search_record_types", 
               "doc": {
                  "headline": "Gets the supported ``Event`` search record types.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.type.TypeList) - a list containing the supported\n                ``Event`` search record types", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: a list containing the supported ``Event`` search record types\n        :rtype: ``osid.type.TypeList``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.type.TypeList", 
               "errors": {}
            }, 
            {
               "name": "supports_event_search_record_type", 
               "doc": {
                  "headline": "Tests if the given ``Event`` search record type is supported.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    event_search_record_type (osid.type.Type): a ``Type``\n                indicating an ``Event`` search record type\n", 
               "return_doc": "        return: (boolean) - ``true`` if the given Type is supported,\n                ``false`` otherwise", 
               "error_doc": "        raise:  NullArgument - ``event_search_record_type`` is ``null``", 
               "sphinx_param_doc": "        :param event_search_record_type: a ``Type`` indicating an ``Event`` search record type\n        :type event_search_record_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "        :return: ``true`` if the given Type is supported, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``event_search_record_type`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "event_search_record_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "boolean", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "get_recurring_event_record_types", 
               "doc": {
                  "headline": "Gets the supported ``RecurringEvent`` record types.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.type.TypeList) - a list containing the supported\n                ``RecurringEvent`` record types", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: a list containing the supported ``RecurringEvent`` record types\n        :rtype: ``osid.type.TypeList``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.type.TypeList", 
               "errors": {}
            }, 
            {
               "name": "supports_recurring_event_record_type", 
               "doc": {
                  "headline": "Tests if the given ``RecurringEvent`` record type is supported.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    recurring_event_record_type (osid.type.Type): a ``Type``\n                indicating a ``RecurringEvent`` record type\n", 
               "return_doc": "        return: (boolean) - ``true`` if the given Type is supported,\n                ``false`` otherwise", 
               "error_doc": "        raise:  NullArgument - ``recurring_event_record_type`` is\n                ``null``", 
               "sphinx_param_doc": "        :param recurring_event_record_type: a ``Type`` indicating a ``RecurringEvent`` record type\n        :type recurring_event_record_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "        :return: ``true`` if the given Type is supported, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``recurring_event_record_type`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "recurring_event_record_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "boolean", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "get_recurring_event_search_record_types", 
               "doc": {
                  "headline": "Gets the supported ``RecurringEvent`` search record types.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.type.TypeList) - a list containing the supported\n                ``RecurringEvent`` search record types", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: a list containing the supported ``RecurringEvent`` search record types\n        :rtype: ``osid.type.TypeList``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.type.TypeList", 
               "errors": {}
            }, 
            {
               "name": "supports_recurring_event_search_record_type", 
               "doc": {
                  "headline": "Tests if the given ``RecurringEvent`` search record type is supported.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    recurring_event_search_record_type (osid.type.Type): a\n                ``Type`` indicating a ``RecurringEvent`` search record\n                type\n", 
               "return_doc": "        return: (boolean) - ``true`` if the given Type is supported,\n                ``false`` otherwise", 
               "error_doc": "        raise:  NullArgument - ``recurring_event_search_record_type`` is\n                ``null``", 
               "sphinx_param_doc": "        :param recurring_event_search_record_type: a ``Type`` indicating a ``RecurringEvent`` search record type\n        :type recurring_event_search_record_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "        :return: ``true`` if the given Type is supported, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``recurring_event_search_record_type`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "recurring_event_search_record_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "boolean", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "get_superseding_event_record_types", 
               "doc": {
                  "headline": "Gets the supported ``Superseding`` record types.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.type.TypeList) - a list containing the supported\n                ``SupersedingEvent`` record types", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: a list containing the supported ``SupersedingEvent`` record types\n        :rtype: ``osid.type.TypeList``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.type.TypeList", 
               "errors": {}
            }, 
            {
               "name": "supports_superseding_event_record_type", 
               "doc": {
                  "headline": "Tests if the given ``SupersedingEvent`` record type is supported.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    superseding_event_record_type (osid.type.Type): a\n                ``Type`` indicating a ``SupersedingEvent`` record type\n", 
               "return_doc": "        return: (boolean) - ``true`` if the given Type is supported,\n                ``false`` otherwise", 
               "error_doc": "        raise:  NullArgument - ``superseding_event_record_type`` is\n                ``null``", 
               "sphinx_param_doc": "        :param superseding_event_record_type: a ``Type`` indicating a ``SupersedingEvent`` record type\n        :type superseding_event_record_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "        :return: ``true`` if the given Type is supported, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``superseding_event_record_type`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "superseding_event_record_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "boolean", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "get_superseding_event_search_record_types", 
               "doc": {
                  "headline": "Gets the supported ``SupersedingEvent`` search record types.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.type.TypeList) - a list containing the supported\n                ``SupersedingEvent`` search record types", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: a list containing the supported ``SupersedingEvent`` search record types\n        :rtype: ``osid.type.TypeList``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.type.TypeList", 
               "errors": {}
            }, 
            {
               "name": "supports_superseding_event_search_record_type", 
               "doc": {
                  "headline": "Tests if the given ``SupersedingEvent`` search record type is supported.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    superseding_event_search_record_type (osid.type.Type): a\n                ``Type`` indicating a ``SupersedingEvent`` search record\n                type\n", 
               "return_doc": "        return: (boolean) - ``true`` if the given Type is supported,\n                ``false`` otherwise", 
               "error_doc": "        raise:  NullArgument - ``superseding_event_search_record_type``\n                is ``null``", 
               "sphinx_param_doc": "        :param superseding_event_search_record_type: a ``Type`` indicating a ``SupersedingEvent`` search record type\n        :type superseding_event_search_record_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "        :return: ``true`` if the given Type is supported, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``superseding_event_search_record_type`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "superseding_event_search_record_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "boolean", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "get_offset_event_record_types", 
               "doc": {
                  "headline": "Gets the supported ``OffsetEvent`` record types.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.type.TypeList) - a list containing the supported\n                ``OffsetEvent`` record types", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: a list containing the supported ``OffsetEvent`` record types\n        :rtype: ``osid.type.TypeList``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.type.TypeList", 
               "errors": {}
            }, 
            {
               "name": "supports_offset_event_record_type", 
               "doc": {
                  "headline": "Tests if the given ``OffsetEvent`` record type is supported.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    offset_event_record_type (osid.type.Type): a ``Type``\n                indicating a ``OffsetEvent`` record type\n", 
               "return_doc": "        return: (boolean) - ``true`` if the given Type is supported,\n                ``false`` otherwise", 
               "error_doc": "        raise:  NullArgument - ``offset_event_record_type`` is ``null``", 
               "sphinx_param_doc": "        :param offset_event_record_type: a ``Type`` indicating a ``OffsetEvent`` record type\n        :type offset_event_record_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "        :return: ``true`` if the given Type is supported, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``offset_event_record_type`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "offset_event_record_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "boolean", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "get_offset_event_search_record_types", 
               "doc": {
                  "headline": "Gets the supported ``OffsetEvent`` search record types.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.type.TypeList) - a list containing the supported\n                ``OffsetEvent`` search record types", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: a list containing the supported ``OffsetEvent`` search record types\n        :rtype: ``osid.type.TypeList``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.type.TypeList", 
               "errors": {}
            }, 
            {
               "name": "supports_offset_event_search_record_type", 
               "doc": {
                  "headline": "Tests if the given ``OffsetEvent`` search record type is supported.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    offset_event_search_record_type (osid.type.Type): a\n                ``Type`` indicating a ``OffsetEvent`` search record type\n", 
               "return_doc": "        return: (boolean) - ``true`` if the given Type is supported,\n                ``false`` otherwise", 
               "error_doc": "        raise:  NullArgument - ``offset_event_search_record_type`` is\n                ``null``", 
               "sphinx_param_doc": "        :param offset_event_search_record_type: a ``Type`` indicating a ``OffsetEvent`` search record type\n        :type offset_event_search_record_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "        :return: ``true`` if the given Type is supported, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``offset_event_search_record_type`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "offset_event_search_record_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "boolean", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "get_schedule_record_types", 
               "doc": {
                  "headline": "Gets the supported ``Schedule`` record types.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.type.TypeList) - a list containing the supported\n                ``Schedule`` record types", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: a list containing the supported ``Schedule`` record types\n        :rtype: ``osid.type.TypeList``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.type.TypeList", 
               "errors": {}
            }, 
            {
               "name": "supports_schedule_record_type", 
               "doc": {
                  "headline": "Tests if the given ``Schedule`` record type is supported.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    schedule_record_type (osid.type.Type): a ``Type``\n                indicating a ``Schedule`` record type\n", 
               "return_doc": "        return: (boolean) - ``true`` if the given Type is supported,\n                ``false`` otherwise", 
               "error_doc": "        raise:  NullArgument - ``schedule_record_type`` is ``null``", 
               "sphinx_param_doc": "        :param schedule_record_type: a ``Type`` indicating a ``Schedule`` record type\n        :type schedule_record_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "        :return: ``true`` if the given Type is supported, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``schedule_record_type`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "schedule_record_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "boolean", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "get_schedule_search_record_types", 
               "doc": {
                  "headline": "Gets the supported ``Schedule`` search record types.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.type.TypeList) - a list containing the supported\n                ``Schedule`` search record types", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: a list containing the supported ``Schedule`` search record types\n        :rtype: ``osid.type.TypeList``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.type.TypeList", 
               "errors": {}
            }, 
            {
               "name": "supports_schedule_search_record_type", 
               "doc": {
                  "headline": "Tests if the given ``Schedule`` search record type is supported.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    schedule_search_record_type (osid.type.Type): a ``Type``\n                indicating a ``Schedule`` search record type\n", 
               "return_doc": "        return: (boolean) - ``true`` if the given Type is supported,\n                ``false`` otherwise", 
               "error_doc": "        raise:  NullArgument - ``schedule_search_record_type`` is\n                ``null``", 
               "sphinx_param_doc": "        :param schedule_search_record_type: a ``Type`` indicating a ``Schedule`` search record type\n        :type schedule_search_record_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "        :return: ``true`` if the given Type is supported, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``schedule_search_record_type`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "schedule_search_record_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "boolean", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "get_schedule_slot_record_types", 
               "doc": {
                  "headline": "Gets the supported ``ScheduleSlot`` record types.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.type.TypeList) - a list containing the supported\n                ``ScheduleSlot`` record types", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: a list containing the supported ``ScheduleSlot`` record types\n        :rtype: ``osid.type.TypeList``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.type.TypeList", 
               "errors": {}
            }, 
            {
               "name": "supports_schedule_slot_record_type", 
               "doc": {
                  "headline": "Tests if the given ``ScheduleSlot`` record type is supported.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    schedule_slot_record_type (osid.type.Type): a ``Type``\n                indicating a ``ScheduleSlot`` record type\n", 
               "return_doc": "        return: (boolean) - ``true`` if the given Type is supported,\n                ``false`` otherwise", 
               "error_doc": "        raise:  NullArgument - ``schedule_slot_record_type`` is ``null``", 
               "sphinx_param_doc": "        :param schedule_slot_record_type: a ``Type`` indicating a ``ScheduleSlot`` record type\n        :type schedule_slot_record_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "        :return: ``true`` if the given Type is supported, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``schedule_slot_record_type`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "schedule_slot_record_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "boolean", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "get_schedule_slot_search_record_types", 
               "doc": {
                  "headline": "Gets the supported ``ScheduleSlot`` search record types.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.type.TypeList) - a list containing the supported\n                ``ScheduleSlot`` search record types", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: a list containing the supported ``ScheduleSlot`` search record types\n        :rtype: ``osid.type.TypeList``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.type.TypeList", 
               "errors": {}
            }, 
            {
               "name": "supports_schedule_slot_search_record_type", 
               "doc": {
                  "headline": "Tests if the given ``ScheduleSlot`` search record type is supported.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    schedule_slot_search_record_type (osid.type.Type): a\n                ``Type`` indicating a ``ScheduleSlot`` search record\n                type\n", 
               "return_doc": "        return: (boolean) - ``true`` if the given Type is supported,\n                ``false`` otherwise", 
               "error_doc": "        raise:  NullArgument - ``schedule_slot_search_record_type`` is\n                ``null``", 
               "sphinx_param_doc": "        :param schedule_slot_search_record_type: a ``Type`` indicating a ``ScheduleSlot`` search record type\n        :type schedule_slot_search_record_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "        :return: ``true`` if the given Type is supported, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``schedule_slot_search_record_type`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "schedule_slot_search_record_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "boolean", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "get_time_period_record_types", 
               "doc": {
                  "headline": "Gets the supported ``TimePeriod`` record types.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.type.TypeList) - a list containing the supported\n                ``TimePeriod`` record types", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: a list containing the supported ``TimePeriod`` record types\n        :rtype: ``osid.type.TypeList``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.type.TypeList", 
               "errors": {}
            }, 
            {
               "name": "supports_time_period_record_type", 
               "doc": {
                  "headline": "Tests if the given ``TimePeriod`` record type is supported.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    time_period_record_type (osid.type.Type): a ``Type``\n                indicating a ``TimePeriod`` record type\n", 
               "return_doc": "        return: (boolean) - ``true`` if the given Type is supported,\n                ``false`` otherwise", 
               "error_doc": "        raise:  NullArgument - ``time_period_record_type`` is ``null``", 
               "sphinx_param_doc": "        :param time_period_record_type: a ``Type`` indicating a ``TimePeriod`` record type\n        :type time_period_record_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "        :return: ``true`` if the given Type is supported, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``time_period_record_type`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "time_period_record_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "boolean", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "get_time_period_search_record_types", 
               "doc": {
                  "headline": "Gets the supported ``TimePeriod`` search record types.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.type.TypeList) - a list containing the supported\n                ``TimePeriod`` search record types", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: a list containing the supported ``TimePeriod`` search record types\n        :rtype: ``osid.type.TypeList``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.type.TypeList", 
               "errors": {}
            }, 
            {
               "name": "supports_time_period_search_record_type", 
               "doc": {
                  "headline": "Tests if the given ``TimePeriod`` search record type is supported.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    time_period_search_record_type (osid.type.Type): a\n                ``Type`` indicating a ``TimePeriod`` search record type\n", 
               "return_doc": "        return: (boolean) - ``true`` if the given Type is supported,\n                ``false`` otherwise", 
               "error_doc": "        raise:  NullArgument - ``time_period_search_record_type`` is\n                ``null``", 
               "sphinx_param_doc": "        :param time_period_search_record_type: a ``Type`` indicating a ``TimePeriod`` search record type\n        :type time_period_search_record_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "        :return: ``true`` if the given Type is supported, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``time_period_search_record_type`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "time_period_search_record_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "boolean", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "get_commitment_record_types", 
               "doc": {
                  "headline": "Gets the supported ``Commitment`` record types.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.type.TypeList) - a list containing the supported\n                ``Commitment`` record types", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: a list containing the supported ``Commitment`` record types\n        :rtype: ``osid.type.TypeList``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.type.TypeList", 
               "errors": {}
            }, 
            {
               "name": "supports_commitment_record_type", 
               "doc": {
                  "headline": "Tests if the given ``Commitment`` record type is supported.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    commitment_record_type (osid.type.Type): a ``Type``\n                indicating a ``Commitment`` type\n", 
               "return_doc": "        return: (boolean) - ``true`` if the given commitment record\n                ``Type`` is supported, ``false`` otherwise", 
               "error_doc": "        raise:  NullArgument - ``commitment_record_type`` is ``null``", 
               "sphinx_param_doc": "        :param commitment_record_type: a ``Type`` indicating a ``Commitment`` type\n        :type commitment_record_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "        :return: ``true`` if the given commitment record ``Type`` is supported, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``commitment_record_type`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "commitment_record_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "boolean", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "get_commitment_search_record_types", 
               "doc": {
                  "headline": "Gets the supported commitment search record types.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.type.TypeList) - a list containing the supported\n                ``Commitment`` search record types", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: a list containing the supported ``Commitment`` search record types\n        :rtype: ``osid.type.TypeList``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.type.TypeList", 
               "errors": {}
            }, 
            {
               "name": "supports_commitment_search_record_type", 
               "doc": {
                  "headline": "Tests if the given commitment search record type is supported.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    commitment_search_record_type (osid.type.Type): a\n                ``Type`` indicating a ``Commitment`` search record type\n", 
               "return_doc": "        return: (boolean) - ``true`` if the given search record ``Type``\n                is supported, ``false`` otherwise", 
               "error_doc": "        raise:  NullArgument - ``commitment_search_record_type`` is\n                ``null``", 
               "sphinx_param_doc": "        :param commitment_search_record_type: a ``Type`` indicating a ``Commitment`` search record type\n        :type commitment_search_record_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "        :return: ``true`` if the given search record ``Type`` is supported, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``commitment_search_record_type`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "commitment_search_record_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "boolean", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "get_calendar_record_types", 
               "doc": {
                  "headline": "Gets the supported ``Calendar`` record types.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.type.TypeList) - a list containing the supported\n                ``Calendar`` record types", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: a list containing the supported ``Calendar`` record types\n        :rtype: ``osid.type.TypeList``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.type.TypeList", 
               "errors": {}
            }, 
            {
               "name": "supports_calendar_record_type", 
               "doc": {
                  "headline": "Tests if the given ``Calendar`` record type is supported.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    calendar_record_type (osid.type.Type): a ``Type``\n                indicating a ``Calendar`` type\n", 
               "return_doc": "        return: (boolean) - ``true`` if the given calendar record\n                ``Type`` is supported, ``false`` otherwise", 
               "error_doc": "        raise:  NullArgument - ``calendar_record_type`` is ``null``", 
               "sphinx_param_doc": "        :param calendar_record_type: a ``Type`` indicating a ``Calendar`` type\n        :type calendar_record_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "        :return: ``true`` if the given calendar record ``Type`` is supported, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``calendar_record_type`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "calendar_record_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "boolean", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "get_calendar_search_record_types", 
               "doc": {
                  "headline": "Gets the supported calendar search record types.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.type.TypeList) - a list containing the supported\n                ``Calendar`` search record types", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: a list containing the supported ``Calendar`` search record types\n        :rtype: ``osid.type.TypeList``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.type.TypeList", 
               "errors": {}
            }, 
            {
               "name": "supports_calendar_search_record_type", 
               "doc": {
                  "headline": "Tests if the given calendar search record type is supported.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    calendar_search_record_type (osid.type.Type): a ``Type``\n                indicating a ``Calendar`` search record type\n", 
               "return_doc": "        return: (boolean) - ``true`` if the given search record ``Type``\n                is supported, ``false`` otherwise", 
               "error_doc": "        raise:  NullArgument - ``calendar_search_record_type`` is\n                ``null``", 
               "sphinx_param_doc": "        :param calendar_search_record_type: a ``Type`` indicating a ``Calendar`` search record type\n        :type calendar_search_record_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "        :return: ``true`` if the given search record ``Type`` is supported, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``calendar_search_record_type`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "calendar_search_record_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "boolean", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "get_spatial_unit_record_types", 
               "doc": {
                  "headline": "Gets all the spatial unit record types supported.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.type.TypeList) - the list of supported spatial\n                unit record types", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the list of supported spatial unit record types\n        :rtype: ``osid.type.TypeList``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.type.TypeList", 
               "errors": {}
            }, 
            {
               "name": "supports_spatial_unit_record_type", 
               "doc": {
                  "headline": "Tests if a given spatial unit record type is supported.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    spatial_unit_record_type (osid.type.Type): the spatial\n                unit record type\n", 
               "return_doc": "        return: (boolean) - ``true`` if the spatial unit record type is\n                supported ``,``  ``false`` otherwise", 
               "error_doc": "        raise:  NullArgument - ``spatial_unit_record_type`` is ``null``", 
               "sphinx_param_doc": "        :param spatial_unit_record_type: the spatial unit record type\n        :type spatial_unit_record_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "        :return: ``true`` if the spatial unit record type is supported ``,``  ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``spatial_unit_record_type`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "spatial_unit_record_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "boolean", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "get_coordinate_record_types", 
               "doc": {
                  "headline": "Gets all the coordinate record types supported.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.type.TypeList) - the list of supported coordinate\n                record types", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the list of supported coordinate record types\n        :rtype: ``osid.type.TypeList``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.type.TypeList", 
               "errors": {}
            }, 
            {
               "name": "supports_coordinate_record_type", 
               "doc": {
                  "headline": "Tests if a given coordinate record type is supported.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    coordinate_record_type (osid.type.Type): the coordinate\n                domain type\n", 
               "return_doc": "        return: (boolean) - ``true`` if the coordinate record type is\n                supported ``,``  ``false`` otherwise", 
               "error_doc": "        raise:  NullArgument - ``coordinate_record_type`` is ``null``", 
               "sphinx_param_doc": "        :param coordinate_record_type: the coordinate domain type\n        :type coordinate_record_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "        :return: ``true`` if the coordinate record type is supported ``,``  ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``coordinate_record_type`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "coordinate_record_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "boolean", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.calendaring.CalendaringManager", 
         "shortname": "CalendaringManager", 
         "category": "managers", 
         "doc": {
            "headline": "The calendaring manager provides access to calendaring sessions and provides interoperability tests for various aspects of this service.", 
            "body": "    The sessions included in this manager are:\n\n      * ``EventLookupSession:`` a session to look up events\n      * ``EventQuerySession:`` a session to query events ``None``\n      * ``EventSearchSession:`` a session to search events\n      * ``EventAdminSession:`` a session to manage events ``None``\n      * ``EventNotificationSession: a`` session to receive messages\n        pertaining to event ```` changes\n      * ``EventCalendarSession:`` a session for retriieving event and\n        calendar mappings\n      * ``EventCalendarAssignmentSession:`` a session for managing event\n        and calendar mappings\n      * ``EventSmartCalendarSession:`` a session to manage dynamic event\n        catalogs\n      * ``RecurringEventLookupSession:`` a session to look up recurring\n        events\n      * ``RecurringEventQuerySession:`` a session to query recurring\n        events\n      * ``RecurringEventSearchSession:`` a session to search recurring\n        events\n      * ``RecurringEventAdminSession:`` a session to create, modify and\n        delete recurring event\n      * ``RecurringEventNotificationSession:`` a session to receive\n        messages pertaining to recurring event changes\n      * ``RecurringEventCalendarSession:`` a session for retriieving\n        recurring event and calendar mappings\n      * ``RecurringEventCalendarAssignmentSession:`` a session for\n        managing recurring event and calendar mappings\n      * ``RecurringEventSmartCalendarSession:`` a session to manage\n        dynamic recurring event catalogs\n    \n      * ``SupersedingEventLookupSession:`` a session to look up\n        superseding events\n      * ``SupersedingEventQuerySession:`` a session to query superseding\n        events ``None``\n      * ``SupersedingEventSearchSession:`` a session to search\n        superseding events\n      * ``SupersedingEventAdminSession:`` a session to create, modify\n        and delete superseding events ``None``\n      * ``SupersedingEventNotificationSession: a`` session to receive\n        messages pertaining to superseding event ```` changes\n      * ``SupersedingEventCalendarSession:`` a session for retriieving\n        superseding event and calendar mappings\n      * ``SupersedingEventCalendarAssignmentSession:`` a session for\n        managing superseding event and calendar mappings\n      * ``SupersedingEventSmartCalendarSession:`` a session to manage\n        dynamic superseding event catalogs\n      * ``OffsetEventLookupSession:`` a session to look up offset events\n      * ``OffsetEventQuerySession:`` a session to query offset events\n      * ``OffsetEventSearchSession:`` a session to search offset events\n      * ``OffsetEventAdminSession:`` a session to create, modify and\n        delete offset events\n      * ``OffsetEventNotificationSession:`` a session to receive\n        messages pertaining to offset event changes\n      * ``OffsetEventCalendarSession:`` a session for retriieving offset\n        event and calendar mappings\n      * ``OffsetEventCalendarAssignmentSession:`` a session for managing\n        offset event and calendar mappings\n      * ``OffsetEventSmartCalendarSession:`` a session to manage dynamic\n        offset event catalogs\n    \n      * ``ScheduleLookupSession:`` a session to look up schedules\n      * ``ScheduleQuerySession:`` a session to query schedules ``None``\n      * ``ScheduleSearchSession:`` a session to search schedules\n      * ``ScheduleAdminSession:`` a session to create, modify and delete\n        schedules ``None``\n      * ``ScheduleNotificationSession: a`` session to receive messages\n        pertaining to schedule ```` changes\n      * ``ScheduleCalendarSession:`` a session for retriieving schedule\n        and calendar mappings\n      * ``ScheduleCalendarAssignmentSession:`` a session for managing\n        schedule and calendar mappings\n      * ``ScheduleSmartCalendarSession:`` a session to manage dynamic\n        schedule catalogs\n      * ``ScheduleSlotLookupSession:`` a session to look up schedule\n        slots\n      * ``ScheduleSlotQuerySession:`` a session to query schedule slots\n      * ``ScheduleSlotSearchSession:`` a session to search scheduls\n        slots\n      * ``ScheduleSlotAdminSession:`` a session to create, modify and\n        delete schedule slots\n      * ``ScheduleSlotNotificationSession:`` a session to receive\n        messages pertaining to schedule slot changes\n      * ``ScheduleSlotCalendarSession:`` a session for retriieving\n        schedule slot and calendar mappings\n      * ``ScheduleSlotCalendarAssignmentSession:`` a session for\n        managing schedule slot and calendar mappings\n      * ``ScheduleSlotSmartCalendarSession:`` a session to manage\n        dynamic schedule slot catalogs\n    \n      * ``CommitmentLookupSession:`` a session to look up commitments\n      * ``CommitmentQuerySession:`` a session to query commitments\n        ``None``\n      * ``CommitmentSearchSession:`` a session to search commitments\n      * ``CommitmentAdminSession:`` a session to create, modify and\n        delete commitments ``None``\n      * ``CommitmentNotificationSession: a`` session to receive messages\n        pertaining to commitment changes\n      * ``CommitmentCalendarSession:`` a session for retriieving\n        commitment and calendar mappings\n      * ``CommitmentCalendarAssignmentSession:`` a session for managing\n        commitment and calendar mappings\n      * ``CommitmentSmartCalendarSession:`` a session to manage dynamic\n        commitment catalogs\n    \n      * ``TimePeriodLookupSession:`` a session to look up time periods\n      * ``TimePeriodQuerySession:`` a session to query time periods\n        ``None``\n      * ``TimePeriodSearchSession:`` a session to search time periods\n      * ``TimePeriodAdminSession:`` a session to create, modify and\n        delete time periods ``None``\n      * ``TimePeriodNotificationSession: a`` session to receive messages\n        pertaining to time period ```` changes\n      * ``TimePeriodCalendarSession:`` a session for retriieving time\n        period and calendar mappings\n      * ``TimePeriodCalendarAssignmentSession:`` a session for managing\n        time period and calendar mappings\n      * ``TimePeriodSmartCalendarSession:`` a session to manage dynamic\n        time period catalogs\n    \n      * ``CalendarLookupSession:`` a session to lookup calendars\n      * ``CalendarSearchSession`` : a session to search calendars\n      * ``CalendarAdminSession`` : a session to create, modify and\n        delete calendars\n      * ``CalendarNotificationSession`` : a session to receive messages\n        pertaining to calendar changes\n      * ``CalendarHierarchySession:`` a session to traverse the calendar\n        hierarchy\n      * ``CalendarHierarchyDesignSession:`` a session to manage the\n        calendar hierarchy\n"
         }, 
         "inherit_fullnames": [
            "osid.OsidManager", 
            "osid.calendaring.CalendaringProfile"
         ], 
         "inherit_shortnames": [
            "OsidManager", 
            "CalendaringProfile"
         ], 
         "inherit_pkg_names": [
            "osid", 
            "calendaring"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidManager"
            }, 
            {
               "pkg_name": "calendaring", 
               "name": "CalendaringProfile"
            }
         ], 
         "method_names": [
            "get_event_lookup_session", 
            "get_event_lookup_session_for_calendar", 
            "get_event_query_session", 
            "get_event_query_session_for_calendar", 
            "get_event_search_session", 
            "get_event_search_session_for_calendar", 
            "get_event_admin_session", 
            "get_event_admin_session_for_calendar", 
            "get_event_notification_session", 
            "get_event_notification_session_for_calendar", 
            "get_event_calendar_session", 
            "get_event_calendar_assignment_session", 
            "get_event_smart_calendar_session", 
            "get_recurring_event_lookup_session", 
            "get_recurring_event_lookup_session_for_calendar", 
            "get_recurring_event_query_session", 
            "get_recurring_event_query_session_for_calendar", 
            "get_recurring_event_search_session", 
            "get_recurring_event_search_session_for_calendar", 
            "get_recurring_event_admin_session", 
            "get_recurring_event_admin_session_for_calendar", 
            "get_recurring_event_notification_session", 
            "get_recurring_event_notification_session_for_calendar", 
            "get_recurring_event_calendar_session", 
            "get_recurring_event_calendar_assignment_session", 
            "get_recurring_event_smart_calendar_session", 
            "get_superseding_event_lookup_session", 
            "get_superseding_event_lookup_session_for_calendar", 
            "get_superseding_event_query_session", 
            "get_superseding_event_query_session_for_calendar", 
            "get_superseding_event_search_session", 
            "get_superseding_event_search_session_for_calendar", 
            "get_superseding_event_admin_session", 
            "get_superseding_event_admin_session_for_calendar", 
            "get_superseding_event_notification_session", 
            "get_superseding_event_notification_session_for_calendar", 
            "get_superseding_event_calendar_session", 
            "get_superseding_event_calendar_assignment_session", 
            "get_superseding_event_smart_calendar_session", 
            "get_offset_event_lookup_session", 
            "get_offset_event_lookup_session_for_calendar", 
            "get_offset_event_query_session", 
            "get_offset_event_query_session_for_calendar", 
            "get_offset_event_search_session", 
            "get_offset_event_search_session_for_calendar", 
            "get_offset_event_admin_session", 
            "get_offset_event_admin_session_for_calendar", 
            "get_offset_event_notification_session", 
            "get_offset_event_notification_session_for_calendar", 
            "get_offset_event_calendar_session", 
            "get_offset_event_calendar_assignment_session", 
            "get_offset_event_smart_calendar_session", 
            "get_schedule_lookup_session", 
            "get_schedule_lookup_session_for_calendar", 
            "get_schedule_query_session", 
            "get_schedule_query_session_for_calendar", 
            "get_schedule_search_session", 
            "get_schedule_search_session_for_calendar", 
            "get_schedule_admin_session", 
            "get_schedule_admin_session_for_calendar", 
            "get_schedule_notification_session", 
            "get_schedule_notification_session_for_calendar", 
            "get_schedule_calendar_session", 
            "get_schedule_calendar_assignment_session", 
            "get_schedule_smart_calendar_session", 
            "get_schedule_slot_lookup_session", 
            "get_schedule_slot_lookup_session_for_calendar", 
            "get_schedule_slot_query_session", 
            "get_schedule_slot_query_session_for_calendar", 
            "get_schedule_slot_search_session", 
            "get_schedule_slot_search_session_for_calendar", 
            "get_schedule_slot_admin_session", 
            "get_schedule_slot_admin_session_for_calendar", 
            "get_schedule_slot_notification_session", 
            "get_schedule_slot_notification_session_for_calendar", 
            "get_schedule_slot_calendar_session", 
            "get_schedule_slot_calendar_assignment_session", 
            "get_schedule_slot_smart_calendar_session", 
            "get_commitment_lookup_session", 
            "get_commitment_lookup_session_for_calendar", 
            "get_commitment_query_session", 
            "get_commitment_query_session_for_calendar", 
            "get_commitment_search_session", 
            "get_commitment_search_session_for_calendar", 
            "get_commitment_admin_session", 
            "get_commitment_admin_session_for_calendar", 
            "get_commitment_notification_session", 
            "get_commitment_notification_session_for_calendar", 
            "get_commitment_calendar_session", 
            "get_commitment_calendar_assignment_session", 
            "get_commitment_smart_calendar_session", 
            "get_time_period_lookup_session", 
            "get_time_period_lookup_session_for_calendar", 
            "get_time_period_query_session", 
            "get_time_period_query_session_for_calendar", 
            "get_time_period_search_session", 
            "get_time_period_search_session_for_calendar", 
            "get_time_period_admin_session", 
            "get_time_period_admin_session_for_calendar", 
            "get_time_period_notification_session", 
            "get_time_period_notification_session_for_calendar", 
            "get_time_period_calendar_session", 
            "get_time_period_calendar_assignment_session", 
            "get_time_period_smart_calendar_session", 
            "get_calendar_lookup_session", 
            "get_calendar_search_session", 
            "get_calendar_admin_session", 
            "get_calendar_notification_session", 
            "get_calendar_hierarchy_session", 
            "get_calendar_hierarchy_design_session", 
            "get_calandaring_batch_manager", 
            "get_calandaring_cycle_manager", 
            "get_calandaring_rules_manager"
         ], 
         "methods": [
            {
               "name": "get_event_lookup_session", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` associated with the event lookup service.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.EventLookupSession) - an\n                ``EventLookupSession``", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_event_lookup()`` is ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: an ``EventLookupSession``\n        :rtype: ``osid.calendaring.EventLookupSession``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_event_lookup()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_event_lookup()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.EventLookupSession", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_event_lookup_session_for_calendar", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` associated with the event lookup service for the given calendar.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    calendar_id (osid.id.Id): the ``Id`` of the calendar\n", 
               "return_doc": "        return: (osid.calendaring.EventLookupSession) - an\n                ``EventLookupSession``", 
               "error_doc": "        raise:  NotFound - ``calendar_id`` not found\n        raise:  NullArgument - ``calendar_id`` is ``null``\n        raise:  OperationFailed - ``unable to complete request``\n        raise:  Unimplemented - ``supports_event_lookup()`` or\n                ``supports_visible_federation()`` is ``false``", 
               "sphinx_param_doc": "        :param calendar_id: the ``Id`` of the calendar\n        :type calendar_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: an ``EventLookupSession``\n        :rtype: ``osid.calendaring.EventLookupSession``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``calendar_id`` not found\n        :raise: ``NullArgument`` -- ``calendar_id`` is ``null``\n        :raise: ``OperationFailed`` -- ``unable to complete request``\n        :raise: ``Unimplemented`` -- ``supports_event_lookup()`` or ``supports_visible_federation()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_event_lookup()`` and ``supports_visible_federation()`` are ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "calendar_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "osid.calendaring.EventLookupSession", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_event_query_session", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` associated with the event query service.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.EventQuerySession) - an\n                ``EventQuerySession``", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_event_query()`` is ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: an ``EventQuerySession``\n        :rtype: ``osid.calendaring.EventQuerySession``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_event_query()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_event_query()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.EventQuerySession", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_event_query_session_for_calendar", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` associated with the event query service for the given calendar.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    calendar_id (osid.id.Id): the ``Id`` of the calendar\n", 
               "return_doc": "        return: (osid.calendaring.EventQuerySession) - an\n                ``EventQuerySession``", 
               "error_doc": "        raise:  NotFound - ``calendar_id`` not found\n        raise:  NullArgument - ``calendar_id`` is ``null``\n        raise:  OperationFailed - ``unable to complete request``\n        raise:  Unimplemented - ``supports_event_query()`` or\n                ``supports_visible_federation()`` is ``false``", 
               "sphinx_param_doc": "        :param calendar_id: the ``Id`` of the calendar\n        :type calendar_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: an ``EventQuerySession``\n        :rtype: ``osid.calendaring.EventQuerySession``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``calendar_id`` not found\n        :raise: ``NullArgument`` -- ``calendar_id`` is ``null``\n        :raise: ``OperationFailed`` -- ``unable to complete request``\n        :raise: ``Unimplemented`` -- ``supports_event_query()`` or ``supports_visible_federation()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_event_query()`` and ``supports_visible_federation()`` are ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "calendar_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "osid.calendaring.EventQuerySession", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_event_search_session", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` associated with the event search service.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.EventSearchSession) - an\n                ``EventSearchSession``", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_event_search()`` is ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: an ``EventSearchSession``\n        :rtype: ``osid.calendaring.EventSearchSession``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_event_search()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_event_search()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.EventSearchSession", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_event_search_session_for_calendar", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` associated with the event search service for the given calendar.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    calendar_id (osid.id.Id): the ``Id`` of the calendar\n", 
               "return_doc": "        return: (osid.calendaring.EventSearchSession) - an\n                ``EventSearchSession``", 
               "error_doc": "        raise:  NotFound - ``calendar_id`` not found\n        raise:  NullArgument - ``calendar_id`` is ``null``\n        raise:  OperationFailed - ``unable to complete request``\n        raise:  Unimplemented - ``supports_event_search()`` or\n                ``supports_visible_federation()`` is ``false``", 
               "sphinx_param_doc": "        :param calendar_id: the ``Id`` of the calendar\n        :type calendar_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: an ``EventSearchSession``\n        :rtype: ``osid.calendaring.EventSearchSession``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``calendar_id`` not found\n        :raise: ``NullArgument`` -- ``calendar_id`` is ``null``\n        :raise: ``OperationFailed`` -- ``unable to complete request``\n        :raise: ``Unimplemented`` -- ``supports_event_search()`` or ``supports_visible_federation()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_event_search()`` and ``supports_visible_federation()`` are ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "calendar_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "osid.calendaring.EventSearchSession", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_event_admin_session", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` associated with the event administration service.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.EventAdminSession) - an\n                ``EventAdminSession``", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_event_admin()`` is ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: an ``EventAdminSession``\n        :rtype: ``osid.calendaring.EventAdminSession``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_event_admin()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_event_admin()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.EventAdminSession", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_event_admin_session_for_calendar", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` associated with the event admin service for the given calendar.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    calendar_id (osid.id.Id): the ``Id`` of the calendar\n", 
               "return_doc": "        return: (osid.calendaring.EventAdminSession) - an\n                ``EventAdminSession``", 
               "error_doc": "        raise:  NotFound - ``calendar_id`` not found\n        raise:  NullArgument - ``calendar_id`` is ``null``\n        raise:  OperationFailed - ``unable to complete request``\n        raise:  Unimplemented - ``supports_event_admin()`` or\n                ``supports_visible_federation()`` is ``false``", 
               "sphinx_param_doc": "        :param calendar_id: the ``Id`` of the calendar\n        :type calendar_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: an ``EventAdminSession``\n        :rtype: ``osid.calendaring.EventAdminSession``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``calendar_id`` not found\n        :raise: ``NullArgument`` -- ``calendar_id`` is ``null``\n        :raise: ``OperationFailed`` -- ``unable to complete request``\n        :raise: ``Unimplemented`` -- ``supports_event_admin()`` or ``supports_visible_federation()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_event_admin()`` and ``supports_visible_federation()`` are ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "calendar_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "osid.calendaring.EventAdminSession", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_event_notification_session", 
               "doc": {
                  "headline": "Gets the notification session for notifications pertaining to event changes.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    event_receiver (osid.calendaring.EventReceiver): the\n                event receiver\n", 
               "return_doc": "        return: (osid.calendaring.EventNotificationSession) - an\n                ``EventNotificationSession``", 
               "error_doc": "        raise:  NullArgument - ``event_receiver`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_event_notification()`` is\n                ``false``", 
               "sphinx_param_doc": "        :param event_receiver: the event receiver\n        :type event_receiver: ``osid.calendaring.EventReceiver``\n", 
               "sphinx_return_doc": "        :return: an ``EventNotificationSession``\n        :rtype: ``osid.calendaring.EventNotificationSession``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``event_receiver`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_event_notification()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_event_notification()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.calendaring.EventReceiver", 
                     "var_name": "event_receiver", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.calendaring.EventReceiver"
               ], 
               "return_type": "osid.calendaring.EventNotificationSession", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_event_notification_session_for_calendar", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` associated with the event notification service for the given calendar.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    event_receiver (osid.calendaring.EventReceiver): the\n                event receiver\n        arg:    calendar_id (osid.id.Id): the ``Id`` of the calendar\n", 
               "return_doc": "        return: (osid.calendaring.EventNotificationSession) - an\n                ``EventNotificationSession``", 
               "error_doc": "        raise:  NotFound - ``calendar_id`` not found\n        raise:  NullArgument - ``event_receiver`` or ``calendar_id`` is\n                ``null``\n        raise:  OperationFailed - ``unable to complete request``\n        raise:  Unimplemented - ``supports_event_notification()`` or\n                ``supports_visible_federation()`` is ``false``", 
               "sphinx_param_doc": "        :param event_receiver: the event receiver\n        :type event_receiver: ``osid.calendaring.EventReceiver``\n        :param calendar_id: the ``Id`` of the calendar\n        :type calendar_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: an ``EventNotificationSession``\n        :rtype: ``osid.calendaring.EventNotificationSession``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``calendar_id`` not found\n        :raise: ``NullArgument`` -- ``event_receiver`` or ``calendar_id`` is ``null``\n        :raise: ``OperationFailed`` -- ``unable to complete request``\n        :raise: ``Unimplemented`` -- ``supports_event_notification()`` or ``supports_visible_federation()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_event_notification()`` and ``supports_visible_federation()`` are ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.calendaring.EventReceiver", 
                     "var_name": "event_receiver", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "calendar_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.calendaring.EventReceiver", 
                  "osid.id.Id"
               ], 
               "return_type": "osid.calendaring.EventNotificationSession", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_event_calendar_session", 
               "doc": {
                  "headline": "Gets the session for retrieving event to calendar mappings.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.EventCalendarSession) - an\n                ``EventCalendarSession``", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_event_calendar()`` is\n                ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: an ``EventCalendarSession``\n        :rtype: ``osid.calendaring.EventCalendarSession``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_event_calendar()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_event_calendar()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.EventCalendarSession", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_event_calendar_assignment_session", 
               "doc": {
                  "headline": "Gets the session for assigning event to calendar mappings.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.EventCalendarAssignmentSession) - an\n                ``EventCalendarAssignmentSession``", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_event_calendar_assignment()``\n                is ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: an ``EventCalendarAssignmentSession``\n        :rtype: ``osid.calendaring.EventCalendarAssignmentSession``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_event_calendar_assignment()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_event_calendar_assignment()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.EventCalendarAssignmentSession", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_event_smart_calendar_session", 
               "doc": {
                  "headline": "Gets the session associated with the event smart calendar for the given calendar.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    calendar_id (osid.id.Id): the ``Id`` of the calendar\n", 
               "return_doc": "        return: (osid.calendaring.EventSmartCalendarSession) - an\n                ``EventSmartCalendarSession``", 
               "error_doc": "        raise:  NotFound - ``calendar_id`` not found\n        raise:  NullArgument - ``calendar_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_event_smart_calendar()`` is\n                ``false``", 
               "sphinx_param_doc": "        :param calendar_id: the ``Id`` of the calendar\n        :type calendar_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: an ``EventSmartCalendarSession``\n        :rtype: ``osid.calendaring.EventSmartCalendarSession``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``calendar_id`` not found\n        :raise: ``NullArgument`` -- ``calendar_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_event_smart_calendar()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_event_smart_calendar()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "calendar_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "osid.calendaring.EventSmartCalendarSession", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_recurring_event_lookup_session", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` associated with the recurring event lookup service.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.RecurringEventLookupSession) - a\n                ``RecurringEventLookupSession``", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_recurring_event_lookup()`` is\n                ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: a ``RecurringEventLookupSession``\n        :rtype: ``osid.calendaring.RecurringEventLookupSession``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_recurring_event_lookup()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_recurring_event_lookup()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.RecurringEventLookupSession", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_recurring_event_lookup_session_for_calendar", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` associated with the recurring event lookup service for the given calendar.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    calendar_id (osid.id.Id): the ``Id`` of the calendar\n", 
               "return_doc": "        return: (osid.calendaring.RecurringEventLookupSession) - a\n                ``RecurringEventLookupSession``", 
               "error_doc": "        raise:  NotFound - ``calendar_id`` not found\n        raise:  NullArgument - ``calendar_id`` is ``null``\n        raise:  OperationFailed - ``unable to complete request``\n        raise:  Unimplemented - ``supports_recurring_event_lookup()`` or\n                ``supports_visible_federation()`` is ``false``", 
               "sphinx_param_doc": "        :param calendar_id: the ``Id`` of the calendar\n        :type calendar_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: a ``RecurringEventLookupSession``\n        :rtype: ``osid.calendaring.RecurringEventLookupSession``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``calendar_id`` not found\n        :raise: ``NullArgument`` -- ``calendar_id`` is ``null``\n        :raise: ``OperationFailed`` -- ``unable to complete request``\n        :raise: ``Unimplemented`` -- ``supports_recurring_event_lookup()`` or ``supports_visible_federation()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_recurring_event_lookup()`` and ``supports_visible_federation()`` are ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "calendar_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "osid.calendaring.RecurringEventLookupSession", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_recurring_event_query_session", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` associated with the recurring event query service.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.RecurringEventQuerySession) - a\n                ``RecurringEventQuerySession``", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_recurring_event_query()`` is\n                ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: a ``RecurringEventQuerySession``\n        :rtype: ``osid.calendaring.RecurringEventQuerySession``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_recurring_event_query()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_recurring_event_query()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.RecurringEventQuerySession", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_recurring_event_query_session_for_calendar", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` associated with the recurring event query service for the given calendar.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    calendar_id (osid.id.Id): the ``Id`` of the calendar\n", 
               "return_doc": "        return: (osid.calendaring.RecurringEventQuerySession) - a\n                ``RecurringEventQuerySession``", 
               "error_doc": "        raise:  NotFound - ``calendar_id`` not found\n        raise:  NullArgument - ``calendar_id`` is ``null``\n        raise:  OperationFailed - ``unable to complete request``\n        raise:  Unimplemented - ``supports_recurring_event_query()`` or\n                ``supports_visible_federation()`` is ``false``", 
               "sphinx_param_doc": "        :param calendar_id: the ``Id`` of the calendar\n        :type calendar_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: a ``RecurringEventQuerySession``\n        :rtype: ``osid.calendaring.RecurringEventQuerySession``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``calendar_id`` not found\n        :raise: ``NullArgument`` -- ``calendar_id`` is ``null``\n        :raise: ``OperationFailed`` -- ``unable to complete request``\n        :raise: ``Unimplemented`` -- ``supports_recurring_event_query()`` or ``supports_visible_federation()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_recurring_event_query()`` and ``supports_visible_federation()`` are ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "calendar_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "osid.calendaring.RecurringEventQuerySession", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_recurring_event_search_session", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` associated with the recurring event search service.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.RecurringEventSearchSession) - a\n                ``RecurringEventSearchSession``", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_recurring_event_search()`` is\n                ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: a ``RecurringEventSearchSession``\n        :rtype: ``osid.calendaring.RecurringEventSearchSession``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_recurring_event_search()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_recurring_event_search()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.RecurringEventSearchSession", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_recurring_event_search_session_for_calendar", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` associated with the recurring event search service for the given calendar.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    calendar_id (osid.id.Id): the ``Id`` of the calendar\n", 
               "return_doc": "        return: (osid.calendaring.RecurringEventSearchSession) - a\n                ``RecurringEventSearchSession``", 
               "error_doc": "        raise:  NotFound - ``calendar_id`` not found\n        raise:  NullArgument - ``calendar_id`` is ``null``\n        raise:  OperationFailed - ``unable to complete request``\n        raise:  Unimplemented - ``supports_recurring_event_search()`` or\n                ``supports_visible_federation()`` is ``false``", 
               "sphinx_param_doc": "        :param calendar_id: the ``Id`` of the calendar\n        :type calendar_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: a ``RecurringEventSearchSession``\n        :rtype: ``osid.calendaring.RecurringEventSearchSession``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``calendar_id`` not found\n        :raise: ``NullArgument`` -- ``calendar_id`` is ``null``\n        :raise: ``OperationFailed`` -- ``unable to complete request``\n        :raise: ``Unimplemented`` -- ``supports_recurring_event_search()`` or ``supports_visible_federation()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_recurring_event_search()`` and ``supports_visible_federation()`` are ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "calendar_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "osid.calendaring.RecurringEventSearchSession", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_recurring_event_admin_session", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` associated with the recurring event administration service.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.RecurringEventAdminSession) - a\n                ``RecurringEventAdminSession``", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_recurring_event_admin()`` is\n                ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: a ``RecurringEventAdminSession``\n        :rtype: ``osid.calendaring.RecurringEventAdminSession``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_recurring_event_admin()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_recurring_event_admin()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.RecurringEventAdminSession", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_recurring_event_admin_session_for_calendar", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` associated with the recurring event admin service for the given calendar.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    calendar_id (osid.id.Id): the ``Id`` of the calendar\n", 
               "return_doc": "        return: (osid.calendaring.RecurringEventAdminSession) - a\n                ``RecurringEventAdminSession``", 
               "error_doc": "        raise:  NotFound - ``calendar_id`` not found\n        raise:  NullArgument - ``calendar_id`` is ``null``\n        raise:  OperationFailed - ``unable to complete request``\n        raise:  Unimplemented - ``supports_recurring_event_admin()`` or\n                ``supports_visible_federation()`` is ``false``", 
               "sphinx_param_doc": "        :param calendar_id: the ``Id`` of the calendar\n        :type calendar_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: a ``RecurringEventAdminSession``\n        :rtype: ``osid.calendaring.RecurringEventAdminSession``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``calendar_id`` not found\n        :raise: ``NullArgument`` -- ``calendar_id`` is ``null``\n        :raise: ``OperationFailed`` -- ``unable to complete request``\n        :raise: ``Unimplemented`` -- ``supports_recurring_event_admin()`` or ``supports_visible_federation()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_recurring_event_admin()`` and ``supports_visible_federation()`` are ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "calendar_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "osid.calendaring.RecurringEventAdminSession", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_recurring_event_notification_session", 
               "doc": {
                  "headline": "Gets the notification session for notifications pertaining to recurring event changes.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    recurring_event_receiver\n                (osid.calendaring.RecurringEventReceiver): the recurring\n                event receiver\n", 
               "return_doc": "        return: (osid.calendaring.RecurringEventNotificationSession) - a\n                ``RecurringEventNotificationSession``", 
               "error_doc": "        raise:  NullArgument - ``recurring_event_receiver`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented -\n                ``supports_recurring_event_notification()`` is ``false``", 
               "sphinx_param_doc": "        :param recurring_event_receiver: the recurring event receiver\n        :type recurring_event_receiver: ``osid.calendaring.RecurringEventReceiver``\n", 
               "sphinx_return_doc": "        :return: a ``RecurringEventNotificationSession``\n        :rtype: ``osid.calendaring.RecurringEventNotificationSession``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``recurring_event_receiver`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_recurring_event_notification()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_recurring_event_notification()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.calendaring.RecurringEventReceiver", 
                     "var_name": "recurring_event_receiver", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.calendaring.RecurringEventReceiver"
               ], 
               "return_type": "osid.calendaring.RecurringEventNotificationSession", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_recurring_event_notification_session_for_calendar", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` associated with the recurring event notification service for the given calendar.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    recurring_event_receiver\n                (osid.calendaring.RecurringEventReceiver): the recurring\n                event receiver\n        arg:    calendar_id (osid.id.Id): the ``Id`` of the calendar\n", 
               "return_doc": "        return: (osid.calendaring.RecurringEventNotificationSession) - a\n                ``RecurringEventNotificationSession``", 
               "error_doc": "        raise:  NotFound - ``calendar_id`` not found\n        raise:  NullArgument - ``recurring_event_receiver`` or\n                ``calendar_id`` is ``null``\n        raise:  OperationFailed - ``unable to complete request``\n        raise:  Unimplemented -\n                ``supports_recurring_event_notification()`` or\n                ``supports_visible_federation()`` is ``false``", 
               "sphinx_param_doc": "        :param recurring_event_receiver: the recurring event receiver\n        :type recurring_event_receiver: ``osid.calendaring.RecurringEventReceiver``\n        :param calendar_id: the ``Id`` of the calendar\n        :type calendar_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: a ``RecurringEventNotificationSession``\n        :rtype: ``osid.calendaring.RecurringEventNotificationSession``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``calendar_id`` not found\n        :raise: ``NullArgument`` -- ``recurring_event_receiver`` or ``calendar_id`` is ``null``\n        :raise: ``OperationFailed`` -- ``unable to complete request``\n        :raise: ``Unimplemented`` -- ``supports_recurring_event_notification()`` or ``supports_visible_federation()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_recurring_event_notification()`` and ``supports_visible_federation()`` are ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.calendaring.RecurringEventReceiver", 
                     "var_name": "recurring_event_receiver", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "calendar_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.calendaring.RecurringEventReceiver", 
                  "osid.id.Id"
               ], 
               "return_type": "osid.calendaring.RecurringEventNotificationSession", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_recurring_event_calendar_session", 
               "doc": {
                  "headline": "Gets the session for retrieving recurring event to calendar mappings.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.RecurringEventCalendarSession) - A\n                ``RecurringEventCalendarSession``", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_recurring_event_calendar()``\n                is ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: A ``RecurringEventCalendarSession``\n        :rtype: ``osid.calendaring.RecurringEventCalendarSession``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_recurring_event_calendar()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_recurring_event_calendar()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.RecurringEventCalendarSession", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_recurring_event_calendar_assignment_session", 
               "doc": {
                  "headline": "Gets the session for assigning recurring event to calendar mappings.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return:\n                (osid.calendaring.RecurringEventCalendarAssignmentSessio\n                n) - a ``RecurringEventCalendarAssignmentSession``", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented -\n                ``supports_recurring_event_calendar_assignment()`` is\n                ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: a ``RecurringEventCalendarAssignmentSession``\n        :rtype: ``osid.calendaring.RecurringEventCalendarAssignmentSession``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_recurring_event_calendar_assignment()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_recurring_event_calendar_assignment()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.RecurringEventCalendarAssignmentSession", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_recurring_event_smart_calendar_session", 
               "doc": {
                  "headline": "Gets the session associated with the recurring event smart calendar for the given calendar.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    calendar_id (osid.id.Id): the ``Id`` of the calendar\n", 
               "return_doc": "        return: (osid.calendaring.RecurringEventSmartCalendarSession) -\n                a ``RecurringEventSmartCalendarSession``", 
               "error_doc": "        raise:  NotFound - ``calendar_id`` not found\n        raise:  NullArgument - ``calendar_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented -\n                ``supports_recurring_event_smart_calendar()`` is\n                ``false``", 
               "sphinx_param_doc": "        :param calendar_id: the ``Id`` of the calendar\n        :type calendar_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: a ``RecurringEventSmartCalendarSession``\n        :rtype: ``osid.calendaring.RecurringEventSmartCalendarSession``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``calendar_id`` not found\n        :raise: ``NullArgument`` -- ``calendar_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_recurring_event_smart_calendar()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_recurring_event_smart_calendar()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "calendar_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "osid.calendaring.RecurringEventSmartCalendarSession", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_superseding_event_lookup_session", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` associated with the superseding event lookup service.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.SupersedingEventLookupSession) - a\n                ``SupersedingEventLookupSession``", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_event_lookup()`` is ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: a ``SupersedingEventLookupSession``\n        :rtype: ``osid.calendaring.SupersedingEventLookupSession``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_event_lookup()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_superseding_event_lookup()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.SupersedingEventLookupSession", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_superseding_event_lookup_session_for_calendar", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` associated with the superseding event lookup service for the given calendar.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    calendar_id (osid.id.Id): the ``Id`` of the calendar\n", 
               "return_doc": "        return: (osid.calendaring.SupersedingEventLookupSession) - a\n                ``SupersedingEventLookupSession``", 
               "error_doc": "        raise:  NotFound - ``calendar_id`` not found\n        raise:  NullArgument - ``calendar_id`` is ``null``\n        raise:  OperationFailed - ``unable to complete request``\n        raise:  Unimplemented - ``supports_superseding_event_lookup()``\n                or ``supports_visible_federation()`` is ``false``", 
               "sphinx_param_doc": "        :param calendar_id: the ``Id`` of the calendar\n        :type calendar_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: a ``SupersedingEventLookupSession``\n        :rtype: ``osid.calendaring.SupersedingEventLookupSession``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``calendar_id`` not found\n        :raise: ``NullArgument`` -- ``calendar_id`` is ``null``\n        :raise: ``OperationFailed`` -- ``unable to complete request``\n        :raise: ``Unimplemented`` -- ``supports_superseding_event_lookup()`` or ``supports_visible_federation()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_superseding_event_lookup()`` and ``supports_visible_federation()`` are ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "calendar_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "osid.calendaring.SupersedingEventLookupSession", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_superseding_event_query_session", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` associated with the superseding event query service.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.SupersedingEventQuerySession) - a\n                ``SupersedingEventQuerySession``", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_superseding_event_query()``\n                is ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: a ``SupersedingEventQuerySession``\n        :rtype: ``osid.calendaring.SupersedingEventQuerySession``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_superseding_event_query()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_superseding_event_query()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.SupersedingEventQuerySession", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_superseding_event_query_session_for_calendar", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` associated with the superseding event query service for the given calendar.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    calendar_id (osid.id.Id): the ``Id`` of the calendar\n", 
               "return_doc": "        return: (osid.calendaring.SupersedingEventQuerySession) - a\n                ``SupersedingEventQuerySession``", 
               "error_doc": "        raise:  NotFound - ``calendar_id`` not found\n        raise:  NullArgument - ``calendar_id`` is ``null``\n        raise:  OperationFailed - ``unable to complete request``\n        raise:  Unimplemented - ``supports_superseding_event_query()``\n                or ``supports_visible_federation()`` is ``false``", 
               "sphinx_param_doc": "        :param calendar_id: the ``Id`` of the calendar\n        :type calendar_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: a ``SupersedingEventQuerySession``\n        :rtype: ``osid.calendaring.SupersedingEventQuerySession``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``calendar_id`` not found\n        :raise: ``NullArgument`` -- ``calendar_id`` is ``null``\n        :raise: ``OperationFailed`` -- ``unable to complete request``\n        :raise: ``Unimplemented`` -- ``supports_superseding_event_query()`` or ``supports_visible_federation()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_superseding_event_query()`` and ``supports_visible_federation()`` are ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "calendar_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "osid.calendaring.SupersedingEventQuerySession", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_superseding_event_search_session", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` associated with the superseding event search service.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.SupersedingEventSearchSession) - a\n                ``SupersedingEventSearchSession``", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_event_search()`` is ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: a ``SupersedingEventSearchSession``\n        :rtype: ``osid.calendaring.SupersedingEventSearchSession``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_event_search()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_event_search()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.SupersedingEventSearchSession", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_superseding_event_search_session_for_calendar", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` associated with the superseding event search service for the given calendar.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    calendar_id (osid.id.Id): the ``Id`` of the calendar\n", 
               "return_doc": "        return: (osid.calendaring.SupersedingEventSearchSession) - a\n                ``SupersedingEventSearchSession``", 
               "error_doc": "        raise:  NotFound - ``calendar_id`` not found\n        raise:  NullArgument - ``calendar_id`` is ``null``\n        raise:  OperationFailed - ``unable to complete request``\n        raise:  Unimplemented - ``supports_superseding_event_search()``\n                or ``supports_visible_federation()`` is ``false``", 
               "sphinx_param_doc": "        :param calendar_id: the ``Id`` of the calendar\n        :type calendar_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: a ``SupersedingEventSearchSession``\n        :rtype: ``osid.calendaring.SupersedingEventSearchSession``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``calendar_id`` not found\n        :raise: ``NullArgument`` -- ``calendar_id`` is ``null``\n        :raise: ``OperationFailed`` -- ``unable to complete request``\n        :raise: ``Unimplemented`` -- ``supports_superseding_event_search()`` or ``supports_visible_federation()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_superseding_event_search()`` and ``supports_visible_federation()`` are ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "calendar_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "osid.calendaring.SupersedingEventSearchSession", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_superseding_event_admin_session", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` associated with the superseding event administration service.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.SupersedingEventAdminSession) - a\n                ``SupersedingEventAdminSession``", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_event_admin()`` is ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: a ``SupersedingEventAdminSession``\n        :rtype: ``osid.calendaring.SupersedingEventAdminSession``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_event_admin()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_superseding_event_admin()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.SupersedingEventAdminSession", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_superseding_event_admin_session_for_calendar", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` associated with the superseding event admin service for the given calendar.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    calendar_id (osid.id.Id): the ``Id`` of the calendar\n", 
               "return_doc": "        return: (osid.calendaring.SupersedingEventAdminSession) - a\n                ``SupersedingEventAdminSession``", 
               "error_doc": "        raise:  NotFound - ``calendar_id`` not found\n        raise:  NullArgument - ``calendar_id`` is ``null``\n        raise:  OperationFailed - ``unable to complete request``\n        raise:  Unimplemented - ``supports_superseding_event_admin()``\n                or ``supports_visible_federation()`` is ``false``", 
               "sphinx_param_doc": "        :param calendar_id: the ``Id`` of the calendar\n        :type calendar_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: a ``SupersedingEventAdminSession``\n        :rtype: ``osid.calendaring.SupersedingEventAdminSession``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``calendar_id`` not found\n        :raise: ``NullArgument`` -- ``calendar_id`` is ``null``\n        :raise: ``OperationFailed`` -- ``unable to complete request``\n        :raise: ``Unimplemented`` -- ``supports_superseding_event_admin()`` or ``supports_visible_federation()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_superseding_event_admin()`` and ``supports_visible_federation()`` are ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "calendar_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "osid.calendaring.SupersedingEventAdminSession", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_superseding_event_notification_session", 
               "doc": {
                  "headline": "Gets the notification session for notifications pertaining to superseding event changes.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    superseding_event_receiver\n                (osid.calendaring.SupersedingEventReceiver): the\n                superseding event receiver\n", 
               "return_doc": "        return: (osid.calendaring.SupersedingEventNotificationSession) -\n                a ``SupersedingEventNotificationSession``", 
               "error_doc": "        raise:  NullArgument - ``superseding_event_receiver`` is\n                ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented -\n                ``supports_superseding_event_notification()`` is\n                ``false``", 
               "sphinx_param_doc": "        :param superseding_event_receiver: the superseding event receiver\n        :type superseding_event_receiver: ``osid.calendaring.SupersedingEventReceiver``\n", 
               "sphinx_return_doc": "        :return: a ``SupersedingEventNotificationSession``\n        :rtype: ``osid.calendaring.SupersedingEventNotificationSession``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``superseding_event_receiver`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_superseding_event_notification()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_superseding_event_notification()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.calendaring.SupersedingEventReceiver", 
                     "var_name": "superseding_event_receiver", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.calendaring.SupersedingEventReceiver"
               ], 
               "return_type": "osid.calendaring.SupersedingEventNotificationSession", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_superseding_event_notification_session_for_calendar", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` associated with the superseding event notification service for the given calendar.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    superseding_event_receiver\n                (osid.calendaring.SupersedingEventReceiver): the\n                superseding event receiver\n        arg:    calendar_id (osid.id.Id): the ``Id`` of the calendar\n", 
               "return_doc": "        return: (osid.calendaring.SupersedingEventNotificationSession) -\n                a ``SupersedingEventNotificationSession``", 
               "error_doc": "        raise:  NotFound - ``calendar_id`` not found\n        raise:  NullArgument - ``superseding_event_receiver`` or\n                ``calendar_id`` is ``null``\n        raise:  OperationFailed - ``unable to complete request``\n        raise:  Unimplemented -\n                ``supports_superseding_event_notification()`` or\n                ``supports_visible_federation()`` is ``false``", 
               "sphinx_param_doc": "        :param superseding_event_receiver: the superseding event receiver\n        :type superseding_event_receiver: ``osid.calendaring.SupersedingEventReceiver``\n        :param calendar_id: the ``Id`` of the calendar\n        :type calendar_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: a ``SupersedingEventNotificationSession``\n        :rtype: ``osid.calendaring.SupersedingEventNotificationSession``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``calendar_id`` not found\n        :raise: ``NullArgument`` -- ``superseding_event_receiver`` or ``calendar_id`` is ``null``\n        :raise: ``OperationFailed`` -- ``unable to complete request``\n        :raise: ``Unimplemented`` -- ``supports_superseding_event_notification()`` or ``supports_visible_federation()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_superseding_event_notification()`` and ``supports_visible_federation()`` are ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.calendaring.SupersedingEventReceiver", 
                     "var_name": "superseding_event_receiver", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "calendar_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.calendaring.SupersedingEventReceiver", 
                  "osid.id.Id"
               ], 
               "return_type": "osid.calendaring.SupersedingEventNotificationSession", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_superseding_event_calendar_session", 
               "doc": {
                  "headline": "Gets the session for retrieving superseding event to calendar mappings.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.SupersedingEventCalendarSession) - a\n                ``SupersedingEventCalendarSession``", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented -\n                ``supports_superseding_event_calendar()`` is ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: a ``SupersedingEventCalendarSession``\n        :rtype: ``osid.calendaring.SupersedingEventCalendarSession``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_superseding_event_calendar()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_superseding_event_calendar()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.SupersedingEventCalendarSession", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_superseding_event_calendar_assignment_session", 
               "doc": {
                  "headline": "Gets the session for assigning superseding event to calendar mappings.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return:\n                (osid.calendaring.SupersedingEventCalendarAssignmentSess\n                ion) - a ``SupersedingEventCalendarAssignmentSession``", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented -\n                ``supports_superseding_event_calendar_assignment()`` is\n                ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: a ``SupersedingEventCalendarAssignmentSession``\n        :rtype: ``osid.calendaring.SupersedingEventCalendarAssignmentSession``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_superseding_event_calendar_assignment()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_superseding_event_calendar_assignment()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.SupersedingEventCalendarAssignmentSession", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_superseding_event_smart_calendar_session", 
               "doc": {
                  "headline": "Gets the session associated with the superseding event smart calendar for the given calendar.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    calendar_id (osid.id.Id): the ``Id`` of the calendar\n", 
               "return_doc": "        return: (osid.calendaring.SupersedingEventSmartCalendarSession)\n                - a ``SupersedingEventSmartCalendarSession``", 
               "error_doc": "        raise:  NotFound - ``calendar_id`` not found\n        raise:  NullArgument - ``calendar_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented -\n                ``supports_superseding_event_smart_calendar()`` is\n                ``false``", 
               "sphinx_param_doc": "        :param calendar_id: the ``Id`` of the calendar\n        :type calendar_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: a ``SupersedingEventSmartCalendarSession``\n        :rtype: ``osid.calendaring.SupersedingEventSmartCalendarSession``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``calendar_id`` not found\n        :raise: ``NullArgument`` -- ``calendar_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_superseding_event_smart_calendar()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_superseding_event_smart_calendar()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "calendar_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "osid.calendaring.SupersedingEventSmartCalendarSession", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_offset_event_lookup_session", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` associated with the offset event lookup service.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.OffsetEventLookupSession) - an\n                ``OffsetEventLookupSession``", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_offset_event_lookup()`` is\n                ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: an ``OffsetEventLookupSession``\n        :rtype: ``osid.calendaring.OffsetEventLookupSession``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_offset_event_lookup()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_offset_event_lookup()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.OffsetEventLookupSession", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_offset_event_lookup_session_for_calendar", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` associated with the offset event lookup service for the given calendar.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    calendar_id (osid.id.Id): the ``Id`` of the calendar\n", 
               "return_doc": "        return: (osid.calendaring.OffsetEventLookupSession) - an\n                ``OffsetEventLookupSession``", 
               "error_doc": "        raise:  NotFound - ``calendar_id`` not found\n        raise:  NullArgument - ``calendar_id`` is ``null``\n        raise:  OperationFailed - ``unable to complete request``\n        raise:  Unimplemented - ``supports_offset_event_lookup()`` or\n                ``supports_visible_federation()`` is ``false``", 
               "sphinx_param_doc": "        :param calendar_id: the ``Id`` of the calendar\n        :type calendar_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: an ``OffsetEventLookupSession``\n        :rtype: ``osid.calendaring.OffsetEventLookupSession``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``calendar_id`` not found\n        :raise: ``NullArgument`` -- ``calendar_id`` is ``null``\n        :raise: ``OperationFailed`` -- ``unable to complete request``\n        :raise: ``Unimplemented`` -- ``supports_offset_event_lookup()`` or ``supports_visible_federation()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_offset_event_lookup()`` and ``supports_visible_federation()`` are ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "calendar_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "osid.calendaring.OffsetEventLookupSession", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_offset_event_query_session", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` associated with the offset event query service.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.OffsetEventQuerySession) - an\n                ``OffsetEventQuerySession``", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_offset_event_query()`` is\n                ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: an ``OffsetEventQuerySession``\n        :rtype: ``osid.calendaring.OffsetEventQuerySession``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_offset_event_query()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_offset_event_query()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.OffsetEventQuerySession", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_offset_event_query_session_for_calendar", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` associated with the offset event query service for the given calendar.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    calendar_id (osid.id.Id): the ``Id`` of the calendar\n", 
               "return_doc": "        return: (osid.calendaring.OffsetEventQuerySession) - an\n                ``OffsetEventQuerySession``", 
               "error_doc": "        raise:  NotFound - ``calendar_id`` not found\n        raise:  NullArgument - ``calendar_id`` is ``null``\n        raise:  OperationFailed - ``unable to complete request``\n        raise:  Unimplemented - ``supports_offset_event_query()`` or\n                ``supports_visible_federation()`` is ``false``", 
               "sphinx_param_doc": "        :param calendar_id: the ``Id`` of the calendar\n        :type calendar_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: an ``OffsetEventQuerySession``\n        :rtype: ``osid.calendaring.OffsetEventQuerySession``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``calendar_id`` not found\n        :raise: ``NullArgument`` -- ``calendar_id`` is ``null``\n        :raise: ``OperationFailed`` -- ``unable to complete request``\n        :raise: ``Unimplemented`` -- ``supports_offset_event_query()`` or ``supports_visible_federation()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_offset_event_query()`` and ``supports_visible_federation()`` are ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "calendar_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "osid.calendaring.OffsetEventQuerySession", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_offset_event_search_session", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` associated with the offset event search service.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.OffsetEventSearchSession) - an\n                ``OffsetEventSearchSession``", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_offset_event_search()`` is\n                ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: an ``OffsetEventSearchSession``\n        :rtype: ``osid.calendaring.OffsetEventSearchSession``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_offset_event_search()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_offset_event_search()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.OffsetEventSearchSession", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_offset_event_search_session_for_calendar", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` associated with the offset event search service for the given calendar.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    calendar_id (osid.id.Id): the ``Id`` of the calendar\n", 
               "return_doc": "        return: (osid.calendaring.OffsetEventSearchSession) - an\n                ``OffsetEventSearchSession``", 
               "error_doc": "        raise:  NotFound - ``calendar_id`` not found\n        raise:  NullArgument - ``calendar_id`` is ``null``\n        raise:  OperationFailed - ``unable to complete request``\n        raise:  Unimplemented - ``supports_offset_event_search()`` or\n                ``supports_visible_federation()`` is ``false``", 
               "sphinx_param_doc": "        :param calendar_id: the ``Id`` of the calendar\n        :type calendar_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: an ``OffsetEventSearchSession``\n        :rtype: ``osid.calendaring.OffsetEventSearchSession``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``calendar_id`` not found\n        :raise: ``NullArgument`` -- ``calendar_id`` is ``null``\n        :raise: ``OperationFailed`` -- ``unable to complete request``\n        :raise: ``Unimplemented`` -- ``supports_offset_event_search()`` or ``supports_visible_federation()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_offset_event_search()`` and ``supports_visible_federation()`` are ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "calendar_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "osid.calendaring.OffsetEventSearchSession", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_offset_event_admin_session", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` associated with the offset event administration service.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.OffsetEventAdminSession) - an\n                ``OffsetEventAdminSession``", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_offset_event_admin()`` is\n                ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: an ``OffsetEventAdminSession``\n        :rtype: ``osid.calendaring.OffsetEventAdminSession``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_offset_event_admin()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_offset_event_admin()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.OffsetEventAdminSession", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_offset_event_admin_session_for_calendar", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` associated with the offset event admin service for the given calendar.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    calendar_id (osid.id.Id): the ``Id`` of the calendar\n", 
               "return_doc": "        return: (osid.calendaring.OffsetEventAdminSession) - an\n                ``OffsetEventAdminSession``", 
               "error_doc": "        raise:  NotFound - ``calendar_id`` not found\n        raise:  NullArgument - ``calendar_id`` is ``null``\n        raise:  OperationFailed - ``unable to complete request``\n        raise:  Unimplemented - ``supports_offset_event_admin()`` or\n                ``supports_visible_federation()`` is ``false``", 
               "sphinx_param_doc": "        :param calendar_id: the ``Id`` of the calendar\n        :type calendar_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: an ``OffsetEventAdminSession``\n        :rtype: ``osid.calendaring.OffsetEventAdminSession``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``calendar_id`` not found\n        :raise: ``NullArgument`` -- ``calendar_id`` is ``null``\n        :raise: ``OperationFailed`` -- ``unable to complete request``\n        :raise: ``Unimplemented`` -- ``supports_offset_event_admin()`` or ``supports_visible_federation()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_offset_event_admin()`` and ``supports_visible_federation()`` are ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "calendar_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "osid.calendaring.OffsetEventAdminSession", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_offset_event_notification_session", 
               "doc": {
                  "headline": "Gets the notification session for notifications pertaining to offset event changes.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    offset_event_receiver\n                (osid.calendaring.OffsetEventReceiver): the offset event\n                receiver\n", 
               "return_doc": "        return: (osid.calendaring.OffsetEventNotificationSession) - an\n                ``OffsetEventNotificationSession``", 
               "error_doc": "        raise:  NullArgument - ``offset_event_receiver`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_offset_event_notification()``\n                is ``false``", 
               "sphinx_param_doc": "        :param offset_event_receiver: the offset event receiver\n        :type offset_event_receiver: ``osid.calendaring.OffsetEventReceiver``\n", 
               "sphinx_return_doc": "        :return: an ``OffsetEventNotificationSession``\n        :rtype: ``osid.calendaring.OffsetEventNotificationSession``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``offset_event_receiver`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_offset_event_notification()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_offset_event_notification()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.calendaring.OffsetEventReceiver", 
                     "var_name": "offset_event_receiver", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.calendaring.OffsetEventReceiver"
               ], 
               "return_type": "osid.calendaring.OffsetEventNotificationSession", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_offset_event_notification_session_for_calendar", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` associated with the offset event notification service for the given calendar.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    offset_event_receiver\n                (osid.calendaring.OffsetEventReceiver): the offset event\n                receiver\n        arg:    calendar_id (osid.id.Id): the ``Id`` of the calendar\n", 
               "return_doc": "        return: (osid.calendaring.OffsetEventNotificationSession) - an\n                ``OffsetEventNotificationSession``", 
               "error_doc": "        raise:  NotFound - ``calendar_id`` not found\n        raise:  NullArgument - ``offset_event_receiver`` or\n                ``calendar_id`` is ``null``\n        raise:  OperationFailed - ``unable to complete request``\n        raise:  Unimplemented - ``supports_offset_event_notification()``\n                or ``supports_visible_federation()`` is ``false``", 
               "sphinx_param_doc": "        :param offset_event_receiver: the offset event receiver\n        :type offset_event_receiver: ``osid.calendaring.OffsetEventReceiver``\n        :param calendar_id: the ``Id`` of the calendar\n        :type calendar_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: an ``OffsetEventNotificationSession``\n        :rtype: ``osid.calendaring.OffsetEventNotificationSession``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``calendar_id`` not found\n        :raise: ``NullArgument`` -- ``offset_event_receiver`` or ``calendar_id`` is ``null``\n        :raise: ``OperationFailed`` -- ``unable to complete request``\n        :raise: ``Unimplemented`` -- ``supports_offset_event_notification()`` or ``supports_visible_federation()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_offset_event_notification()`` and ``supports_visible_federation()`` are ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.calendaring.OffsetEventReceiver", 
                     "var_name": "offset_event_receiver", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "calendar_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.calendaring.OffsetEventReceiver", 
                  "osid.id.Id"
               ], 
               "return_type": "osid.calendaring.OffsetEventNotificationSession", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_offset_event_calendar_session", 
               "doc": {
                  "headline": "Gets the session for retrieving offset event to calendar mappings.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.OffsetEventCalendarSession) - an\n                ``OffsetEventCalendarSession``", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_offset_event_calendar()`` is\n                ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: an ``OffsetEventCalendarSession``\n        :rtype: ``osid.calendaring.OffsetEventCalendarSession``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_offset_event_calendar()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_offset_event_calendar()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.OffsetEventCalendarSession", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_offset_event_calendar_assignment_session", 
               "doc": {
                  "headline": "Gets the session for assigning offset event to calendar mappings.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.OffsetEventCalendarAssignmentSession)\n                - an ``OffsetEventCalendarAssignmentSession``", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented -\n                ``supports_offset_event_calendar_assignment()`` is\n                ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: an ``OffsetEventCalendarAssignmentSession``\n        :rtype: ``osid.calendaring.OffsetEventCalendarAssignmentSession``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_offset_event_calendar_assignment()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_offset_event_calendar_assignment()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.OffsetEventCalendarAssignmentSession", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_offset_event_smart_calendar_session", 
               "doc": {
                  "headline": "Gets the session associated with the offset event smart calendar for the given calendar.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    calendar_id (osid.id.Id): the ``Id`` of the calendar\n", 
               "return_doc": "        return: (osid.calendaring.OffsetEventSmartCalendarSession) - an\n                ``OffsetEventSmartCalendarSession``", 
               "error_doc": "        raise:  NotFound - ``calendar_id`` not found\n        raise:  NullArgument - ``calendar_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented -\n                ``supports_offset_event_smart_calendar()`` is ``false``", 
               "sphinx_param_doc": "        :param calendar_id: the ``Id`` of the calendar\n        :type calendar_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: an ``OffsetEventSmartCalendarSession``\n        :rtype: ``osid.calendaring.OffsetEventSmartCalendarSession``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``calendar_id`` not found\n        :raise: ``NullArgument`` -- ``calendar_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_offset_event_smart_calendar()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_offset_event_smart_calendar()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "calendar_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "osid.calendaring.OffsetEventSmartCalendarSession", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_schedule_lookup_session", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` associated with the schedule lookup service.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.ScheduleLookupSession) - a\n                ``ScheduleLookupSession``", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_schedule_lookup()`` is\n                ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: a ``ScheduleLookupSession``\n        :rtype: ``osid.calendaring.ScheduleLookupSession``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_schedule_lookup()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_schedule_lookup()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.ScheduleLookupSession", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_schedule_lookup_session_for_calendar", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` associated with the schedule lookup service for the given calendar.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    calendar_id (osid.id.Id): the ``Id`` of the calendar\n", 
               "return_doc": "        return: (osid.calendaring.ScheduleLookupSession) - a\n                ``ScheduleLookupSession``", 
               "error_doc": "        raise:  NotFound - ``calendar_id`` not found\n        raise:  NullArgument - ``calendar_id`` is ``null``\n        raise:  OperationFailed - ``unable to complete request``\n        raise:  Unimplemented - ``supports_schedule_lookup()`` or\n                ``supports_visible_federation()`` is ``false``", 
               "sphinx_param_doc": "        :param calendar_id: the ``Id`` of the calendar\n        :type calendar_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: a ``ScheduleLookupSession``\n        :rtype: ``osid.calendaring.ScheduleLookupSession``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``calendar_id`` not found\n        :raise: ``NullArgument`` -- ``calendar_id`` is ``null``\n        :raise: ``OperationFailed`` -- ``unable to complete request``\n        :raise: ``Unimplemented`` -- ``supports_schedule_lookup()`` or ``supports_visible_federation()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_schedule_lookup()`` and ``supports_visible_federation()`` are ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "calendar_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "osid.calendaring.ScheduleLookupSession", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_schedule_query_session", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` associated with the schedule query service.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.ScheduleQuerySession) - a\n                ``ScheduleQuerySession``", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_schedule_query()`` is\n                ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: a ``ScheduleQuerySession``\n        :rtype: ``osid.calendaring.ScheduleQuerySession``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_schedule_query()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_schedule_query()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.ScheduleQuerySession", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_schedule_query_session_for_calendar", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` associated with the schedule query service for the given calendar.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    calendar_id (osid.id.Id): the ``Id`` of the calendar\n", 
               "return_doc": "        return: (osid.calendaring.ScheduleQuerySession) - a\n                ``ScheduleQuerySession``", 
               "error_doc": "        raise:  NotFound - ``calendar_id`` not found\n        raise:  NullArgument - ``calendar_id`` is ``null``\n        raise:  OperationFailed - ``unable to complete request``\n        raise:  Unimplemented - ``supports_schedule_query()`` or\n                ``supports_visible_federation()`` is ``false``", 
               "sphinx_param_doc": "        :param calendar_id: the ``Id`` of the calendar\n        :type calendar_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: a ``ScheduleQuerySession``\n        :rtype: ``osid.calendaring.ScheduleQuerySession``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``calendar_id`` not found\n        :raise: ``NullArgument`` -- ``calendar_id`` is ``null``\n        :raise: ``OperationFailed`` -- ``unable to complete request``\n        :raise: ``Unimplemented`` -- ``supports_schedule_query()`` or ``supports_visible_federation()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_schedule_query()`` and ``supports_visible_federation()`` are ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "calendar_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "osid.calendaring.ScheduleQuerySession", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_schedule_search_session", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` associated with the schedule search service.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.ScheduleSearchSession) - a\n                ``ScheduleSearchSession``", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_schedule_search()`` is\n                ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: a ``ScheduleSearchSession``\n        :rtype: ``osid.calendaring.ScheduleSearchSession``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_schedule_search()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_schedule_search()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.ScheduleSearchSession", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_schedule_search_session_for_calendar", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` associated with the schedule search service for the given calendar.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    calendar_id (osid.id.Id): the ``Id`` of the calendar\n", 
               "return_doc": "        return: (osid.calendaring.ScheduleSearchSession) - a\n                ``ScheduleSearchSession``", 
               "error_doc": "        raise:  NotFound - ``calendar_id`` not found\n        raise:  NullArgument - ``calendar_id`` is ``null``\n        raise:  OperationFailed - ``unable to complete request``\n        raise:  Unimplemented - ``supports_schedule_search()`` or\n                ``supports_visible_federation()`` is ``false``", 
               "sphinx_param_doc": "        :param calendar_id: the ``Id`` of the calendar\n        :type calendar_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: a ``ScheduleSearchSession``\n        :rtype: ``osid.calendaring.ScheduleSearchSession``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``calendar_id`` not found\n        :raise: ``NullArgument`` -- ``calendar_id`` is ``null``\n        :raise: ``OperationFailed`` -- ``unable to complete request``\n        :raise: ``Unimplemented`` -- ``supports_schedule_search()`` or ``supports_visible_federation()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_schedule_search()`` and ``supports_visible_federation()`` are ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "calendar_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "osid.calendaring.ScheduleSearchSession", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_schedule_admin_session", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` associated with the schedule administration service.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.ScheduleAdminSession) - a\n                ``ScheduleAdminSession``", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_schedule_admin()`` is\n                ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: a ``ScheduleAdminSession``\n        :rtype: ``osid.calendaring.ScheduleAdminSession``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_schedule_admin()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_schedule_admin()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.ScheduleAdminSession", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_schedule_admin_session_for_calendar", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` associated with the schedule admin service for the given calendar.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    calendar_id (osid.id.Id): the ``Id`` of the calendar\n", 
               "return_doc": "        return: (osid.calendaring.ScheduleAdminSession) - a\n                ``ScheduleAdminSession``", 
               "error_doc": "        raise:  NotFound - ``calendar_id`` not found\n        raise:  NullArgument - ``calendar_id`` is ``null``\n        raise:  OperationFailed - ``unable to complete request``\n        raise:  Unimplemented - ``supports_schedule_admin()`` or\n                ``supports_visible_federation()`` is ``false``", 
               "sphinx_param_doc": "        :param calendar_id: the ``Id`` of the calendar\n        :type calendar_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: a ``ScheduleAdminSession``\n        :rtype: ``osid.calendaring.ScheduleAdminSession``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``calendar_id`` not found\n        :raise: ``NullArgument`` -- ``calendar_id`` is ``null``\n        :raise: ``OperationFailed`` -- ``unable to complete request``\n        :raise: ``Unimplemented`` -- ``supports_schedule_admin()`` or ``supports_visible_federation()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_schedule_admin()`` and ``supports_visible_federation()`` are ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "calendar_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "osid.calendaring.ScheduleAdminSession", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_schedule_notification_session", 
               "doc": {
                  "headline": "Gets the notification session for notifications pertaining to schedule changes.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    schedule_receiver (osid.calendaring.ScheduleReceiver):\n                the schedule receiver\n", 
               "return_doc": "        return: (osid.calendaring.ScheduleNotificationSession) - a\n                ``ScheduleNotificationSession``", 
               "error_doc": "        raise:  NullArgument - ``schedule_receiver`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_schedule_notification()`` is\n                ``false``", 
               "sphinx_param_doc": "        :param schedule_receiver: the schedule receiver\n        :type schedule_receiver: ``osid.calendaring.ScheduleReceiver``\n", 
               "sphinx_return_doc": "        :return: a ``ScheduleNotificationSession``\n        :rtype: ``osid.calendaring.ScheduleNotificationSession``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``schedule_receiver`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_schedule_notification()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_schedule_notification()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.calendaring.ScheduleReceiver", 
                     "var_name": "schedule_receiver", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.calendaring.ScheduleReceiver"
               ], 
               "return_type": "osid.calendaring.ScheduleNotificationSession", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_schedule_notification_session_for_calendar", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` associated with the schedule notification service for the given calendar.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    schedule_receiver (osid.calendaring.ScheduleReceiver):\n                the schedule receiver\n        arg:    calendar_id (osid.id.Id): the ``Id`` of the calendar\n", 
               "return_doc": "        return: (osid.calendaring.ScheduleNotificationSession) - a\n                ``ScheduleNotificationSession``", 
               "error_doc": "        raise:  NotFound - ``calendar_id`` not found\n        raise:  NullArgument - ``schedule_receiver`` or ``calendar_id``\n                is ``null``\n        raise:  OperationFailed - ``unable to complete request``\n        raise:  Unimplemented - ``supports_schedule_notification()`` or\n                ``supports_visible_federation()`` is ``false``", 
               "sphinx_param_doc": "        :param schedule_receiver: the schedule receiver\n        :type schedule_receiver: ``osid.calendaring.ScheduleReceiver``\n        :param calendar_id: the ``Id`` of the calendar\n        :type calendar_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: a ``ScheduleNotificationSession``\n        :rtype: ``osid.calendaring.ScheduleNotificationSession``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``calendar_id`` not found\n        :raise: ``NullArgument`` -- ``schedule_receiver`` or ``calendar_id`` is ``null``\n        :raise: ``OperationFailed`` -- ``unable to complete request``\n        :raise: ``Unimplemented`` -- ``supports_schedule_notification()`` or ``supports_visible_federation()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_schedule_notification()`` and ``supports_visible_federation()`` are ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.calendaring.ScheduleReceiver", 
                     "var_name": "schedule_receiver", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "calendar_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.calendaring.ScheduleReceiver", 
                  "osid.id.Id"
               ], 
               "return_type": "osid.calendaring.ScheduleNotificationSession", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_schedule_calendar_session", 
               "doc": {
                  "headline": "Gets the session for retrieving schedule to calendar mappings.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.ScheduleCalendarSession) - a\n                ``ScheduleCalendarSession``", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_schedule_calendar()`` is\n                ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: a ``ScheduleCalendarSession``\n        :rtype: ``osid.calendaring.ScheduleCalendarSession``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_schedule_calendar()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_schedule_calendar()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.ScheduleCalendarSession", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_schedule_calendar_assignment_session", 
               "doc": {
                  "headline": "Gets the session for assigning schedule to calendar mappings.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.ScheduleCalendarAssignmentSession) - a\n                ``ScheduleCalendarAssignmentSession``", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented -\n                ``supports_schedule_calendar_assignment()`` is ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: a ``ScheduleCalendarAssignmentSession``\n        :rtype: ``osid.calendaring.ScheduleCalendarAssignmentSession``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_schedule_calendar_assignment()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_schedule_calendar_assignment()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.ScheduleCalendarAssignmentSession", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_schedule_smart_calendar_session", 
               "doc": {
                  "headline": "Gets the session associated with the schedule smart calendar for the given calendar.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    calendar_id (osid.id.Id): the ``Id`` of the calendar\n", 
               "return_doc": "        return: (osid.calendaring.ScheduleSmartCalendarSession) - a\n                ``ScheduleSmartCalendarSession``", 
               "error_doc": "        raise:  NotFound - ``calendar_id`` not found\n        raise:  NullArgument - ``calendar_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_schedule_smart_calendar()``\n                is ``false``", 
               "sphinx_param_doc": "        :param calendar_id: the ``Id`` of the calendar\n        :type calendar_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: a ``ScheduleSmartCalendarSession``\n        :rtype: ``osid.calendaring.ScheduleSmartCalendarSession``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``calendar_id`` not found\n        :raise: ``NullArgument`` -- ``calendar_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_schedule_smart_calendar()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_schedule_smart_calendar()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "calendar_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "osid.calendaring.ScheduleSmartCalendarSession", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_schedule_slot_lookup_session", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` associated with the schedule slot lookup service.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.ScheduleSlotLookupSession) - a\n                ``ScheduleSlotLookupSession``", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_schedule_slot_lookup()`` is\n                ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: a ``ScheduleSlotLookupSession``\n        :rtype: ``osid.calendaring.ScheduleSlotLookupSession``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_schedule_slot_lookup()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_schedule_slot_lookup()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.ScheduleSlotLookupSession", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_schedule_slot_lookup_session_for_calendar", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` associated with the schedule slot lookup service for the given calendar.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    calendar_id (osid.id.Id): the ``Id`` of the calendar\n", 
               "return_doc": "        return: (osid.calendaring.ScheduleSlotLookupSession) - a\n                ``ScheduleSlotLookupSession``", 
               "error_doc": "        raise:  NotFound - ``calendar_id`` not found\n        raise:  NullArgument - ``calendar_id`` is ``null``\n        raise:  OperationFailed - ``unable to complete request``\n        raise:  Unimplemented - ``supports_schedule_slot_lookup()`` or\n                ``supports_visible_federation()`` is ``false``", 
               "sphinx_param_doc": "        :param calendar_id: the ``Id`` of the calendar\n        :type calendar_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: a ``ScheduleSlotLookupSession``\n        :rtype: ``osid.calendaring.ScheduleSlotLookupSession``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``calendar_id`` not found\n        :raise: ``NullArgument`` -- ``calendar_id`` is ``null``\n        :raise: ``OperationFailed`` -- ``unable to complete request``\n        :raise: ``Unimplemented`` -- ``supports_schedule_slot_lookup()`` or ``supports_visible_federation()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_schedule_slot_lookup()`` and ``supports_visible_federation()`` are ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "calendar_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "osid.calendaring.ScheduleSlotLookupSession", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_schedule_slot_query_session", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` associated with the schedule slot query service.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.ScheduleSlotQuerySession) - a\n                ``ScheduleSlotQuerySession``", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_schedule_slot_query()`` is\n                ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: a ``ScheduleSlotQuerySession``\n        :rtype: ``osid.calendaring.ScheduleSlotQuerySession``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_schedule_slot_query()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_schedule_slot_query()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.ScheduleSlotQuerySession", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_schedule_slot_query_session_for_calendar", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` associated with the schedule slot query service for the given calendar.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    calendar_id (osid.id.Id): the ``Id`` of the calendar\n", 
               "return_doc": "        return: (osid.calendaring.ScheduleSlotQuerySession) - a\n                ``ScheduleSlotQuerySession``", 
               "error_doc": "        raise:  NotFound - ``calendar_id`` not found\n        raise:  NullArgument - ``calendar_id`` is ``null``\n        raise:  OperationFailed - ``unable to complete request``\n        raise:  Unimplemented - ``supports_schedule_slot_query()`` or\n                ``supports_visible_federation()`` is ``false``", 
               "sphinx_param_doc": "        :param calendar_id: the ``Id`` of the calendar\n        :type calendar_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: a ``ScheduleSlotQuerySession``\n        :rtype: ``osid.calendaring.ScheduleSlotQuerySession``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``calendar_id`` not found\n        :raise: ``NullArgument`` -- ``calendar_id`` is ``null``\n        :raise: ``OperationFailed`` -- ``unable to complete request``\n        :raise: ``Unimplemented`` -- ``supports_schedule_slot_query()`` or ``supports_visible_federation()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_schedule_slot_query()`` and ``supports_visible_federation()`` are ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "calendar_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "osid.calendaring.ScheduleSlotQuerySession", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_schedule_slot_search_session", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` associated with the schedule slot search service.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.ScheduleSlotSearchSession) - a\n                ``ScheduleSlotSearchSession``", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_schedule_slot_search()`` is\n                ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: a ``ScheduleSlotSearchSession``\n        :rtype: ``osid.calendaring.ScheduleSlotSearchSession``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_schedule_slot_search()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_schedule_slot_search()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.ScheduleSlotSearchSession", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_schedule_slot_search_session_for_calendar", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` associated with the schedule slot search service for the given calendar.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    calendar_id (osid.id.Id): the ``Id`` of the calendar\n", 
               "return_doc": "        return: (osid.calendaring.ScheduleSlotSearchSession) - a\n                ``ScheduleSlotSearchSession``", 
               "error_doc": "        raise:  NotFound - ``calendar_id`` not found\n        raise:  NullArgument - ``calendar_id`` is ``null``\n        raise:  OperationFailed - ``unable to complete request``\n        raise:  Unimplemented - ``supports_schedule_slot_search()`` or\n                ``supports_visible_federation()`` is ``false``", 
               "sphinx_param_doc": "        :param calendar_id: the ``Id`` of the calendar\n        :type calendar_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: a ``ScheduleSlotSearchSession``\n        :rtype: ``osid.calendaring.ScheduleSlotSearchSession``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``calendar_id`` not found\n        :raise: ``NullArgument`` -- ``calendar_id`` is ``null``\n        :raise: ``OperationFailed`` -- ``unable to complete request``\n        :raise: ``Unimplemented`` -- ``supports_schedule_slot_search()`` or ``supports_visible_federation()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_schedule_slot_search()`` and ``supports_visible_federation()`` are ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "calendar_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "osid.calendaring.ScheduleSlotSearchSession", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_schedule_slot_admin_session", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` associated with the schedule slot administration service.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.ScheduleSlotAdminSession) - a\n                ``ScheduleSlotAdminSession``", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_schedule_slot_admin()`` is\n                ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: a ``ScheduleSlotAdminSession``\n        :rtype: ``osid.calendaring.ScheduleSlotAdminSession``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_schedule_slot_admin()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_schedule_slot_admin()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.ScheduleSlotAdminSession", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_schedule_slot_admin_session_for_calendar", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` associated with the schedule slot admin service for the given calendar.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    calendar_id (osid.id.Id): the ``Id`` of the calendar\n", 
               "return_doc": "        return: (osid.calendaring.ScheduleSlotAdminSession) - a\n                ``ScheduleSlotAdminSession``", 
               "error_doc": "        raise:  NotFound - ``calendar_id`` not found\n        raise:  NullArgument - ``calendar_id`` is ``null``\n        raise:  OperationFailed - ``unable to complete request``\n        raise:  Unimplemented - ``supports_schedule_slot_admin()`` or\n                ``supports_visible_federation()`` is ``false``", 
               "sphinx_param_doc": "        :param calendar_id: the ``Id`` of the calendar\n        :type calendar_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: a ``ScheduleSlotAdminSession``\n        :rtype: ``osid.calendaring.ScheduleSlotAdminSession``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``calendar_id`` not found\n        :raise: ``NullArgument`` -- ``calendar_id`` is ``null``\n        :raise: ``OperationFailed`` -- ``unable to complete request``\n        :raise: ``Unimplemented`` -- ``supports_schedule_slot_admin()`` or ``supports_visible_federation()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_schedule_slot_admin()`` and ``supports_visible_federation()`` are ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "calendar_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "osid.calendaring.ScheduleSlotAdminSession", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_schedule_slot_notification_session", 
               "doc": {
                  "headline": "Gets the notification session for notifications pertaining to schedule slot changes.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    schedule_slot_receiver\n                (osid.calendaring.ScheduleSlotReceiver): the schedule\n                slot receiver\n", 
               "return_doc": "        return: (osid.calendaring.ScheduleSlotNotificationSession) - a\n                ``ScheduleSlotNotificationSession``", 
               "error_doc": "        raise:  NullArgument - ``schedule_slot_receiver`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented -\n                ``supports_schedule_slot_notification()`` is ``false``", 
               "sphinx_param_doc": "        :param schedule_slot_receiver: the schedule slot receiver\n        :type schedule_slot_receiver: ``osid.calendaring.ScheduleSlotReceiver``\n", 
               "sphinx_return_doc": "        :return: a ``ScheduleSlotNotificationSession``\n        :rtype: ``osid.calendaring.ScheduleSlotNotificationSession``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``schedule_slot_receiver`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_schedule_slot_notification()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_schedule_slot_notification()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.calendaring.ScheduleSlotReceiver", 
                     "var_name": "schedule_slot_receiver", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.calendaring.ScheduleSlotReceiver"
               ], 
               "return_type": "osid.calendaring.ScheduleSlotNotificationSession", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_schedule_slot_notification_session_for_calendar", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` associated with the schedule slot notification service for the given calendar.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    schedule_slot_receiver\n                (osid.calendaring.ScheduleSlotReceiver): the schedule\n                slot receiver\n        arg:    calendar_id (osid.id.Id): the ``Id`` of the calendar\n", 
               "return_doc": "        return: (osid.calendaring.ScheduleSlotNotificationSession) - a\n                ``ScheduleSlotNotificationSession``", 
               "error_doc": "        raise:  NotFound - ``calendar_id`` not found\n        raise:  NullArgument - ``schedule_slot_receiver`` or\n                ``calendar_id`` is ``null``\n        raise:  OperationFailed - ``unable to complete request``\n        raise:  Unimplemented -\n                ``supports_schedule_slot_notification()`` or\n                ``supports_visible_federation()`` is ``false``", 
               "sphinx_param_doc": "        :param schedule_slot_receiver: the schedule slot receiver\n        :type schedule_slot_receiver: ``osid.calendaring.ScheduleSlotReceiver``\n        :param calendar_id: the ``Id`` of the calendar\n        :type calendar_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: a ``ScheduleSlotNotificationSession``\n        :rtype: ``osid.calendaring.ScheduleSlotNotificationSession``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``calendar_id`` not found\n        :raise: ``NullArgument`` -- ``schedule_slot_receiver`` or ``calendar_id`` is ``null``\n        :raise: ``OperationFailed`` -- ``unable to complete request``\n        :raise: ``Unimplemented`` -- ``supports_schedule_slot_notification()`` or ``supports_visible_federation()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_schedule_slot_notification()`` and ``supports_visible_federation()`` are ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.calendaring.ScheduleSlotReceiver", 
                     "var_name": "schedule_slot_receiver", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "calendar_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.calendaring.ScheduleSlotReceiver", 
                  "osid.id.Id"
               ], 
               "return_type": "osid.calendaring.ScheduleSlotNotificationSession", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_schedule_slot_calendar_session", 
               "doc": {
                  "headline": "Gets the session for retrieving schedule slot to calendar mappings.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.ScheduleSlotCalendarSession) - a\n                ``ScheduleSlotCalendarSession``", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_schedule_slot_calendar()`` is\n                ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: a ``ScheduleSlotCalendarSession``\n        :rtype: ``osid.calendaring.ScheduleSlotCalendarSession``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_schedule_slot_calendar()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_schedule_slot_calendar()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.ScheduleSlotCalendarSession", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_schedule_slot_calendar_assignment_session", 
               "doc": {
                  "headline": "Gets the session for assigning schedule slot to calendar mappings.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.ScheduleSlotCalendarAssignmentSession)\n                - a ``ScheduleSlotCalendarAssignmentSession``", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented -\n                ``supports_schedule_slot_calendar_assignment()`` is\n                ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: a ``ScheduleSlotCalendarAssignmentSession``\n        :rtype: ``osid.calendaring.ScheduleSlotCalendarAssignmentSession``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_schedule_slot_calendar_assignment()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_schedule_slot_calendar_assignment()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.ScheduleSlotCalendarAssignmentSession", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_schedule_slot_smart_calendar_session", 
               "doc": {
                  "headline": "Gets the session associated with the schedule slot smart calendar for the given calendar.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    calendar_id (osid.id.Id): the ``Id`` of the calendar\n", 
               "return_doc": "        return: (osid.calendaring.ScheduleSlotSmartCalendarSession) - a\n                ``ScheduleSlotSmartCalendarSession``", 
               "error_doc": "        raise:  NotFound - ``calendar_id`` not found\n        raise:  NullArgument - ``calendar_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented -\n                ``supports_schedule_slot_smart_calendar()`` is ``false``", 
               "sphinx_param_doc": "        :param calendar_id: the ``Id`` of the calendar\n        :type calendar_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: a ``ScheduleSlotSmartCalendarSession``\n        :rtype: ``osid.calendaring.ScheduleSlotSmartCalendarSession``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``calendar_id`` not found\n        :raise: ``NullArgument`` -- ``calendar_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_schedule_slot_smart_calendar()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_schedule_slot_smart_calendar()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "calendar_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "osid.calendaring.ScheduleSlotSmartCalendarSession", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_commitment_lookup_session", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` associated with the commitment lookup service.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.CommitmentLookupSession) - a\n                ``CommitmentLookupSession``", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_commitment_lookup()`` is\n                ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: a ``CommitmentLookupSession``\n        :rtype: ``osid.calendaring.CommitmentLookupSession``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_commitment_lookup()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_commitment_lookup()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.CommitmentLookupSession", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_commitment_lookup_session_for_calendar", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` associated with the commitment lookup service for the given calendar.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    calendar_id (osid.id.Id): the ``Id`` of the calendar\n", 
               "return_doc": "        return: (osid.calendaring.CommitmentLookupSession) - a\n                ``CommitmentLookupSession``", 
               "error_doc": "        raise:  NotFound - ``calendar_id`` not found\n        raise:  NullArgument - ``calendar_id`` is ``null``\n        raise:  OperationFailed - ``unable to complete request``\n        raise:  Unimplemented - ``supports_commitment_lookup()`` or\n                ``supports_visible_federation()`` is ``false``", 
               "sphinx_param_doc": "        :param calendar_id: the ``Id`` of the calendar\n        :type calendar_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: a ``CommitmentLookupSession``\n        :rtype: ``osid.calendaring.CommitmentLookupSession``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``calendar_id`` not found\n        :raise: ``NullArgument`` -- ``calendar_id`` is ``null``\n        :raise: ``OperationFailed`` -- ``unable to complete request``\n        :raise: ``Unimplemented`` -- ``supports_commitment_lookup()`` or ``supports_visible_federation()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_commitment_lookup()`` and ``supports_visible_federation()`` are ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "calendar_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "osid.calendaring.CommitmentLookupSession", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_commitment_query_session", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` associated with the commitment query service.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.CommitmentQuerySession) - a\n                ``CommitmentQuerySession``", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_commitment_query()`` is\n                ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: a ``CommitmentQuerySession``\n        :rtype: ``osid.calendaring.CommitmentQuerySession``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_commitment_query()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_commitment_lookup()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.CommitmentQuerySession", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_commitment_query_session_for_calendar", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` associated with the commitment query service for the given calendar.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    calendar_id (osid.id.Id): the ``Id`` of the calendar\n", 
               "return_doc": "        return: (osid.calendaring.CommitmentQuerySession) - a\n                ``CommitmentQuerySession``", 
               "error_doc": "        raise:  NotFound - ``calendar_id`` not found\n        raise:  NullArgument - ``calendar_id`` is ``null``\n        raise:  OperationFailed - ``unable to complete request``\n        raise:  Unimplemented - ``supports_commitment_query()`` or\n                ``supports_visible_federation()`` is ``false``", 
               "sphinx_param_doc": "        :param calendar_id: the ``Id`` of the calendar\n        :type calendar_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: a ``CommitmentQuerySession``\n        :rtype: ``osid.calendaring.CommitmentQuerySession``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``calendar_id`` not found\n        :raise: ``NullArgument`` -- ``calendar_id`` is ``null``\n        :raise: ``OperationFailed`` -- ``unable to complete request``\n        :raise: ``Unimplemented`` -- ``supports_commitment_query()`` or ``supports_visible_federation()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_commitment_query()`` and ``supports_visible_federation()`` are ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "calendar_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "osid.calendaring.CommitmentQuerySession", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_commitment_search_session", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` associated with the commitment search service.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.CommitmentSearchSession) - a\n                ``CommitmentSearchSession``", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_commitment_search()`` is\n                ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: a ``CommitmentSearchSession``\n        :rtype: ``osid.calendaring.CommitmentSearchSession``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_commitment_search()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_commitment_search()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.CommitmentSearchSession", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_commitment_search_session_for_calendar", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` associated with the commitment search service for the given calendar.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    calendar_id (osid.id.Id): the ``Id`` of the calendar\n", 
               "return_doc": "        return: (osid.calendaring.CommitmentSearchSession) - a\n                ``CommitmentSearchSession``", 
               "error_doc": "        raise:  NotFound - ``calendar_id`` not found\n        raise:  NullArgument - ``calendar_id`` is ``null``\n        raise:  OperationFailed - ``unable to complete request``\n        raise:  Unimplemented - ``supports_commitment_search()`` or\n                ``supports_visible_federation()`` is ``false``", 
               "sphinx_param_doc": "        :param calendar_id: the ``Id`` of the calendar\n        :type calendar_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: a ``CommitmentSearchSession``\n        :rtype: ``osid.calendaring.CommitmentSearchSession``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``calendar_id`` not found\n        :raise: ``NullArgument`` -- ``calendar_id`` is ``null``\n        :raise: ``OperationFailed`` -- ``unable to complete request``\n        :raise: ``Unimplemented`` -- ``supports_commitment_search()`` or ``supports_visible_federation()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_commitment_search()`` and ``supports_visible_federation()`` are ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "calendar_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "osid.calendaring.CommitmentSearchSession", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_commitment_admin_session", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` associated with the commitment administration service.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.CommitmentAdminSession) - a\n                ``CommitmentAdminSession``", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_commitment_admin()`` is\n                ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: a ``CommitmentAdminSession``\n        :rtype: ``osid.calendaring.CommitmentAdminSession``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_commitment_admin()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_commitment_admin()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.CommitmentAdminSession", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_commitment_admin_session_for_calendar", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` associated with the commitment admin service for the given calendar.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    calendar_id (osid.id.Id): the ``Id`` of the calendar\n", 
               "return_doc": "        return: (osid.calendaring.CommitmentAdminSession) - a\n                ``CommitmenttAdminSession``", 
               "error_doc": "        raise:  NotFound - ``calendar_id`` not found\n        raise:  NullArgument - ``calendar_id`` is ``null``\n        raise:  OperationFailed - ``unable to complete request``\n        raise:  Unimplemented - ``supports_commitment_admin()`` or\n                ``supports_visible_federation()`` is ``false``", 
               "sphinx_param_doc": "        :param calendar_id: the ``Id`` of the calendar\n        :type calendar_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: a ``CommitmenttAdminSession``\n        :rtype: ``osid.calendaring.CommitmentAdminSession``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``calendar_id`` not found\n        :raise: ``NullArgument`` -- ``calendar_id`` is ``null``\n        :raise: ``OperationFailed`` -- ``unable to complete request``\n        :raise: ``Unimplemented`` -- ``supports_commitment_admin()`` or ``supports_visible_federation()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_commitment_admin()`` and ``supports_visible_federation()`` are ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "calendar_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "osid.calendaring.CommitmentAdminSession", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_commitment_notification_session", 
               "doc": {
                  "headline": "Gets the notification session for notifications pertaining to commitment changes.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    commitment_receiver\n                (osid.calendaring.CommitmentReceiver): the commitment\n                receiver\n", 
               "return_doc": "        return: (osid.calendaring.CommitmentNotificationSession) - a\n                ``CommitmentNotificationSession``", 
               "error_doc": "        raise:  NullArgument - ``commitment_receiver`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_commitment_notification()``\n                is ``false``", 
               "sphinx_param_doc": "        :param commitment_receiver: the commitment receiver\n        :type commitment_receiver: ``osid.calendaring.CommitmentReceiver``\n", 
               "sphinx_return_doc": "        :return: a ``CommitmentNotificationSession``\n        :rtype: ``osid.calendaring.CommitmentNotificationSession``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``commitment_receiver`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_commitment_notification()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_commitment_notification()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.calendaring.CommitmentReceiver", 
                     "var_name": "commitment_receiver", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.calendaring.CommitmentReceiver"
               ], 
               "return_type": "osid.calendaring.CommitmentNotificationSession", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_commitment_notification_session_for_calendar", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` associated with the commitment notification service for the given calendar.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    commitment_receiver\n                (osid.calendaring.CommitmentReceiver): the commitment\n                receiver\n        arg:    calendar_id (osid.id.Id): the ``Id`` of the calendar\n", 
               "return_doc": "        return: (osid.calendaring.CommitmentNotificationSession) - a\n                ``CommitmentNotificationSession``", 
               "error_doc": "        raise:  NotFound - ``calendar_id`` not found\n        raise:  NullArgument - ``commitment_receiver`` or\n                ``calendar_id`` is ``null``\n        raise:  OperationFailed - ``unable to complete request``\n        raise:  Unimplemented - ``supports_commitment_notification()``\n                or ``supports_visible_federation()`` is ``false``", 
               "sphinx_param_doc": "        :param commitment_receiver: the commitment receiver\n        :type commitment_receiver: ``osid.calendaring.CommitmentReceiver``\n        :param calendar_id: the ``Id`` of the calendar\n        :type calendar_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: a ``CommitmentNotificationSession``\n        :rtype: ``osid.calendaring.CommitmentNotificationSession``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``calendar_id`` not found\n        :raise: ``NullArgument`` -- ``commitment_receiver`` or ``calendar_id`` is ``null``\n        :raise: ``OperationFailed`` -- ``unable to complete request``\n        :raise: ``Unimplemented`` -- ``supports_commitment_notification()`` or ``supports_visible_federation()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_commitment_notification()`` and ``supports_visible_federation()`` are ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.calendaring.CommitmentReceiver", 
                     "var_name": "commitment_receiver", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "calendar_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.calendaring.CommitmentReceiver", 
                  "osid.id.Id"
               ], 
               "return_type": "osid.calendaring.CommitmentNotificationSession", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_commitment_calendar_session", 
               "doc": {
                  "headline": "Gets the session for retrieving commitment to calendar mappings.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.CommitmentCalendarSession) - a\n                ``CommitmentCalendarSession``", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_commitment_calendar()`` is\n                ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: a ``CommitmentCalendarSession``\n        :rtype: ``osid.calendaring.CommitmentCalendarSession``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_commitment_calendar()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_commitment_calendar()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.CommitmentCalendarSession", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_commitment_calendar_assignment_session", 
               "doc": {
                  "headline": "Gets the session for assigning commitment to calendar mappings.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.CommitmentCalendarAssignmentSession) -\n                a ``CommitmentCalendarAssignmentSession``", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented -\n                ``supports_commitment_calendar_assignment()`` is\n                ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: a ``CommitmentCalendarAssignmentSession``\n        :rtype: ``osid.calendaring.CommitmentCalendarAssignmentSession``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_commitment_calendar_assignment()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_commitment_calendar_assignment()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.CommitmentCalendarAssignmentSession", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_commitment_smart_calendar_session", 
               "doc": {
                  "headline": "Gets the session associated with the commitment smart calendar for the given calendar.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    calendar_id (osid.id.Id): the ``Id`` of the calendar\n", 
               "return_doc": "        return: (osid.calendaring.CommitmentSmartCalendarSession) - a\n                ``CommitmentSmartCalendarSession``", 
               "error_doc": "        raise:  NotFound - ``calendar_id`` not found\n        raise:  NullArgument - ``calendar_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_commitment_smart_calendar()``\n                is ``false``", 
               "sphinx_param_doc": "        :param calendar_id: the ``Id`` of the calendar\n        :type calendar_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: a ``CommitmentSmartCalendarSession``\n        :rtype: ``osid.calendaring.CommitmentSmartCalendarSession``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``calendar_id`` not found\n        :raise: ``NullArgument`` -- ``calendar_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_commitment_smart_calendar()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_commitment_smart_calendar()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "calendar_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "osid.calendaring.CommitmentSmartCalendarSession", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_time_period_lookup_session", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` associated with the time period lookup service.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.TimePeriodLookupSession) - a\n                ``TimePeriodLookupSession``", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_time_period_lookup()`` is\n                ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: a ``TimePeriodLookupSession``\n        :rtype: ``osid.calendaring.TimePeriodLookupSession``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_time_period_lookup()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_time_period_lookup()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.TimePeriodLookupSession", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_time_period_lookup_session_for_calendar", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` associated with the time period lookup service for the given calendar.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    calendar_id (osid.id.Id): the ``Id`` of the calendar\n", 
               "return_doc": "        return: (osid.calendaring.TimePeriodLookupSession) - a\n                ``TimePeriodLookupSession``", 
               "error_doc": "        raise:  NotFound - ``calendar_id`` not found\n        raise:  NullArgument - ``calendar_id`` is ``null``\n        raise:  OperationFailed - ``unable to complete request``\n        raise:  Unimplemented - ``supports_time_period_lookup()`` or\n                ``supports_visible_federation()`` is ``false``", 
               "sphinx_param_doc": "        :param calendar_id: the ``Id`` of the calendar\n        :type calendar_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: a ``TimePeriodLookupSession``\n        :rtype: ``osid.calendaring.TimePeriodLookupSession``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``calendar_id`` not found\n        :raise: ``NullArgument`` -- ``calendar_id`` is ``null``\n        :raise: ``OperationFailed`` -- ``unable to complete request``\n        :raise: ``Unimplemented`` -- ``supports_time_period_lookup()`` or ``supports_visible_federation()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_time_period_lookup()`` and ``supports_visible_federation()`` are ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "calendar_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "osid.calendaring.TimePeriodLookupSession", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_time_period_query_session", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` associated with the time period query service.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.TimePeriodQuerySession) - a\n                ``TimePeriodQuerySession``", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_time_period_query()`` is\n                ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: a ``TimePeriodQuerySession``\n        :rtype: ``osid.calendaring.TimePeriodQuerySession``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_time_period_query()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_time_period_query()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.TimePeriodQuerySession", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_time_period_query_session_for_calendar", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` associated with the time period query service for the given calendar.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    calendar_id (osid.id.Id): the ``Id`` of the calendar\n", 
               "return_doc": "        return: (osid.calendaring.TimePeriodQuerySession) - a\n                ``TimePeriodQuerySession``", 
               "error_doc": "        raise:  NotFound - ``calendar_id`` not found\n        raise:  NullArgument - ``calendar_id`` is ``null``\n        raise:  OperationFailed - ``unable to complete request``\n        raise:  Unimplemented - ``supports_time_period_query()`` or\n                ``supports_visible_federation()`` is ``false``", 
               "sphinx_param_doc": "        :param calendar_id: the ``Id`` of the calendar\n        :type calendar_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: a ``TimePeriodQuerySession``\n        :rtype: ``osid.calendaring.TimePeriodQuerySession``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``calendar_id`` not found\n        :raise: ``NullArgument`` -- ``calendar_id`` is ``null``\n        :raise: ``OperationFailed`` -- ``unable to complete request``\n        :raise: ``Unimplemented`` -- ``supports_time_period_query()`` or ``supports_visible_federation()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_time_period_query()`` and ``supports_visible_federation()`` are ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "calendar_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "osid.calendaring.TimePeriodQuerySession", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_time_period_search_session", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` associated with the time period search service.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.TimePeriodSearchSession) - a\n                ``TimePeriodSearchSession``", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_time_period_search()`` is\n                ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: a ``TimePeriodSearchSession``\n        :rtype: ``osid.calendaring.TimePeriodSearchSession``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_time_period_search()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_time_period_search()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.TimePeriodSearchSession", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_time_period_search_session_for_calendar", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` associated with the time period search service for the given calendar.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    calendar_id (osid.id.Id): the ``Id`` of the calendar\n", 
               "return_doc": "        return: (osid.calendaring.TimePeriodSearchSession) - a\n                ``TimePeriodSearchSession``", 
               "error_doc": "        raise:  NotFound - ``calendar_id`` not found\n        raise:  NullArgument - ``calendar_id`` is ``null``\n        raise:  OperationFailed - ``unable to complete request``\n        raise:  Unimplemented - ``supports_time_period_search()`` or\n                ``supports_visible_federation()`` is ``false``", 
               "sphinx_param_doc": "        :param calendar_id: the ``Id`` of the calendar\n        :type calendar_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: a ``TimePeriodSearchSession``\n        :rtype: ``osid.calendaring.TimePeriodSearchSession``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``calendar_id`` not found\n        :raise: ``NullArgument`` -- ``calendar_id`` is ``null``\n        :raise: ``OperationFailed`` -- ``unable to complete request``\n        :raise: ``Unimplemented`` -- ``supports_time_period_search()`` or ``supports_visible_federation()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_time_period_search()`` and ``supports_visible_federation()`` are ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "calendar_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "osid.calendaring.TimePeriodSearchSession", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_time_period_admin_session", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` associated with the time period administration service.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.TimePeriodAdminSession) - a\n                ``TimePeriodAdminSession``", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_time_period_admin()`` is\n                ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: a ``TimePeriodAdminSession``\n        :rtype: ``osid.calendaring.TimePeriodAdminSession``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_time_period_admin()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_time_period_admin()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.TimePeriodAdminSession", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_time_period_admin_session_for_calendar", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` associated with the time period admin service for the given calendar.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    calendar_id (osid.id.Id): the ``Id`` of the calendar\n", 
               "return_doc": "        return: (osid.calendaring.TimePeriodAdminSession) - a\n                ``TimePeriodAdminSession``", 
               "error_doc": "        raise:  NotFound - ``calendar_id`` not found\n        raise:  NullArgument - ``calendar_id`` is ``null``\n        raise:  OperationFailed - ``unable to complete request``\n        raise:  Unimplemented - ``supports_time_period_admin()`` or\n                ``supports_visible_federation()`` is ``false``", 
               "sphinx_param_doc": "        :param calendar_id: the ``Id`` of the calendar\n        :type calendar_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: a ``TimePeriodAdminSession``\n        :rtype: ``osid.calendaring.TimePeriodAdminSession``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``calendar_id`` not found\n        :raise: ``NullArgument`` -- ``calendar_id`` is ``null``\n        :raise: ``OperationFailed`` -- ``unable to complete request``\n        :raise: ``Unimplemented`` -- ``supports_time_period_admin()`` or ``supports_visible_federation()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_time_period_admin()`` and ``supports_visible_federation()`` are ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "calendar_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "osid.calendaring.TimePeriodAdminSession", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_time_period_notification_session", 
               "doc": {
                  "headline": "Gets the notification session for notifications pertaining to time period changes.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    time_period_receiver\n                (osid.calendaring.TimePeriodReceiver): the time period\n                receiver\n", 
               "return_doc": "        return: (osid.calendaring.TimePeriodNotificationSession) - a\n                ``TimePeriodNotificationSession``", 
               "error_doc": "        raise:  NullArgument - ``time_period_receiver`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_time_period_notification()``\n                is ``false``", 
               "sphinx_param_doc": "        :param time_period_receiver: the time period receiver\n        :type time_period_receiver: ``osid.calendaring.TimePeriodReceiver``\n", 
               "sphinx_return_doc": "        :return: a ``TimePeriodNotificationSession``\n        :rtype: ``osid.calendaring.TimePeriodNotificationSession``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``time_period_receiver`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_time_period_notification()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_time_period_notification()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.calendaring.TimePeriodReceiver", 
                     "var_name": "time_period_receiver", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.calendaring.TimePeriodReceiver"
               ], 
               "return_type": "osid.calendaring.TimePeriodNotificationSession", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_time_period_notification_session_for_calendar", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` associated with the time period notification service for the given calendar.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    time_period_receiver\n                (osid.calendaring.TimePeriodReceiver): the time period\n                receiver\n        arg:    calendar_id (osid.id.Id): the ``Id`` of the calendar\n", 
               "return_doc": "        return: (osid.calendaring.TimePeriodNotificationSession) - ``a\n                _time_period_notification_session``", 
               "error_doc": "        raise:  NotFound - ``calendar_id`` not found\n        raise:  NullArgument - ``time_period_receiver`` or\n                ``calendar_id`` is ``null``\n        raise:  OperationFailed - ``unable to complete request``\n        raise:  Unimplemented - ``supports_time_period_notification()``\n                or ``supports_visible_federation()`` is ``false``", 
               "sphinx_param_doc": "        :param time_period_receiver: the time period receiver\n        :type time_period_receiver: ``osid.calendaring.TimePeriodReceiver``\n        :param calendar_id: the ``Id`` of the calendar\n        :type calendar_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: ``a _time_period_notification_session``\n        :rtype: ``osid.calendaring.TimePeriodNotificationSession``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``calendar_id`` not found\n        :raise: ``NullArgument`` -- ``time_period_receiver`` or ``calendar_id`` is ``null``\n        :raise: ``OperationFailed`` -- ``unable to complete request``\n        :raise: ``Unimplemented`` -- ``supports_time_period_notification()`` or ``supports_visible_federation()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_time_period_notification()`` and ``supports_visible_federation()`` are ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.calendaring.TimePeriodReceiver", 
                     "var_name": "time_period_receiver", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "calendar_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.calendaring.TimePeriodReceiver", 
                  "osid.id.Id"
               ], 
               "return_type": "osid.calendaring.TimePeriodNotificationSession", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_time_period_calendar_session", 
               "doc": {
                  "headline": "Gets the session for retrieving time period to calendar mappings.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.TimePeriodCalendarSession) - a\n                ``TimePeriodCalendarSession``", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_time_period_calendar()`` is\n                ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: a ``TimePeriodCalendarSession``\n        :rtype: ``osid.calendaring.TimePeriodCalendarSession``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_time_period_calendar()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_time_period_calendar()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.TimePeriodCalendarSession", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_time_period_calendar_assignment_session", 
               "doc": {
                  "headline": "Gets the session for assigning time period to calendar mappings.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.TimePeriodCalendarAssignmentSession) -\n                a ``TimePeriodCalendarAssignmentSession``", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented -\n                ``supports_time_period_calendar_assignment()`` is\n                ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: a ``TimePeriodCalendarAssignmentSession``\n        :rtype: ``osid.calendaring.TimePeriodCalendarAssignmentSession``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_time_period_calendar_assignment()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_time_period_calendar_assignment()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.TimePeriodCalendarAssignmentSession", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_time_period_smart_calendar_session", 
               "doc": {
                  "headline": "Gets the session associated with the time period smart calendar for the given calendar.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    calendar_id (osid.id.Id): the ``Id`` of the calendar\n", 
               "return_doc": "        return: (osid.calendaring.TimePeriodSmartCalendarSession) - a\n                ``TimePeriodSmartCalendarSession``", 
               "error_doc": "        raise:  NotFound - ``calendar_id`` not found\n        raise:  NullArgument - ``calendar_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented -\n                ``supports_time_period_smart_calendar()`` is ``false``", 
               "sphinx_param_doc": "        :param calendar_id: the ``Id`` of the calendar\n        :type calendar_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: a ``TimePeriodSmartCalendarSession``\n        :rtype: ``osid.calendaring.TimePeriodSmartCalendarSession``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``calendar_id`` not found\n        :raise: ``NullArgument`` -- ``calendar_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_time_period_smart_calendar()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_time_period_smart_calendar()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "calendar_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "osid.calendaring.TimePeriodSmartCalendarSession", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_calendar_lookup_session", 
               "doc": {
                  "headline": "Gets the OsidSession associated with the calendar lookup service.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.CalendarLookupSession) - a\n                ``CalendarLookupSession``", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_calendar_lookup() is false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: a ``CalendarLookupSession``\n        :rtype: ``osid.calendaring.CalendarLookupSession``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_calendar_lookup() is false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_calendar_lookup()`` is true.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.CalendarLookupSession", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_calendar_search_session", 
               "doc": {
                  "headline": "Gets the OsidSession associated with the calendar search service.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.CalendarSearchSession) - a\n                ``CalendarSearchSession``", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_calendar_search() is false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: a ``CalendarSearchSession``\n        :rtype: ``osid.calendaring.CalendarSearchSession``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_calendar_search() is false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_calendar_search()`` is true.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.CalendarSearchSession", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_calendar_admin_session", 
               "doc": {
                  "headline": "Gets the OsidSession associated with the calendar administration service.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.CalendarAdminSession) - a\n                ``CalendarAdminSession``", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_calendar_admin() is false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: a ``CalendarAdminSession``\n        :rtype: ``osid.calendaring.CalendarAdminSession``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_calendar_admin() is false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_calendar_admin()`` is true.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.CalendarAdminSession", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_calendar_notification_session", 
               "doc": {
                  "headline": "Gets the notification session for notifications pertaining to calendar service changes.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    calendar_receiver (osid.calendaring.CalendarReceiver):\n                the calendar receiver\n", 
               "return_doc": "        return: (osid.calendaring.CalendarNotificationSession) - a\n                ``CalendarNotificationSession``", 
               "error_doc": "        raise:  NullArgument - ``calendar_receiver`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_calendar_notification() is\n                false``", 
               "sphinx_param_doc": "        :param calendar_receiver: the calendar receiver\n        :type calendar_receiver: ``osid.calendaring.CalendarReceiver``\n", 
               "sphinx_return_doc": "        :return: a ``CalendarNotificationSession``\n        :rtype: ``osid.calendaring.CalendarNotificationSession``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``calendar_receiver`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_calendar_notification() is false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_calendar_notification()`` is true.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.calendaring.CalendarReceiver", 
                     "var_name": "calendar_receiver", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.calendaring.CalendarReceiver"
               ], 
               "return_type": "osid.calendaring.CalendarNotificationSession", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_calendar_hierarchy_session", 
               "doc": {
                  "headline": "Gets the session traversing calendar hierarchies.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.CalendarHierarchySession) - a\n                ``CalendarHierarchySession``", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_calendar_hierarchy() is\n                false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: a ``CalendarHierarchySession``\n        :rtype: ``osid.calendaring.CalendarHierarchySession``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_calendar_hierarchy() is false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_calendar_hierarchy()`` is true.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.CalendarHierarchySession", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_calendar_hierarchy_design_session", 
               "doc": {
                  "headline": "Gets the session designing calendar hierarchies.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.CalendarHierarchyDesignSession) - a\n                ``CalendarHierarchyDesignSession``", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_calendar_hierarchy_design()\n                is false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: a ``CalendarHierarchyDesignSession``\n        :rtype: ``osid.calendaring.CalendarHierarchyDesignSession``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_calendar_hierarchy_design() is false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_calendar_hierarchy_design()`` is true.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.CalendarHierarchyDesignSession", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_calandaring_batch_manager", 
               "doc": {
                  "headline": "Gets the calendaring batch manager.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.batch.CalendaringBatchManager) - a\n                ``CalendaringBatchManager``", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_calendaring_batch()`` is\n                ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: a ``CalendaringBatchManager``\n        :rtype: ``osid.calendaring.batch.CalendaringBatchManager``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_calendaring_batch()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_calendaring_batch()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.batch.CalendaringBatchManager", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_calandaring_cycle_manager", 
               "doc": {
                  "headline": "Gets the calendaring cycle manager.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.cycle.CalendaringCycleManager) - a\n                ``CalendaringCycleManager``", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_calendaring_cycle()`` is\n                ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: a ``CalendaringCycleManager``\n        :rtype: ``osid.calendaring.cycle.CalendaringCycleManager``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_calendaring_cycle()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_calendaring_cycle()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.cycle.CalendaringCycleManager", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_calandaring_rules_manager", 
               "doc": {
                  "headline": "Gets the calendaring rules manager.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.rules.CalendaringRulesManager) - a\n                ``CalendaringRulesManager``", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_calendaring_rules()`` is\n                ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: a ``CalendaringRulesManager``\n        :rtype: ``osid.calendaring.rules.CalendaringRulesManager``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_calendaring_rules()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_calendaring_rules()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.rules.CalendaringRulesManager", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.calendaring.CalendaringProxyManager", 
         "shortname": "CalendaringProxyManager", 
         "category": "managers", 
         "doc": {
            "headline": "The calendaring manager provides access to calendaring sessions and provides interoperability tests for various aspects of this service.", 
            "body": "    Methods in this manager support the passing of a ``Proxy`` object.\n    The sessions included in this manager are:\n\n      * ``EventLookupSession:`` a session to look up events\n      * ``EventQuerySession:`` a session to query events ``None``\n      * ``EventSearchSession:`` a session to search events\n      * ``EventAdminSession:`` a session to create, modify and delete\n        events ``None``\n      * ``EventNotificationSession: a`` session to receive messages\n        pertaining to event ```` changes\n      * ``EventCalendarSession:`` a session for retriieving event and\n        calendar mappings\n      * ``EventCalendarAssignmentSession:`` a session for managing event\n        and calendar mappings\n      * ``EventSmartCalendarSession:`` a session to manage dynamic event\n        catalogs\n      * ``RecurringEventLookupSession:`` a session to look up recurring\n        events\n      * ``RecurringEventQuerySession:`` a session to query recurring\n        events\n      * ``RecurringEventSearchSession:`` a session to search recurring\n        events\n      * ``RecurringEventAdminSession:`` a session to create, modify and\n        delete recurring events\n      * ``RecurringEventNotificationSession:`` a session to receive\n        messages pertaining to recurring event changes\n      * ``RecurringEventCalendarSession:`` a session for retriieving\n        recurring event and calendar mappings\n      * ``RecurringEventCalendarAssignmentSession:`` a session for\n        managing recurring event and calendar mappings\n      * ``RecurringEventSmartCalendarSession:`` a session to manage\n        dynamic recurring event catalogs\n    \n      * ``SupersedingEventLookupSession:`` a session to look up\n        superseding events\n      * ``SupersedingEventQuerySession:`` a session to query superseding\n        events ``None``\n      * ``SupersedingEventSearchSession:`` a session to search\n        superseding events\n      * ``SupersedingEventAdminSession:`` a session to create, modify\n        and delete superseding events ``None``\n      * ``SupersedingEventNotificationSession: a`` session to receive\n        messages pertaining to superseding event ```` changes\n      * ``SupersedingEventCalendarSession:`` a session for retriieving\n        superseding event and calendar mappings\n      * ``SupersedingEventCalendarAssignmentSession:`` a session for\n        managing superseding event and calendar mappings\n      * ``SupersedingEventSmartCalendarSession:`` a session to manage\n        dynamic superseding event catalogs\n      * ``OffsetEventLookupSession:`` a session to look up offset events\n      * ``OffsetEventQuerySession:`` a session to query offset events\n      * ``OffsetEventSearchSession:`` a session to search offset events\n      * ``OffsetEventAdminSession:`` a session to create, modify and\n        delete offset events\n      * ``OffsetEventNotificationSession:`` a session to receive\n        messages pertaining to offset event changes\n      * ``OffsetEventCalendarSession:`` a session for retriieving offset\n        event and calendar mappings\n      * ``OffsetEventCalendarAssignmentSession:`` a session for managing\n        offset event and calendar mappings\n      * ``OffsetEventSmartCalendarSession:`` a session to manage dynamic\n        offset event catalogs\n    \n      * ``ScheduleLookupSession:`` a session to look up schedules\n      * ``ScheduleQuerySession:`` a session to query schedules ``None``\n      * ``ScheduleSearchSession:`` a session to search schedules\n      * ``ScheduleAdminSession:`` a session to create, modify and delete\n        schedules ``None``\n      * ``ScheduleNotificationSession: a`` session to receive messages\n        pertaining to schedule ```` changes\n      * ``ScheduleCalendarSession:`` a session for retriieving schedule\n        and calendar mappings\n      * ``ScheduleCalendarAssignmentSession:`` a session for managing\n        schedule and calendar mappings\n      * ``ScheduleSmartCalendarSession:`` a session to manage dynamic\n        schedule catalogs\n      * ``ScheduleSlotLookupSession:`` a session to look up schedule\n        slots\n      * ``ScheduleSlotQuerySession:`` a session to query schedule slots\n      * ``ScheduleSlotSearchSession:`` a session to search scheduls\n        slots\n      * ``ScheduleSlotAdminSession:`` a session to create, modify and\n        delete schedule slots\n      * ``ScheduleSlotNotificationSession:`` a session to receive\n        messages pertaining to schedule slot changes\n      * ``ScheduleSlotCalendarSession:`` a session for retriieving\n        schedule slot and calendar mappings\n      * ``ScheduleSlotCalendarAssignmentSession:`` a session for\n        managing schedule slot and calendar mappings\n      * ``ScheduleSlotSmartCalendarSession:`` a session to manage\n        dynamic schedule slot catalogs\n    \n      * ``CommitmentLookupSession:`` a session to look up commitments\n      * ``CommitmentQuerySession:`` a session to query commitments\n        ``None``\n      * ``CommitmentSearchSession:`` a session to search commitments\n      * ``CommitmentAdminSession:`` a session to create, modify and\n        delete commitments ``None``\n      * ``CommitmentNotificationSession: a`` session to receive messages\n        pertaining to commitment changes\n      * ``CommitmentCalendarSession:`` a session for retriieving\n        commitment and calendar mappings\n      * ``CommitmentCalendarAssignmentSession:`` a session for managing\n        commitment and calendar mappings\n      * ``CommitmentSmartCalendarSession:`` a session to manage dynamic\n        commitment catalogs\n    \n      * ``TimePeriodLookupSession:`` a session to look up time periods\n      * ``TimePeriodQuerySession:`` a session to query time periods\n        ``None``\n      * ``TimePeriodSearchSession:`` a session to search time periods\n      * ``TimePeriodAdminSession:`` a session to create, modify and\n        delete time periods ``None``\n      * ``TimePeriodNotificationSession: a`` session to receive messages\n        pertaining to time period ```` changes\n      * ``TimePeriodCalendarSession:`` a session for retriieving time\n        period and calendar mappings\n      * ``TimePeriodCalendarAssignmentSession:`` a session for managing\n        time period and calendar mappings\n      * ``TimePeriodSmartCalendarSession:`` a session to manage dynamic\n        time period catalogs\n    \n      * ``CalendarLookupSession:`` a session to lookup calendars\n      * ``CalendarSearchSession`` : a session to search calendars\n      * ``CalendarAdminSession`` : a session to create, modify and\n        delete calendars\n      * ``CalendarNotificationSession`` : a session to receive messages\n        pertaining to calendar changes\n      * ``CalendarHierarchySession:`` a session to traverse the calendar\n        hierarchy\n      * ``CalendarHierarchyDesignSession:`` a session to manage the\n        calendar hierarchy\n"
         }, 
         "inherit_fullnames": [
            "osid.OsidProxyManager", 
            "osid.calendaring.CalendaringProfile"
         ], 
         "inherit_shortnames": [
            "OsidProxyManager", 
            "CalendaringProfile"
         ], 
         "inherit_pkg_names": [
            "osid", 
            "calendaring"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidProxyManager"
            }, 
            {
               "pkg_name": "calendaring", 
               "name": "CalendaringProfile"
            }
         ], 
         "method_names": [
            "get_event_lookup_session", 
            "get_event_lookup_session_for_calendar", 
            "get_event_query_session", 
            "get_event_query_session_for_calendar", 
            "get_event_search_session", 
            "get_event_search_session_for_calendar", 
            "get_event_admin_session", 
            "get_event_admin_session_for_calendar", 
            "get_event_notification_session", 
            "get_event_notification_session_for_calendar", 
            "get_event_calendar_session", 
            "get_event_calendar_assignment_session", 
            "get_event_smart_calendar_session", 
            "get_recurring_event_lookup_session", 
            "get_recurring_event_lookup_session_for_calendar", 
            "get_recurring_event_query_session", 
            "get_recurring_event_query_session_for_calendar", 
            "get_recurring_event_search_session", 
            "get_recurring_event_search_session_for_calendar", 
            "get_recurring_event_admin_session", 
            "get_recurring_event_admin_session_for_calendar", 
            "get_recurring_event_notification_session", 
            "get_recurring_event_notification_session_for_calendar", 
            "get_recurring_event_calendar_session", 
            "get_recurring_event_calendar_assignment_session", 
            "get_recurring_event_smart_calendar_session", 
            "get_superseding_event_lookup_session", 
            "get_superseding_event_lookup_session_for_calendar", 
            "get_superseding_event_query_session", 
            "get_superseding_event_query_session_for_calendar", 
            "get_superseding_event_search_session", 
            "get_superseding_event_search_session_for_calendar", 
            "get_superseding_event_admin_session", 
            "get_superseding_event_admin_session_for_calendar", 
            "get_superseding_event_notification_session", 
            "get_superseding_event_notification_session_for_calendar", 
            "get_superseding_event_calendar_session", 
            "get_superseding_event_calendar_assignment_session", 
            "get_superseding_event_smart_calendar_session", 
            "get_offset_event_lookup_session", 
            "get_offset_event_lookup_session_for_calendar", 
            "get_offset_event_query_session", 
            "get_offset_event_query_session_for_calendar", 
            "get_offset_event_search_session", 
            "get_offset_event_search_session_for_calendar", 
            "get_offset_event_admin_session", 
            "get_offset_event_admin_session_for_calendar", 
            "get_offset_event_notification_session", 
            "get_offset_event_notification_session_for_calendar", 
            "get_offset_event_calendar_session", 
            "get_offset_event_calendar_assignment_session", 
            "get_offset_event_smart_calendar_session", 
            "get_schedule_lookup_session", 
            "get_schedule_lookup_session_for_calendar", 
            "get_schedule_query_session", 
            "get_schedule_query_session_for_calendar", 
            "get_schedule_search_session", 
            "get_schedule_search_session_for_calendar", 
            "get_schedule_admin_session", 
            "get_schedule_admin_session_for_calendar", 
            "get_schedule_notification_session", 
            "get_schedule_notification_session_for_calendar", 
            "get_schedule_calendar_session", 
            "get_schedule_calendar_assignment_session", 
            "get_schedule_smart_calendar_session", 
            "get_schedule_slot_lookup_session", 
            "get_schedule_slot_lookup_session_for_calendar", 
            "get_schedule_slot_query_session", 
            "get_schedule_slot_query_session_for_calendar", 
            "get_schedule_slot_search_session", 
            "get_schedule_slot_search_session_for_calendar", 
            "get_schedule_slot_admin_session", 
            "get_schedule_slot_admin_session_for_calendar", 
            "get_schedule_slot_notification_session", 
            "get_schedule_slot_notification_session_for_calendar", 
            "get_schedule_slot_calendar_session", 
            "get_schedule_slot_calendar_assignment_session", 
            "get_schedule_slot_smart_calendar_session", 
            "get_commitment_lookup_session", 
            "get_commitment_lookup_session_for_calendar", 
            "get_commitment_query_session", 
            "get_commitment_query_session_for_calendar", 
            "get_commitment_search_session", 
            "get_commitment_search_session_for_calendar", 
            "get_commitment_admin_session", 
            "get_commitment_admin_session_for_calendar", 
            "get_commitment_notification_session", 
            "get_commitment_notification_session_for_calendar", 
            "get_commitment_calendar_session", 
            "get_commitment_calendar_assignment_session", 
            "get_commitment_smart_calendar_session", 
            "get_time_period_lookup_session", 
            "get_time_period_lookup_session_for_calendar", 
            "get_time_period_query_session", 
            "get_time_period_query_session_for_calendar", 
            "get_time_period_search_session", 
            "get_time_period_search_session_for_calendar", 
            "get_time_period_admin_session", 
            "get_time_period_admin_session_for_calendar", 
            "get_time_period_notification_session", 
            "get_time_period_notification_session_for_calendar", 
            "get_time_period_calendar_session", 
            "get_time_period_calendar_assignment_session", 
            "get_time_period_smart_calendar_session", 
            "get_calendar_lookup_session", 
            "get_calendar_search_session", 
            "get_calendar_admin_session", 
            "get_calendar_notification_session", 
            "get_calendar_hierarchy_session", 
            "get_calendar_hierarchy_design_session", 
            "get_calandaring_batch_proxy_manager", 
            "get_calandaring_cycle_proxy_manager", 
            "get_calandaring_rules_proxy_manager"
         ], 
         "methods": [
            {
               "name": "get_event_lookup_session", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` associated with the event lookup service.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    proxy (osid.proxy.Proxy): a proxy\n", 
               "return_doc": "        return: (osid.calendaring.EventLookupSession) - an\n                ``EventLookupSession``", 
               "error_doc": "        raise:  NullArgument - ``proxy`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_event_lookup()`` is ``false``", 
               "sphinx_param_doc": "        :param proxy: a proxy\n        :type proxy: ``osid.proxy.Proxy``\n", 
               "sphinx_return_doc": "        :return: an ``EventLookupSession``\n        :rtype: ``osid.calendaring.EventLookupSession``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``proxy`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_event_lookup()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_event_lookup()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.proxy.Proxy", 
                     "var_name": "proxy", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.proxy.Proxy"
               ], 
               "return_type": "osid.calendaring.EventLookupSession", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_event_lookup_session_for_calendar", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` associated with the event lookup service for the given calendar.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    calendar_id (osid.id.Id): the ``Id`` of the calendar\n        arg:    proxy (osid.proxy.Proxy): a proxy\n", 
               "return_doc": "        return: (osid.calendaring.EventLookupSession) - an\n                ``EventLookupSession``", 
               "error_doc": "        raise:  NotFound - ``calendar_id`` not found\n        raise:  NullArgument - ``calendar_id`` or ``proxy`` is ``null``\n        raise:  OperationFailed - ``unable to complete request``\n        raise:  Unimplemented - ``supports_event_lookup()`` or\n                ``supports_visible_federation()`` is ``false``", 
               "sphinx_param_doc": "        :param calendar_id: the ``Id`` of the calendar\n        :type calendar_id: ``osid.id.Id``\n        :param proxy: a proxy\n        :type proxy: ``osid.proxy.Proxy``\n", 
               "sphinx_return_doc": "        :return: an ``EventLookupSession``\n        :rtype: ``osid.calendaring.EventLookupSession``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``calendar_id`` not found\n        :raise: ``NullArgument`` -- ``calendar_id`` or ``proxy`` is ``null``\n        :raise: ``OperationFailed`` -- ``unable to complete request``\n        :raise: ``Unimplemented`` -- ``supports_event_lookup()`` or ``supports_visible_federation()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_event_lookup()`` and ``supports_visible_federation()`` are ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "calendar_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.proxy.Proxy", 
                     "var_name": "proxy", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "osid.proxy.Proxy"
               ], 
               "return_type": "osid.calendaring.EventLookupSession", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_event_query_session", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` associated with the event query service.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    proxy (osid.proxy.Proxy): a proxy\n", 
               "return_doc": "        return: (osid.calendaring.EventQuerySession) - an\n                ``EventQuerySession``", 
               "error_doc": "        raise:  NullArgument - ``proxy`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_event_query()`` is ``false``", 
               "sphinx_param_doc": "        :param proxy: a proxy\n        :type proxy: ``osid.proxy.Proxy``\n", 
               "sphinx_return_doc": "        :return: an ``EventQuerySession``\n        :rtype: ``osid.calendaring.EventQuerySession``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``proxy`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_event_query()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_event_query()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.proxy.Proxy", 
                     "var_name": "proxy", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.proxy.Proxy"
               ], 
               "return_type": "osid.calendaring.EventQuerySession", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_event_query_session_for_calendar", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` associated with the event query service for the given calendar.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    calendar_id (osid.id.Id): the ``Id`` of the calendar\n        arg:    proxy (osid.proxy.Proxy): a proxy\n", 
               "return_doc": "        return: (osid.calendaring.EventQuerySession) - an\n                ``EventQuerySession``", 
               "error_doc": "        raise:  NotFound - ``calendar_id`` not found\n        raise:  NullArgument - ``calendar_id`` or ``proxy`` is ``null``\n        raise:  OperationFailed - ``unable to complete request``\n        raise:  Unimplemented - ``supports_event_query()`` or\n                ``supports_visible_federation()`` is ``false``", 
               "sphinx_param_doc": "        :param calendar_id: the ``Id`` of the calendar\n        :type calendar_id: ``osid.id.Id``\n        :param proxy: a proxy\n        :type proxy: ``osid.proxy.Proxy``\n", 
               "sphinx_return_doc": "        :return: an ``EventQuerySession``\n        :rtype: ``osid.calendaring.EventQuerySession``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``calendar_id`` not found\n        :raise: ``NullArgument`` -- ``calendar_id`` or ``proxy`` is ``null``\n        :raise: ``OperationFailed`` -- ``unable to complete request``\n        :raise: ``Unimplemented`` -- ``supports_event_query()`` or ``supports_visible_federation()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_event_query()`` and ``supports_visible_federation()`` are ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "calendar_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.proxy.Proxy", 
                     "var_name": "proxy", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "osid.proxy.Proxy"
               ], 
               "return_type": "osid.calendaring.EventQuerySession", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_event_search_session", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` associated with the event search service.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    proxy (osid.proxy.Proxy): a proxy\n", 
               "return_doc": "        return: (osid.calendaring.EventSearchSession) - an\n                ``EventSearchSession``", 
               "error_doc": "        raise:  NullArgument - ``proxy`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_event_search()`` is ``false``", 
               "sphinx_param_doc": "        :param proxy: a proxy\n        :type proxy: ``osid.proxy.Proxy``\n", 
               "sphinx_return_doc": "        :return: an ``EventSearchSession``\n        :rtype: ``osid.calendaring.EventSearchSession``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``proxy`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_event_search()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_event_search()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.proxy.Proxy", 
                     "var_name": "proxy", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.proxy.Proxy"
               ], 
               "return_type": "osid.calendaring.EventSearchSession", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_event_search_session_for_calendar", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` associated with the event search service for the given calendar.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    calendar_id (osid.id.Id): the ``Id`` of the calendar\n        arg:    proxy (osid.proxy.Proxy): a proxy\n", 
               "return_doc": "        return: (osid.calendaring.EventSearchSession) - an\n                ``EventSearchSession``", 
               "error_doc": "        raise:  NotFound - ``calendar_id`` not found\n        raise:  NullArgument - ``calendar_id`` or ``proxy`` is ``null``\n        raise:  OperationFailed - ``unable to complete request``\n        raise:  Unimplemented - ``supports_event_search()`` or\n                ``supports_visible_federation()`` is ``false``", 
               "sphinx_param_doc": "        :param calendar_id: the ``Id`` of the calendar\n        :type calendar_id: ``osid.id.Id``\n        :param proxy: a proxy\n        :type proxy: ``osid.proxy.Proxy``\n", 
               "sphinx_return_doc": "        :return: an ``EventSearchSession``\n        :rtype: ``osid.calendaring.EventSearchSession``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``calendar_id`` not found\n        :raise: ``NullArgument`` -- ``calendar_id`` or ``proxy`` is ``null``\n        :raise: ``OperationFailed`` -- ``unable to complete request``\n        :raise: ``Unimplemented`` -- ``supports_event_search()`` or ``supports_visible_federation()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_event_search()`` and ``supports_visible_federation()`` are ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "calendar_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.proxy.Proxy", 
                     "var_name": "proxy", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "osid.proxy.Proxy"
               ], 
               "return_type": "osid.calendaring.EventSearchSession", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_event_admin_session", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` associated with the event administration service.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    proxy (osid.proxy.Proxy): a proxy\n", 
               "return_doc": "        return: (osid.calendaring.EventAdminSession) - an\n                ``EventAdminSession``", 
               "error_doc": "        raise:  NullArgument - ``proxy`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_event_admin()`` is ``false``", 
               "sphinx_param_doc": "        :param proxy: a proxy\n        :type proxy: ``osid.proxy.Proxy``\n", 
               "sphinx_return_doc": "        :return: an ``EventAdminSession``\n        :rtype: ``osid.calendaring.EventAdminSession``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``proxy`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_event_admin()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_event_admin()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.proxy.Proxy", 
                     "var_name": "proxy", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.proxy.Proxy"
               ], 
               "return_type": "osid.calendaring.EventAdminSession", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_event_admin_session_for_calendar", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` associated with the event admin service for the given calendar.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    calendar_id (osid.id.Id): the ``Id`` of the calendar\n        arg:    proxy (osid.proxy.Proxy): a proxy\n", 
               "return_doc": "        return: (osid.calendaring.EventAdminSession) - an\n                ``EventAdminSession``", 
               "error_doc": "        raise:  NotFound - ``calendar_id`` not found\n        raise:  NullArgument - ``calendar_id`` or ``proxy`` is ``null``\n        raise:  OperationFailed - ``unable to complete request``\n        raise:  Unimplemented - ``supports_event_admin()`` or\n                ``supports_visible_federation()`` is ``false``", 
               "sphinx_param_doc": "        :param calendar_id: the ``Id`` of the calendar\n        :type calendar_id: ``osid.id.Id``\n        :param proxy: a proxy\n        :type proxy: ``osid.proxy.Proxy``\n", 
               "sphinx_return_doc": "        :return: an ``EventAdminSession``\n        :rtype: ``osid.calendaring.EventAdminSession``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``calendar_id`` not found\n        :raise: ``NullArgument`` -- ``calendar_id`` or ``proxy`` is ``null``\n        :raise: ``OperationFailed`` -- ``unable to complete request``\n        :raise: ``Unimplemented`` -- ``supports_event_admin()`` or ``supports_visible_federation()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_event_admin()`` and ``supports_visible_federation()`` are ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "calendar_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.proxy.Proxy", 
                     "var_name": "proxy", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "osid.proxy.Proxy"
               ], 
               "return_type": "osid.calendaring.EventAdminSession", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_event_notification_session", 
               "doc": {
                  "headline": "Gets the notification session for notifications pertaining to event changes.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    event_receiver (osid.calendaring.EventReceiver): the\n                event receiver\n        arg:    proxy (osid.proxy.Proxy): a proxy\n", 
               "return_doc": "        return: (osid.calendaring.EventNotificationSession) - an\n                ``EventNotificationSession``", 
               "error_doc": "        raise:  NullArgument - ``event_receiver`` or ``proxy`` is\n                ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_event_notification()`` is\n                ``false``", 
               "sphinx_param_doc": "        :param event_receiver: the event receiver\n        :type event_receiver: ``osid.calendaring.EventReceiver``\n        :param proxy: a proxy\n        :type proxy: ``osid.proxy.Proxy``\n", 
               "sphinx_return_doc": "        :return: an ``EventNotificationSession``\n        :rtype: ``osid.calendaring.EventNotificationSession``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``event_receiver`` or ``proxy`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_event_notification()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_event_notification()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.calendaring.EventReceiver", 
                     "var_name": "event_receiver", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.proxy.Proxy", 
                     "var_name": "proxy", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.calendaring.EventReceiver", 
                  "osid.proxy.Proxy"
               ], 
               "return_type": "osid.calendaring.EventNotificationSession", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_event_notification_session_for_calendar", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` associated with the event notification service for the given calendar.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    event_receiver (osid.calendaring.EventReceiver): the\n                event receiver\n        arg:    calendar_id (osid.id.Id): the ``Id`` of the calendar\n        arg:    proxy (osid.proxy.Proxy): a proxy\n", 
               "return_doc": "        return: (osid.calendaring.EventNotificationSession) - ``an\n                _event_notification_session``", 
               "error_doc": "        raise:  NotFound - ``calendar_id`` not found\n        raise:  NullArgument - ``event_receiver,`` None ``calendar_id``\n                or ``proxy`` is ``null``\n        raise:  OperationFailed - ``unable to complete request``\n        raise:  Unimplemented - ``supports_event_notification()`` or\n                ``supports_visible_federation()`` is ``false``", 
               "sphinx_param_doc": "        :param event_receiver: the event receiver\n        :type event_receiver: ``osid.calendaring.EventReceiver``\n        :param calendar_id: the ``Id`` of the calendar\n        :type calendar_id: ``osid.id.Id``\n        :param proxy: a proxy\n        :type proxy: ``osid.proxy.Proxy``\n", 
               "sphinx_return_doc": "        :return: ``an _event_notification_session``\n        :rtype: ``osid.calendaring.EventNotificationSession``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``calendar_id`` not found\n        :raise: ``NullArgument`` -- ``event_receiver,`` None ``calendar_id`` or ``proxy`` is ``null``\n        :raise: ``OperationFailed`` -- ``unable to complete request``\n        :raise: ``Unimplemented`` -- ``supports_event_notification()`` or ``supports_visible_federation()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_event_notification()`` and ``supports_visible_federation()`` are ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.calendaring.EventReceiver", 
                     "var_name": "event_receiver", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "calendar_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.proxy.Proxy", 
                     "var_name": "proxy", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.calendaring.EventReceiver", 
                  "osid.id.Id", 
                  "osid.proxy.Proxy"
               ], 
               "return_type": "osid.calendaring.EventNotificationSession", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_event_calendar_session", 
               "doc": {
                  "headline": "Gets the session for retrieving event to calendar mappings.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    proxy (osid.proxy.Proxy): a proxy\n", 
               "return_doc": "        return: (osid.calendaring.EventCalendarSession) - an\n                ``EventCalendarSession``", 
               "error_doc": "        raise:  NullArgument - ``proxy`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_event_calendar()`` is\n                ``false``", 
               "sphinx_param_doc": "        :param proxy: a proxy\n        :type proxy: ``osid.proxy.Proxy``\n", 
               "sphinx_return_doc": "        :return: an ``EventCalendarSession``\n        :rtype: ``osid.calendaring.EventCalendarSession``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``proxy`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_event_calendar()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_event_calendar()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.proxy.Proxy", 
                     "var_name": "proxy", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.proxy.Proxy"
               ], 
               "return_type": "osid.calendaring.EventCalendarSession", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_event_calendar_assignment_session", 
               "doc": {
                  "headline": "Gets the session for assigning event to calendar mappings.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    proxy (osid.proxy.Proxy): a proxy\n", 
               "return_doc": "        return: (osid.calendaring.EventCalendarAssignmentSession) - an\n                ``EventCalendarAssignmentSession``", 
               "error_doc": "        raise:  NullArgument - ``proxy`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_event_calendar_assignment()``\n                is ``false``", 
               "sphinx_param_doc": "        :param proxy: a proxy\n        :type proxy: ``osid.proxy.Proxy``\n", 
               "sphinx_return_doc": "        :return: an ``EventCalendarAssignmentSession``\n        :rtype: ``osid.calendaring.EventCalendarAssignmentSession``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``proxy`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_event_calendar_assignment()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_event_calendar_assignment()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.proxy.Proxy", 
                     "var_name": "proxy", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.proxy.Proxy"
               ], 
               "return_type": "osid.calendaring.EventCalendarAssignmentSession", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_event_smart_calendar_session", 
               "doc": {
                  "headline": "Gets the session associated with the event smart calendar for the given calendar.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    calendar_id (osid.id.Id): the ``Id`` of the calendar\n        arg:    proxy (osid.proxy.Proxy): a proxy\n", 
               "return_doc": "        return: (osid.calendaring.EventSmartCalendarSession) - an\n                ``EventSmartCalendarSession``", 
               "error_doc": "        raise:  NotFound - ``calendar_id`` not found\n        raise:  NullArgument - ``calendar_id or proxy is null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_event_smart_calendar()`` is\n                ``false``", 
               "sphinx_param_doc": "        :param calendar_id: the ``Id`` of the calendar\n        :type calendar_id: ``osid.id.Id``\n        :param proxy: a proxy\n        :type proxy: ``osid.proxy.Proxy``\n", 
               "sphinx_return_doc": "        :return: an ``EventSmartCalendarSession``\n        :rtype: ``osid.calendaring.EventSmartCalendarSession``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``calendar_id`` not found\n        :raise: ``NullArgument`` -- ``calendar_id or proxy is null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_event_smart_calendar()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_event_smart_calendar()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "calendar_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.proxy.Proxy", 
                     "var_name": "proxy", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "osid.proxy.Proxy"
               ], 
               "return_type": "osid.calendaring.EventSmartCalendarSession", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_recurring_event_lookup_session", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` associated with the recurring event lookup service.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    proxy (osid.proxy.Proxy): a proxy\n", 
               "return_doc": "        return: (osid.calendaring.RecurringEventLookupSession) - a\n                ``RecurringEventLookupSession``", 
               "error_doc": "        raise:  NullArgument - ``proxy`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_recurring_event_lookup()`` is\n                ``false``", 
               "sphinx_param_doc": "        :param proxy: a proxy\n        :type proxy: ``osid.proxy.Proxy``\n", 
               "sphinx_return_doc": "        :return: a ``RecurringEventLookupSession``\n        :rtype: ``osid.calendaring.RecurringEventLookupSession``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``proxy`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_recurring_event_lookup()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_recurring_event_lookup()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.proxy.Proxy", 
                     "var_name": "proxy", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.proxy.Proxy"
               ], 
               "return_type": "osid.calendaring.RecurringEventLookupSession", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_recurring_event_lookup_session_for_calendar", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` associated with the recurring event lookup service for the given calendar.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    calendar_id (osid.id.Id): the ``Id`` of the calendar\n        arg:    proxy (osid.proxy.Proxy): a proxy\n", 
               "return_doc": "        return: (osid.calendaring.RecurringEventLookupSession) - a\n                ``RecurringEventLookupSession``", 
               "error_doc": "        raise:  NotFound - ``calendar_id`` not found\n        raise:  NullArgument - ``calendar_id or proxy is null``\n        raise:  OperationFailed - ``unable to complete request``\n        raise:  Unimplemented - ``supports_recurring_event_lookup()`` or\n                ``supports_visible_federation()`` is ``false``", 
               "sphinx_param_doc": "        :param calendar_id: the ``Id`` of the calendar\n        :type calendar_id: ``osid.id.Id``\n        :param proxy: a proxy\n        :type proxy: ``osid.proxy.Proxy``\n", 
               "sphinx_return_doc": "        :return: a ``RecurringEventLookupSession``\n        :rtype: ``osid.calendaring.RecurringEventLookupSession``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``calendar_id`` not found\n        :raise: ``NullArgument`` -- ``calendar_id or proxy is null``\n        :raise: ``OperationFailed`` -- ``unable to complete request``\n        :raise: ``Unimplemented`` -- ``supports_recurring_event_lookup()`` or ``supports_visible_federation()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_recurring_event_lookup()`` and ``supports_visible_federation()`` are ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "calendar_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.proxy.Proxy", 
                     "var_name": "proxy", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "osid.proxy.Proxy"
               ], 
               "return_type": "osid.calendaring.RecurringEventLookupSession", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_recurring_event_query_session", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` associated with the recurring event query service.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    proxy (osid.proxy.Proxy): a proxy\n", 
               "return_doc": "        return: (osid.calendaring.RecurringEventQuerySession) - a\n                ``RecurringEventQuerySession``", 
               "error_doc": "        raise:  NullArgument - ``proxy`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_recurring_event_query()`` is\n                ``false``", 
               "sphinx_param_doc": "        :param proxy: a proxy\n        :type proxy: ``osid.proxy.Proxy``\n", 
               "sphinx_return_doc": "        :return: a ``RecurringEventQuerySession``\n        :rtype: ``osid.calendaring.RecurringEventQuerySession``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``proxy`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_recurring_event_query()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_recurring_event_query()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.proxy.Proxy", 
                     "var_name": "proxy", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.proxy.Proxy"
               ], 
               "return_type": "osid.calendaring.RecurringEventQuerySession", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_recurring_event_query_session_for_calendar", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` associated with the recurring event query service for the given calendar.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    calendar_id (osid.id.Id): the ``Id`` of the calendar\n        arg:    proxy (osid.proxy.Proxy): a proxy\n", 
               "return_doc": "        return: (osid.calendaring.RecurringEventQuerySession) - a\n                ``RecurringEventQuerySession``", 
               "error_doc": "        raise:  NotFound - ``calendar_id`` not found\n        raise:  NullArgument - ``calendar_id or proxy is null``\n        raise:  OperationFailed - ``unable to complete request``\n        raise:  Unimplemented - ``supports_recurring_event_query()`` or\n                ``supports_visible_federation()`` is ``false``", 
               "sphinx_param_doc": "        :param calendar_id: the ``Id`` of the calendar\n        :type calendar_id: ``osid.id.Id``\n        :param proxy: a proxy\n        :type proxy: ``osid.proxy.Proxy``\n", 
               "sphinx_return_doc": "        :return: a ``RecurringEventQuerySession``\n        :rtype: ``osid.calendaring.RecurringEventQuerySession``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``calendar_id`` not found\n        :raise: ``NullArgument`` -- ``calendar_id or proxy is null``\n        :raise: ``OperationFailed`` -- ``unable to complete request``\n        :raise: ``Unimplemented`` -- ``supports_recurring_event_query()`` or ``supports_visible_federation()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_recurring_event_query()`` and ``supports_visible_federation()`` are ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "calendar_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.proxy.Proxy", 
                     "var_name": "proxy", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "osid.proxy.Proxy"
               ], 
               "return_type": "osid.calendaring.RecurringEventQuerySession", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_recurring_event_search_session", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` associated with the recurring event search service.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    proxy (osid.proxy.Proxy): a proxy\n", 
               "return_doc": "        return: (osid.calendaring.RecurringEventSearchSession) - a\n                ``RecurringEventSearchSession``", 
               "error_doc": "        raise:  NullArgument - ``proxy`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_recurring_event_search()`` is\n                ``false``", 
               "sphinx_param_doc": "        :param proxy: a proxy\n        :type proxy: ``osid.proxy.Proxy``\n", 
               "sphinx_return_doc": "        :return: a ``RecurringEventSearchSession``\n        :rtype: ``osid.calendaring.RecurringEventSearchSession``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``proxy`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_recurring_event_search()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_recurring_event_search()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.proxy.Proxy", 
                     "var_name": "proxy", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.proxy.Proxy"
               ], 
               "return_type": "osid.calendaring.RecurringEventSearchSession", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_recurring_event_search_session_for_calendar", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` associated with the recurring event search service for the given calendar.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    calendar_id (osid.id.Id): the ``Id`` of the calendar\n        arg:    proxy (osid.proxy.Proxy): a proxy\n", 
               "return_doc": "        return: (osid.calendaring.RecurringEventSearchSession) - a\n                ``RecurringEventSearchSession``", 
               "error_doc": "        raise:  NotFound - ``calendar_id`` not found\n        raise:  NullArgument - ``calendar_id or proxy is null``\n        raise:  OperationFailed - ``unable to complete request``\n        raise:  Unimplemented - ``supports_recurring_event_search()`` or\n                ``supports_visible_federation()`` is ``false``", 
               "sphinx_param_doc": "        :param calendar_id: the ``Id`` of the calendar\n        :type calendar_id: ``osid.id.Id``\n        :param proxy: a proxy\n        :type proxy: ``osid.proxy.Proxy``\n", 
               "sphinx_return_doc": "        :return: a ``RecurringEventSearchSession``\n        :rtype: ``osid.calendaring.RecurringEventSearchSession``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``calendar_id`` not found\n        :raise: ``NullArgument`` -- ``calendar_id or proxy is null``\n        :raise: ``OperationFailed`` -- ``unable to complete request``\n        :raise: ``Unimplemented`` -- ``supports_recurring_event_search()`` or ``supports_visible_federation()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_recurring_event_search()`` and ``supports_visible_federation()`` are ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "calendar_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.proxy.Proxy", 
                     "var_name": "proxy", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "osid.proxy.Proxy"
               ], 
               "return_type": "osid.calendaring.RecurringEventSearchSession", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_recurring_event_admin_session", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` associated with the recurring event administration service.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    proxy (osid.proxy.Proxy): a proxy\n", 
               "return_doc": "        return: (osid.calendaring.RecurringEventAdminSession) - a\n                ``RecurringEventAdminSession``", 
               "error_doc": "        raise:  NullArgument - ``proxy`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_recurring_event_admin()`` is\n                ``false``", 
               "sphinx_param_doc": "        :param proxy: a proxy\n        :type proxy: ``osid.proxy.Proxy``\n", 
               "sphinx_return_doc": "        :return: a ``RecurringEventAdminSession``\n        :rtype: ``osid.calendaring.RecurringEventAdminSession``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``proxy`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_recurring_event_admin()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_recurring_event_admin()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.proxy.Proxy", 
                     "var_name": "proxy", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.proxy.Proxy"
               ], 
               "return_type": "osid.calendaring.RecurringEventAdminSession", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_recurring_event_admin_session_for_calendar", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` associated with the recurring event admin service for the given calendar.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    calendar_id (osid.id.Id): the ``Id`` of the calendar\n        arg:    proxy (osid.proxy.Proxy): a proxy\n", 
               "return_doc": "        return: (osid.calendaring.RecurringEventAdminSession) - a\n                ``RecurringEventAdminSession``", 
               "error_doc": "        raise:  NotFound - ``calendar_id`` not found\n        raise:  NullArgument - ``calendar_id or proxy is null``\n        raise:  OperationFailed - ``unable to complete request``\n        raise:  Unimplemented - ``supports_recurring_event_admin()`` or\n                ``supports_visible_federation()`` is ``false``", 
               "sphinx_param_doc": "        :param calendar_id: the ``Id`` of the calendar\n        :type calendar_id: ``osid.id.Id``\n        :param proxy: a proxy\n        :type proxy: ``osid.proxy.Proxy``\n", 
               "sphinx_return_doc": "        :return: a ``RecurringEventAdminSession``\n        :rtype: ``osid.calendaring.RecurringEventAdminSession``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``calendar_id`` not found\n        :raise: ``NullArgument`` -- ``calendar_id or proxy is null``\n        :raise: ``OperationFailed`` -- ``unable to complete request``\n        :raise: ``Unimplemented`` -- ``supports_recurring_event_admin()`` or ``supports_visible_federation()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_recurring_event_admin()`` and ``supports_visible_federation()`` are ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "calendar_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.proxy.Proxy", 
                     "var_name": "proxy", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "osid.proxy.Proxy"
               ], 
               "return_type": "osid.calendaring.RecurringEventAdminSession", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_recurring_event_notification_session", 
               "doc": {
                  "headline": "Gets the notification session for notifications pertaining to recurring event changes.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    recurring_event_receiver\n                (osid.calendaring.RecurringEventReceiver): the recurring\n                event receiver\n        arg:    proxy (osid.proxy.Proxy): a proxy\n", 
               "return_doc": "        return: (osid.calendaring.RecurringEventNotificationSession) - a\n                ``RecurringEventNotificationSession``", 
               "error_doc": "        raise:  NullArgument - ``recurring_event_receiver`` or ``proxy``\n                is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented -\n                ``supports_recurring_event_notification()`` is ``false``", 
               "sphinx_param_doc": "        :param recurring_event_receiver: the recurring event receiver\n        :type recurring_event_receiver: ``osid.calendaring.RecurringEventReceiver``\n        :param proxy: a proxy\n        :type proxy: ``osid.proxy.Proxy``\n", 
               "sphinx_return_doc": "        :return: a ``RecurringEventNotificationSession``\n        :rtype: ``osid.calendaring.RecurringEventNotificationSession``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``recurring_event_receiver`` or ``proxy`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_recurring_event_notification()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_recurring_event_notification()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.calendaring.RecurringEventReceiver", 
                     "var_name": "recurring_event_receiver", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.proxy.Proxy", 
                     "var_name": "proxy", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.calendaring.RecurringEventReceiver", 
                  "osid.proxy.Proxy"
               ], 
               "return_type": "osid.calendaring.RecurringEventNotificationSession", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_recurring_event_notification_session_for_calendar", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` associated with the recurring event notification service for the given calendar.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    recurring_event_receiver\n                (osid.calendaring.RecurringEventReceiver): the recurring\n                event receiver\n        arg:    calendar_id (osid.id.Id): the ``Id`` of the calendar\n        arg:    proxy (osid.proxy.Proxy): a proxy\n", 
               "return_doc": "        return: (osid.calendaring.RecurringEventNotificationSession) - a\n                ``RecurringEventNotificationSession``", 
               "error_doc": "        raise:  NotFound - ``calendar_id`` not found\n        raise:  NullArgument - ``recurring_event_receiver,``\n                ``calendar_id`` or ``proxy`` is ``null``\n        raise:  OperationFailed - ``unable to complete request``\n        raise:  Unimplemented -\n                ``supports_recurring_event_notification()`` or\n                ``supports_visible_federation()`` is ``false``", 
               "sphinx_param_doc": "        :param recurring_event_receiver: the recurring event receiver\n        :type recurring_event_receiver: ``osid.calendaring.RecurringEventReceiver``\n        :param calendar_id: the ``Id`` of the calendar\n        :type calendar_id: ``osid.id.Id``\n        :param proxy: a proxy\n        :type proxy: ``osid.proxy.Proxy``\n", 
               "sphinx_return_doc": "        :return: a ``RecurringEventNotificationSession``\n        :rtype: ``osid.calendaring.RecurringEventNotificationSession``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``calendar_id`` not found\n        :raise: ``NullArgument`` -- ``recurring_event_receiver,``  ``calendar_id`` or ``proxy`` is ``null``\n        :raise: ``OperationFailed`` -- ``unable to complete request``\n        :raise: ``Unimplemented`` -- ``supports_recurring_event_notification()`` or ``supports_visible_federation()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_recurring_event_notification()`` and ``supports_visible_federation()`` are ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.calendaring.RecurringEventReceiver", 
                     "var_name": "recurring_event_receiver", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "calendar_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.proxy.Proxy", 
                     "var_name": "proxy", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.calendaring.RecurringEventReceiver", 
                  "osid.id.Id", 
                  "osid.proxy.Proxy"
               ], 
               "return_type": "osid.calendaring.RecurringEventNotificationSession", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_recurring_event_calendar_session", 
               "doc": {
                  "headline": "Gets the session for retrieving recurring event to calendar mappings.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    proxy (osid.proxy.Proxy): a proxy\n", 
               "return_doc": "        return: (osid.calendaring.RecurringEventCalendarSession) - a\n                ``RecurringEventCalendarSession``", 
               "error_doc": "        raise:  NullArgument - ``proxy`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_recurring_event_calendar()``\n                is ``false``", 
               "sphinx_param_doc": "        :param proxy: a proxy\n        :type proxy: ``osid.proxy.Proxy``\n", 
               "sphinx_return_doc": "        :return: a ``RecurringEventCalendarSession``\n        :rtype: ``osid.calendaring.RecurringEventCalendarSession``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``proxy`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_recurring_event_calendar()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_recurring_event_calendar()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.proxy.Proxy", 
                     "var_name": "proxy", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.proxy.Proxy"
               ], 
               "return_type": "osid.calendaring.RecurringEventCalendarSession", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_recurring_event_calendar_assignment_session", 
               "doc": {
                  "headline": "Gets the session for assigning recurring event to calendar mappings.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    proxy (osid.proxy.Proxy): a proxy\n", 
               "return_doc": "        return:\n                (osid.calendaring.RecurringEventCalendarAssignmentSessio\n                n) - a ``RecurringEventCalendarAssignmentSession``", 
               "error_doc": "        raise:  NullArgument - ``proxy`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented -\n                ``supports_recurring_event_calendar_assignment()`` is\n                ``false``", 
               "sphinx_param_doc": "        :param proxy: a proxy\n        :type proxy: ``osid.proxy.Proxy``\n", 
               "sphinx_return_doc": "        :return: a ``RecurringEventCalendarAssignmentSession``\n        :rtype: ``osid.calendaring.RecurringEventCalendarAssignmentSession``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``proxy`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_recurring_event_calendar_assignment()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_recurring_event_calendar_assignment()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.proxy.Proxy", 
                     "var_name": "proxy", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.proxy.Proxy"
               ], 
               "return_type": "osid.calendaring.RecurringEventCalendarAssignmentSession", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_recurring_event_smart_calendar_session", 
               "doc": {
                  "headline": "Gets the session associated with the recurring event smart calendar for the given calendar.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    calendar_id (osid.id.Id): the ``Id`` of the calendar\n        arg:    proxy (osid.proxy.Proxy): a proxy\n", 
               "return_doc": "        return: (osid.calendaring.RecurringEventSmartCalendarSession) -\n                a ``RecurringEventSmartCalendarSession``", 
               "error_doc": "        raise:  NotFound - ``calendar_id`` not found\n        raise:  NullArgument - ``calendar_id or proxy is null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented -\n                ``supports_recurring_event_smart_calendar()`` is\n                ``false``", 
               "sphinx_param_doc": "        :param calendar_id: the ``Id`` of the calendar\n        :type calendar_id: ``osid.id.Id``\n        :param proxy: a proxy\n        :type proxy: ``osid.proxy.Proxy``\n", 
               "sphinx_return_doc": "        :return: a ``RecurringEventSmartCalendarSession``\n        :rtype: ``osid.calendaring.RecurringEventSmartCalendarSession``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``calendar_id`` not found\n        :raise: ``NullArgument`` -- ``calendar_id or proxy is null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_recurring_event_smart_calendar()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_recurring_event_smart_calendar()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "calendar_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.proxy.Proxy", 
                     "var_name": "proxy", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "osid.proxy.Proxy"
               ], 
               "return_type": "osid.calendaring.RecurringEventSmartCalendarSession", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_superseding_event_lookup_session", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` associated with the superseding event lookup service.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    proxy (osid.proxy.Proxy): a proxy\n", 
               "return_doc": "        return: (osid.calendaring.SupersedingEventLookupSession) - a\n                ``SupersedingEventLookupSession``", 
               "error_doc": "        raise:  NullArgument - ``proxy`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_event_lookup()`` is ``false``", 
               "sphinx_param_doc": "        :param proxy: a proxy\n        :type proxy: ``osid.proxy.Proxy``\n", 
               "sphinx_return_doc": "        :return: a ``SupersedingEventLookupSession``\n        :rtype: ``osid.calendaring.SupersedingEventLookupSession``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``proxy`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_event_lookup()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_superseding_event_lookup()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.proxy.Proxy", 
                     "var_name": "proxy", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.proxy.Proxy"
               ], 
               "return_type": "osid.calendaring.SupersedingEventLookupSession", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_superseding_event_lookup_session_for_calendar", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` associated with the superseding event lookup service for the given calendar.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    calendar_id (osid.id.Id): the ``Id`` of the calendar\n        arg:    proxy (osid.proxy.Proxy): a proxy\n", 
               "return_doc": "        return: (osid.calendaring.SupersedingEventLookupSession) - a\n                ``SupersedingEventLookupSession``", 
               "error_doc": "        raise:  NotFound - ``calendar_id`` not found\n        raise:  NullArgument - ``calendar_id or proxy is null``\n        raise:  OperationFailed - ``unable to complete request``\n        raise:  Unimplemented - ``supports_superseding_event_lookup()``\n                or ``supports_visible_federation()`` is ``false``", 
               "sphinx_param_doc": "        :param calendar_id: the ``Id`` of the calendar\n        :type calendar_id: ``osid.id.Id``\n        :param proxy: a proxy\n        :type proxy: ``osid.proxy.Proxy``\n", 
               "sphinx_return_doc": "        :return: a ``SupersedingEventLookupSession``\n        :rtype: ``osid.calendaring.SupersedingEventLookupSession``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``calendar_id`` not found\n        :raise: ``NullArgument`` -- ``calendar_id or proxy is null``\n        :raise: ``OperationFailed`` -- ``unable to complete request``\n        :raise: ``Unimplemented`` -- ``supports_superseding_event_lookup()`` or ``supports_visible_federation()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_superseding_event_lookup()`` and ``supports_visible_federation()`` are ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "calendar_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.proxy.Proxy", 
                     "var_name": "proxy", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "osid.proxy.Proxy"
               ], 
               "return_type": "osid.calendaring.SupersedingEventLookupSession", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_superseding_event_query_session", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` associated with the superseding event query service.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    proxy (osid.proxy.Proxy): a proxy\n", 
               "return_doc": "        return: (osid.calendaring.SupersedingEventQuerySession) - a\n                ``SupersedingEventQuerySession``", 
               "error_doc": "        raise:  NullArgument - ``proxy`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_superseding_event_query()``\n                is ``false``", 
               "sphinx_param_doc": "        :param proxy: a proxy\n        :type proxy: ``osid.proxy.Proxy``\n", 
               "sphinx_return_doc": "        :return: a ``SupersedingEventQuerySession``\n        :rtype: ``osid.calendaring.SupersedingEventQuerySession``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``proxy`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_superseding_event_query()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_superseding_event_query()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.proxy.Proxy", 
                     "var_name": "proxy", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.proxy.Proxy"
               ], 
               "return_type": "osid.calendaring.SupersedingEventQuerySession", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_superseding_event_query_session_for_calendar", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` associated with the superseding event query service for the given calendar.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    calendar_id (osid.id.Id): the ``Id`` of the calendar\n        arg:    proxy (osid.proxy.Proxy): a proxy\n", 
               "return_doc": "        return: (osid.calendaring.SupersedingEventQuerySession) - a\n                ``SupersedingEventQuerySession``", 
               "error_doc": "        raise:  NotFound - ``calendar_id`` not found\n        raise:  NullArgument - ``calendar_id or proxy is null``\n        raise:  OperationFailed - ``unable to complete request``\n        raise:  Unimplemented - ``supports_superseding_event_query()``\n                or ``supports_visible_federation()`` is ``false``", 
               "sphinx_param_doc": "        :param calendar_id: the ``Id`` of the calendar\n        :type calendar_id: ``osid.id.Id``\n        :param proxy: a proxy\n        :type proxy: ``osid.proxy.Proxy``\n", 
               "sphinx_return_doc": "        :return: a ``SupersedingEventQuerySession``\n        :rtype: ``osid.calendaring.SupersedingEventQuerySession``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``calendar_id`` not found\n        :raise: ``NullArgument`` -- ``calendar_id or proxy is null``\n        :raise: ``OperationFailed`` -- ``unable to complete request``\n        :raise: ``Unimplemented`` -- ``supports_superseding_event_query()`` or ``supports_visible_federation()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_superseding_event_query()`` and ``supports_visible_federation()`` are ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "calendar_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.proxy.Proxy", 
                     "var_name": "proxy", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "osid.proxy.Proxy"
               ], 
               "return_type": "osid.calendaring.SupersedingEventQuerySession", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_superseding_event_search_session", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` associated with the superseding event search service.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    proxy (osid.proxy.Proxy): a proxy\n", 
               "return_doc": "        return: (osid.calendaring.SupersedingEventSearchSession) - a\n                ``SupersedingEventSearchSession``", 
               "error_doc": "        raise:  NullArgument - ``proxy`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_event_search()`` is ``false``", 
               "sphinx_param_doc": "        :param proxy: a proxy\n        :type proxy: ``osid.proxy.Proxy``\n", 
               "sphinx_return_doc": "        :return: a ``SupersedingEventSearchSession``\n        :rtype: ``osid.calendaring.SupersedingEventSearchSession``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``proxy`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_event_search()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_event_search()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.proxy.Proxy", 
                     "var_name": "proxy", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.proxy.Proxy"
               ], 
               "return_type": "osid.calendaring.SupersedingEventSearchSession", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_superseding_event_search_session_for_calendar", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` associated with the superseding event search service for the given calendar.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    calendar_id (osid.id.Id): the ``Id`` of the calendar\n        arg:    proxy (osid.proxy.Proxy): a proxy\n", 
               "return_doc": "        return: (osid.calendaring.SupersedingEventSearchSession) - a\n                ``SupersedingEventSearchSession``", 
               "error_doc": "        raise:  NotFound - ``calendar_id`` not found\n        raise:  NullArgument - ``calendar_id or proxy is null``\n        raise:  OperationFailed - ``unable to complete request``\n        raise:  Unimplemented - ``supports_superseding_event_search()``\n                or ``supports_visible_federation()`` is ``false``", 
               "sphinx_param_doc": "        :param calendar_id: the ``Id`` of the calendar\n        :type calendar_id: ``osid.id.Id``\n        :param proxy: a proxy\n        :type proxy: ``osid.proxy.Proxy``\n", 
               "sphinx_return_doc": "        :return: a ``SupersedingEventSearchSession``\n        :rtype: ``osid.calendaring.SupersedingEventSearchSession``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``calendar_id`` not found\n        :raise: ``NullArgument`` -- ``calendar_id or proxy is null``\n        :raise: ``OperationFailed`` -- ``unable to complete request``\n        :raise: ``Unimplemented`` -- ``supports_superseding_event_search()`` or ``supports_visible_federation()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_superseding_event_search()`` and ``supports_visible_federation()`` are ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "calendar_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.proxy.Proxy", 
                     "var_name": "proxy", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "osid.proxy.Proxy"
               ], 
               "return_type": "osid.calendaring.SupersedingEventSearchSession", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_superseding_event_admin_session", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` associated with the superseding event administration service.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    proxy (osid.proxy.Proxy): a proxy\n", 
               "return_doc": "        return: (osid.calendaring.SupersedingEventAdminSession) - a\n                ``SupersedingEventAdminSession``", 
               "error_doc": "        raise:  NullArgument - ``proxy`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_event_admin()`` is ``false``", 
               "sphinx_param_doc": "        :param proxy: a proxy\n        :type proxy: ``osid.proxy.Proxy``\n", 
               "sphinx_return_doc": "        :return: a ``SupersedingEventAdminSession``\n        :rtype: ``osid.calendaring.SupersedingEventAdminSession``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``proxy`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_event_admin()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_superseding_event_admin()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.proxy.Proxy", 
                     "var_name": "proxy", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.proxy.Proxy"
               ], 
               "return_type": "osid.calendaring.SupersedingEventAdminSession", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_superseding_event_admin_session_for_calendar", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` associated with the superseding event admin service for the given calendar.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    calendar_id (osid.id.Id): the ``Id`` of the calendar\n        arg:    proxy (osid.proxy.Proxy): a proxy\n", 
               "return_doc": "        return: (osid.calendaring.SupersedingEventAdminSession) - a\n                ``SupersedingEventAdminSession``", 
               "error_doc": "        raise:  NotFound - ``calendar_id`` not found\n        raise:  NullArgument - ``calendar_id or proxy is null``\n        raise:  OperationFailed - ``unable to complete request``\n        raise:  Unimplemented - ``supports_superseding_event_admin()``\n                or ``supports_visible_federation()`` is ``false``", 
               "sphinx_param_doc": "        :param calendar_id: the ``Id`` of the calendar\n        :type calendar_id: ``osid.id.Id``\n        :param proxy: a proxy\n        :type proxy: ``osid.proxy.Proxy``\n", 
               "sphinx_return_doc": "        :return: a ``SupersedingEventAdminSession``\n        :rtype: ``osid.calendaring.SupersedingEventAdminSession``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``calendar_id`` not found\n        :raise: ``NullArgument`` -- ``calendar_id or proxy is null``\n        :raise: ``OperationFailed`` -- ``unable to complete request``\n        :raise: ``Unimplemented`` -- ``supports_superseding_event_admin()`` or ``supports_visible_federation()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_superseding_event_admin()`` and ``supports_visible_federation()`` are ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "calendar_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.proxy.Proxy", 
                     "var_name": "proxy", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "osid.proxy.Proxy"
               ], 
               "return_type": "osid.calendaring.SupersedingEventAdminSession", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_superseding_event_notification_session", 
               "doc": {
                  "headline": "Gets the notification session for notifications pertaining to superseding event changes.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    superseding_event_receiver\n                (osid.calendaring.SupersedingEventReceiver): the\n                superseding event receiver\n        arg:    proxy (osid.proxy.Proxy): a proxy\n", 
               "return_doc": "        return: (osid.calendaring.SupersedingEventNotificationSession) -\n                a ``SupersedingEventNotificationSession``", 
               "error_doc": "        raise:  NullArgument - ``superseding_event_receiver`` or\n                ``proxy`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented -\n                ``supports_superseding_event_notification()`` is\n                ``false``", 
               "sphinx_param_doc": "        :param superseding_event_receiver: the superseding event receiver\n        :type superseding_event_receiver: ``osid.calendaring.SupersedingEventReceiver``\n        :param proxy: a proxy\n        :type proxy: ``osid.proxy.Proxy``\n", 
               "sphinx_return_doc": "        :return: a ``SupersedingEventNotificationSession``\n        :rtype: ``osid.calendaring.SupersedingEventNotificationSession``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``superseding_event_receiver`` or ``proxy`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_superseding_event_notification()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_superseding_event_notification()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.calendaring.SupersedingEventReceiver", 
                     "var_name": "superseding_event_receiver", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.proxy.Proxy", 
                     "var_name": "proxy", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.calendaring.SupersedingEventReceiver", 
                  "osid.proxy.Proxy"
               ], 
               "return_type": "osid.calendaring.SupersedingEventNotificationSession", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_superseding_event_notification_session_for_calendar", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` associated with the superseding event notification service for the given calendar.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    superseding_event_receiver\n                (osid.calendaring.SupersedingEventReceiver): the\n                superseding event receiver\n        arg:    calendar_id (osid.id.Id): the ``Id`` of the calendar\n        arg:    proxy (osid.proxy.Proxy): a proxy\n", 
               "return_doc": "        return: (osid.calendaring.SupersedingEventNotificationSession) -\n                a ``SupersedingEventNotificationSession``", 
               "error_doc": "        raise:  NotFound - ``calendar_id`` not found\n        raise:  NullArgument - ``superseding_event_receiver,\n                calendar_id`` or ``proxy`` is ``null``\n        raise:  OperationFailed - ``unable to complete request``\n        raise:  Unimplemented -\n                ``supports_superseding_event_notification()`` or\n                ``supports_visible_federation()`` is ``false``", 
               "sphinx_param_doc": "        :param superseding_event_receiver: the superseding event receiver\n        :type superseding_event_receiver: ``osid.calendaring.SupersedingEventReceiver``\n        :param calendar_id: the ``Id`` of the calendar\n        :type calendar_id: ``osid.id.Id``\n        :param proxy: a proxy\n        :type proxy: ``osid.proxy.Proxy``\n", 
               "sphinx_return_doc": "        :return: a ``SupersedingEventNotificationSession``\n        :rtype: ``osid.calendaring.SupersedingEventNotificationSession``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``calendar_id`` not found\n        :raise: ``NullArgument`` -- ``superseding_event_receiver, calendar_id`` or ``proxy`` is ``null``\n        :raise: ``OperationFailed`` -- ``unable to complete request``\n        :raise: ``Unimplemented`` -- ``supports_superseding_event_notification()`` or ``supports_visible_federation()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_superseding_event_notification()`` and ``supports_visible_federation()`` are ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.calendaring.SupersedingEventReceiver", 
                     "var_name": "superseding_event_receiver", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "calendar_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.proxy.Proxy", 
                     "var_name": "proxy", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.calendaring.SupersedingEventReceiver", 
                  "osid.id.Id", 
                  "osid.proxy.Proxy"
               ], 
               "return_type": "osid.calendaring.SupersedingEventNotificationSession", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_superseding_event_calendar_session", 
               "doc": {
                  "headline": "Gets the session for retrieving superseding event to calendar mappings.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    proxy (osid.proxy.Proxy): a proxy\n", 
               "return_doc": "        return: (osid.calendaring.SupersedingEventCalendarSession) - a\n                ``SupersedingEventCalendarSession``", 
               "error_doc": "        raise:  NullArgument - ``proxy`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented -\n                ``supports_superseding_event_calendar()`` is ``false``", 
               "sphinx_param_doc": "        :param proxy: a proxy\n        :type proxy: ``osid.proxy.Proxy``\n", 
               "sphinx_return_doc": "        :return: a ``SupersedingEventCalendarSession``\n        :rtype: ``osid.calendaring.SupersedingEventCalendarSession``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``proxy`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_superseding_event_calendar()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_superseding_event_calendar()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.proxy.Proxy", 
                     "var_name": "proxy", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.proxy.Proxy"
               ], 
               "return_type": "osid.calendaring.SupersedingEventCalendarSession", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_superseding_event_calendar_assignment_session", 
               "doc": {
                  "headline": "Gets the session for assigning superseding event to calendar mappings.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    proxy (osid.proxy.Proxy): a proxy\n", 
               "return_doc": "        return:\n                (osid.calendaring.SupersedingEventCalendarAssignmentSess\n                ion) - a ``SupersedingEventCalendarAssignmentSession``", 
               "error_doc": "        raise:  NullArgument - ``proxy`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented -\n                ``supports_superseding_event_calendar_assignment()`` is\n                ``false``", 
               "sphinx_param_doc": "        :param proxy: a proxy\n        :type proxy: ``osid.proxy.Proxy``\n", 
               "sphinx_return_doc": "        :return: a ``SupersedingEventCalendarAssignmentSession``\n        :rtype: ``osid.calendaring.SupersedingEventCalendarAssignmentSession``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``proxy`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_superseding_event_calendar_assignment()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_superseding_event_calendar_assignment()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.proxy.Proxy", 
                     "var_name": "proxy", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.proxy.Proxy"
               ], 
               "return_type": "osid.calendaring.SupersedingEventCalendarAssignmentSession", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_superseding_event_smart_calendar_session", 
               "doc": {
                  "headline": "Gets the session associated with the superseding event smart calendar for the given calendar.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    calendar_id (osid.id.Id): the ``Id`` of the calendar\n        arg:    proxy (osid.proxy.Proxy): a proxy\n", 
               "return_doc": "        return: (osid.calendaring.SupersedingEventSmartCalendarSession)\n                - a ``SupersedingEventSmartCalendarSession``", 
               "error_doc": "        raise:  NotFound - ``calendar_id`` not found\n        raise:  NullArgument - ``calendar_id or proxy is null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented -\n                ``supports_superseding_event_smart_calendar()`` is\n                ``false``", 
               "sphinx_param_doc": "        :param calendar_id: the ``Id`` of the calendar\n        :type calendar_id: ``osid.id.Id``\n        :param proxy: a proxy\n        :type proxy: ``osid.proxy.Proxy``\n", 
               "sphinx_return_doc": "        :return: a ``SupersedingEventSmartCalendarSession``\n        :rtype: ``osid.calendaring.SupersedingEventSmartCalendarSession``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``calendar_id`` not found\n        :raise: ``NullArgument`` -- ``calendar_id or proxy is null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_superseding_event_smart_calendar()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_superseding_event_smart_calendar()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "calendar_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.proxy.Proxy", 
                     "var_name": "proxy", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "osid.proxy.Proxy"
               ], 
               "return_type": "osid.calendaring.SupersedingEventSmartCalendarSession", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_offset_event_lookup_session", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` associated with the offset event lookup service.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    proxy (osid.proxy.Proxy): a proxy\n", 
               "return_doc": "        return: (osid.calendaring.OffsetEventLookupSession) - an\n                ``OffsetEventLookupSession``", 
               "error_doc": "        raise:  NullArgument - ``proxy`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_offset_event_lookup()`` is\n                ``false``", 
               "sphinx_param_doc": "        :param proxy: a proxy\n        :type proxy: ``osid.proxy.Proxy``\n", 
               "sphinx_return_doc": "        :return: an ``OffsetEventLookupSession``\n        :rtype: ``osid.calendaring.OffsetEventLookupSession``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``proxy`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_offset_event_lookup()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_offset_event_lookup()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.proxy.Proxy", 
                     "var_name": "proxy", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.proxy.Proxy"
               ], 
               "return_type": "osid.calendaring.OffsetEventLookupSession", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_offset_event_lookup_session_for_calendar", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` associated with the offset event lookup service for the given calendar.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    calendar_id (osid.id.Id): the ``Id`` of the calendar\n        arg:    proxy (osid.proxy.Proxy): a proxy\n", 
               "return_doc": "        return: (osid.calendaring.OffsetEventLookupSession) - an\n                ``OffsetEventLookupSession``", 
               "error_doc": "        raise:  NotFound - ``calendar_id`` not found\n        raise:  NullArgument - ``calendar_id or proxy is null``\n        raise:  OperationFailed - ``unable to complete request``\n        raise:  Unimplemented - ``supports_offset_event_lookup()`` or\n                ``supports_visible_federation()`` is ``false``", 
               "sphinx_param_doc": "        :param calendar_id: the ``Id`` of the calendar\n        :type calendar_id: ``osid.id.Id``\n        :param proxy: a proxy\n        :type proxy: ``osid.proxy.Proxy``\n", 
               "sphinx_return_doc": "        :return: an ``OffsetEventLookupSession``\n        :rtype: ``osid.calendaring.OffsetEventLookupSession``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``calendar_id`` not found\n        :raise: ``NullArgument`` -- ``calendar_id or proxy is null``\n        :raise: ``OperationFailed`` -- ``unable to complete request``\n        :raise: ``Unimplemented`` -- ``supports_offset_event_lookup()`` or ``supports_visible_federation()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_offset_event_lookup()`` and ``supports_visible_federation()`` are ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "calendar_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.proxy.Proxy", 
                     "var_name": "proxy", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "osid.proxy.Proxy"
               ], 
               "return_type": "osid.calendaring.OffsetEventLookupSession", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_offset_event_query_session", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` associated with the offset event query service.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    proxy (osid.proxy.Proxy): a proxy\n", 
               "return_doc": "        return: (osid.calendaring.OffsetEventQuerySession) - an\n                ``OffsetEventQuerySession``", 
               "error_doc": "        raise:  NullArgument - ``proxy`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_offset_event_query()`` is\n                ``false``", 
               "sphinx_param_doc": "        :param proxy: a proxy\n        :type proxy: ``osid.proxy.Proxy``\n", 
               "sphinx_return_doc": "        :return: an ``OffsetEventQuerySession``\n        :rtype: ``osid.calendaring.OffsetEventQuerySession``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``proxy`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_offset_event_query()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_offset_event_query()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.proxy.Proxy", 
                     "var_name": "proxy", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.proxy.Proxy"
               ], 
               "return_type": "osid.calendaring.OffsetEventQuerySession", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_offset_event_query_session_for_calendar", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` associated with the offset event query service for the given calendar.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    calendar_id (osid.id.Id): the ``Id`` of the calendar\n        arg:    proxy (osid.proxy.Proxy): a proxy\n", 
               "return_doc": "        return: (osid.calendaring.OffsetEventQuerySession) - an\n                ``OffsetEventQuerySession``", 
               "error_doc": "        raise:  NotFound - ``calendar_id`` not found\n        raise:  NullArgument - ``calendar_id or proxy is null``\n        raise:  OperationFailed - ``unable to complete request``\n        raise:  Unimplemented - ``supports_offset_event_query()`` or\n                ``supports_visible_federation()`` is ``false``", 
               "sphinx_param_doc": "        :param calendar_id: the ``Id`` of the calendar\n        :type calendar_id: ``osid.id.Id``\n        :param proxy: a proxy\n        :type proxy: ``osid.proxy.Proxy``\n", 
               "sphinx_return_doc": "        :return: an ``OffsetEventQuerySession``\n        :rtype: ``osid.calendaring.OffsetEventQuerySession``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``calendar_id`` not found\n        :raise: ``NullArgument`` -- ``calendar_id or proxy is null``\n        :raise: ``OperationFailed`` -- ``unable to complete request``\n        :raise: ``Unimplemented`` -- ``supports_offset_event_query()`` or ``supports_visible_federation()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_offset_event_query()`` and ``supports_visible_federation()`` are ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "calendar_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.proxy.Proxy", 
                     "var_name": "proxy", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "osid.proxy.Proxy"
               ], 
               "return_type": "osid.calendaring.OffsetEventQuerySession", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_offset_event_search_session", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` associated with the offset event search service.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    proxy (osid.proxy.Proxy): a proxy\n", 
               "return_doc": "        return: (osid.calendaring.OffsetEventSearchSession) - an\n                ``OffsetEventSearchSession``", 
               "error_doc": "        raise:  NullArgument - ``proxy`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_offset_event_search()`` is\n                ``false``", 
               "sphinx_param_doc": "        :param proxy: a proxy\n        :type proxy: ``osid.proxy.Proxy``\n", 
               "sphinx_return_doc": "        :return: an ``OffsetEventSearchSession``\n        :rtype: ``osid.calendaring.OffsetEventSearchSession``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``proxy`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_offset_event_search()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_offset_event_search()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.proxy.Proxy", 
                     "var_name": "proxy", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.proxy.Proxy"
               ], 
               "return_type": "osid.calendaring.OffsetEventSearchSession", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_offset_event_search_session_for_calendar", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` associated with the offset event search service for the given calendar.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    calendar_id (osid.id.Id): the ``Id`` of the calendar\n        arg:    proxy (osid.proxy.Proxy): a proxy\n", 
               "return_doc": "        return: (osid.calendaring.OffsetEventSearchSession) - an\n                ``OffsetEventSearchSession``", 
               "error_doc": "        raise:  NotFound - ``calendar_id`` not found\n        raise:  NullArgument - ``calendar_id or proxy is null``\n        raise:  OperationFailed - ``unable to complete request``\n        raise:  Unimplemented - ``supports_offset_event_search()`` or\n                ``supports_visible_federation()`` is ``false``", 
               "sphinx_param_doc": "        :param calendar_id: the ``Id`` of the calendar\n        :type calendar_id: ``osid.id.Id``\n        :param proxy: a proxy\n        :type proxy: ``osid.proxy.Proxy``\n", 
               "sphinx_return_doc": "        :return: an ``OffsetEventSearchSession``\n        :rtype: ``osid.calendaring.OffsetEventSearchSession``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``calendar_id`` not found\n        :raise: ``NullArgument`` -- ``calendar_id or proxy is null``\n        :raise: ``OperationFailed`` -- ``unable to complete request``\n        :raise: ``Unimplemented`` -- ``supports_offset_event_search()`` or ``supports_visible_federation()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_offset_event_search()`` and ``supports_visible_federation()`` are ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "calendar_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.proxy.Proxy", 
                     "var_name": "proxy", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "osid.proxy.Proxy"
               ], 
               "return_type": "osid.calendaring.OffsetEventSearchSession", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_offset_event_admin_session", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` associated with the offset event administration service.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    proxy (osid.proxy.Proxy): a proxy\n", 
               "return_doc": "        return: (osid.calendaring.OffsetEventAdminSession) - an\n                ``OffsetEventAdminSession``", 
               "error_doc": "        raise:  NullArgument - ``proxy`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_offset_event_admin()`` is\n                ``false``", 
               "sphinx_param_doc": "        :param proxy: a proxy\n        :type proxy: ``osid.proxy.Proxy``\n", 
               "sphinx_return_doc": "        :return: an ``OffsetEventAdminSession``\n        :rtype: ``osid.calendaring.OffsetEventAdminSession``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``proxy`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_offset_event_admin()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_offset_event_admin()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.proxy.Proxy", 
                     "var_name": "proxy", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.proxy.Proxy"
               ], 
               "return_type": "osid.calendaring.OffsetEventAdminSession", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_offset_event_admin_session_for_calendar", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` associated with the offset event admin service for the given calendar.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    calendar_id (osid.id.Id): the ``Id`` of the calendar\n        arg:    proxy (osid.proxy.Proxy): a proxy\n", 
               "return_doc": "        return: (osid.calendaring.OffsetEventAdminSession) - an\n                ``OffsetEventAdminSession``", 
               "error_doc": "        raise:  NotFound - ``calendar_id`` not found\n        raise:  NullArgument - ``calendar_id or proxy is null``\n        raise:  OperationFailed - ``unable to complete request``\n        raise:  Unimplemented - ``supports_offset_event_admin()`` or\n                ``supports_visible_federation()`` is ``false``", 
               "sphinx_param_doc": "        :param calendar_id: the ``Id`` of the calendar\n        :type calendar_id: ``osid.id.Id``\n        :param proxy: a proxy\n        :type proxy: ``osid.proxy.Proxy``\n", 
               "sphinx_return_doc": "        :return: an ``OffsetEventAdminSession``\n        :rtype: ``osid.calendaring.OffsetEventAdminSession``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``calendar_id`` not found\n        :raise: ``NullArgument`` -- ``calendar_id or proxy is null``\n        :raise: ``OperationFailed`` -- ``unable to complete request``\n        :raise: ``Unimplemented`` -- ``supports_offset_event_admin()`` or ``supports_visible_federation()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_offset_event_admin()`` and ``supports_visible_federation()`` are ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "calendar_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.proxy.Proxy", 
                     "var_name": "proxy", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "osid.proxy.Proxy"
               ], 
               "return_type": "osid.calendaring.OffsetEventAdminSession", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_offset_event_notification_session", 
               "doc": {
                  "headline": "Gets the notification session for notifications pertaining to offset event changes.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    offset_event_receiver\n                (osid.calendaring.OffsetEventReceiver): the offset event\n                receiver\n        arg:    proxy (osid.proxy.Proxy): a proxy\n", 
               "return_doc": "        return: (osid.calendaring.OffsetEventNotificationSession) - an\n                ``OffsetEventNotificationSession``", 
               "error_doc": "        raise:  NullArgument - ``offset_event_receiver`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_offset_event_notification()``\n                is ``false``", 
               "sphinx_param_doc": "        :param offset_event_receiver: the offset event receiver\n        :type offset_event_receiver: ``osid.calendaring.OffsetEventReceiver``\n        :param proxy: a proxy\n        :type proxy: ``osid.proxy.Proxy``\n", 
               "sphinx_return_doc": "        :return: an ``OffsetEventNotificationSession``\n        :rtype: ``osid.calendaring.OffsetEventNotificationSession``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``offset_event_receiver`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_offset_event_notification()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_offset_event_notification()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.calendaring.OffsetEventReceiver", 
                     "var_name": "offset_event_receiver", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.proxy.Proxy", 
                     "var_name": "proxy", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.calendaring.OffsetEventReceiver", 
                  "osid.proxy.Proxy"
               ], 
               "return_type": "osid.calendaring.OffsetEventNotificationSession", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_offset_event_notification_session_for_calendar", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` associated with the offset event notification service for the given calendar.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    offset_event_receiver\n                (osid.calendaring.OffsetEventReceiver): the offset event\n                receiver\n        arg:    calendar_id (osid.id.Id): the ``Id`` of the calendar\n        arg:    proxy (osid.proxy.Proxy): a proxy\n", 
               "return_doc": "        return: (osid.calendaring.OffsetEventNotificationSession) - an\n                ``OffsetEventNotificationSession``", 
               "error_doc": "        raise:  NotFound - ``calendar_id`` not found\n        raise:  NullArgument - ``offset_event_receiver, calendar_id`` or\n                ``proxy`` is ``null``\n        raise:  OperationFailed - ``unable to complete request``\n        raise:  Unimplemented - ``supports_offset_event_notification()``\n                or ``supports_visible_federation()`` is ``false``", 
               "sphinx_param_doc": "        :param offset_event_receiver: the offset event receiver\n        :type offset_event_receiver: ``osid.calendaring.OffsetEventReceiver``\n        :param calendar_id: the ``Id`` of the calendar\n        :type calendar_id: ``osid.id.Id``\n        :param proxy: a proxy\n        :type proxy: ``osid.proxy.Proxy``\n", 
               "sphinx_return_doc": "        :return: an ``OffsetEventNotificationSession``\n        :rtype: ``osid.calendaring.OffsetEventNotificationSession``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``calendar_id`` not found\n        :raise: ``NullArgument`` -- ``offset_event_receiver, calendar_id`` or ``proxy`` is ``null``\n        :raise: ``OperationFailed`` -- ``unable to complete request``\n        :raise: ``Unimplemented`` -- ``supports_offset_event_notification()`` or ``supports_visible_federation()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_offset_event_notification()`` and ``supports_visible_federation()`` are ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.calendaring.OffsetEventReceiver", 
                     "var_name": "offset_event_receiver", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "calendar_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.proxy.Proxy", 
                     "var_name": "proxy", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.calendaring.OffsetEventReceiver", 
                  "osid.id.Id", 
                  "osid.proxy.Proxy"
               ], 
               "return_type": "osid.calendaring.OffsetEventNotificationSession", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_offset_event_calendar_session", 
               "doc": {
                  "headline": "Gets the session for retrieving offset event to calendar mappings.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    proxy (osid.proxy.Proxy): a proxy\n", 
               "return_doc": "        return: (osid.calendaring.OffsetEventCalendarSession) - an\n                ``OffsetEventCalendarSession``", 
               "error_doc": "        raise:  NullArgument - ``proxy`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_offset_event_calendar()`` is\n                ``false``", 
               "sphinx_param_doc": "        :param proxy: a proxy\n        :type proxy: ``osid.proxy.Proxy``\n", 
               "sphinx_return_doc": "        :return: an ``OffsetEventCalendarSession``\n        :rtype: ``osid.calendaring.OffsetEventCalendarSession``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``proxy`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_offset_event_calendar()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_offset_event_calendar()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.proxy.Proxy", 
                     "var_name": "proxy", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.proxy.Proxy"
               ], 
               "return_type": "osid.calendaring.OffsetEventCalendarSession", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_offset_event_calendar_assignment_session", 
               "doc": {
                  "headline": "Gets the session for assigning offset event to calendar mappings.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    proxy (osid.proxy.Proxy): a proxy\n", 
               "return_doc": "        return: (osid.calendaring.OffsetEventCalendarAssignmentSession)\n                - an ``OffsetEventCalendarAssignmentSession``", 
               "error_doc": "        raise:  NullArgument - ``proxy`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented -\n                ``supports_offset_event_calendar_assignment()`` is\n                ``false``", 
               "sphinx_param_doc": "        :param proxy: a proxy\n        :type proxy: ``osid.proxy.Proxy``\n", 
               "sphinx_return_doc": "        :return: an ``OffsetEventCalendarAssignmentSession``\n        :rtype: ``osid.calendaring.OffsetEventCalendarAssignmentSession``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``proxy`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_offset_event_calendar_assignment()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_offset_event_calendar_assignment()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.proxy.Proxy", 
                     "var_name": "proxy", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.proxy.Proxy"
               ], 
               "return_type": "osid.calendaring.OffsetEventCalendarAssignmentSession", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_offset_event_smart_calendar_session", 
               "doc": {
                  "headline": "Gets the session associated with the offset event smart calendar for the given calendar.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    calendar_id (osid.id.Id): the ``Id`` of the calendar\n        arg:    proxy (osid.proxy.Proxy): a proxy\n", 
               "return_doc": "        return: (osid.calendaring.OffsetEventSmartCalendarSession) - an\n                ``OffsetEventSmartCalendarSession``", 
               "error_doc": "        raise:  NotFound - ``calendar_id`` not found\n        raise:  NullArgument - ``calendar_id or proxy is null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented -\n                ``supports_offset_event_smart_calendar()`` is ``false``", 
               "sphinx_param_doc": "        :param calendar_id: the ``Id`` of the calendar\n        :type calendar_id: ``osid.id.Id``\n        :param proxy: a proxy\n        :type proxy: ``osid.proxy.Proxy``\n", 
               "sphinx_return_doc": "        :return: an ``OffsetEventSmartCalendarSession``\n        :rtype: ``osid.calendaring.OffsetEventSmartCalendarSession``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``calendar_id`` not found\n        :raise: ``NullArgument`` -- ``calendar_id or proxy is null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_offset_event_smart_calendar()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_offset_event_smart_calendar()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "calendar_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.proxy.Proxy", 
                     "var_name": "proxy", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "osid.proxy.Proxy"
               ], 
               "return_type": "osid.calendaring.OffsetEventSmartCalendarSession", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_schedule_lookup_session", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` associated with the schedule lookup service.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    proxy (osid.proxy.Proxy): a proxy\n", 
               "return_doc": "        return: (osid.calendaring.ScheduleLookupSession) - a\n                ``ScheduleLookupSession``", 
               "error_doc": "        raise:  NullArgument - ``proxy`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_schedule_lookup()`` is\n                ``false``", 
               "sphinx_param_doc": "        :param proxy: a proxy\n        :type proxy: ``osid.proxy.Proxy``\n", 
               "sphinx_return_doc": "        :return: a ``ScheduleLookupSession``\n        :rtype: ``osid.calendaring.ScheduleLookupSession``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``proxy`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_schedule_lookup()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_schedule_lookup()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.proxy.Proxy", 
                     "var_name": "proxy", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.proxy.Proxy"
               ], 
               "return_type": "osid.calendaring.ScheduleLookupSession", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_schedule_lookup_session_for_calendar", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` associated with the schedule lookup service for the given calendar.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    calendar_id (osid.id.Id): the ``Id`` of the calendar\n        arg:    proxy (osid.proxy.Proxy): a proxy\n", 
               "return_doc": "        return: (osid.calendaring.ScheduleLookupSession) - a\n                ``ScheduleLookupSession``", 
               "error_doc": "        raise:  NotFound - ``calendar_id`` not found\n        raise:  NullArgument - ``calendar_id or proxy is null``\n        raise:  OperationFailed - ``unable to complete request``\n        raise:  Unimplemented - ``supports_schedule_lookup()`` or\n                ``supports_visible_federation()`` is ``false``", 
               "sphinx_param_doc": "        :param calendar_id: the ``Id`` of the calendar\n        :type calendar_id: ``osid.id.Id``\n        :param proxy: a proxy\n        :type proxy: ``osid.proxy.Proxy``\n", 
               "sphinx_return_doc": "        :return: a ``ScheduleLookupSession``\n        :rtype: ``osid.calendaring.ScheduleLookupSession``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``calendar_id`` not found\n        :raise: ``NullArgument`` -- ``calendar_id or proxy is null``\n        :raise: ``OperationFailed`` -- ``unable to complete request``\n        :raise: ``Unimplemented`` -- ``supports_schedule_lookup()`` or ``supports_visible_federation()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_schedule_lookup()`` and ``supports_visible_federation()`` are ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "calendar_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.proxy.Proxy", 
                     "var_name": "proxy", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "osid.proxy.Proxy"
               ], 
               "return_type": "osid.calendaring.ScheduleLookupSession", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_schedule_query_session", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` associated with the schedule query service.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    proxy (osid.proxy.Proxy): a proxy\n", 
               "return_doc": "        return: (osid.calendaring.ScheduleQuerySession) - a\n                ``ScheduleQuerySession``", 
               "error_doc": "        raise:  NullArgument - ``proxy`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_schedule_query()`` is\n                ``false``", 
               "sphinx_param_doc": "        :param proxy: a proxy\n        :type proxy: ``osid.proxy.Proxy``\n", 
               "sphinx_return_doc": "        :return: a ``ScheduleQuerySession``\n        :rtype: ``osid.calendaring.ScheduleQuerySession``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``proxy`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_schedule_query()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_schedule_query()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.proxy.Proxy", 
                     "var_name": "proxy", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.proxy.Proxy"
               ], 
               "return_type": "osid.calendaring.ScheduleQuerySession", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_schedule_query_session_for_calendar", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` associated with the schedule query service for the given calendar.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    calendar_id (osid.id.Id): the ``Id`` of the calendar\n        arg:    proxy (osid.proxy.Proxy): a proxy\n", 
               "return_doc": "        return: (osid.calendaring.ScheduleQuerySession) - a\n                ``ScheduleQuerySession``", 
               "error_doc": "        raise:  NotFound - ``calendar_id`` not found\n        raise:  NullArgument - ``calendar_id or proxy is null``\n        raise:  OperationFailed - ``unable to complete request``\n        raise:  Unimplemented - ``supports_schedule_query()`` or\n                ``supports_visible_federation()`` is ``false``", 
               "sphinx_param_doc": "        :param calendar_id: the ``Id`` of the calendar\n        :type calendar_id: ``osid.id.Id``\n        :param proxy: a proxy\n        :type proxy: ``osid.proxy.Proxy``\n", 
               "sphinx_return_doc": "        :return: a ``ScheduleQuerySession``\n        :rtype: ``osid.calendaring.ScheduleQuerySession``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``calendar_id`` not found\n        :raise: ``NullArgument`` -- ``calendar_id or proxy is null``\n        :raise: ``OperationFailed`` -- ``unable to complete request``\n        :raise: ``Unimplemented`` -- ``supports_schedule_query()`` or ``supports_visible_federation()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_schedule_query()`` and ``supports_visible_federation()`` are ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "calendar_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.proxy.Proxy", 
                     "var_name": "proxy", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "osid.proxy.Proxy"
               ], 
               "return_type": "osid.calendaring.ScheduleQuerySession", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_schedule_search_session", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` associated with the schedule search service.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    proxy (osid.proxy.Proxy): a proxy\n", 
               "return_doc": "        return: (osid.calendaring.ScheduleSearchSession) - a\n                ``ScheduleSearchSession``", 
               "error_doc": "        raise:  NullArgument - ``proxy`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_schedule_search()`` is\n                ``false``", 
               "sphinx_param_doc": "        :param proxy: a proxy\n        :type proxy: ``osid.proxy.Proxy``\n", 
               "sphinx_return_doc": "        :return: a ``ScheduleSearchSession``\n        :rtype: ``osid.calendaring.ScheduleSearchSession``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``proxy`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_schedule_search()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_schedule_search()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.proxy.Proxy", 
                     "var_name": "proxy", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.proxy.Proxy"
               ], 
               "return_type": "osid.calendaring.ScheduleSearchSession", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_schedule_search_session_for_calendar", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` associated with the schedule search service for the given calendar.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    calendar_id (osid.id.Id): the ``Id`` of the calendar\n        arg:    proxy (osid.proxy.Proxy): a proxy\n", 
               "return_doc": "        return: (osid.calendaring.ScheduleSearchSession) - a\n                ``ScheduleSearchSession``", 
               "error_doc": "        raise:  NotFound - ``calendar_id`` not found\n        raise:  NullArgument - ``calendar_id or proxy is null``\n        raise:  OperationFailed - ``unable to complete request``\n        raise:  Unimplemented - ``supports_schedule_search()`` or\n                ``supports_visible_federation()`` is ``false``", 
               "sphinx_param_doc": "        :param calendar_id: the ``Id`` of the calendar\n        :type calendar_id: ``osid.id.Id``\n        :param proxy: a proxy\n        :type proxy: ``osid.proxy.Proxy``\n", 
               "sphinx_return_doc": "        :return: a ``ScheduleSearchSession``\n        :rtype: ``osid.calendaring.ScheduleSearchSession``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``calendar_id`` not found\n        :raise: ``NullArgument`` -- ``calendar_id or proxy is null``\n        :raise: ``OperationFailed`` -- ``unable to complete request``\n        :raise: ``Unimplemented`` -- ``supports_schedule_search()`` or ``supports_visible_federation()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_schedule_search()`` and ``supports_visible_federation()`` are ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "calendar_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.proxy.Proxy", 
                     "var_name": "proxy", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "osid.proxy.Proxy"
               ], 
               "return_type": "osid.calendaring.ScheduleSearchSession", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_schedule_admin_session", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` associated with the schedule administration service.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    proxy (osid.proxy.Proxy): a proxy\n", 
               "return_doc": "        return: (osid.calendaring.ScheduleAdminSession) - a\n                ``ScheduleAdminSession``", 
               "error_doc": "        raise:  NullArgument - ``proxy`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_schedule_admin()`` is\n                ``false``", 
               "sphinx_param_doc": "        :param proxy: a proxy\n        :type proxy: ``osid.proxy.Proxy``\n", 
               "sphinx_return_doc": "        :return: a ``ScheduleAdminSession``\n        :rtype: ``osid.calendaring.ScheduleAdminSession``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``proxy`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_schedule_admin()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_schedule_admin()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.proxy.Proxy", 
                     "var_name": "proxy", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.proxy.Proxy"
               ], 
               "return_type": "osid.calendaring.ScheduleAdminSession", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_schedule_admin_session_for_calendar", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` associated with the schedule admin service for the given calendar.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    calendar_id (osid.id.Id): the ``Id`` of the calendar\n        arg:    proxy (osid.proxy.Proxy): a proxy\n", 
               "return_doc": "        return: (osid.calendaring.ScheduleAdminSession) - a\n                ``ScheduleAdminSession``", 
               "error_doc": "        raise:  NotFound - ``calendar_id`` not found\n        raise:  NullArgument - ``calendar_id or proxy is null``\n        raise:  OperationFailed - ``unable to complete request``\n        raise:  Unimplemented - ``supports_schedule_admin()`` or\n                ``supports_visible_federation()`` is ``false``", 
               "sphinx_param_doc": "        :param calendar_id: the ``Id`` of the calendar\n        :type calendar_id: ``osid.id.Id``\n        :param proxy: a proxy\n        :type proxy: ``osid.proxy.Proxy``\n", 
               "sphinx_return_doc": "        :return: a ``ScheduleAdminSession``\n        :rtype: ``osid.calendaring.ScheduleAdminSession``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``calendar_id`` not found\n        :raise: ``NullArgument`` -- ``calendar_id or proxy is null``\n        :raise: ``OperationFailed`` -- ``unable to complete request``\n        :raise: ``Unimplemented`` -- ``supports_schedule_admin()`` or ``supports_visible_federation()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_schedule_admin()`` and ``supports_visible_federation()`` are ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "calendar_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.proxy.Proxy", 
                     "var_name": "proxy", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "osid.proxy.Proxy"
               ], 
               "return_type": "osid.calendaring.ScheduleAdminSession", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_schedule_notification_session", 
               "doc": {
                  "headline": "Gets the notification session for notifications pertaining to schedule changes.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    schedule_receiver (osid.calendaring.ScheduleReceiver):\n                the schedule receiver\n        arg:    proxy (osid.proxy.Proxy): a proxy\n", 
               "return_doc": "        return: (osid.calendaring.ScheduleNotificationSession) - a\n                ``ScheduleNotificationSession``", 
               "error_doc": "        raise:  NullArgument - ``schedule_receiver`` or ``proxy`` is\n                ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_schedule_notification()`` is\n                ``false``", 
               "sphinx_param_doc": "        :param schedule_receiver: the schedule receiver\n        :type schedule_receiver: ``osid.calendaring.ScheduleReceiver``\n        :param proxy: a proxy\n        :type proxy: ``osid.proxy.Proxy``\n", 
               "sphinx_return_doc": "        :return: a ``ScheduleNotificationSession``\n        :rtype: ``osid.calendaring.ScheduleNotificationSession``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``schedule_receiver`` or ``proxy`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_schedule_notification()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_schedule_notification()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.calendaring.ScheduleReceiver", 
                     "var_name": "schedule_receiver", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.proxy.Proxy", 
                     "var_name": "proxy", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.calendaring.ScheduleReceiver", 
                  "osid.proxy.Proxy"
               ], 
               "return_type": "osid.calendaring.ScheduleNotificationSession", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_schedule_notification_session_for_calendar", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` associated with the schedule notification service for the given calendar.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    schedule_receiver (osid.calendaring.ScheduleReceiver):\n                the schedule receiver\n        arg:    calendar_id (osid.id.Id): the ``Id`` of the calendar\n        arg:    proxy (osid.proxy.Proxy): a proxy\n", 
               "return_doc": "        return: (osid.calendaring.ScheduleNotificationSession) - a\n                ``ScheduleNotificationSession``", 
               "error_doc": "        raise:  NotFound - ``calendar_id`` not found\n        raise:  NullArgument - ``schedule_receiver, calendar_id`` or\n                ``proxy`` is ``null``\n        raise:  OperationFailed - ``unable to complete request``\n        raise:  Unimplemented - ``supports_schedule_notification()`` or\n                ``supports_visible_federation()`` is ``false``", 
               "sphinx_param_doc": "        :param schedule_receiver: the schedule receiver\n        :type schedule_receiver: ``osid.calendaring.ScheduleReceiver``\n        :param calendar_id: the ``Id`` of the calendar\n        :type calendar_id: ``osid.id.Id``\n        :param proxy: a proxy\n        :type proxy: ``osid.proxy.Proxy``\n", 
               "sphinx_return_doc": "        :return: a ``ScheduleNotificationSession``\n        :rtype: ``osid.calendaring.ScheduleNotificationSession``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``calendar_id`` not found\n        :raise: ``NullArgument`` -- ``schedule_receiver, calendar_id`` or ``proxy`` is ``null``\n        :raise: ``OperationFailed`` -- ``unable to complete request``\n        :raise: ``Unimplemented`` -- ``supports_schedule_notification()`` or ``supports_visible_federation()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_schedule_notification()`` and ``supports_visible_federation()`` are ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.calendaring.ScheduleReceiver", 
                     "var_name": "schedule_receiver", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "calendar_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.proxy.Proxy", 
                     "var_name": "proxy", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.calendaring.ScheduleReceiver", 
                  "osid.id.Id", 
                  "osid.proxy.Proxy"
               ], 
               "return_type": "osid.calendaring.ScheduleNotificationSession", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_schedule_calendar_session", 
               "doc": {
                  "headline": "Gets the session for retrieving schedule to calendar mappings.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    proxy (osid.proxy.Proxy): a proxy\n", 
               "return_doc": "        return: (osid.calendaring.ScheduleCalendarSession) - a\n                ``ScheduleCalendarSession``", 
               "error_doc": "        raise:  NullArgument - ``proxy`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_schedule_calendar()`` is\n                ``false``", 
               "sphinx_param_doc": "        :param proxy: a proxy\n        :type proxy: ``osid.proxy.Proxy``\n", 
               "sphinx_return_doc": "        :return: a ``ScheduleCalendarSession``\n        :rtype: ``osid.calendaring.ScheduleCalendarSession``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``proxy`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_schedule_calendar()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_schedule_calendar()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.proxy.Proxy", 
                     "var_name": "proxy", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.proxy.Proxy"
               ], 
               "return_type": "osid.calendaring.ScheduleCalendarSession", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_schedule_calendar_assignment_session", 
               "doc": {
                  "headline": "Gets the session for assigning schedule to calendar mappings.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    proxy (osid.proxy.Proxy): a proxy\n", 
               "return_doc": "        return: (osid.calendaring.ScheduleCalendarAssignmentSession) - a\n                ``ScheduleCalendarAssignmentSession``", 
               "error_doc": "        raise:  NullArgument - ``proxy`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented -\n                ``supports_schedule_calendar_assignment()`` is ``false``", 
               "sphinx_param_doc": "        :param proxy: a proxy\n        :type proxy: ``osid.proxy.Proxy``\n", 
               "sphinx_return_doc": "        :return: a ``ScheduleCalendarAssignmentSession``\n        :rtype: ``osid.calendaring.ScheduleCalendarAssignmentSession``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``proxy`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_schedule_calendar_assignment()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_schedule_calendar_assignment()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.proxy.Proxy", 
                     "var_name": "proxy", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.proxy.Proxy"
               ], 
               "return_type": "osid.calendaring.ScheduleCalendarAssignmentSession", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_schedule_smart_calendar_session", 
               "doc": {
                  "headline": "Gets the session associated with the schedule smart calendar for the given calendar.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    calendar_id (osid.id.Id): the ``Id`` of the calendar\n        arg:    proxy (osid.proxy.Proxy): a proxy\n", 
               "return_doc": "        return: (osid.calendaring.ScheduleSmartCalendarSession) - a\n                ``ScheduleSmartCalendarSession``", 
               "error_doc": "        raise:  NotFound - ``calendar_id`` not found\n        raise:  NullArgument - ``calendar_id or proxy is null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_schedule_smart_calendar()``\n                is ``false``", 
               "sphinx_param_doc": "        :param calendar_id: the ``Id`` of the calendar\n        :type calendar_id: ``osid.id.Id``\n        :param proxy: a proxy\n        :type proxy: ``osid.proxy.Proxy``\n", 
               "sphinx_return_doc": "        :return: a ``ScheduleSmartCalendarSession``\n        :rtype: ``osid.calendaring.ScheduleSmartCalendarSession``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``calendar_id`` not found\n        :raise: ``NullArgument`` -- ``calendar_id or proxy is null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_schedule_smart_calendar()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_schedule_smart_calendar()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "calendar_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.proxy.Proxy", 
                     "var_name": "proxy", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "osid.proxy.Proxy"
               ], 
               "return_type": "osid.calendaring.ScheduleSmartCalendarSession", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_schedule_slot_lookup_session", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` associated with the schedule slot lookup service.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    proxy (osid.proxy.Proxy): a proxy\n", 
               "return_doc": "        return: (osid.calendaring.ScheduleSlotLookupSession) - a\n                ``ScheduleSlotLookupSession``", 
               "error_doc": "        raise:  NullArgument - ``proxy`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_schedule_slot_lookup()`` is\n                ``false``", 
               "sphinx_param_doc": "        :param proxy: a proxy\n        :type proxy: ``osid.proxy.Proxy``\n", 
               "sphinx_return_doc": "        :return: a ``ScheduleSlotLookupSession``\n        :rtype: ``osid.calendaring.ScheduleSlotLookupSession``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``proxy`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_schedule_slot_lookup()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_schedule_slot_lookup()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.proxy.Proxy", 
                     "var_name": "proxy", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.proxy.Proxy"
               ], 
               "return_type": "osid.calendaring.ScheduleSlotLookupSession", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_schedule_slot_lookup_session_for_calendar", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` associated with the schedule slot lookup service for the given calendar.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    calendar_id (osid.id.Id): the ``Id`` of the calendar\n        arg:    proxy (osid.proxy.Proxy): a proxy\n", 
               "return_doc": "        return: (osid.calendaring.ScheduleSlotLookupSession) - a\n                ``ScheduleSlotLookupSession``", 
               "error_doc": "        raise:  NotFound - ``calendar_id`` not found\n        raise:  NullArgument - ``calendar_id or proxy is null``\n        raise:  OperationFailed - ``unable to complete request``\n        raise:  Unimplemented - ``supports_schedule_slot_lookup()`` or\n                ``supports_visible_federation()`` is ``false``", 
               "sphinx_param_doc": "        :param calendar_id: the ``Id`` of the calendar\n        :type calendar_id: ``osid.id.Id``\n        :param proxy: a proxy\n        :type proxy: ``osid.proxy.Proxy``\n", 
               "sphinx_return_doc": "        :return: a ``ScheduleSlotLookupSession``\n        :rtype: ``osid.calendaring.ScheduleSlotLookupSession``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``calendar_id`` not found\n        :raise: ``NullArgument`` -- ``calendar_id or proxy is null``\n        :raise: ``OperationFailed`` -- ``unable to complete request``\n        :raise: ``Unimplemented`` -- ``supports_schedule_slot_lookup()`` or ``supports_visible_federation()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_schedule_slot_lookup()`` and ``supports_visible_federation()`` are ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "calendar_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.proxy.Proxy", 
                     "var_name": "proxy", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "osid.proxy.Proxy"
               ], 
               "return_type": "osid.calendaring.ScheduleSlotLookupSession", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_schedule_slot_query_session", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` associated with the schedule slot query service.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    proxy (osid.proxy.Proxy): a proxy\n", 
               "return_doc": "        return: (osid.calendaring.ScheduleSlotQuerySession) - a\n                ``ScheduleSlotQuerySession``", 
               "error_doc": "        raise:  NullArgument - ``proxy`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_schedule_slot_query()`` is\n                ``false``", 
               "sphinx_param_doc": "        :param proxy: a proxy\n        :type proxy: ``osid.proxy.Proxy``\n", 
               "sphinx_return_doc": "        :return: a ``ScheduleSlotQuerySession``\n        :rtype: ``osid.calendaring.ScheduleSlotQuerySession``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``proxy`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_schedule_slot_query()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_schedule_slot_query()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.proxy.Proxy", 
                     "var_name": "proxy", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.proxy.Proxy"
               ], 
               "return_type": "osid.calendaring.ScheduleSlotQuerySession", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_schedule_slot_query_session_for_calendar", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` associated with the schedule slot query service for the given calendar.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    calendar_id (osid.id.Id): the ``Id`` of the calendar\n        arg:    proxy (osid.proxy.Proxy): a proxy\n", 
               "return_doc": "        return: (osid.calendaring.ScheduleSlotQuerySession) - a\n                ``ScheduleSlotQuerySession``", 
               "error_doc": "        raise:  NotFound - ``calendar_id`` not found\n        raise:  NullArgument - ``calendar_id or proxy is null``\n        raise:  OperationFailed - ``unable to complete request``\n        raise:  Unimplemented - ``supports_schedule_slot_query()`` or\n                ``supports_visible_federation()`` is ``false``", 
               "sphinx_param_doc": "        :param calendar_id: the ``Id`` of the calendar\n        :type calendar_id: ``osid.id.Id``\n        :param proxy: a proxy\n        :type proxy: ``osid.proxy.Proxy``\n", 
               "sphinx_return_doc": "        :return: a ``ScheduleSlotQuerySession``\n        :rtype: ``osid.calendaring.ScheduleSlotQuerySession``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``calendar_id`` not found\n        :raise: ``NullArgument`` -- ``calendar_id or proxy is null``\n        :raise: ``OperationFailed`` -- ``unable to complete request``\n        :raise: ``Unimplemented`` -- ``supports_schedule_slot_query()`` or ``supports_visible_federation()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_schedule_slot_query()`` and ``supports_visible_federation()`` are ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "calendar_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.proxy.Proxy", 
                     "var_name": "proxy", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "osid.proxy.Proxy"
               ], 
               "return_type": "osid.calendaring.ScheduleSlotQuerySession", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_schedule_slot_search_session", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` associated with the schedule slot search service.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    proxy (osid.proxy.Proxy): a proxy\n", 
               "return_doc": "        return: (osid.calendaring.ScheduleSlotSearchSession) - a\n                ``ScheduleSlotSearchSession``", 
               "error_doc": "        raise:  NullArgument - ``proxy`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_schedule_slot_search()`` is\n                ``false``", 
               "sphinx_param_doc": "        :param proxy: a proxy\n        :type proxy: ``osid.proxy.Proxy``\n", 
               "sphinx_return_doc": "        :return: a ``ScheduleSlotSearchSession``\n        :rtype: ``osid.calendaring.ScheduleSlotSearchSession``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``proxy`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_schedule_slot_search()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_schedule_slot_search()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.proxy.Proxy", 
                     "var_name": "proxy", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.proxy.Proxy"
               ], 
               "return_type": "osid.calendaring.ScheduleSlotSearchSession", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_schedule_slot_search_session_for_calendar", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` associated with the schedule slot search service for the given calendar.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    calendar_id (osid.id.Id): the ``Id`` of the calendar\n        arg:    proxy (osid.proxy.Proxy): a proxy\n", 
               "return_doc": "        return: (osid.calendaring.ScheduleSlotSearchSession) - a\n                ``ScheduleSlotSearchSession``", 
               "error_doc": "        raise:  NotFound - ``calendar_id`` not found\n        raise:  NullArgument - ``calendar_id or proxy is null``\n        raise:  OperationFailed - ``unable to complete request``\n        raise:  Unimplemented - ``supports_schedule_slot_search()`` or\n                ``supports_visible_federation()`` is ``false``", 
               "sphinx_param_doc": "        :param calendar_id: the ``Id`` of the calendar\n        :type calendar_id: ``osid.id.Id``\n        :param proxy: a proxy\n        :type proxy: ``osid.proxy.Proxy``\n", 
               "sphinx_return_doc": "        :return: a ``ScheduleSlotSearchSession``\n        :rtype: ``osid.calendaring.ScheduleSlotSearchSession``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``calendar_id`` not found\n        :raise: ``NullArgument`` -- ``calendar_id or proxy is null``\n        :raise: ``OperationFailed`` -- ``unable to complete request``\n        :raise: ``Unimplemented`` -- ``supports_schedule_slot_search()`` or ``supports_visible_federation()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_schedule_slot_search()`` and ``supports_visible_federation()`` are ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "calendar_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.proxy.Proxy", 
                     "var_name": "proxy", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "osid.proxy.Proxy"
               ], 
               "return_type": "osid.calendaring.ScheduleSlotSearchSession", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_schedule_slot_admin_session", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` associated with the schedule slot administration service.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    proxy (osid.proxy.Proxy): a proxy\n", 
               "return_doc": "        return: (osid.calendaring.ScheduleSlotAdminSession) - a\n                ``ScheduleSlotAdminSession``", 
               "error_doc": "        raise:  NullArgument - ``proxy`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_schedule_slot_admin()`` is\n                ``false``", 
               "sphinx_param_doc": "        :param proxy: a proxy\n        :type proxy: ``osid.proxy.Proxy``\n", 
               "sphinx_return_doc": "        :return: a ``ScheduleSlotAdminSession``\n        :rtype: ``osid.calendaring.ScheduleSlotAdminSession``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``proxy`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_schedule_slot_admin()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_schedule_slot_admin()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.proxy.Proxy", 
                     "var_name": "proxy", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.proxy.Proxy"
               ], 
               "return_type": "osid.calendaring.ScheduleSlotAdminSession", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_schedule_slot_admin_session_for_calendar", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` associated with the schedule slot admin service for the given calendar.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    calendar_id (osid.id.Id): the ``Id`` of the calendar\n        arg:    proxy (osid.proxy.Proxy): a proxy\n", 
               "return_doc": "        return: (osid.calendaring.ScheduleSlotAdminSession) - a\n                ``ScheduleSlotAdminSession``", 
               "error_doc": "        raise:  NotFound - ``calendar_id`` not found\n        raise:  NullArgument - ``calendar_id or proxy is null``\n        raise:  OperationFailed - ``unable to complete request``\n        raise:  Unimplemented - ``supports_schedule_slot_admin()`` or\n                ``supports_visible_federation()`` is ``false``", 
               "sphinx_param_doc": "        :param calendar_id: the ``Id`` of the calendar\n        :type calendar_id: ``osid.id.Id``\n        :param proxy: a proxy\n        :type proxy: ``osid.proxy.Proxy``\n", 
               "sphinx_return_doc": "        :return: a ``ScheduleSlotAdminSession``\n        :rtype: ``osid.calendaring.ScheduleSlotAdminSession``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``calendar_id`` not found\n        :raise: ``NullArgument`` -- ``calendar_id or proxy is null``\n        :raise: ``OperationFailed`` -- ``unable to complete request``\n        :raise: ``Unimplemented`` -- ``supports_schedule_slot_admin()`` or ``supports_visible_federation()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_schedule_slot_admin()`` and ``supports_visible_federation()`` are ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "calendar_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.proxy.Proxy", 
                     "var_name": "proxy", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "osid.proxy.Proxy"
               ], 
               "return_type": "osid.calendaring.ScheduleSlotAdminSession", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_schedule_slot_notification_session", 
               "doc": {
                  "headline": "Gets the notification session for notifications pertaining to schedule slot changes.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    schedule_slot_receiver\n                (osid.calendaring.ScheduleSlotReceiver): the schedule\n                slot receiver\n        arg:    proxy (osid.proxy.Proxy): a proxy\n", 
               "return_doc": "        return: (osid.calendaring.ScheduleSlotNotificationSession) - a\n                ``ScheduleSlotNotificationSession``", 
               "error_doc": "        raise:  NullArgument - ``schedule_slot_receiver`` or ``proxy``\n                is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented -\n                ``supports_schedule_slot_notification()`` is ``false``", 
               "sphinx_param_doc": "        :param schedule_slot_receiver: the schedule slot receiver\n        :type schedule_slot_receiver: ``osid.calendaring.ScheduleSlotReceiver``\n        :param proxy: a proxy\n        :type proxy: ``osid.proxy.Proxy``\n", 
               "sphinx_return_doc": "        :return: a ``ScheduleSlotNotificationSession``\n        :rtype: ``osid.calendaring.ScheduleSlotNotificationSession``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``schedule_slot_receiver`` or ``proxy`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_schedule_slot_notification()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_schedule_slot_notification()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.calendaring.ScheduleSlotReceiver", 
                     "var_name": "schedule_slot_receiver", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.proxy.Proxy", 
                     "var_name": "proxy", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.calendaring.ScheduleSlotReceiver", 
                  "osid.proxy.Proxy"
               ], 
               "return_type": "osid.calendaring.ScheduleSlotNotificationSession", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_schedule_slot_notification_session_for_calendar", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` associated with the schedule slot notification service for the given calendar.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    schedule_slot_receiver\n                (osid.calendaring.ScheduleSlotReceiver): the schedule\n                slot receiver\n        arg:    calendar_id (osid.id.Id): the ``Id`` of the calendar\n        arg:    proxy (osid.proxy.Proxy): a proxy\n", 
               "return_doc": "        return: (osid.calendaring.ScheduleSlotNotificationSession) - a\n                ``ScheduleSlotNotificationSession``", 
               "error_doc": "        raise:  NotFound - ``calendar_id`` not found\n        raise:  NullArgument - ``schedule_slot_receiver, calendar_id``\n                or ``proxy`` is ``null``\n        raise:  OperationFailed - ``unable to complete request``\n        raise:  Unimplemented -\n                ``supports_schedule_slot_notification()`` or\n                ``supports_visible_federation()`` is ``false``", 
               "sphinx_param_doc": "        :param schedule_slot_receiver: the schedule slot receiver\n        :type schedule_slot_receiver: ``osid.calendaring.ScheduleSlotReceiver``\n        :param calendar_id: the ``Id`` of the calendar\n        :type calendar_id: ``osid.id.Id``\n        :param proxy: a proxy\n        :type proxy: ``osid.proxy.Proxy``\n", 
               "sphinx_return_doc": "        :return: a ``ScheduleSlotNotificationSession``\n        :rtype: ``osid.calendaring.ScheduleSlotNotificationSession``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``calendar_id`` not found\n        :raise: ``NullArgument`` -- ``schedule_slot_receiver, calendar_id`` or ``proxy`` is ``null``\n        :raise: ``OperationFailed`` -- ``unable to complete request``\n        :raise: ``Unimplemented`` -- ``supports_schedule_slot_notification()`` or ``supports_visible_federation()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_schedule_slot_notification()`` and ``supports_visible_federation()`` are ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.calendaring.ScheduleSlotReceiver", 
                     "var_name": "schedule_slot_receiver", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "calendar_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.proxy.Proxy", 
                     "var_name": "proxy", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.calendaring.ScheduleSlotReceiver", 
                  "osid.id.Id", 
                  "osid.proxy.Proxy"
               ], 
               "return_type": "osid.calendaring.ScheduleSlotNotificationSession", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_schedule_slot_calendar_session", 
               "doc": {
                  "headline": "Gets the session for retrieving schedule slot to calendar mappings.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    proxy (osid.proxy.Proxy): a proxy\n", 
               "return_doc": "        return: (osid.calendaring.ScheduleSlotCalendarSession) - a\n                ``ScheduleSlotCalendarSession``", 
               "error_doc": "        raise:  NullArgument - ``proxy`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_schedule_slot_calendar()`` is\n                ``false``", 
               "sphinx_param_doc": "        :param proxy: a proxy\n        :type proxy: ``osid.proxy.Proxy``\n", 
               "sphinx_return_doc": "        :return: a ``ScheduleSlotCalendarSession``\n        :rtype: ``osid.calendaring.ScheduleSlotCalendarSession``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``proxy`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_schedule_slot_calendar()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_schedule_slot_calendar()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.proxy.Proxy", 
                     "var_name": "proxy", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.proxy.Proxy"
               ], 
               "return_type": "osid.calendaring.ScheduleSlotCalendarSession", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_schedule_slot_calendar_assignment_session", 
               "doc": {
                  "headline": "Gets the session for assigning schedule slot to calendar mappings.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    proxy (osid.proxy.Proxy): a proxy\n", 
               "return_doc": "        return: (osid.calendaring.ScheduleSlotCalendarAssignmentSession)\n                - a ``ScheduleSlotCalendarAssignmentSession``", 
               "error_doc": "        raise:  NullArgument - ``proxy`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented -\n                ``supports_schedule_slot_calendar_assignment()`` is\n                ``false``", 
               "sphinx_param_doc": "        :param proxy: a proxy\n        :type proxy: ``osid.proxy.Proxy``\n", 
               "sphinx_return_doc": "        :return: a ``ScheduleSlotCalendarAssignmentSession``\n        :rtype: ``osid.calendaring.ScheduleSlotCalendarAssignmentSession``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``proxy`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_schedule_slot_calendar_assignment()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_schedule_slot_calendar_assignment()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.proxy.Proxy", 
                     "var_name": "proxy", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.proxy.Proxy"
               ], 
               "return_type": "osid.calendaring.ScheduleSlotCalendarAssignmentSession", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_schedule_slot_smart_calendar_session", 
               "doc": {
                  "headline": "Gets the session associated with the schedule slot smart calendar for the given calendar.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    calendar_id (osid.id.Id): the ``Id`` of the calendar\n        arg:    proxy (osid.proxy.Proxy): a proxy\n", 
               "return_doc": "        return: (osid.calendaring.ScheduleSlotSmartCalendarSession) - a\n                ``ScheduleSlotSmartCalendarSession``", 
               "error_doc": "        raise:  NotFound - ``calendar_id`` not found\n        raise:  NullArgument - ``calendar_id or proxy is null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented -\n                ``supports_schedule_slot_smart_calendar()`` is ``false``", 
               "sphinx_param_doc": "        :param calendar_id: the ``Id`` of the calendar\n        :type calendar_id: ``osid.id.Id``\n        :param proxy: a proxy\n        :type proxy: ``osid.proxy.Proxy``\n", 
               "sphinx_return_doc": "        :return: a ``ScheduleSlotSmartCalendarSession``\n        :rtype: ``osid.calendaring.ScheduleSlotSmartCalendarSession``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``calendar_id`` not found\n        :raise: ``NullArgument`` -- ``calendar_id or proxy is null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_schedule_slot_smart_calendar()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_schedule_slot_smart_calendar()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "calendar_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.proxy.Proxy", 
                     "var_name": "proxy", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "osid.proxy.Proxy"
               ], 
               "return_type": "osid.calendaring.ScheduleSlotSmartCalendarSession", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_commitment_lookup_session", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` associated with the commitment lookup service.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    proxy (osid.proxy.Proxy): a proxy\n", 
               "return_doc": "        return: (osid.calendaring.CommitmentLookupSession) - a\n                ``CommitmentLookupSession``", 
               "error_doc": "        raise:  NullArgument - ``proxy`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_commitment_lookup()`` is\n                ``false``", 
               "sphinx_param_doc": "        :param proxy: a proxy\n        :type proxy: ``osid.proxy.Proxy``\n", 
               "sphinx_return_doc": "        :return: a ``CommitmentLookupSession``\n        :rtype: ``osid.calendaring.CommitmentLookupSession``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``proxy`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_commitment_lookup()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_commitment_lookup()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.proxy.Proxy", 
                     "var_name": "proxy", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.proxy.Proxy"
               ], 
               "return_type": "osid.calendaring.CommitmentLookupSession", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_commitment_lookup_session_for_calendar", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` associated with the commitment lookup service for the given calendar.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    calendar_id (osid.id.Id): the ``Id`` of the calendar\n        arg:    proxy (osid.proxy.Proxy): a proxy\n", 
               "return_doc": "        return: (osid.calendaring.CommitmentLookupSession) - ``a\n                CommitmentLookupSession``", 
               "error_doc": "        raise:  NotFound - ``calendar_id`` not found\n        raise:  NullArgument - ``calendar_id or proxy is null``\n        raise:  OperationFailed - ``unable to complete request``\n        raise:  Unimplemented - ``supports_commitment_lookup()`` or\n                ``supports_visible_federation()`` is ``false``", 
               "sphinx_param_doc": "        :param calendar_id: the ``Id`` of the calendar\n        :type calendar_id: ``osid.id.Id``\n        :param proxy: a proxy\n        :type proxy: ``osid.proxy.Proxy``\n", 
               "sphinx_return_doc": "        :return: ``a CommitmentLookupSession``\n        :rtype: ``osid.calendaring.CommitmentLookupSession``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``calendar_id`` not found\n        :raise: ``NullArgument`` -- ``calendar_id or proxy is null``\n        :raise: ``OperationFailed`` -- ``unable to complete request``\n        :raise: ``Unimplemented`` -- ``supports_commitment_lookup()`` or ``supports_visible_federation()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_commitment_lookup()`` and ``supports_visible_federation()`` are ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "calendar_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.proxy.Proxy", 
                     "var_name": "proxy", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "osid.proxy.Proxy"
               ], 
               "return_type": "osid.calendaring.CommitmentLookupSession", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_commitment_query_session", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` associated with the commitment query service.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    proxy (osid.proxy.Proxy): a proxy\n", 
               "return_doc": "        return: (osid.calendaring.CommitmentQuerySession) - a\n                ``CommitmentQuerySession``", 
               "error_doc": "        raise:  NullArgument - ``proxy`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_commitment_query()`` is\n                ``false``", 
               "sphinx_param_doc": "        :param proxy: a proxy\n        :type proxy: ``osid.proxy.Proxy``\n", 
               "sphinx_return_doc": "        :return: a ``CommitmentQuerySession``\n        :rtype: ``osid.calendaring.CommitmentQuerySession``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``proxy`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_commitment_query()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_commitment_lookup()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.proxy.Proxy", 
                     "var_name": "proxy", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.proxy.Proxy"
               ], 
               "return_type": "osid.calendaring.CommitmentQuerySession", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_commitment_query_session_for_calendar", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` associated with the commitment query service for the given calendar.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    calendar_id (osid.id.Id): the ``Id`` of the calendar\n        arg:    proxy (osid.proxy.Proxy): a proxy\n", 
               "return_doc": "        return: (osid.calendaring.CommitmentQuerySession) - a\n                ``CommitmentQuerySession``", 
               "error_doc": "        raise:  NotFound - ``calendar_id`` not found\n        raise:  NullArgument - ``calendar_id or proxy is null``\n        raise:  OperationFailed - ``unable to complete request``\n        raise:  Unimplemented - ``supports_commitment_query()`` or\n                ``supports_visible_federation()`` is ``false``", 
               "sphinx_param_doc": "        :param calendar_id: the ``Id`` of the calendar\n        :type calendar_id: ``osid.id.Id``\n        :param proxy: a proxy\n        :type proxy: ``osid.proxy.Proxy``\n", 
               "sphinx_return_doc": "        :return: a ``CommitmentQuerySession``\n        :rtype: ``osid.calendaring.CommitmentQuerySession``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``calendar_id`` not found\n        :raise: ``NullArgument`` -- ``calendar_id or proxy is null``\n        :raise: ``OperationFailed`` -- ``unable to complete request``\n        :raise: ``Unimplemented`` -- ``supports_commitment_query()`` or ``supports_visible_federation()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_commitment_query()`` and ``supports_visible_federation()`` are ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "calendar_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.proxy.Proxy", 
                     "var_name": "proxy", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "osid.proxy.Proxy"
               ], 
               "return_type": "osid.calendaring.CommitmentQuerySession", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_commitment_search_session", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` associated with the commitment search service.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    proxy (osid.proxy.Proxy): a proxy\n", 
               "return_doc": "        return: (osid.calendaring.CommitmentSearchSession) - a\n                ``CommitmentSearchSession``", 
               "error_doc": "        raise:  NullArgument - ``proxy`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_commitment_search()`` is\n                ``false``", 
               "sphinx_param_doc": "        :param proxy: a proxy\n        :type proxy: ``osid.proxy.Proxy``\n", 
               "sphinx_return_doc": "        :return: a ``CommitmentSearchSession``\n        :rtype: ``osid.calendaring.CommitmentSearchSession``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``proxy`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_commitment_search()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_commitment_search()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.proxy.Proxy", 
                     "var_name": "proxy", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.proxy.Proxy"
               ], 
               "return_type": "osid.calendaring.CommitmentSearchSession", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_commitment_search_session_for_calendar", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` associated with the commitment search service for the given calendar.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    calendar_id (osid.id.Id): the ``Id`` of the calendar\n        arg:    proxy (osid.proxy.Proxy): a proxy\n", 
               "return_doc": "        return: (osid.calendaring.CommitmentSearchSession) - a\n                ``CommitmentSearchSession``", 
               "error_doc": "        raise:  NotFound - ``calendar_id`` not found\n        raise:  NullArgument - ``calendar_id or proxy is null``\n        raise:  OperationFailed - ``unable to complete request``\n        raise:  Unimplemented - ``supports_commitment_search()`` or\n                ``supports_visible_federation()`` is ``false``", 
               "sphinx_param_doc": "        :param calendar_id: the ``Id`` of the calendar\n        :type calendar_id: ``osid.id.Id``\n        :param proxy: a proxy\n        :type proxy: ``osid.proxy.Proxy``\n", 
               "sphinx_return_doc": "        :return: a ``CommitmentSearchSession``\n        :rtype: ``osid.calendaring.CommitmentSearchSession``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``calendar_id`` not found\n        :raise: ``NullArgument`` -- ``calendar_id or proxy is null``\n        :raise: ``OperationFailed`` -- ``unable to complete request``\n        :raise: ``Unimplemented`` -- ``supports_commitment_search()`` or ``supports_visible_federation()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_commitment_search()`` and ``supports_visible_federation()`` are ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "calendar_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.proxy.Proxy", 
                     "var_name": "proxy", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "osid.proxy.Proxy"
               ], 
               "return_type": "osid.calendaring.CommitmentSearchSession", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_commitment_admin_session", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` associated with the commitment administration service.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    proxy (osid.proxy.Proxy): a proxy\n", 
               "return_doc": "        return: (osid.calendaring.CommitmentAdminSession) - a\n                ``CommitmentAdminSession``", 
               "error_doc": "        raise:  NullArgument - ``proxy`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_commitment_admin()`` is\n                ``false``", 
               "sphinx_param_doc": "        :param proxy: a proxy\n        :type proxy: ``osid.proxy.Proxy``\n", 
               "sphinx_return_doc": "        :return: a ``CommitmentAdminSession``\n        :rtype: ``osid.calendaring.CommitmentAdminSession``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``proxy`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_commitment_admin()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_commitment_admin()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.proxy.Proxy", 
                     "var_name": "proxy", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.proxy.Proxy"
               ], 
               "return_type": "osid.calendaring.CommitmentAdminSession", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_commitment_admin_session_for_calendar", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` associated with the commitment admin service for the given calendar.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    calendar_id (osid.id.Id): the ``Id`` of the calendar\n        arg:    proxy (osid.proxy.Proxy): a proxy\n", 
               "return_doc": "        return: (osid.calendaring.CommitmentAdminSession) - a\n                ``CommitmenttAdminSession``", 
               "error_doc": "        raise:  NotFound - ``calendar_id`` not found\n        raise:  NullArgument - ``calendar_id or proxy is null``\n        raise:  OperationFailed - ``unable to complete request``\n        raise:  Unimplemented - ``supports_commitment_admin()`` or\n                ``supports_visible_federation()`` is ``false``", 
               "sphinx_param_doc": "        :param calendar_id: the ``Id`` of the calendar\n        :type calendar_id: ``osid.id.Id``\n        :param proxy: a proxy\n        :type proxy: ``osid.proxy.Proxy``\n", 
               "sphinx_return_doc": "        :return: a ``CommitmenttAdminSession``\n        :rtype: ``osid.calendaring.CommitmentAdminSession``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``calendar_id`` not found\n        :raise: ``NullArgument`` -- ``calendar_id or proxy is null``\n        :raise: ``OperationFailed`` -- ``unable to complete request``\n        :raise: ``Unimplemented`` -- ``supports_commitment_admin()`` or ``supports_visible_federation()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_commitment_admin()`` and ``supports_visible_federation()`` are ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "calendar_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.proxy.Proxy", 
                     "var_name": "proxy", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "osid.proxy.Proxy"
               ], 
               "return_type": "osid.calendaring.CommitmentAdminSession", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_commitment_notification_session", 
               "doc": {
                  "headline": "Gets the notification session for notifications pertaining to commitment changes.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    commitment_receiver\n                (osid.calendaring.CommitmentReceiver): the commitment\n                receiver\n        arg:    proxy (osid.proxy.Proxy): a proxy\n", 
               "return_doc": "        return: (osid.calendaring.CommitmentNotificationSession) - a\n                ``CommitmentNotificationSession``", 
               "error_doc": "        raise:  NullArgument - ``commitment_receiver`` or ``proxy`` is\n                ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_commitment_notification()``\n                is ``false``", 
               "sphinx_param_doc": "        :param commitment_receiver: the commitment receiver\n        :type commitment_receiver: ``osid.calendaring.CommitmentReceiver``\n        :param proxy: a proxy\n        :type proxy: ``osid.proxy.Proxy``\n", 
               "sphinx_return_doc": "        :return: a ``CommitmentNotificationSession``\n        :rtype: ``osid.calendaring.CommitmentNotificationSession``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``commitment_receiver`` or ``proxy`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_commitment_notification()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_commitment_notification()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.calendaring.CommitmentReceiver", 
                     "var_name": "commitment_receiver", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.proxy.Proxy", 
                     "var_name": "proxy", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.calendaring.CommitmentReceiver", 
                  "osid.proxy.Proxy"
               ], 
               "return_type": "osid.calendaring.CommitmentNotificationSession", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_commitment_notification_session_for_calendar", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` associated with the commitment notification service for the given calendar.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    commitment_receiver\n                (osid.calendaring.CommitmentReceiver): the commitment\n                receiver\n        arg:    calendar_id (osid.id.Id): the ``Id`` of the calendar\n        arg:    proxy (osid.proxy.Proxy): a proxy\n", 
               "return_doc": "        return: (osid.calendaring.CommitmentNotificationSession) - a\n                ``CommitmentNotificationSession``", 
               "error_doc": "        raise:  NotFound - ``calendar_id`` not found\n        raise:  NullArgument - ``commitment_receiver, calendar_id`` or\n                ``proxy`` is ``null``\n        raise:  OperationFailed - ``unable to complete request``\n        raise:  Unimplemented - ``supports_commitment_notification()``\n                or ``supports_visible_federation()`` is ``false``", 
               "sphinx_param_doc": "        :param commitment_receiver: the commitment receiver\n        :type commitment_receiver: ``osid.calendaring.CommitmentReceiver``\n        :param calendar_id: the ``Id`` of the calendar\n        :type calendar_id: ``osid.id.Id``\n        :param proxy: a proxy\n        :type proxy: ``osid.proxy.Proxy``\n", 
               "sphinx_return_doc": "        :return: a ``CommitmentNotificationSession``\n        :rtype: ``osid.calendaring.CommitmentNotificationSession``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``calendar_id`` not found\n        :raise: ``NullArgument`` -- ``commitment_receiver, calendar_id`` or ``proxy`` is ``null``\n        :raise: ``OperationFailed`` -- ``unable to complete request``\n        :raise: ``Unimplemented`` -- ``supports_commitment_notification()`` or ``supports_visible_federation()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_commitment_notification()`` and ``supports_visible_federation()`` are ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.calendaring.CommitmentReceiver", 
                     "var_name": "commitment_receiver", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "calendar_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.proxy.Proxy", 
                     "var_name": "proxy", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.calendaring.CommitmentReceiver", 
                  "osid.id.Id", 
                  "osid.proxy.Proxy"
               ], 
               "return_type": "osid.calendaring.CommitmentNotificationSession", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_commitment_calendar_session", 
               "doc": {
                  "headline": "Gets the session for retrieving commitment to calendar mappings.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    proxy (osid.proxy.Proxy): a proxy\n", 
               "return_doc": "        return: (osid.calendaring.CommitmentCalendarSession) - a\n                ``CommitmentCalendarSession``", 
               "error_doc": "        raise:  NullArgument - ``proxy`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_commitment_calendar()`` is\n                ``false``", 
               "sphinx_param_doc": "        :param proxy: a proxy\n        :type proxy: ``osid.proxy.Proxy``\n", 
               "sphinx_return_doc": "        :return: a ``CommitmentCalendarSession``\n        :rtype: ``osid.calendaring.CommitmentCalendarSession``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``proxy`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_commitment_calendar()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_commitment_calendar()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.proxy.Proxy", 
                     "var_name": "proxy", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.proxy.Proxy"
               ], 
               "return_type": "osid.calendaring.CommitmentCalendarSession", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_commitment_calendar_assignment_session", 
               "doc": {
                  "headline": "Gets the session for assigning commitment to calendar mappings.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    proxy (osid.proxy.Proxy): a proxy\n", 
               "return_doc": "        return: (osid.calendaring.CommitmentCalendarAssignmentSession) -\n                a ``CommitmentCalendarAssignmentSession``", 
               "error_doc": "        raise:  NullArgument - ``proxy`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented -\n                ``supports_commitment_calendar_assignment()`` is\n                ``false``", 
               "sphinx_param_doc": "        :param proxy: a proxy\n        :type proxy: ``osid.proxy.Proxy``\n", 
               "sphinx_return_doc": "        :return: a ``CommitmentCalendarAssignmentSession``\n        :rtype: ``osid.calendaring.CommitmentCalendarAssignmentSession``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``proxy`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_commitment_calendar_assignment()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_commitment_calendar_assignment()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.proxy.Proxy", 
                     "var_name": "proxy", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.proxy.Proxy"
               ], 
               "return_type": "osid.calendaring.CommitmentCalendarAssignmentSession", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_commitment_smart_calendar_session", 
               "doc": {
                  "headline": "Gets the session associated with the commitment smart calendar for the given calendar.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    calendar_id (osid.id.Id): the ``Id`` of the calendar\n        arg:    proxy (osid.proxy.Proxy): a proxy\n", 
               "return_doc": "        return: (osid.calendaring.CommitmentSmartCalendarSession) - a\n                ``CommitmentSmartCalendarSession``", 
               "error_doc": "        raise:  NotFound - ``calendar_id`` not found\n        raise:  NullArgument - ``calendar_id or proxy is null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_commitment_smart_calendar()``\n                is ``false``", 
               "sphinx_param_doc": "        :param calendar_id: the ``Id`` of the calendar\n        :type calendar_id: ``osid.id.Id``\n        :param proxy: a proxy\n        :type proxy: ``osid.proxy.Proxy``\n", 
               "sphinx_return_doc": "        :return: a ``CommitmentSmartCalendarSession``\n        :rtype: ``osid.calendaring.CommitmentSmartCalendarSession``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``calendar_id`` not found\n        :raise: ``NullArgument`` -- ``calendar_id or proxy is null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_commitment_smart_calendar()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_commitment_smart_calendar()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "calendar_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.proxy.Proxy", 
                     "var_name": "proxy", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "osid.proxy.Proxy"
               ], 
               "return_type": "osid.calendaring.CommitmentSmartCalendarSession", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_time_period_lookup_session", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` associated with the time period lookup service.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    proxy (osid.proxy.Proxy): a proxy\n", 
               "return_doc": "        return: (osid.calendaring.TimePeriodLookupSession) - a\n                ``TimePeriodLookupSession``", 
               "error_doc": "        raise:  NullArgument - ``proxy`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_time_period_lookup()`` is\n                ``false``", 
               "sphinx_param_doc": "        :param proxy: a proxy\n        :type proxy: ``osid.proxy.Proxy``\n", 
               "sphinx_return_doc": "        :return: a ``TimePeriodLookupSession``\n        :rtype: ``osid.calendaring.TimePeriodLookupSession``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``proxy`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_time_period_lookup()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_time_period_lookup()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.proxy.Proxy", 
                     "var_name": "proxy", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.proxy.Proxy"
               ], 
               "return_type": "osid.calendaring.TimePeriodLookupSession", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_time_period_lookup_session_for_calendar", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` associated with the time period lookup service for the given calendar.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    calendar_id (osid.id.Id): the ``Id`` of the calendar\n        arg:    proxy (osid.proxy.Proxy): a proxy\n", 
               "return_doc": "        return: (osid.calendaring.TimePeriodLookupSession) - a\n                ``TimePeriodLookupSession``", 
               "error_doc": "        raise:  NotFound - ``calendar_id`` not found\n        raise:  NullArgument - ``calendar_id or proxy is null``\n        raise:  OperationFailed - ``unable to complete request``\n        raise:  Unimplemented - ``supports_time_period_lookup()`` or\n                ``supports_visible_federation()`` is ``false``", 
               "sphinx_param_doc": "        :param calendar_id: the ``Id`` of the calendar\n        :type calendar_id: ``osid.id.Id``\n        :param proxy: a proxy\n        :type proxy: ``osid.proxy.Proxy``\n", 
               "sphinx_return_doc": "        :return: a ``TimePeriodLookupSession``\n        :rtype: ``osid.calendaring.TimePeriodLookupSession``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``calendar_id`` not found\n        :raise: ``NullArgument`` -- ``calendar_id or proxy is null``\n        :raise: ``OperationFailed`` -- ``unable to complete request``\n        :raise: ``Unimplemented`` -- ``supports_time_period_lookup()`` or ``supports_visible_federation()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_time_period_lookup()`` and ``supports_visible_federation()`` are ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "calendar_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.proxy.Proxy", 
                     "var_name": "proxy", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "osid.proxy.Proxy"
               ], 
               "return_type": "osid.calendaring.TimePeriodLookupSession", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_time_period_query_session", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` associated with the time period query service.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    proxy (osid.proxy.Proxy): a proxy\n", 
               "return_doc": "        return: (osid.calendaring.TimePeriodQuerySession) - a\n                ``TimePeriodQuerySession``", 
               "error_doc": "        raise:  NullArgument - ``proxy`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_time_period_query()`` is\n                ``false``", 
               "sphinx_param_doc": "        :param proxy: a proxy\n        :type proxy: ``osid.proxy.Proxy``\n", 
               "sphinx_return_doc": "        :return: a ``TimePeriodQuerySession``\n        :rtype: ``osid.calendaring.TimePeriodQuerySession``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``proxy`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_time_period_query()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_time_period_query()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.proxy.Proxy", 
                     "var_name": "proxy", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.proxy.Proxy"
               ], 
               "return_type": "osid.calendaring.TimePeriodQuerySession", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_time_period_query_session_for_calendar", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` associated with the time period query service for the given calendar.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    calendar_id (osid.id.Id): the ``Id`` of the calendar\n        arg:    proxy (osid.proxy.Proxy): a proxy\n", 
               "return_doc": "        return: (osid.calendaring.TimePeriodQuerySession) - a\n                ``TimePeriodQuerySession``", 
               "error_doc": "        raise:  NotFound - ``calendar_id`` not found\n        raise:  NullArgument - ``calendar_id or proxy is null``\n        raise:  OperationFailed - ``unable to complete request``\n        raise:  Unimplemented - ``supports_time_period_query()`` or\n                ``supports_visible_federation()`` is ``false``", 
               "sphinx_param_doc": "        :param calendar_id: the ``Id`` of the calendar\n        :type calendar_id: ``osid.id.Id``\n        :param proxy: a proxy\n        :type proxy: ``osid.proxy.Proxy``\n", 
               "sphinx_return_doc": "        :return: a ``TimePeriodQuerySession``\n        :rtype: ``osid.calendaring.TimePeriodQuerySession``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``calendar_id`` not found\n        :raise: ``NullArgument`` -- ``calendar_id or proxy is null``\n        :raise: ``OperationFailed`` -- ``unable to complete request``\n        :raise: ``Unimplemented`` -- ``supports_time_period_query()`` or ``supports_visible_federation()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_time_period_query()`` and ``supports_visible_federation()`` are ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "calendar_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.proxy.Proxy", 
                     "var_name": "proxy", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "osid.proxy.Proxy"
               ], 
               "return_type": "osid.calendaring.TimePeriodQuerySession", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_time_period_search_session", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` associated with the time period search service.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    proxy (osid.proxy.Proxy): a proxy\n", 
               "return_doc": "        return: (osid.calendaring.TimePeriodSearchSession) - a\n                ``TimePeriodSearchSession``", 
               "error_doc": "        raise:  NullArgument - ``proxy`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_time_period_search()`` is\n                ``false``", 
               "sphinx_param_doc": "        :param proxy: a proxy\n        :type proxy: ``osid.proxy.Proxy``\n", 
               "sphinx_return_doc": "        :return: a ``TimePeriodSearchSession``\n        :rtype: ``osid.calendaring.TimePeriodSearchSession``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``proxy`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_time_period_search()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_time_period_search()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.proxy.Proxy", 
                     "var_name": "proxy", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.proxy.Proxy"
               ], 
               "return_type": "osid.calendaring.TimePeriodSearchSession", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_time_period_search_session_for_calendar", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` associated with the time period search service for the given calendar.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    calendar_id (osid.id.Id): the ``Id`` of the calendar\n        arg:    proxy (osid.proxy.Proxy): a proxy\n", 
               "return_doc": "        return: (osid.calendaring.TimePeriodSearchSession) - a\n                ``TimePeriodSearchSession``", 
               "error_doc": "        raise:  NotFound - ``calendar_id`` not found\n        raise:  NullArgument - ``calendar_id or proxy is null``\n        raise:  OperationFailed - ``unable to complete request``\n        raise:  Unimplemented - ``supports_time_period_search()`` or\n                ``supports_visible_federation()`` is ``false``", 
               "sphinx_param_doc": "        :param calendar_id: the ``Id`` of the calendar\n        :type calendar_id: ``osid.id.Id``\n        :param proxy: a proxy\n        :type proxy: ``osid.proxy.Proxy``\n", 
               "sphinx_return_doc": "        :return: a ``TimePeriodSearchSession``\n        :rtype: ``osid.calendaring.TimePeriodSearchSession``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``calendar_id`` not found\n        :raise: ``NullArgument`` -- ``calendar_id or proxy is null``\n        :raise: ``OperationFailed`` -- ``unable to complete request``\n        :raise: ``Unimplemented`` -- ``supports_time_period_search()`` or ``supports_visible_federation()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_time_period_search()`` and ``supports_visible_federation()`` are ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "calendar_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.proxy.Proxy", 
                     "var_name": "proxy", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "osid.proxy.Proxy"
               ], 
               "return_type": "osid.calendaring.TimePeriodSearchSession", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_time_period_admin_session", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` associated with the time period administration service.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    proxy (osid.proxy.Proxy): a proxy\n", 
               "return_doc": "        return: (osid.calendaring.TimePeriodAdminSession) - a\n                ``TimePeriodAdminSession``", 
               "error_doc": "        raise:  NullArgument - ``proxy`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_time_period_admin()`` is\n                ``false``", 
               "sphinx_param_doc": "        :param proxy: a proxy\n        :type proxy: ``osid.proxy.Proxy``\n", 
               "sphinx_return_doc": "        :return: a ``TimePeriodAdminSession``\n        :rtype: ``osid.calendaring.TimePeriodAdminSession``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``proxy`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_time_period_admin()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_time_period_admin()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.proxy.Proxy", 
                     "var_name": "proxy", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.proxy.Proxy"
               ], 
               "return_type": "osid.calendaring.TimePeriodAdminSession", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_time_period_admin_session_for_calendar", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` associated with the time period admin service for the given calendar.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    calendar_id (osid.id.Id): the ``Id`` of the calendar\n        arg:    proxy (osid.proxy.Proxy): a proxy\n", 
               "return_doc": "        return: (osid.calendaring.TimePeriodAdminSession) -\n                ``calendar_id`` not found", 
               "error_doc": "        raise:  NotFound - a ``TimePeriodAdminSession``\n        raise:  NullArgument - ``calendar_id or proxy is null``\n        raise:  OperationFailed - ``unable to complete request``\n        raise:  Unimplemented - ``supports_time_period_admin()`` or\n                ``supports_visible_federation()`` is ``false``", 
               "sphinx_param_doc": "        :param calendar_id: the ``Id`` of the calendar\n        :type calendar_id: ``osid.id.Id``\n        :param proxy: a proxy\n        :type proxy: ``osid.proxy.Proxy``\n", 
               "sphinx_return_doc": "        :return: ``calendar_id`` not found\n        :rtype: ``osid.calendaring.TimePeriodAdminSession``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- a ``TimePeriodAdminSession``\n        :raise: ``NullArgument`` -- ``calendar_id or proxy is null``\n        :raise: ``OperationFailed`` -- ``unable to complete request``\n        :raise: ``Unimplemented`` -- ``supports_time_period_admin()`` or ``supports_visible_federation()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_time_period_admin()`` and ``supports_visible_federation()`` are ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "calendar_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.proxy.Proxy", 
                     "var_name": "proxy", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "osid.proxy.Proxy"
               ], 
               "return_type": "osid.calendaring.TimePeriodAdminSession", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_time_period_notification_session", 
               "doc": {
                  "headline": "Gets the notification session for notifications pertaining to time period changes.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    time_period_receiver\n                (osid.calendaring.TimePeriodReceiver): the time period\n                receiver\n        arg:    proxy (osid.proxy.Proxy): a proxy\n", 
               "return_doc": "        return: (osid.calendaring.TimePeriodNotificationSession) - a\n                ``TimePeriodNotificationSession``", 
               "error_doc": "        raise:  NullArgument - ``time_period_receiver`` or ``proxy`` is\n                ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_time_period_notification()``\n                is ``false``", 
               "sphinx_param_doc": "        :param time_period_receiver: the time period receiver\n        :type time_period_receiver: ``osid.calendaring.TimePeriodReceiver``\n        :param proxy: a proxy\n        :type proxy: ``osid.proxy.Proxy``\n", 
               "sphinx_return_doc": "        :return: a ``TimePeriodNotificationSession``\n        :rtype: ``osid.calendaring.TimePeriodNotificationSession``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``time_period_receiver`` or ``proxy`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_time_period_notification()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_time_period_notification()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.calendaring.TimePeriodReceiver", 
                     "var_name": "time_period_receiver", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.proxy.Proxy", 
                     "var_name": "proxy", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.calendaring.TimePeriodReceiver", 
                  "osid.proxy.Proxy"
               ], 
               "return_type": "osid.calendaring.TimePeriodNotificationSession", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_time_period_notification_session_for_calendar", 
               "doc": {
                  "headline": "Gets the ``OsidSession`` associated with the time period notification service for the given calendar.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    time_period_receiver\n                (osid.calendaring.TimePeriodReceiver): the time period\n                receiver\n        arg:    calendar_id (osid.id.Id): the ``Id`` of the calendar\n        arg:    proxy (osid.proxy.Proxy): a proxy\n", 
               "return_doc": "        return: (osid.calendaring.TimePeriodNotificationSession) - ``a\n                _time_period_notification_session``", 
               "error_doc": "        raise:  NotFound - ``calendar_id`` not found\n        raise:  NullArgument - ``time_period_receiver`` or\n                ``calendar_id`` or ``proxy`` is ``null``\n        raise:  OperationFailed - ``unable to complete request``\n        raise:  Unimplemented - ``supports_time_period_notification()``\n                or ``supports_visible_federation()`` is ``false``", 
               "sphinx_param_doc": "        :param time_period_receiver: the time period receiver\n        :type time_period_receiver: ``osid.calendaring.TimePeriodReceiver``\n        :param calendar_id: the ``Id`` of the calendar\n        :type calendar_id: ``osid.id.Id``\n        :param proxy: a proxy\n        :type proxy: ``osid.proxy.Proxy``\n", 
               "sphinx_return_doc": "        :return: ``a _time_period_notification_session``\n        :rtype: ``osid.calendaring.TimePeriodNotificationSession``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``calendar_id`` not found\n        :raise: ``NullArgument`` -- ``time_period_receiver`` or ``calendar_id`` or ``proxy`` is ``null``\n        :raise: ``OperationFailed`` -- ``unable to complete request``\n        :raise: ``Unimplemented`` -- ``supports_time_period_notification()`` or ``supports_visible_federation()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_time_period_notification()`` and ``supports_visible_federation()`` are ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.calendaring.TimePeriodReceiver", 
                     "var_name": "time_period_receiver", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "calendar_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.proxy.Proxy", 
                     "var_name": "proxy", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.calendaring.TimePeriodReceiver", 
                  "osid.id.Id", 
                  "osid.proxy.Proxy"
               ], 
               "return_type": "osid.calendaring.TimePeriodNotificationSession", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_time_period_calendar_session", 
               "doc": {
                  "headline": "Gets the session for retrieving time period to calendar mappings.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    proxy (osid.proxy.Proxy): a proxy\n", 
               "return_doc": "        return: (osid.calendaring.TimePeriodCalendarSession) - a\n                ``TimePeriodCalendarSession``", 
               "error_doc": "        raise:  NullArgument - ``proxy`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_time_period_calendar()`` is\n                ``false``", 
               "sphinx_param_doc": "        :param proxy: a proxy\n        :type proxy: ``osid.proxy.Proxy``\n", 
               "sphinx_return_doc": "        :return: a ``TimePeriodCalendarSession``\n        :rtype: ``osid.calendaring.TimePeriodCalendarSession``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``proxy`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_time_period_calendar()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_time_period_calendar()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.proxy.Proxy", 
                     "var_name": "proxy", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.proxy.Proxy"
               ], 
               "return_type": "osid.calendaring.TimePeriodCalendarSession", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_time_period_calendar_assignment_session", 
               "doc": {
                  "headline": "Gets the session for assigning time period to calendar mappings.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    proxy (osid.proxy.Proxy): a proxy\n", 
               "return_doc": "        return: (osid.calendaring.TimePeriodCalendarAssignmentSession) -\n                a ``TimePeriodCalendarAssignmentSession``", 
               "error_doc": "        raise:  NullArgument - ``proxy`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented -\n                ``supports_time_period_calendar_assignment()`` is\n                ``false``", 
               "sphinx_param_doc": "        :param proxy: a proxy\n        :type proxy: ``osid.proxy.Proxy``\n", 
               "sphinx_return_doc": "        :return: a ``TimePeriodCalendarAssignmentSession``\n        :rtype: ``osid.calendaring.TimePeriodCalendarAssignmentSession``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``proxy`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_time_period_calendar_assignment()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_time_period_calendar_assignment()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.proxy.Proxy", 
                     "var_name": "proxy", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.proxy.Proxy"
               ], 
               "return_type": "osid.calendaring.TimePeriodCalendarAssignmentSession", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_time_period_smart_calendar_session", 
               "doc": {
                  "headline": "Gets the session associated with the time period smart calendar for the given calendar.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    calendar_id (osid.id.Id): the ``Id`` of the calendar\n        arg:    proxy (osid.proxy.Proxy): a proxy\n", 
               "return_doc": "        return: (osid.calendaring.TimePeriodSmartCalendarSession) - a\n                ``TimePeriodSmartCalendarSession``", 
               "error_doc": "        raise:  NotFound - ``calendar_id`` not found\n        raise:  NullArgument - ``calendar_id or proxy is null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented -\n                ``supports_time_period_smart_calendar()`` is ``false``", 
               "sphinx_param_doc": "        :param calendar_id: the ``Id`` of the calendar\n        :type calendar_id: ``osid.id.Id``\n        :param proxy: a proxy\n        :type proxy: ``osid.proxy.Proxy``\n", 
               "sphinx_return_doc": "        :return: a ``TimePeriodSmartCalendarSession``\n        :rtype: ``osid.calendaring.TimePeriodSmartCalendarSession``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``calendar_id`` not found\n        :raise: ``NullArgument`` -- ``calendar_id or proxy is null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_time_period_smart_calendar()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_time_period_smart_calendar()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "calendar_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.proxy.Proxy", 
                     "var_name": "proxy", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "osid.proxy.Proxy"
               ], 
               "return_type": "osid.calendaring.TimePeriodSmartCalendarSession", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_calendar_lookup_session", 
               "doc": {
                  "headline": "Gets the OsidSession associated with the calendar lookup service.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    proxy (osid.proxy.Proxy): a proxy\n", 
               "return_doc": "        return: (osid.calendaring.CalendarLookupSession) - a\n                ``CalendarLookupSession``", 
               "error_doc": "        raise:  NullArgument - ``proxy`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_calendar_lookup() is false``", 
               "sphinx_param_doc": "        :param proxy: a proxy\n        :type proxy: ``osid.proxy.Proxy``\n", 
               "sphinx_return_doc": "        :return: a ``CalendarLookupSession``\n        :rtype: ``osid.calendaring.CalendarLookupSession``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``proxy`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_calendar_lookup() is false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_calendar_lookup()`` is true.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.proxy.Proxy", 
                     "var_name": "proxy", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.proxy.Proxy"
               ], 
               "return_type": "osid.calendaring.CalendarLookupSession", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_calendar_search_session", 
               "doc": {
                  "headline": "Gets the OsidSession associated with the calendar search service.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    proxy (osid.proxy.Proxy): a proxy\n", 
               "return_doc": "        return: (osid.calendaring.CalendarSearchSession) - a\n                ``CalendarSearchSession``", 
               "error_doc": "        raise:  NullArgument - ``proxy`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_calendar_search() is false``", 
               "sphinx_param_doc": "        :param proxy: a proxy\n        :type proxy: ``osid.proxy.Proxy``\n", 
               "sphinx_return_doc": "        :return: a ``CalendarSearchSession``\n        :rtype: ``osid.calendaring.CalendarSearchSession``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``proxy`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_calendar_search() is false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_calendar_search()`` is true.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.proxy.Proxy", 
                     "var_name": "proxy", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.proxy.Proxy"
               ], 
               "return_type": "osid.calendaring.CalendarSearchSession", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_calendar_admin_session", 
               "doc": {
                  "headline": "Gets the OsidSession associated with the calendar administration service.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    proxy (osid.proxy.Proxy): a proxy\n", 
               "return_doc": "        return: (osid.calendaring.CalendarAdminSession) - a\n                ``CalendarAdminSession``", 
               "error_doc": "        raise:  NullArgument - ``proxy`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_calendar_admin() is false``", 
               "sphinx_param_doc": "        :param proxy: a proxy\n        :type proxy: ``osid.proxy.Proxy``\n", 
               "sphinx_return_doc": "        :return: a ``CalendarAdminSession``\n        :rtype: ``osid.calendaring.CalendarAdminSession``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``proxy`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_calendar_admin() is false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_calendar_admin()`` is true.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.proxy.Proxy", 
                     "var_name": "proxy", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.proxy.Proxy"
               ], 
               "return_type": "osid.calendaring.CalendarAdminSession", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_calendar_notification_session", 
               "doc": {
                  "headline": "Gets the notification session for notifications pertaining to calendar service changes.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    calendar_receiver (osid.calendaring.CalendarReceiver):\n                the calendar receiver\n        arg:    proxy (osid.proxy.Proxy): a proxy\n", 
               "return_doc": "        return: (osid.calendaring.CalendarNotificationSession) - a\n                ``CalendarNotificationSession``", 
               "error_doc": "        raise:  NullArgument - ``calendar_receiver`` or ``proxy`` is\n                ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_calendar_notification() is\n                false``", 
               "sphinx_param_doc": "        :param calendar_receiver: the calendar receiver\n        :type calendar_receiver: ``osid.calendaring.CalendarReceiver``\n        :param proxy: a proxy\n        :type proxy: ``osid.proxy.Proxy``\n", 
               "sphinx_return_doc": "        :return: a ``CalendarNotificationSession``\n        :rtype: ``osid.calendaring.CalendarNotificationSession``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``calendar_receiver`` or ``proxy`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_calendar_notification() is false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_calendar_notification()`` is true.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.calendaring.CalendarReceiver", 
                     "var_name": "calendar_receiver", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.proxy.Proxy", 
                     "var_name": "proxy", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.calendaring.CalendarReceiver", 
                  "osid.proxy.Proxy"
               ], 
               "return_type": "osid.calendaring.CalendarNotificationSession", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_calendar_hierarchy_session", 
               "doc": {
                  "headline": "Gets the session traversing calendar hierarchies.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    proxy (osid.proxy.Proxy): a proxy\n", 
               "return_doc": "        return: (osid.calendaring.CalendarHierarchySession) - a\n                ``CalendarHierarchySession``", 
               "error_doc": "        raise:  NullArgument - ``proxy`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_calendar_hierarchy() is\n                false``", 
               "sphinx_param_doc": "        :param proxy: a proxy\n        :type proxy: ``osid.proxy.Proxy``\n", 
               "sphinx_return_doc": "        :return: a ``CalendarHierarchySession``\n        :rtype: ``osid.calendaring.CalendarHierarchySession``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``proxy`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_calendar_hierarchy() is false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_calendar_hierarchy()`` is true.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.proxy.Proxy", 
                     "var_name": "proxy", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.proxy.Proxy"
               ], 
               "return_type": "osid.calendaring.CalendarHierarchySession", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_calendar_hierarchy_design_session", 
               "doc": {
                  "headline": "Gets the session designing calendar hierarchies.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    proxy (osid.proxy.Proxy): a proxy\n", 
               "return_doc": "        return: (osid.calendaring.CalendarHierarchyDesignSession) - a\n                ``CalendarHierarchyDesignSession``", 
               "error_doc": "        raise:  NullArgument - ``proxy`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_calendar_hierarchy_design()\n                is false``", 
               "sphinx_param_doc": "        :param proxy: a proxy\n        :type proxy: ``osid.proxy.Proxy``\n", 
               "sphinx_return_doc": "        :return: a ``CalendarHierarchyDesignSession``\n        :rtype: ``osid.calendaring.CalendarHierarchyDesignSession``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``proxy`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_calendar_hierarchy_design() is false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_calendar_hierarchy_design()`` is true.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.proxy.Proxy", 
                     "var_name": "proxy", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.proxy.Proxy"
               ], 
               "return_type": "osid.calendaring.CalendarHierarchyDesignSession", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_calandaring_batch_proxy_manager", 
               "doc": {
                  "headline": "Gets the calendaring batch proxy manager.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.batch.CalendaringBatchProxyManager) -\n                a ``CalendaringBatchProxyManager``", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_calendaring_batch()`` is\n                ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: a ``CalendaringBatchProxyManager``\n        :rtype: ``osid.calendaring.batch.CalendaringBatchProxyManager``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_calendaring_batch()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_calendaring_batch()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.batch.CalendaringBatchProxyManager", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_calandaring_cycle_proxy_manager", 
               "doc": {
                  "headline": "Gets the calendaring cycle proxy manager.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.cycle.CalendaringCycleProxyManager) -\n                a ``CalendaringCycleProxyManager``", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_calendaring_cycle()`` is\n                ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: a ``CalendaringCycleProxyManager``\n        :rtype: ``osid.calendaring.cycle.CalendaringCycleProxyManager``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_calendaring_cycle()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_calendaring_cycle()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.cycle.CalendaringCycleProxyManager", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_calandaring_rules_proxy_manager", 
               "doc": {
                  "headline": "Gets the calendaring rules proxy manager.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.rules.CalendaringRulesProxyManager) -\n                a ``CalendaringRulesProxyManager``", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  Unimplemented - ``supports_calendaring_rules()`` is\n                ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: a ``CalendaringRulesProxyManager``\n        :rtype: ``osid.calendaring.rules.CalendaringRulesProxyManager``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unimplemented`` -- ``supports_calendaring_rules()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_calendaring_rules()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.rules.CalendaringRulesProxyManager", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.calendaring.EventLookupSession", 
         "shortname": "EventLookupSession", 
         "category": "sessions", 
         "doc": {
            "headline": "This session provides methods for retrieving ``Event`` s.", 
            "body": ""
         }, 
         "inherit_fullnames": [
            "osid.OsidSession"
         ], 
         "inherit_shortnames": [
            "OsidSession"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidSession"
            }
         ], 
         "method_names": [
            "get_calendar_id", 
            "get_calendar", 
            "can_lookup_events", 
            "use_comparative_event_view", 
            "use_plenary_event_view", 
            "use_federated_calendar_view", 
            "use_isolated_calendar_view", 
            "use_effective_event_view", 
            "use_any_effective_event_view", 
            "use_normalized_event_view", 
            "use_denormalized_event_view", 
            "use_sequestered_event_view", 
            "use_unsequestered_event_view", 
            "get_event", 
            "get_events_by_ids", 
            "get_events_by_genus_type", 
            "get_events_by_parent_genus_type", 
            "get_events_by_record_type", 
            "get_events_on_date", 
            "get_events_in_date_range", 
            "get_upcoming_events", 
            "get_events_by_location", 
            "get_events_by_location_on_date", 
            "get_events_by_location_in_date_range", 
            "get_events_by_sponsor", 
            "get_events_by_sponsor_on_date", 
            "get_events_by_sponsor_in_date_range", 
            "get_events"
         ], 
         "methods": [
            {
               "name": "get_calendar_id", 
               "doc": {
                  "headline": "Gets the ``Calendar``  ``Id`` associated with this session.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.id.Id) - the ``Calendar Id`` associated with this\n                session", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the ``Calendar Id`` associated with this session\n        :rtype: ``osid.id.Id``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.id.Id", 
               "errors": {}
            }, 
            {
               "name": "get_calendar", 
               "doc": {
                  "headline": "Gets the ``Calendar`` associated with this session.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.Calendar) - the ``Calendar``\n                associated with this session", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the ``Calendar`` associated with this session\n        :rtype: ``osid.calendaring.Calendar``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.Calendar", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "can_lookup_events", 
               "doc": {
                  "headline": "Tests if this user can perform ``Event`` lookups.", 
                  "body": "        A return of true does not guarantee successful authorization. A\n        return of false indicates that it is known all methods in this\n        session will result in a ``PermissionDenied``. This is intended\n        as a hint to an application that may opt not to offer lookup\n        operations to unauthorized users."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``false`` if lookup methods are not\n                authorized, ``true`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``false`` if lookup methods are not authorized, ``true`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "use_comparative_event_view", 
               "doc": {
                  "headline": "The returns from the lookup methods may omit or translate elements based on this session, such as authorization, and not result in an error.", 
                  "body": "        This view is used when greater interoperability is desired at\n        the expense of precision."
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "use_plenary_event_view", 
               "doc": {
                  "headline": "A complete view of the ``Event`` returns is desired.", 
                  "body": "        Methods will return what is requested or result in an error.\n        This view is used when greater precision is desired at the\n        expense of interoperability."
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "use_federated_calendar_view", 
               "doc": {
                  "headline": "Federates the view for methods in this session.", 
                  "body": "        A federated view will include events in calendars which are\n        children of this calendar in the calendar hierarchy."
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "use_isolated_calendar_view", 
               "doc": {
                  "headline": "Isolates the view for methods in this session.", 
                  "body": "        An isolated view restricts lookups to this calendar only."
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "use_effective_event_view", 
               "doc": {
                  "headline": "Only events whose effective dates are current are returned by methods in this session.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "use_any_effective_event_view", 
               "doc": {
                  "headline": "All events of any effective dates are returned by methods in this session.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "use_normalized_event_view", 
               "doc": {
                  "headline": "A normalized view uses a single ``Event`` to represent a set of recurring events.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "use_denormalized_event_view", 
               "doc": {
                  "headline": "A denormalized view expands recurring events into a series of ``Events``.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "use_sequestered_event_view", 
               "doc": {
                  "headline": "The returns from the lookup methods omit sequestered events.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "use_unsequestered_event_view", 
               "doc": {
                  "headline": "All events are returned including sequestered events.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "get_event", 
               "doc": {
                  "headline": "Gets the ``Event`` specified by its ``Id``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    event_id (osid.id.Id): ``Id`` of the ``Event``\n", 
               "return_doc": "        return: (osid.calendaring.Event) - the event", 
               "error_doc": "        raise:  NotFound - ``event_id`` not found\n        raise:  NullArgument - ``event_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param event_id: ``Id`` of the ``Event``\n        :type event_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: the event\n        :rtype: ``osid.calendaring.Event``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``event_id`` not found\n        :raise: ``NullArgument`` -- ``event_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "event_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "osid.calendaring.Event", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_events_by_ids", 
               "doc": {
                  "headline": "Gets an ``EventList`` corresponding to the given ``IdList``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    event_ids (osid.id.IdList): the list of ``Ids`` to\n                retrieve\n", 
               "return_doc": "        return: (osid.calendaring.EventList) - the returned ``Event``\n                list", 
               "error_doc": "        raise:  NotFound - an ``Id was`` not found\n        raise:  NullArgument - ``event_ids`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param event_ids: the list of ``Ids`` to retrieve\n        :type event_ids: ``osid.id.IdList``\n", 
               "sphinx_return_doc": "        :return: the returned ``Event`` list\n        :rtype: ``osid.calendaring.EventList``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- an ``Id was`` not found\n        :raise: ``NullArgument`` -- ``event_ids`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.IdList", 
                     "var_name": "event_ids", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.IdList"
               ], 
               "return_type": "osid.calendaring.EventList", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_events_by_genus_type", 
               "doc": {
                  "headline": "Gets an ``EventList`` corresponding to the given event genus ``Type`` which does not include events of genus types derived from the specified ``Type``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    event_genus_type (osid.type.Type): an event genus type\n", 
               "return_doc": "        return: (osid.calendaring.EventList) - the returned ``Event``\n                list", 
               "error_doc": "        raise:  NullArgument - ``event_genus_type`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param event_genus_type: an event genus type\n        :type event_genus_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "        :return: the returned ``Event`` list\n        :rtype: ``osid.calendaring.EventList``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``event_genus_type`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "event_genus_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "osid.calendaring.EventList", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_events_by_parent_genus_type", 
               "doc": {
                  "headline": "Gets an ``EventList`` corresponding to the given event genus ``Type`` and include any additional event with genus types derived from the specified ``Type``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    event_genus_type (osid.type.Type): an event genus type\n", 
               "return_doc": "        return: (osid.calendaring.EventList) - the returned ``Event``\n                list", 
               "error_doc": "        raise:  NullArgument - ``event_genus_type`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param event_genus_type: an event genus type\n        :type event_genus_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "        :return: the returned ``Event`` list\n        :rtype: ``osid.calendaring.EventList``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``event_genus_type`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "event_genus_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "osid.calendaring.EventList", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_events_by_record_type", 
               "doc": {
                  "headline": "Gets an ``EventList`` containing the given event record ``Type``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    event_record_type (osid.type.Type): an event record type\n", 
               "return_doc": "        return: (osid.calendaring.EventList) - the returned ``Event``\n                list", 
               "error_doc": "        raise:  NullArgument - ``event_record_type`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param event_record_type: an event record type\n        :type event_record_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "        :return: the returned ``Event`` list\n        :rtype: ``osid.calendaring.EventList``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``event_record_type`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "event_record_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "osid.calendaring.EventList", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_events_on_date", 
               "doc": {
                  "headline": "Gets a list of events where the given date range falls within an event inclusive.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    from (osid.calendaring.DateTime): starting date\n        arg:    to (osid.calendaring.DateTime): ending date\n", 
               "return_doc": "        return: (osid.calendaring.EventList) - the returned ``Event``\n                list", 
               "error_doc": "        raise:  InvalidArgument - ``from`` is greater than ``to``\n        raise:  NullArgument - ``from`` or ``to`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param from: starting date\n        :type from: ``osid.calendaring.DateTime``\n        :param to: ending date\n        :type to: ``osid.calendaring.DateTime``\n", 
               "sphinx_return_doc": "        :return: the returned ``Event`` list\n        :rtype: ``osid.calendaring.EventList``", 
               "sphinx_error_doc": "        :raise: ``InvalidArgument`` -- ``from`` is greater than ``to``\n        :raise: ``NullArgument`` -- ``from`` or ``to`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.calendaring.DateTime", 
                     "var_name": "from_", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.calendaring.DateTime", 
                     "var_name": "to", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.calendaring.DateTime", 
                  "osid.calendaring.DateTime"
               ], 
               "return_type": "osid.calendaring.EventList", 
               "errors": {
                  "INVALID_ARGUMENT": "ConsumerContract", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_events_in_date_range", 
               "doc": {
                  "headline": "Gets an ``EventList`` that fall within the given range inclusive ````.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    from (osid.calendaring.DateTime): start date\n        arg:    to (osid.calendaring.DateTime): end date\n", 
               "return_doc": "        return: (osid.calendaring.EventList) - the returned ``Event``\n                list", 
               "error_doc": "        raise:  InvalidArgument - ``to`` is less than ``from``\n        raise:  NullArgument - ``from`` or ``to`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param from: start date\n        :type from: ``osid.calendaring.DateTime``\n        :param to: end date\n        :type to: ``osid.calendaring.DateTime``\n", 
               "sphinx_return_doc": "        :return: the returned ``Event`` list\n        :rtype: ``osid.calendaring.EventList``", 
               "sphinx_error_doc": "        :raise: ``InvalidArgument`` -- ``to`` is less than ``from``\n        :raise: ``NullArgument`` -- ``from`` or ``to`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.calendaring.DateTime", 
                     "var_name": "from_", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.calendaring.DateTime", 
                     "var_name": "to", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.calendaring.DateTime", 
                  "osid.calendaring.DateTime"
               ], 
               "return_type": "osid.calendaring.EventList", 
               "errors": {
                  "INVALID_ARGUMENT": "ConsumerContract", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_upcoming_events", 
               "doc": {
                  "headline": "Gets the next upcoming events on this calendar.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    number (cardinal): the number of events\n", 
               "return_doc": "        return: (osid.calendaring.EventList) - the returned ``Event``\n                list", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param number: the number of events\n        :type number: ``cardinal``\n", 
               "sphinx_return_doc": "        :return: the returned ``Event`` list\n        :rtype: ``osid.calendaring.EventList``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "cardinal", 
                     "var_name": "number", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "cardinal"
               ], 
               "return_type": "osid.calendaring.EventList", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_events_by_location", 
               "doc": {
                  "headline": "Gets a list of events with the given location.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    location_id (osid.id.Id): a location\n", 
               "return_doc": "        return: (osid.calendaring.EventList) - the returned ``Event``\n                list", 
               "error_doc": "        raise:  NullArgument - ``location_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param location_id: a location\n        :type location_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: the returned ``Event`` list\n        :rtype: ``osid.calendaring.EventList``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``location_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "location_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "osid.calendaring.EventList", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_events_by_location_on_date", 
               "doc": {
                  "headline": "Gets an ``EventList`` at the given location where the given date range falls within the event dates inclusive.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    location_id (osid.id.Id): a location\n        arg:    from (osid.calendaring.DateTime): start date\n        arg:    to (osid.calendaring.DateTime): end date\n", 
               "return_doc": "        return: (osid.calendaring.EventList) - the returned ``Event``\n                list", 
               "error_doc": "        raise:  InvalidArgument - ``to`` is less than ``from``\n        raise:  NullArgument - ``location_id, from`` , or ``to`` is\n                ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param location_id: a location\n        :type location_id: ``osid.id.Id``\n        :param from: start date\n        :type from: ``osid.calendaring.DateTime``\n        :param to: end date\n        :type to: ``osid.calendaring.DateTime``\n", 
               "sphinx_return_doc": "        :return: the returned ``Event`` list\n        :rtype: ``osid.calendaring.EventList``", 
               "sphinx_error_doc": "        :raise: ``InvalidArgument`` -- ``to`` is less than ``from``\n        :raise: ``NullArgument`` -- ``location_id, from`` , or ``to`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "location_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.calendaring.DateTime", 
                     "var_name": "from_", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.calendaring.DateTime", 
                     "var_name": "to", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "osid.calendaring.DateTime", 
                  "osid.calendaring.DateTime"
               ], 
               "return_type": "osid.calendaring.EventList", 
               "errors": {
                  "INVALID_ARGUMENT": "ConsumerContract", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_events_by_location_in_date_range", 
               "doc": {
                  "headline": "Gets an ``EventList`` that fall within the given range inclusive at the given location ````.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    location_id (osid.id.Id): a location\n        arg:    from (osid.calendaring.DateTime): start date\n        arg:    to (osid.calendaring.DateTime): end date\n", 
               "return_doc": "        return: (osid.calendaring.EventList) - the returned ``Event``\n                list", 
               "error_doc": "        raise:  InvalidArgument - ``to`` is less than ``from``\n        raise:  NullArgument - ``location_id, from`` , or ``to`` is\n                ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param location_id: a location\n        :type location_id: ``osid.id.Id``\n        :param from: start date\n        :type from: ``osid.calendaring.DateTime``\n        :param to: end date\n        :type to: ``osid.calendaring.DateTime``\n", 
               "sphinx_return_doc": "        :return: the returned ``Event`` list\n        :rtype: ``osid.calendaring.EventList``", 
               "sphinx_error_doc": "        :raise: ``InvalidArgument`` -- ``to`` is less than ``from``\n        :raise: ``NullArgument`` -- ``location_id, from`` , or ``to`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "location_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.calendaring.DateTime", 
                     "var_name": "from_", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.calendaring.DateTime", 
                     "var_name": "to", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "osid.calendaring.DateTime", 
                  "osid.calendaring.DateTime"
               ], 
               "return_type": "osid.calendaring.EventList", 
               "errors": {
                  "INVALID_ARGUMENT": "ConsumerContract", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_events_by_sponsor", 
               "doc": {
                  "headline": "Gets a list of events with the given sponsor.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    resource_id (osid.id.Id): a sponsor\n", 
               "return_doc": "        return: (osid.calendaring.EventList) - the returned ``Event``\n                list", 
               "error_doc": "        raise:  NullArgument - ``resource_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param resource_id: a sponsor\n        :type resource_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: the returned ``Event`` list\n        :rtype: ``osid.calendaring.EventList``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``resource_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "resource_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "osid.calendaring.EventList", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_events_by_sponsor_on_date", 
               "doc": {
                  "headline": "Gets an ``EventList`` with the given sponsor where the given date range falls within the event dates inclusive.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    resource_id (osid.id.Id): a sponsor\n        arg:    from (osid.calendaring.DateTime): start date\n        arg:    to (osid.calendaring.DateTime): end date\n", 
               "return_doc": "        return: (osid.calendaring.EventList) - the returned ``Event``\n                list", 
               "error_doc": "        raise:  InvalidArgument - ``to`` is less than ``from``\n        raise:  NullArgument - ``resource_id, from,`` or ``to`` is\n                ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param resource_id: a sponsor\n        :type resource_id: ``osid.id.Id``\n        :param from: start date\n        :type from: ``osid.calendaring.DateTime``\n        :param to: end date\n        :type to: ``osid.calendaring.DateTime``\n", 
               "sphinx_return_doc": "        :return: the returned ``Event`` list\n        :rtype: ``osid.calendaring.EventList``", 
               "sphinx_error_doc": "        :raise: ``InvalidArgument`` -- ``to`` is less than ``from``\n        :raise: ``NullArgument`` -- ``resource_id, from,`` or ``to`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "resource_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.calendaring.DateTime", 
                     "var_name": "from_", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.calendaring.DateTime", 
                     "var_name": "to", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "osid.calendaring.DateTime", 
                  "osid.calendaring.DateTime"
               ], 
               "return_type": "osid.calendaring.EventList", 
               "errors": {
                  "INVALID_ARGUMENT": "ConsumerContract", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_events_by_sponsor_in_date_range", 
               "doc": {
                  "headline": "Gets an ``EventList`` that fall within the given range inclusive at the given location ````.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    resource_id (osid.id.Id): a sponsor\n        arg:    from (osid.calendaring.DateTime): start date\n        arg:    to (osid.calendaring.DateTime): end date\n", 
               "return_doc": "        return: (osid.calendaring.EventList) - the returned ``Event``\n                list", 
               "error_doc": "        raise:  InvalidArgument - ``to`` is less than ``from``\n        raise:  NullArgument - ``resource_id, from,`` or ``to`` is\n                ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param resource_id: a sponsor\n        :type resource_id: ``osid.id.Id``\n        :param from: start date\n        :type from: ``osid.calendaring.DateTime``\n        :param to: end date\n        :type to: ``osid.calendaring.DateTime``\n", 
               "sphinx_return_doc": "        :return: the returned ``Event`` list\n        :rtype: ``osid.calendaring.EventList``", 
               "sphinx_error_doc": "        :raise: ``InvalidArgument`` -- ``to`` is less than ``from``\n        :raise: ``NullArgument`` -- ``resource_id, from,`` or ``to`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "resource_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.calendaring.DateTime", 
                     "var_name": "from_", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.calendaring.DateTime", 
                     "var_name": "to", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "osid.calendaring.DateTime", 
                  "osid.calendaring.DateTime"
               ], 
               "return_type": "osid.calendaring.EventList", 
               "errors": {
                  "INVALID_ARGUMENT": "ConsumerContract", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_events", 
               "doc": {
                  "headline": "Gets all ``Events``.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.EventList) - an ``EventList``", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: an ``EventList``\n        :rtype: ``osid.calendaring.EventList``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.EventList", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.calendaring.EventQuerySession", 
         "shortname": "EventQuerySession", 
         "category": "sessions", 
         "doc": {
            "headline": "This session provides methods for searching ``Event`` objects.", 
            "body": "    The search query is constructed using the ``EventQuery``. The event\n    record ``Type`` also specifies the record for the event query.\n\n    This session defines views that offer differing behaviors for\n    searching.\n    \n      * federated calendar view: searches include events in calendars of\n        which this calendar is an ancestor in the calendar hierarchy\n      * isolated calendar view: searches are restricted to events in\n        this calendar\n      * denormalized event view: recurring events are expanded into a\n        series of non-recurring events\n      * normalized event view: a series of recurring events is\n        represented by a single ``Event``\n      * sequestered event viiew: All event methods suppress sequestered\n        events.\n      * unsequestered event view: All event methods return all events.\n\n    \n    Events may have a query record indicated by their respective record\n    types. The query record is accessed via the ``EventQuery``."
         }, 
         "inherit_fullnames": [
            "osid.OsidSession"
         ], 
         "inherit_shortnames": [
            "OsidSession"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidSession"
            }
         ], 
         "method_names": [
            "get_calendar_id", 
            "get_calendar", 
            "can_search_events", 
            "use_federated_calendar_view", 
            "use_isolated_calendar_view", 
            "use_normalized_event_view", 
            "use_denormalized_event_view", 
            "use_sequestered_event_view", 
            "use_unsequestered_event_view", 
            "get_event_query", 
            "get_events_by_query"
         ], 
         "methods": [
            {
               "name": "get_calendar_id", 
               "doc": {
                  "headline": "Gets the ``Calendar``  ``Id`` associated with this session.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.id.Id) - the ``Calendar Id`` associated with this\n                session", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the ``Calendar Id`` associated with this session\n        :rtype: ``osid.id.Id``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.id.Id", 
               "errors": {}
            }, 
            {
               "name": "get_calendar", 
               "doc": {
                  "headline": "Gets the ``Calendar`` associated with this session.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.Calendar) - the ``Calendar``\n                associated with this session", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the ``Calendar`` associated with this session\n        :rtype: ``osid.calendaring.Calendar``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.Calendar", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "can_search_events", 
               "doc": {
                  "headline": "Tests if this user can perform ``Events`` searches.", 
                  "body": "        A return of true does not guarantee successful authorization. A\n        return of false indicates that it is known all methods in this\n        session will result in a ``PermissionDenied``. This is intended\n        as a hint to an application that may opt not to offer search\n        operations to unauthorized users."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``false`` if search methods are not\n                authorized, ``true`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``false`` if search methods are not authorized, ``true`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "use_federated_calendar_view", 
               "doc": {
                  "headline": "Federates the view for methods in this session.", 
                  "body": "        A federated view will include events in calendars which are\n        children of this calendar in the calendar hierarchy."
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "use_isolated_calendar_view", 
               "doc": {
                  "headline": "Isolates the view for methods in this session.", 
                  "body": "        An isolated view restricts searches to this calendar only."
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "use_normalized_event_view", 
               "doc": {
                  "headline": "A normalized view uses a single ``Event`` to represent a set of recurring events.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "use_denormalized_event_view", 
               "doc": {
                  "headline": "A denormalized view expands recurring events into a series of ``Events``.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "use_sequestered_event_view", 
               "doc": {
                  "headline": "The returns from the search methods omit sequestered events.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "use_unsequestered_event_view", 
               "doc": {
                  "headline": "All replies are returned including sequestered events.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "get_event_query", 
               "doc": {
                  "headline": "Gets an event query.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.EventQuery) - the event query", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the event query\n        :rtype: ``osid.calendaring.EventQuery``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.EventQuery", 
               "errors": {}
            }, 
            {
               "name": "get_events_by_query", 
               "doc": {
                  "headline": "Gets a list of ``Events`` matching the given event query.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    event_query (osid.calendaring.EventQuery): the event\n                query\n", 
               "return_doc": "        return: (osid.calendaring.EventList) - the returned\n                ``EventList``", 
               "error_doc": "        raise:  NullArgument - ``event_query`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        raise:  Unsupported - ``event_query`` is not of this service", 
               "sphinx_param_doc": "        :param event_query: the event query\n        :type event_query: ``osid.calendaring.EventQuery``\n", 
               "sphinx_return_doc": "        :return: the returned ``EventList``\n        :rtype: ``osid.calendaring.EventList``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``event_query`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure\n        :raise: ``Unsupported`` -- ``event_query`` is not of this service", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.calendaring.EventQuery", 
                     "var_name": "event_query", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.calendaring.EventQuery"
               ], 
               "return_type": "osid.calendaring.EventList", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.calendaring.EventSearchSession", 
         "shortname": "EventSearchSession", 
         "category": "sessions", 
         "doc": {
            "headline": "This session provides methods for searching ``Event`` objects.", 
            "body": "    The search query is constructed using the ``EventQuery``. The event\n    record ``Type`` also specifies the record for the event query.\n\n    ``get_events_by_query()`` is the basic search method and returns a\n    list of ``Events``. A more advanced search may be performed with\n    ``getEventsBySearch()``. It accepts an ``EventSearch`` in addition\n    to the query for the purpose of specifying additional options\n    affecting the entire search, such as ordering.\n    ``get_events_by_search()`` returns an ``EventSearchResults`` that\n    can be used to access the resulting ``EventList`` or be used to\n    perform a search within the result set through ``EventSearch``.\n    \n    This session defines views that offer differing behaviors for\n    searching.\n    \n      * federated calendar view: searches include events in calendars of\n        which this calendar is a ancestor in the calendar hierarchy\n      * isolated calendar view: searches are restricted to events in\n        this calendar\n      * denormalized event view: recurring events are expanded into a\n        series of non-recurring events\n      * normalized event view: a series of recurring events is\n        represented by a single ``Event``\n\n    \n    Events may have a query record indicated by their respective record\n    types. The query record is accessed via the ``EventQuery``."
         }, 
         "inherit_fullnames": [
            "osid.calendaring.EventQuerySession"
         ], 
         "inherit_shortnames": [
            "EventQuerySession"
         ], 
         "inherit_pkg_names": [
            "calendaring"
         ], 
         "inheritance": [
            {
               "pkg_name": "calendaring", 
               "name": "EventQuerySession"
            }
         ], 
         "method_names": [
            "get_event_search", 
            "get_event_search_order", 
            "get_events_by_search", 
            "get_event_query_from_inspector"
         ], 
         "methods": [
            {
               "name": "get_event_search", 
               "doc": {
                  "headline": "Gets an event search.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.EventSearch) - the event search", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the event search\n        :rtype: ``osid.calendaring.EventSearch``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.EventSearch", 
               "errors": {}
            }, 
            {
               "name": "get_event_search_order", 
               "doc": {
                  "headline": "Gets an event search order.", 
                  "body": "        The ``EventSearchOrder`` is supplied to an ``EventSearch`` to\n        specify the ordering of results."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.EventSearchOrder) - the event search\n                order", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the event search order\n        :rtype: ``osid.calendaring.EventSearchOrder``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.EventSearchOrder", 
               "errors": {}
            }, 
            {
               "name": "get_events_by_search", 
               "doc": {
                  "headline": "Gets the search results matching the given search query using the given search.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    event_query (osid.calendaring.EventQuery): the event\n                search query\n        arg:    event_search (osid.calendaring.EventSearch): the event\n                search\n", 
               "return_doc": "        return: (osid.calendaring.EventSearchResults) - the event search\n                results", 
               "error_doc": "        raise:  NullArgument - ``event_query`` or ``event_search`` is\n                ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        raise:  Unsupported - ``event_search`` or ``event_query`` is not\n                of this service", 
               "sphinx_param_doc": "        :param event_query: the event search query\n        :type event_query: ``osid.calendaring.EventQuery``\n        :param event_search: the event search\n        :type event_search: ``osid.calendaring.EventSearch``\n", 
               "sphinx_return_doc": "        :return: the event search results\n        :rtype: ``osid.calendaring.EventSearchResults``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``event_query`` or ``event_search`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure\n        :raise: ``Unsupported`` -- ``event_search`` or ``event_query`` is not of this service", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.calendaring.EventQuery", 
                     "var_name": "event_query", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.calendaring.EventSearch", 
                     "var_name": "event_search", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.calendaring.EventQuery", 
                  "osid.calendaring.EventSearch"
               ], 
               "return_type": "osid.calendaring.EventSearchResults", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_event_query_from_inspector", 
               "doc": {
                  "headline": "Gets an event query from an inspector.", 
                  "body": "        The inspector is available from an ``EventSearchResults``."
               }, 
               "arg_doc": "        arg:    event_query_inspector\n                (osid.calendaring.EventQueryInspector): an event query\n                inspector\n", 
               "return_doc": "        return: (osid.calendaring.EventQuery) - the event query", 
               "error_doc": "        raise:  NullArgument - ``event_query_inspector`` is ``null``\n        raise:  Unsupported - ``event_query_inspector`` is not of this\n                service", 
               "sphinx_param_doc": "        :param event_query_inspector: an event query inspector\n        :type event_query_inspector: ``osid.calendaring.EventQueryInspector``\n", 
               "sphinx_return_doc": "        :return: the event query\n        :rtype: ``osid.calendaring.EventQuery``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``event_query_inspector`` is ``null``\n        :raise: ``Unsupported`` -- ``event_query_inspector`` is not of this service", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.calendaring.EventQueryInspector", 
                     "var_name": "event_query_inspector", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.calendaring.EventQueryInspector"
               ], 
               "return_type": "osid.calendaring.EventQuery", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.calendaring.EventAdminSession", 
         "shortname": "EventAdminSession", 
         "category": "sessions", 
         "doc": {
            "headline": "This session creates, updates, and deletes ``Events``.", 
            "body": "    The data for create and update is provided by the consumer via the\n    form object. ``OsidForms`` are requested for each create or update\n    and may not be reused.\n\n    Create and update operations differ in their usage. To create an\n    ``Event,`` an ``EventForm`` is requested using\n    ``get_event_form_for_create()`` specifying the desired and record\n    ``Types`` or none if no record ``Types`` are needed. The returned\n    ``EventForm`` will indicate that it is to be used with a create\n    operation and can be used to examine metdata or validate data prior\n    to creation. Once the ``EventForm`` is submiited to a create\n    operation, it cannot be reused with another create operation unless\n    the first operation was unsuccessful. Each ``EventForm`` corresponds\n    to an attempted transaction.\n    \n    For updates, ``EventForms`` are requested to the ``Event``  ``Id``\n    that is to be updated using ``getEventFormForUpdate()``. Similarly,\n    the ``EventForm`` has metadata about the data that can be updated\n    and it can perform validation before submitting the update. The\n    ``EventForm`` can only be used once for a successful update and\n    cannot be reused.\n    \n    The delete operations delete ``Events``. To unmap an ``Event`` from\n    the current ``Calendar,`` the ``EventCalendarAssignmentSession``\n    should be used. These delete operations attempt to remove the\n    ``Event`` itself thus removing it from all known ``Calendar``\n    catalogs.\n    \n    This session includes an ``Id`` aliasing mechanism to assign an\n    external ``Id`` to an internally assigned Id."
         }, 
         "inherit_fullnames": [
            "osid.OsidSession"
         ], 
         "inherit_shortnames": [
            "OsidSession"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidSession"
            }
         ], 
         "method_names": [
            "get_calendar_id", 
            "get_calendar", 
            "can_create_events", 
            "can_create_event_with_record_types", 
            "get_event_form_for_create", 
            "create_event", 
            "can_update_events", 
            "get_event_form_for_update", 
            "update_event", 
            "can_delete_events", 
            "delete_event", 
            "can_manage_event_aliases", 
            "alias_event"
         ], 
         "methods": [
            {
               "name": "get_calendar_id", 
               "doc": {
                  "headline": "Gets the ``Calendar``  ``Id`` associated with this session.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.id.Id) - the ``Calendar Id`` associated with this\n                session", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the ``Calendar Id`` associated with this session\n        :rtype: ``osid.id.Id``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.id.Id", 
               "errors": {}
            }, 
            {
               "name": "get_calendar", 
               "doc": {
                  "headline": "Gets the ``Calendar`` associated with this session.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.Calendar) - the ``Calendar``\n                associated with this session", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the ``Calendar`` associated with this session\n        :rtype: ``osid.calendaring.Calendar``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.Calendar", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "can_create_events", 
               "doc": {
                  "headline": "Tests if this user can create ``Events``.", 
                  "body": "        A return of true does not guarantee successful authorization. A\n        return of false indicates that it is known creating an ``Event``\n        will result in a ``PermissionDenied``. This is intended as a\n        hint to an application that may opt not to offer create\n        operations to an unauthorized user."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``false`` if ``Event`` creation is not\n                authorized, ``true`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``false`` if ``Event`` creation is not authorized, ``true`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "can_create_event_with_record_types", 
               "doc": {
                  "headline": "Tests if this user can create a single ``Event`` using the desired record types.", 
                  "body": "        While ``CalendaringManager.getEventRecordTypes()`` can be used\n        to examine which records are supported, this method tests which\n        record(s) are required for creating a specific ``Event``.\n        Providing an empty array tests if an ``Event`` can be created\n        with no records."
               }, 
               "arg_doc": "        arg:    event_record_types (osid.type.Type[]): array of event\n                record types\n", 
               "return_doc": "        return: (boolean) - ``true`` if ``Event`` creation using the\n                specified record ``Types`` is supported, ``false``\n                otherwise", 
               "error_doc": "        raise:  NullArgument - ``event_record_types`` is ``null``", 
               "sphinx_param_doc": "        :param event_record_types: array of event record types\n        :type event_record_types: ``osid.type.Type[]``\n", 
               "sphinx_return_doc": "        :return: ``true`` if ``Event`` creation using the specified record ``Types`` is supported, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``event_record_types`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type[]", 
                     "var_name": "event_record_types", 
                     "array": true
                  }
               ], 
               "arg_types": [
                  "osid.type.Type[]"
               ], 
               "return_type": "boolean", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "get_event_form_for_create", 
               "doc": {
                  "headline": "Gets the event form for creating new events.", 
                  "body": "        A new form should be requested for each create transaction."
               }, 
               "arg_doc": "        arg:    event_record_types (osid.type.Type[]): array of event\n                record types\n", 
               "return_doc": "        return: (osid.calendaring.EventForm) - the event form", 
               "error_doc": "        raise:  NullArgument - ``event_record_types`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        raise:  Unsupported - unable to get form for requested record\n                types", 
               "sphinx_param_doc": "        :param event_record_types: array of event record types\n        :type event_record_types: ``osid.type.Type[]``\n", 
               "sphinx_return_doc": "        :return: the event form\n        :rtype: ``osid.calendaring.EventForm``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``event_record_types`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure\n        :raise: ``Unsupported`` -- unable to get form for requested record types", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type[]", 
                     "var_name": "event_record_types", 
                     "array": true
                  }
               ], 
               "arg_types": [
                  "osid.type.Type[]"
               ], 
               "return_type": "osid.calendaring.EventForm", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }, 
            {
               "name": "create_event", 
               "doc": {
                  "headline": "Creates a new ``Event``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    event_form (osid.calendaring.EventForm): the form for\n                this ``Event``\n", 
               "return_doc": "        return: (osid.calendaring.Event) - the new ``Event``", 
               "error_doc": "        raise:  IllegalState - ``event_form`` already used in a create\n                transaction\n        raise:  InvalidArgument - one or more of the form elements is\n                invalid\n        raise:  NullArgument - ``event_form`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        raise:  Unsupported - ``event_form`` did not originate from\n                ``get_event_form_for_create()``", 
               "sphinx_param_doc": "        :param event_form: the form for this ``Event``\n        :type event_form: ``osid.calendaring.EventForm``\n", 
               "sphinx_return_doc": "        :return: the new ``Event``\n        :rtype: ``osid.calendaring.Event``", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- ``event_form`` already used in a create transaction\n        :raise: ``InvalidArgument`` -- one or more of the form elements is invalid\n        :raise: ``NullArgument`` -- ``event_form`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure\n        :raise: ``Unsupported`` -- ``event_form`` did not originate from ``get_event_form_for_create()``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.calendaring.EventForm", 
                     "var_name": "event_form", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.calendaring.EventForm"
               ], 
               "return_type": "osid.calendaring.Event", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract", 
                  "INVALID_ARGUMENT": "ConsumerContract", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }, 
            {
               "name": "can_update_events", 
               "doc": {
                  "headline": "Tests if this user can update ``Events``.", 
                  "body": "        A return of true does not guarantee successful authorization. A\n        return of false indicates that it is known updating an ``Event``\n        will result in a ``PermissionDenied``. This is intended as a\n        hint to an application that may opt not to offer update\n        operations to an unauthorized user."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``false`` if event modification is not\n                authorized, ``true`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``false`` if event modification is not authorized, ``true`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "get_event_form_for_update", 
               "doc": {
                  "headline": "Gets the event form for updating an existing event.", 
                  "body": "        A new event form should be requested for each update\n        transaction."
               }, 
               "arg_doc": "        arg:    event_id (osid.id.Id): the ``Id`` of the ``Event``\n", 
               "return_doc": "        return: (osid.calendaring.EventForm) - the event form", 
               "error_doc": "        raise:  NotFound - ``event_id`` is not found\n        raise:  NullArgument - ``event_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param event_id: the ``Id`` of the ``Event``\n        :type event_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: the event form\n        :rtype: ``osid.calendaring.EventForm``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``event_id`` is not found\n        :raise: ``NullArgument`` -- ``event_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "event_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "osid.calendaring.EventForm", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "update_event", 
               "doc": {
                  "headline": "Updates an existing event.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    event_form (osid.calendaring.EventForm): the form\n                containing the elements to be updated\n", 
               "return_doc": "", 
               "error_doc": "        raise:  IllegalState - ``event_form`` already used in an update\n                transaction\n        raise:  InvalidArgument - one or more of the form elements is\n                invalid\n        raise:  NullArgument - ``event_form`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        raise:  Unsupported - ``event_form`` did not originate from\n                ``get_event_form_for_update()``", 
               "sphinx_param_doc": "        :param event_form: the form containing the elements to be updated\n        :type event_form: ``osid.calendaring.EventForm``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- ``event_form`` already used in an update transaction\n        :raise: ``InvalidArgument`` -- one or more of the form elements is invalid\n        :raise: ``NullArgument`` -- ``event_form`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure\n        :raise: ``Unsupported`` -- ``event_form`` did not originate from ``get_event_form_for_update()``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.calendaring.EventForm", 
                     "var_name": "event_form", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.calendaring.EventForm"
               ], 
               "return_type": "", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract", 
                  "INVALID_ARGUMENT": "ConsumerContract", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }, 
            {
               "name": "can_delete_events", 
               "doc": {
                  "headline": "Tests if this user can delete ``Events``.", 
                  "body": "        A return of true does not guarantee successful authorization. A\n        return of false indicates that it is known deleting an ``Event``\n        will result in a ``PermissionDenied``. This is intended as a\n        hint to an application that may opt not to offer delete\n        operations to an unauthorized user."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``false`` if ``Event`` deletion is not\n                authorized, ``true`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``false`` if ``Event`` deletion is not authorized, ``true`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "delete_event", 
               "doc": {
                  "headline": "Deletes the ``Event`` identified by the given ``Id``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    event_id (osid.id.Id): the ``Id`` of the ``Event`` to\n                delete\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NotFound - an ``Event`` was not found identified by the\n                given ``Id``\n        raise:  NullArgument - ``event_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param event_id: the ``Id`` of the ``Event`` to delete\n        :type event_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- an ``Event`` was not found identified by the given ``Id``\n        :raise: ``NullArgument`` -- ``event_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "event_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "can_manage_event_aliases", 
               "doc": {
                  "headline": "Tests if this user can manage ``Id`` aliases for ``Events``.", 
                  "body": "        A return of true does not guarantee successful authorization. A\n        return of false indicates that it is known changing an alias\n        will result in a ``PermissionDenied``. This is intended as a\n        hint to an application that may opt not to offer alias\n        operations to an unauthorized user."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``false`` if ``Event`` aliasing is not\n                authorized, ``true`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``false`` if ``Event`` aliasing is not authorized, ``true`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "alias_event", 
               "doc": {
                  "headline": "Adds an ``Id`` to an ``Event`` for the purpose of creating compatibility.", 
                  "body": "        The primary ``Id`` of the ``Event`` is determined by the\n        provider. The new ``Id`` performs as an alias to the primary\n        ``Id``. If the alias is a pointer to another event, it is\n        reassigned to the given event ``Id``."
               }, 
               "arg_doc": "        arg:    event_id (osid.id.Id): the ``Id`` of an ``Event``\n        arg:    alias_id (osid.id.Id): the alias ``Id``\n", 
               "return_doc": "", 
               "error_doc": "        raise:  AlreadyExists - ``alias_id`` is already assigned\n        raise:  NotFound - ``event_id`` not found\n        raise:  NullArgument - ``event_id`` or ``alias_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param event_id: the ``Id`` of an ``Event``\n        :type event_id: ``osid.id.Id``\n        :param alias_id: the alias ``Id``\n        :type alias_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``AlreadyExists`` -- ``alias_id`` is already assigned\n        :raise: ``NotFound`` -- ``event_id`` not found\n        :raise: ``NullArgument`` -- ``event_id`` or ``alias_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "event_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "alias_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {
                  "ALREADY_EXISTS": "User", 
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.calendaring.EventNotificationSession", 
         "shortname": "EventNotificationSession", 
         "category": "sessions", 
         "doc": {
            "headline": "This session defines methods to receive asynchronous notifications on adds/changes to ``Event`` objects.", 
            "body": "    This session is intended for consumers needing to synchronize their\n    state with this service without the use of polling. Notifications\n    are cancelled when this session is closed.\n\n    The views defined in this session correspond to the views in the\n    ``EventLookupSession``."
         }, 
         "inherit_fullnames": [
            "osid.OsidSession"
         ], 
         "inherit_shortnames": [
            "OsidSession"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidSession"
            }
         ], 
         "method_names": [
            "get_calendar_id", 
            "get_calendar", 
            "can_register_for_event_notifications", 
            "use_federated_calendar_view", 
            "use_isolated_calendar_view", 
            "use_normalized_event_view", 
            "use_denormalized_event_view", 
            "register_for_new_events", 
            "register_for_changed_events", 
            "register_for_changed_event", 
            "register_for_deleted_events", 
            "register_for_deleted_event"
         ], 
         "methods": [
            {
               "name": "get_calendar_id", 
               "doc": {
                  "headline": "Gets the ``Calendar``  ``Id`` associated with this session.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.id.Id) - the ``Calendar Id`` associated with this\n                session", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the ``Calendar Id`` associated with this session\n        :rtype: ``osid.id.Id``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.id.Id", 
               "errors": {}
            }, 
            {
               "name": "get_calendar", 
               "doc": {
                  "headline": "Gets the ``Calendar`` associated with this session.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.Calendar) - the ``Calendar``\n                associated with this session", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the ``Calendar`` associated with this session\n        :rtype: ``osid.calendaring.Calendar``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.Calendar", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "can_register_for_event_notifications", 
               "doc": {
                  "headline": "Tests if this user can register for ``Event`` notifications.", 
                  "body": "        A return of true does not guarantee successful authorization. A\n        return of false indicates that it is known all methods in this\n        session will result in a ``PermissionDenied``. This is intended\n        as a hint to an application that may opt not to offer\n        notification operations."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``false`` if notification methods are not\n                authorized, ``true`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``false`` if notification methods are not authorized, ``true`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "use_federated_calendar_view", 
               "doc": {
                  "headline": "Federates the view for methods in this session.", 
                  "body": "        A federated view will include notifications for events in\n        calendars which are children of this calendar in the calendar\n        hierarchy."
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "use_isolated_calendar_view", 
               "doc": {
                  "headline": "Isolates the view for methods in this session.", 
                  "body": "        An isolated view restricts notifications to this calendar only."
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "use_normalized_event_view", 
               "doc": {
                  "headline": "A normalized view sends a single notification for recurring events.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "use_denormalized_event_view", 
               "doc": {
                  "headline": "A denormalized view sends a separate notification for each non- recurring event within a recurring set.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "register_for_new_events", 
               "doc": {
                  "headline": "Register for notifications of new events.", 
                  "body": "        ``EventReceiver.newEvent()`` is invoked when a new event is\n        created."
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "register_for_changed_events", 
               "doc": {
                  "headline": "Registers for notification of updated events.", 
                  "body": "        ``EventReceiver.changedEvent()`` is invoked when an event is\n        changed."
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "register_for_changed_event", 
               "doc": {
                  "headline": "Registers for notification of an updated event.", 
                  "body": "        ``EventReceiver.changedEvent()`` is invoked when the specified\n        event is changed."
               }, 
               "arg_doc": "        arg:    event_id (osid.id.Id): the ``Id`` of the ``Event`` to\n                monitor\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``event_id is null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param event_id: the ``Id`` of the ``Event`` to monitor\n        :type event_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``event_id is null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "event_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "register_for_deleted_events", 
               "doc": {
                  "headline": "Registers for notification of deleted events.", 
                  "body": "        ``EventReceiver.deletedEvent()`` is invoked when an event is\n        removed from this calendar."
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "register_for_deleted_event", 
               "doc": {
                  "headline": "Registers for notification of a deleted event.", 
                  "body": "        ``EventReceiver.changedEvent()`` is invoked when the specified\n        event is removed from this calendar."
               }, 
               "arg_doc": "        arg:    event_id (osid.id.Id): the ``Id`` of the ``Event`` to\n                monitor\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``event_id is null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param event_id: the ``Id`` of the ``Event`` to monitor\n        :type event_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``event_id is null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "event_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.calendaring.EventCalendarSession", 
         "shortname": "EventCalendarSession", 
         "category": "sessions", 
         "doc": {
            "headline": "This session provides methods to retrieve ``Event`` to ``Calendar`` mappings.", 
            "body": "    An ``Event`` may appear in multiple ``Calendars``. Each ``Calendar``\n    may have its own authorizations governing who is allowed to look at\n    it.\n\n    This lookup session defines two views:\n    \n      * comparative view: elements may be silently omitted or re-ordered\n      * plenary view: provides a complete result set or is an error\n        condition\n      * normalized event view: a single recurring event is used to\n        represent a series of events\n      * denormalized view: recurring events are expanded into individual\n        events\n"
         }, 
         "inherit_fullnames": [
            "osid.OsidSession"
         ], 
         "inherit_shortnames": [
            "OsidSession"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidSession"
            }
         ], 
         "method_names": [
            "can_lookup_event_calendar_mappings", 
            "use_comparative_calendar_view", 
            "use_plenary_calendar_view", 
            "use_normalized_event_view", 
            "use_denormalized_event_view", 
            "get_event_ids_by_calendar", 
            "get_events_by_calendar", 
            "get_event_ids_by_calendars", 
            "get_events_by_calendars", 
            "get_calendar_ids_by_event", 
            "get_calendars_by_event"
         ], 
         "methods": [
            {
               "name": "can_lookup_event_calendar_mappings", 
               "doc": {
                  "headline": "Tests if this user can perform lookups of event/calendar mappings.", 
                  "body": "        A return of true does not guarantee successful authorization. A\n        return of false indicates that it is known lookup methods in\n        this session will result in a ``PermissionDenied``. This is\n        intended as a hint to an application that may opt not to offer\n        lookup operations to unauthorized users."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``false`` if looking up mappings is not\n                authorized, ``true`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``false`` if looking up mappings is not authorized, ``true`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "use_comparative_calendar_view", 
               "doc": {
                  "headline": "The returns from the lookup methods may omit or translate elements based on this session, such as authorization, and not result in an error.", 
                  "body": "        This view is used when greater interoperability is desired at\n        the expense of precision."
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "use_plenary_calendar_view", 
               "doc": {
                  "headline": "A complete view of the ``Event`` and ``Calendar`` returns is desired.", 
                  "body": "        Methods will return what is requested or result in an error.\n        This view is used when greater precision is desired at the\n        expense of interoperability."
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "use_normalized_event_view", 
               "doc": {
                  "headline": "A normalized view sends a single notification for recurring events.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "use_denormalized_event_view", 
               "doc": {
                  "headline": "A denormalized view sends a separate notification for each event in a recurring set.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "get_event_ids_by_calendar", 
               "doc": {
                  "headline": "Gets the list of ``Event``  ``Ids`` associated with a ``Calendar``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    calendar_id (osid.id.Id): ``Id`` of the ``Calendar``\n", 
               "return_doc": "        return: (osid.id.IdList) - list of related event ``Ids``", 
               "error_doc": "        raise:  NotFound - ``calendar_id`` is not found\n        raise:  NullArgument - ``calendar_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param calendar_id: ``Id`` of the ``Calendar``\n        :type calendar_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: list of related event ``Ids``\n        :rtype: ``osid.id.IdList``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``calendar_id`` is not found\n        :raise: ``NullArgument`` -- ``calendar_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "calendar_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "osid.id.IdList", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_events_by_calendar", 
               "doc": {
                  "headline": "Gets the list of ``Events`` associated with a ``Calendar``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    calendar_id (osid.id.Id): ``Id`` of the ``Calendar``\n", 
               "return_doc": "        return: (osid.calendaring.EventList) - list of related events", 
               "error_doc": "        raise:  NotFound - ``calendar_id`` is not found\n        raise:  NullArgument - ``calendar_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param calendar_id: ``Id`` of the ``Calendar``\n        :type calendar_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: list of related events\n        :rtype: ``osid.calendaring.EventList``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``calendar_id`` is not found\n        :raise: ``NullArgument`` -- ``calendar_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "calendar_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "osid.calendaring.EventList", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_event_ids_by_calendars", 
               "doc": {
                  "headline": "Gets the list of ``Event Ids`` corresponding to a list of ``Calendars``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    calendar_ids (osid.id.IdList): list of calendar ``Ids``\n", 
               "return_doc": "        return: (osid.id.IdList) - list of event ``Ids``", 
               "error_doc": "        raise:  NullArgument - ``calendar_ids`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param calendar_ids: list of calendar ``Ids``\n        :type calendar_ids: ``osid.id.IdList``\n", 
               "sphinx_return_doc": "        :return: list of event ``Ids``\n        :rtype: ``osid.id.IdList``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``calendar_ids`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.IdList", 
                     "var_name": "calendar_ids", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.IdList"
               ], 
               "return_type": "osid.id.IdList", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_events_by_calendars", 
               "doc": {
                  "headline": "Gets the list of ``Events`` corresponding to a list of ``Calendars``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    calendar_ids (osid.id.IdList): list of calendar ``Ids``\n", 
               "return_doc": "        return: (osid.calendaring.EventList) - list of events", 
               "error_doc": "        raise:  NullArgument - ``calendar_ids`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param calendar_ids: list of calendar ``Ids``\n        :type calendar_ids: ``osid.id.IdList``\n", 
               "sphinx_return_doc": "        :return: list of events\n        :rtype: ``osid.calendaring.EventList``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``calendar_ids`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.IdList", 
                     "var_name": "calendar_ids", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.IdList"
               ], 
               "return_type": "osid.calendaring.EventList", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_calendar_ids_by_event", 
               "doc": {
                  "headline": "Gets the list of ``Calendar``  ``Ids`` mapped to an ``Event``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    event_id (osid.id.Id): ``Id`` of an ``Event``\n", 
               "return_doc": "        return: (osid.id.IdList) - list of calendar ``Ids``", 
               "error_doc": "        raise:  NotFound - ``event_id`` is not found\n        raise:  NullArgument - ``event_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param event_id: ``Id`` of an ``Event``\n        :type event_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: list of calendar ``Ids``\n        :rtype: ``osid.id.IdList``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``event_id`` is not found\n        :raise: ``NullArgument`` -- ``event_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "event_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "osid.id.IdList", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_calendars_by_event", 
               "doc": {
                  "headline": "Gets the list of ``Calendars`` mapped to an ``Event``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    event_id (osid.id.Id): ``Id`` of an ``Event``\n", 
               "return_doc": "        return: (osid.calendaring.CalendarList) - list of calendars", 
               "error_doc": "        raise:  NotFound - ``event_id`` is not found\n        raise:  NullArgument - ``event_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param event_id: ``Id`` of an ``Event``\n        :type event_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: list of calendars\n        :rtype: ``osid.calendaring.CalendarList``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``event_id`` is not found\n        :raise: ``NullArgument`` -- ``event_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "event_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "osid.calendaring.CalendarList", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.calendaring.EventCalendarAssignmentSession", 
         "shortname": "EventCalendarAssignmentSession", 
         "category": "sessions", 
         "doc": {
            "headline": "This session provides methods to re-assign ``Events`` to ``Calendars``.", 
            "body": "    An ``Event`` may map to multiple ``Calendars`` and removing the last\n    reference to an ``Event`` is the equivalent of deleting it. Each\n    ``Calendar`` may have its own authorizations governing who is\n    allowed to operate on it.\n\n    Moving or adding a reference of an ``Event`` to another ``Calendar``\n    is not a copy operation (eg: does not change its ``Id`` )."
         }, 
         "inherit_fullnames": [
            "osid.OsidSession"
         ], 
         "inherit_shortnames": [
            "OsidSession"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidSession"
            }
         ], 
         "method_names": [
            "can_assign_events", 
            "can_assign_events_to_calendar", 
            "get_assignable_calendar_ids", 
            "get_assignable_calendar_ids_for_event", 
            "assign_event_to_calendar", 
            "unassign_event_from_calendar"
         ], 
         "methods": [
            {
               "name": "can_assign_events", 
               "doc": {
                  "headline": "Tests if this user can alter event/calendar mappings.", 
                  "body": "        A return of true does not guarantee successful authorization. A\n        return of false indicates that it is known mapping methods in\n        this session will result in a ``PermissionDenied``. This is\n        intended as a hint to an application that may opt not to offer\n        assignment operations to unauthorized users."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``false`` if mapping is not authorized,\n                ``true`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``false`` if mapping is not authorized, ``true`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "can_assign_events_to_calendar", 
               "doc": {
                  "headline": "Tests if this user can alter event/calendar mappings.", 
                  "body": "        A return of true does not guarantee successful authorization. A\n        return of false indicates that it is known mapping methods in\n        this session will result in a PERMISSION_DENIED. This is\n        intended as a hint to an application that may opt not to offer\n        assignment operations to unauthorized users."
               }, 
               "arg_doc": "        arg:    calendar_id (osid.id.Id): the ``Id`` of the ``Calendar``\n", 
               "return_doc": "        return: (boolean) - ``false`` if mapping is not authorized,\n                ``true`` otherwise", 
               "error_doc": "        raise:  NullArgument - ``calendar_id`` is ``null``", 
               "sphinx_param_doc": "        :param calendar_id: the ``Id`` of the ``Calendar``\n        :type calendar_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: ``false`` if mapping is not authorized, ``true`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``calendar_id`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "calendar_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "boolean", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "get_assignable_calendar_ids", 
               "doc": {
                  "headline": "Gets a list of calendars including and under the given calendar node in which any event can be assigned.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    calendar_id (osid.id.Id): the ``Id`` of the ``Calendar``\n", 
               "return_doc": "        return: (osid.id.IdList) - list of assignable calendar ``Ids``", 
               "error_doc": "        raise:  NullArgument - ``calendar_id`` is ``null``\n        raise:  OperationFailed - unable to complete request", 
               "sphinx_param_doc": "        :param calendar_id: the ``Id`` of the ``Calendar``\n        :type calendar_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: list of assignable calendar ``Ids``\n        :rtype: ``osid.id.IdList``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``calendar_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "calendar_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "osid.id.IdList", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational"
               }
            }, 
            {
               "name": "get_assignable_calendar_ids_for_event", 
               "doc": {
                  "headline": "Gets a list of calendars including and under the given calendar node in which a specific event can be assigned.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    calendar_id (osid.id.Id): the ``Id`` of the ``Calendar``\n        arg:    event_id (osid.id.Id): the ``Id`` of the ``Event``\n", 
               "return_doc": "        return: (osid.id.IdList) - list of assignable calendar ``Ids``", 
               "error_doc": "        raise:  NullArgument - ``calendar_id`` or ``event_id`` is\n                ``null``\n        raise:  OperationFailed - unable to complete request", 
               "sphinx_param_doc": "        :param calendar_id: the ``Id`` of the ``Calendar``\n        :type calendar_id: ``osid.id.Id``\n        :param event_id: the ``Id`` of the ``Event``\n        :type event_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: list of assignable calendar ``Ids``\n        :rtype: ``osid.id.IdList``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``calendar_id`` or ``event_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "calendar_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "event_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "osid.id.Id"
               ], 
               "return_type": "osid.id.IdList", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational"
               }
            }, 
            {
               "name": "assign_event_to_calendar", 
               "doc": {
                  "headline": "Adds an existing ``Event`` to a ``Calendar``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    event_id (osid.id.Id): the ``Id`` of the ``Event``\n        arg:    calendar_id (osid.id.Id): the ``Id`` of the ``Calendar``\n", 
               "return_doc": "", 
               "error_doc": "        raise:  AlreadyExists - ``event_id`` is already assigned to\n                ``calendar_id``\n        raise:  NotFound - ``event_id`` or ``calendar_id`` not found\n        raise:  NullArgument - ``event_id`` or ``calendar_id`` is\n                ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param event_id: the ``Id`` of the ``Event``\n        :type event_id: ``osid.id.Id``\n        :param calendar_id: the ``Id`` of the ``Calendar``\n        :type calendar_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``AlreadyExists`` -- ``event_id`` is already assigned to ``calendar_id``\n        :raise: ``NotFound`` -- ``event_id`` or ``calendar_id`` not found\n        :raise: ``NullArgument`` -- ``event_id`` or ``calendar_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "event_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "calendar_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {
                  "ALREADY_EXISTS": "User", 
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "unassign_event_from_calendar", 
               "doc": {
                  "headline": "Removes an ``Event`` from a ``Calendar``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    event_id (osid.id.Id): the ``Id`` of the ``Event``\n        arg:    calendar_id (osid.id.Id): the ``Id`` of the ``Calendar``\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NotFound - ``event_id or calendar_id not found or\n                event_id not assigned to calendar_id``\n        raise:  NullArgument - ``event_id`` or ``calendar_id`` is\n                ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param event_id: the ``Id`` of the ``Event``\n        :type event_id: ``osid.id.Id``\n        :param calendar_id: the ``Id`` of the ``Calendar``\n        :type calendar_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``event_id or calendar_id not found or event_id not assigned to calendar_id``\n        :raise: ``NullArgument`` -- ``event_id`` or ``calendar_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "event_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "calendar_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.calendaring.EventSmartCalendarSession", 
         "shortname": "EventSmartCalendarSession", 
         "category": "sessions", 
         "doc": {
            "headline": "This session manages queries and sequencing to create \"smart\" dynamic catalogs.", 
            "body": "    An ``EventQuery`` can be retrieved from this session and mapped to\n    this ``Calendar`` to create a virtual collection of ``Events``. The\n    entries may be sequenced using the ``EventSearchOrder`` from this\n    session.\n\n    This ``Calendar`` has a default query that matches any event and a\n    default search order that specifies no sequencing. The queries may\n    be examined using an ``EventQueryInspector``. The query may be\n    modified by converting the inspector back to an ``EventQuery``."
         }, 
         "inherit_fullnames": [
            "osid.OsidSession"
         ], 
         "inherit_shortnames": [
            "OsidSession"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidSession"
            }
         ], 
         "method_names": [
            "get_calendar_id", 
            "get_calendar", 
            "can_manage_smart_calendars", 
            "get_event_query", 
            "get_event_search_order", 
            "apply_event_query", 
            "inspect_event_query", 
            "apply_event_sequencing", 
            "get_event_query_from_inspector"
         ], 
         "methods": [
            {
               "name": "get_calendar_id", 
               "doc": {
                  "headline": "Gets the ``Calendar``  ``Id`` associated with this session.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.id.Id) - the ``Calendar Id`` associated with this\n                session", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the ``Calendar Id`` associated with this session\n        :rtype: ``osid.id.Id``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.id.Id", 
               "errors": {}
            }, 
            {
               "name": "get_calendar", 
               "doc": {
                  "headline": "Gets the ``Calendar`` associated with this session.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.Calendar) - the ``Calendar``\n                associated with this session", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the ``Calendar`` associated with this session\n        :rtype: ``osid.calendaring.Calendar``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.Calendar", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "can_manage_smart_calendars", 
               "doc": {
                  "headline": "Tests if this user can manage smart calendars.", 
                  "body": "        A return of true does not guarantee successful authorization. A\n        return of false indicates that it is known all methods in this\n        session will result in a ``PermissionDenied``. This is intended\n        as a hint to an application that may opt not to offer smart\n        operations."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``false`` if smart calendar methods are not\n                authorized, ``true`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``false`` if smart calendar methods are not authorized, ``true`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "get_event_query", 
               "doc": {
                  "headline": "Gets an event query.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.EventQuery) - the event query", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the event query\n        :rtype: ``osid.calendaring.EventQuery``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.EventQuery", 
               "errors": {}
            }, 
            {
               "name": "get_event_search_order", 
               "doc": {
                  "headline": "Gets an event search order.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.EventSearchOrder) - the event search\n                order", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the event search order\n        :rtype: ``osid.calendaring.EventSearchOrder``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.EventSearchOrder", 
               "errors": {}
            }, 
            {
               "name": "apply_event_query", 
               "doc": {
                  "headline": "Applies an event query to this calendar.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    event_query (osid.calendaring.EventQuery): the event\n                query\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``event_query`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure occurred\n        raise:  Unsupported - ``event_query`` not of this service", 
               "sphinx_param_doc": "        :param event_query: the event query\n        :type event_query: ``osid.calendaring.EventQuery``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``event_query`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure occurred\n        :raise: ``Unsupported`` -- ``event_query`` not of this service", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.calendaring.EventQuery", 
                     "var_name": "event_query", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.calendaring.EventQuery"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }, 
            {
               "name": "inspect_event_query", 
               "doc": {
                  "headline": "Gets an event query inspector for this calendar.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.EventQueryInspector) - the event query\n                inspector", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure occurred", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the event query inspector\n        :rtype: ``osid.calendaring.EventQueryInspector``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure occurred", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.EventQueryInspector", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "apply_event_sequencing", 
               "doc": {
                  "headline": "Applies an event search order to this calendar.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    event_search_order (osid.calendaring.EventSearchOrder):\n                the event search order\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``event_search_order`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure occurred\n        raise:  Unsupported - ``event_search_order`` not of this service", 
               "sphinx_param_doc": "        :param event_search_order: the event search order\n        :type event_search_order: ``osid.calendaring.EventSearchOrder``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``event_search_order`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure occurred\n        :raise: ``Unsupported`` -- ``event_search_order`` not of this service", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.calendaring.EventSearchOrder", 
                     "var_name": "event_search_order", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.calendaring.EventSearchOrder"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_event_query_from_inspector", 
               "doc": {
                  "headline": "Gets an event query from an inspector.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    event_query_inspector\n                (osid.calendaring.EventQueryInspector): an event query\n                inspector\n", 
               "return_doc": "        return: (osid.calendaring.EventQuery) - the event query", 
               "error_doc": "        raise:  NullArgument - ``event_query_inspector`` is ``null``\n        raise:  Unsupported - ``event_query_inspector`` is not of this\n                service", 
               "sphinx_param_doc": "        :param event_query_inspector: an event query inspector\n        :type event_query_inspector: ``osid.calendaring.EventQueryInspector``\n", 
               "sphinx_return_doc": "        :return: the event query\n        :rtype: ``osid.calendaring.EventQuery``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``event_query_inspector`` is ``null``\n        :raise: ``Unsupported`` -- ``event_query_inspector`` is not of this service", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.calendaring.EventQueryInspector", 
                     "var_name": "event_query_inspector", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.calendaring.EventQueryInspector"
               ], 
               "return_type": "osid.calendaring.EventQuery", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.calendaring.RecurringEventLookupSession", 
         "shortname": "RecurringEventLookupSession", 
         "category": "sessions", 
         "doc": {
            "headline": "This session provides methods for retrieving ``RecurringEvent`` s.", 
            "body": ""
         }, 
         "inherit_fullnames": [
            "osid.OsidSession"
         ], 
         "inherit_shortnames": [
            "OsidSession"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidSession"
            }
         ], 
         "method_names": [
            "get_calendar_id", 
            "get_calendar", 
            "can_lookup_recurring_events", 
            "use_comparative_recurring_event_view", 
            "use_plenary_recurring_event_view", 
            "use_federated_calendar_view", 
            "use_isolated_calendar_view", 
            "use_active_recurring_event_view", 
            "use_any_status_recurring_event_view", 
            "use_sequestered_recurring_event_view", 
            "use_unsequestered_recurring_event_view", 
            "get_recurring_event", 
            "get_recurring_events_by_ids", 
            "get_recurring_events_by_genus_type", 
            "get_recurring_events_by_parent_genus_type", 
            "get_recurring_events_by_record_type", 
            "get_recurring_events_by_schedule_slot", 
            "get_recurring_events"
         ], 
         "methods": [
            {
               "name": "get_calendar_id", 
               "doc": {
                  "headline": "Gets the ``Calendar``  ``Id`` associated with this session.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.id.Id) - the ``Calendar Id`` associated with this\n                session", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the ``Calendar Id`` associated with this session\n        :rtype: ``osid.id.Id``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.id.Id", 
               "errors": {}
            }, 
            {
               "name": "get_calendar", 
               "doc": {
                  "headline": "Gets the ``Calendar`` associated with this session.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.Calendar) - the ``Calendar``\n                associated with this session", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the ``Calendar`` associated with this session\n        :rtype: ``osid.calendaring.Calendar``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.Calendar", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "can_lookup_recurring_events", 
               "doc": {
                  "headline": "Tests if this user can perform ``RecurringEvent`` lookups.", 
                  "body": "        A return of true does not guarantee successful authorization. A\n        return of false indicates that it is known all methods in this\n        session will result in a ``PermissionDenied``. This is intended\n        as a hint to an application that may opt not to offer lookup\n        operations to unauthorized users."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``false`` if lookup methods are not\n                authorized, ``true`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``false`` if lookup methods are not authorized, ``true`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "use_comparative_recurring_event_view", 
               "doc": {
                  "headline": "The returns from the lookup methods may omit or translate elements based on this session, such as authorization, and not result in an error.", 
                  "body": "        This view is used when greater interoperability is desired at\n        the expense of precision."
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "use_plenary_recurring_event_view", 
               "doc": {
                  "headline": "A complete view of the ``Event`` returns is desired.", 
                  "body": "        Methods will return what is requested or result in an error.\n        This view is used when greater precision is desired at the\n        expense of interoperability."
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "use_federated_calendar_view", 
               "doc": {
                  "headline": "Federates the view for methods in this session.", 
                  "body": "        A federated view will include recurring events in calendars\n        which are children of this calendar in the calendar hierarchy."
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "use_isolated_calendar_view", 
               "doc": {
                  "headline": "Isolates the view for methods in this session.", 
                  "body": "        An isolated view restricts lookups to this calendar only."
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "use_active_recurring_event_view", 
               "doc": {
                  "headline": "Only active recurring events are returned by methods in this session.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "use_any_status_recurring_event_view", 
               "doc": {
                  "headline": "All active and inactive recurring events are returned by methods in this session.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "use_sequestered_recurring_event_view", 
               "doc": {
                  "headline": "The returns from the lookup methods omit sequestered recurring events.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "use_unsequestered_recurring_event_view", 
               "doc": {
                  "headline": "All recurring events are returned including sequestered recurring events.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "get_recurring_event", 
               "doc": {
                  "headline": "Gets the ``RecurringEvent`` specified by its ``Id``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    recurring_event_id (osid.id.Id): ``Id`` of the\n                ``RecurringEvent``\n", 
               "return_doc": "        return: (osid.calendaring.RecurringEvent) - the recurring event", 
               "error_doc": "        raise:  NotFound - ``recurring_event_id`` not found\n        raise:  NullArgument - ``recurring_event_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param recurring_event_id: ``Id`` of the ``RecurringEvent``\n        :type recurring_event_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: the recurring event\n        :rtype: ``osid.calendaring.RecurringEvent``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``recurring_event_id`` not found\n        :raise: ``NullArgument`` -- ``recurring_event_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "recurring_event_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "osid.calendaring.RecurringEvent", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_recurring_events_by_ids", 
               "doc": {
                  "headline": "Gets a ``RecurringEventList`` corresponding to the given ``IdList``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    recurring_event_ids (osid.id.IdList): the list of\n                ``Ids`` to retrieve\n", 
               "return_doc": "        return: (osid.calendaring.RecurringEventList) - the returned\n                ``RecurringEvent`` list", 
               "error_doc": "        raise:  NotFound - an ``Id was`` not found\n        raise:  NullArgument - ``recurring_event_ids`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param recurring_event_ids: the list of ``Ids`` to retrieve\n        :type recurring_event_ids: ``osid.id.IdList``\n", 
               "sphinx_return_doc": "        :return: the returned ``RecurringEvent`` list\n        :rtype: ``osid.calendaring.RecurringEventList``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- an ``Id was`` not found\n        :raise: ``NullArgument`` -- ``recurring_event_ids`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.IdList", 
                     "var_name": "recurring_event_ids", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.IdList"
               ], 
               "return_type": "osid.calendaring.RecurringEventList", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_recurring_events_by_genus_type", 
               "doc": {
                  "headline": "Gets a ``RecurringEventList`` corresponding to the given recurring event genus ``Type`` which does not include recurring events of genus types derived from the specified ``Type``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    recurring_event_genus_type (osid.type.Type): a recurring\n                event genus type\n", 
               "return_doc": "        return: (osid.calendaring.RecurringEventList) - the returned\n                ``RecurringEvent`` list", 
               "error_doc": "        raise:  NullArgument - ``recurring_event_genus_type`` is\n                ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param recurring_event_genus_type: a recurring event genus type\n        :type recurring_event_genus_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "        :return: the returned ``RecurringEvent`` list\n        :rtype: ``osid.calendaring.RecurringEventList``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``recurring_event_genus_type`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "recurring_event_genus_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "osid.calendaring.RecurringEventList", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_recurring_events_by_parent_genus_type", 
               "doc": {
                  "headline": "Gets a ``RecurringEventList`` corresponding to the given recurring event genus ``Type`` and include any additional recurring event with genus types derived from the specified ``Type``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    recurring_event_genus_type (osid.type.Type): a recurring\n                event genus type\n", 
               "return_doc": "        return: (osid.calendaring.RecurringEventList) - the returned\n                ``RecurringEvent`` list", 
               "error_doc": "        raise:  NullArgument - ``recurring_event_genus_type`` is\n                ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param recurring_event_genus_type: a recurring event genus type\n        :type recurring_event_genus_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "        :return: the returned ``RecurringEvent`` list\n        :rtype: ``osid.calendaring.RecurringEventList``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``recurring_event_genus_type`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "recurring_event_genus_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "osid.calendaring.RecurringEventList", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_recurring_events_by_record_type", 
               "doc": {
                  "headline": "Gets a ``RecurringEventList`` containing the given recurring event record ``Type``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    recurring_event_record_type (osid.type.Type): a\n                recurring event record type\n", 
               "return_doc": "        return: (osid.calendaring.RecurringEventList) - the returned\n                ``RecurringEvent`` list", 
               "error_doc": "        raise:  NullArgument - ``recurring_event_record_type`` is\n                ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param recurring_event_record_type: a recurring event record type\n        :type recurring_event_record_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "        :return: the returned ``RecurringEvent`` list\n        :rtype: ``osid.calendaring.RecurringEventList``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``recurring_event_record_type`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "recurring_event_record_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "osid.calendaring.RecurringEventList", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_recurring_events_by_schedule_slot", 
               "doc": {
                  "headline": "Gets the ``RecurringEvents`` containing the given schedule slot.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    schedule_slot_id (osid.id.Id): a schedule slot ``Id``\n", 
               "return_doc": "        return: (osid.calendaring.RecurringEventList) - the returned\n                ``RecurringEvent`` list", 
               "error_doc": "        raise:  NullArgument - ``schedule_slot_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param schedule_slot_id: a schedule slot ``Id``\n        :type schedule_slot_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: the returned ``RecurringEvent`` list\n        :rtype: ``osid.calendaring.RecurringEventList``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``schedule_slot_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "schedule_slot_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "osid.calendaring.RecurringEventList", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_recurring_events", 
               "doc": {
                  "headline": "Gets all ``RecurringEvents``.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.RecurringEventList) - a\n                ``RecurringEventList``", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: a ``RecurringEventList``\n        :rtype: ``osid.calendaring.RecurringEventList``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.RecurringEventList", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.calendaring.RecurringEventUnravellingSession", 
         "shortname": "RecurringEventUnravellingSession", 
         "category": "sessions", 
         "doc": {
            "headline": "This session provides methods for retrieving and expanding ``RecurringEvent`` s.", 
            "body": ""
         }, 
         "inherit_fullnames": [
            "osid.OsidSession"
         ], 
         "inherit_shortnames": [
            "OsidSession"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidSession"
            }
         ], 
         "method_names": [
            "get_calendar_id", 
            "get_calendar", 
            "can_unravel_recurring_events", 
            "use_comparative_recurring_event_view", 
            "use_plenary_recurring_event_view", 
            "use_federated_calendar_view", 
            "use_isolated_calendar_view", 
            "get_recurring_event_by_event", 
            "get_recurring_events_by_events", 
            "expand_recurring_event", 
            "expand_recurring_event_in_date_range", 
            "expand_recurring_events", 
            "expand_recurring_events_in_date_range", 
            "get_recurring_events_by_date", 
            "get_recurring_events_in_date_range", 
            "get_number_of_events", 
            "get_number_of_events_in_date_range"
         ], 
         "methods": [
            {
               "name": "get_calendar_id", 
               "doc": {
                  "headline": "Gets the ``Calendar``  ``Id`` associated with this session.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.id.Id) - the ``Calendar Id`` associated with this\n                session", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the ``Calendar Id`` associated with this session\n        :rtype: ``osid.id.Id``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.id.Id", 
               "errors": {}
            }, 
            {
               "name": "get_calendar", 
               "doc": {
                  "headline": "Gets the ``Calendar`` associated with this session.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.Calendar) - the ``Calendar``\n                associated with this session", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the ``Calendar`` associated with this session\n        :rtype: ``osid.calendaring.Calendar``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.Calendar", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "can_unravel_recurring_events", 
               "doc": {
                  "headline": "Tests if this user can perform ``RecurringEvent`` lookups.", 
                  "body": "        A return of true does not guarantee successful authorization. A\n        return of false indicates that it is known all methods in this\n        session will result in a ``PermissionDenied``. This is intended\n        as a hint to an application that may opt not to offer lookup\n        operations to unauthorized users."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``false`` if lookup methods are not\n                authorized, ``true`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``false`` if lookup methods are not authorized, ``true`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "use_comparative_recurring_event_view", 
               "doc": {
                  "headline": "The returns from the lookup methods may omit or translate elements based on this session, such as authorization, and not result in an error.", 
                  "body": "        This view is used when greater interoperability is desired at\n        the expense of precision."
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "use_plenary_recurring_event_view", 
               "doc": {
                  "headline": "A complete view of the ``Event`` returns is desired.", 
                  "body": "        Methods will return what is requested or result in an error.\n        This view is used when greater precision is desired at the\n        expense of interoperability."
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "use_federated_calendar_view", 
               "doc": {
                  "headline": "Federates the view for methods in this session.", 
                  "body": "        A federated view will include events in calendars which are\n        children of this calendar in the calendar hierarchy."
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "use_isolated_calendar_view", 
               "doc": {
                  "headline": "Isolates the view for methods in this session.", 
                  "body": "        An isolated view restricts lookups to this calendar only."
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "get_recurring_event_by_event", 
               "doc": {
                  "headline": "Gets the recurring event where the given event ``Id`` was issued as part of the recurring series.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    event_id (osid.id.Id): ``an event _id``\n", 
               "return_doc": "        return: (osid.calendaring.RecurringEvent) - the returned\n                ``RecurringEvent``", 
               "error_doc": "        raise:  NotFound - ``event_id`` is not found\n        raise:  NullArgument - ``event_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param event_id: ``an event _id``\n        :type event_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: the returned ``RecurringEvent``\n        :rtype: ``osid.calendaring.RecurringEvent``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``event_id`` is not found\n        :raise: ``NullArgument`` -- ``event_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "event_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "osid.calendaring.RecurringEvent", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_recurring_events_by_events", 
               "doc": {
                  "headline": "Gets a ``RecurringEventList`` corresponding to the given event ``IdList`` where the events were implcitly created from the recurring series.", 
                  "body": "        In plenary mode, the returned list contains all of the recurring\n        events corresponding to the events in the ``Id`` list, in the\n        order of the list, including duplicates, or an error results if\n        an ``Id`` in the supplied list is not found or inaccessible.\n        Otherwise, inaccessible ``Events`` may be omitted from the list\n        and may present the elements in any order including returning a\n        unique set."
               }, 
               "arg_doc": "        arg:    event_ids (osid.id.IdList): the list of ``Ids`` to\n                retrieve\n", 
               "return_doc": "        return: (osid.calendaring.RecurringEventList) - the returned\n                ``RecurringEvent`` list", 
               "error_doc": "        raise:  NotFound - an ``Id was`` not found\n        raise:  NullArgument - ``event_ids`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param event_ids: the list of ``Ids`` to retrieve\n        :type event_ids: ``osid.id.IdList``\n", 
               "sphinx_return_doc": "        :return: the returned ``RecurringEvent`` list\n        :rtype: ``osid.calendaring.RecurringEventList``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- an ``Id was`` not found\n        :raise: ``NullArgument`` -- ``event_ids`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.IdList", 
                     "var_name": "event_ids", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.IdList"
               ], 
               "return_type": "osid.calendaring.RecurringEventList", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "expand_recurring_event", 
               "doc": {
                  "headline": "Expands the given recurring event into a series of non-recurring events.", 
                  "body": "        In plenary mode, the returned list contains all of the events in\n        the series, including duplicates, or an error results. In\n        comparative mode, events may be omitted from the list and may\n        present the elements in any order, including providing a unique\n        set."
               }, 
               "arg_doc": "        arg:    recurring_event_id (osid.id.Id): ``Id`` of the recurring\n                ``Event``\n", 
               "return_doc": "        return: (osid.calendaring.EventList) - the returned ``Event\n                list``", 
               "error_doc": "        raise:  NotFound - ``recurring_event_id was`` not found\n        raise:  NullArgument - ``recurring_event_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param recurring_event_id: ``Id`` of the recurring ``Event``\n        :type recurring_event_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: the returned ``Event list``\n        :rtype: ``osid.calendaring.EventList``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``recurring_event_id was`` not found\n        :raise: ``NullArgument`` -- ``recurring_event_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "recurring_event_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "osid.calendaring.EventList", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "expand_recurring_event_in_date_range", 
               "doc": {
                  "headline": "Expands the given recurring event into a series of non-recurring events that fall within the given date range inclusive.", 
                  "body": "        In plenary mode, the returned list contains all of the events in\n        the series, including duplicates, or an error results. In\n        comparative mode, events may be omitted from the list and may\n        present the elements in any order, including providing a unique\n        set."
               }, 
               "arg_doc": "        arg:    recurring_event_id (osid.id.Id): ``Id`` of the recurring\n                ``Event``\n        arg:    from (osid.calendaring.DateTime): start date\n        arg:    to (osid.calendaring.DateTime): end date\n", 
               "return_doc": "        return: (osid.calendaring.EventList) - the returned ``Event\n                list``", 
               "error_doc": "        raise:  InvalidArgument - ``to`` is less than ``from``\n        raise:  NotFound - ``recurring_event_id was`` not found\n        raise:  NullArgument - ``recurring_event_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param recurring_event_id: ``Id`` of the recurring ``Event``\n        :type recurring_event_id: ``osid.id.Id``\n        :param from: start date\n        :type from: ``osid.calendaring.DateTime``\n        :param to: end date\n        :type to: ``osid.calendaring.DateTime``\n", 
               "sphinx_return_doc": "        :return: the returned ``Event list``\n        :rtype: ``osid.calendaring.EventList``", 
               "sphinx_error_doc": "        :raise: ``InvalidArgument`` -- ``to`` is less than ``from``\n        :raise: ``NotFound`` -- ``recurring_event_id was`` not found\n        :raise: ``NullArgument`` -- ``recurring_event_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "recurring_event_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.calendaring.DateTime", 
                     "var_name": "from_", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.calendaring.DateTime", 
                     "var_name": "to", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "osid.calendaring.DateTime", 
                  "osid.calendaring.DateTime"
               ], 
               "return_type": "osid.calendaring.EventList", 
               "errors": {
                  "INVALID_ARGUMENT": "ConsumerContract", 
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "expand_recurring_events", 
               "doc": {
                  "headline": "Expands the given recurring events into a series of non- recurring events.", 
                  "body": "        In plenary mode, the returned list contains all of the events in\n        the series, including duplicates, or an error results. In\n        comparative mode, events may be omitted from the list and may\n        present the elements in any order, including providing a unique\n        set."
               }, 
               "arg_doc": "        arg:    recurring_event_ids (osid.id.IdList): the list of\n                ``Ids`` to expand\n", 
               "return_doc": "        return: (osid.calendaring.EventList) - the returned ``Event\n                list``", 
               "error_doc": "        raise:  NotFound - an ``Id was`` not found\n        raise:  NullArgument - ``recurring_event_ids`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param recurring_event_ids: the list of ``Ids`` to expand\n        :type recurring_event_ids: ``osid.id.IdList``\n", 
               "sphinx_return_doc": "        :return: the returned ``Event list``\n        :rtype: ``osid.calendaring.EventList``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- an ``Id was`` not found\n        :raise: ``NullArgument`` -- ``recurring_event_ids`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.IdList", 
                     "var_name": "recurring_event_ids", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.IdList"
               ], 
               "return_type": "osid.calendaring.EventList", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "expand_recurring_events_in_date_range", 
               "doc": {
                  "headline": "Expands the given recurring events into a series of non- recurring events that fall within the given date range inclusive.", 
                  "body": "        In plenary mode, the returned list contains all of the events in\n        the series, including duplicates, or an error results. In\n        comparative mode, events may be omitted from the list and may\n        present the elements in any order, including providing a unique\n        set."
               }, 
               "arg_doc": "        arg:    recurring_event_ids (osid.id.Id): the list of ``Ids`` to\n                expand\n        arg:    from (osid.calendaring.DateTime): start date\n        arg:    to (osid.calendaring.DateTime): end date\n", 
               "return_doc": "        return: (osid.calendaring.EventList) - the returned ``Event\n                list``", 
               "error_doc": "        raise:  InvalidArgument - ``to`` is less than ``from``\n        raise:  NotFound - an ``Id was`` not found\n        raise:  NullArgument - ``recurring_event_ids`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param recurring_event_ids: the list of ``Ids`` to expand\n        :type recurring_event_ids: ``osid.id.Id``\n        :param from: start date\n        :type from: ``osid.calendaring.DateTime``\n        :param to: end date\n        :type to: ``osid.calendaring.DateTime``\n", 
               "sphinx_return_doc": "        :return: the returned ``Event list``\n        :rtype: ``osid.calendaring.EventList``", 
               "sphinx_error_doc": "        :raise: ``InvalidArgument`` -- ``to`` is less than ``from``\n        :raise: ``NotFound`` -- an ``Id was`` not found\n        :raise: ``NullArgument`` -- ``recurring_event_ids`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "recurring_event_ids", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.calendaring.DateTime", 
                     "var_name": "from_", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.calendaring.DateTime", 
                     "var_name": "to", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "osid.calendaring.DateTime", 
                  "osid.calendaring.DateTime"
               ], 
               "return_type": "osid.calendaring.EventList", 
               "errors": {
                  "INVALID_ARGUMENT": "ConsumerContract", 
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_recurring_events_by_date", 
               "doc": {
                  "headline": "Gets a list of recurring events where the given date falls within the span of a recurring event.", 
                  "body": "        In plenary mode, the returned list contains all known events or\n        an error results. Otherwise, the returned list may contain only\n        those events that are accessible through this session. In both\n        cases, the order of the set is not specified."
               }, 
               "arg_doc": "        arg:    datetime (osid.calendaring.DateTime): a date\n", 
               "return_doc": "        return: (osid.calendaring.RecurringEventList) - the returned\n                ``RecurringEvent`` list", 
               "error_doc": "        raise:  NullArgument - ``datetime`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param datetime: a date\n        :type datetime: ``osid.calendaring.DateTime``\n", 
               "sphinx_return_doc": "        :return: the returned ``RecurringEvent`` list\n        :rtype: ``osid.calendaring.RecurringEventList``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``datetime`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.calendaring.DateTime", 
                     "var_name": "datetime", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.calendaring.DateTime"
               ], 
               "return_type": "osid.calendaring.RecurringEventList", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_recurring_events_in_date_range", 
               "doc": {
                  "headline": "Gets a ``RecurringEventList`` whose series falls entirely within the given range inclusive ````.", 
                  "body": "        In plenary mode, the returned list contains all known recurring\n        events or an error results. Otherwise, the returned list may\n        contain only those recurring events that are accessible through\n        this session. In both cases, the order of the set is not\n        specified."
               }, 
               "arg_doc": "        arg:    from (osid.calendaring.DateTime): start date\n        arg:    to (osid.calendaring.DateTime): end date\n", 
               "return_doc": "        return: (osid.calendaring.RecurringEventList) - the returned\n                ``RecurringEvent`` list", 
               "error_doc": "        raise:  InvalidArgument - ``to`` is less than ``from``\n        raise:  NullArgument - ``from`` or ``to`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param from: start date\n        :type from: ``osid.calendaring.DateTime``\n        :param to: end date\n        :type to: ``osid.calendaring.DateTime``\n", 
               "sphinx_return_doc": "        :return: the returned ``RecurringEvent`` list\n        :rtype: ``osid.calendaring.RecurringEventList``", 
               "sphinx_error_doc": "        :raise: ``InvalidArgument`` -- ``to`` is less than ``from``\n        :raise: ``NullArgument`` -- ``from`` or ``to`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.calendaring.DateTime", 
                     "var_name": "from_", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.calendaring.DateTime", 
                     "var_name": "to", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.calendaring.DateTime", 
                  "osid.calendaring.DateTime"
               ], 
               "return_type": "osid.calendaring.RecurringEventList", 
               "errors": {
                  "INVALID_ARGUMENT": "ConsumerContract", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_number_of_events", 
               "doc": {
                  "headline": "Gets the number of events in the recurring series.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    recurring_event_id (osid.id.Id): ``Id`` of the recurring\n                ``Event``\n", 
               "return_doc": "        return: (cardinal) - the number of meeting times", 
               "error_doc": "        raise:  NotFound - ``recurring_event_id was`` not found\n        raise:  NullArgument - ``recurring_event_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param recurring_event_id: ``Id`` of the recurring ``Event``\n        :type recurring_event_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: the number of meeting times\n        :rtype: ``cardinal``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``recurring_event_id was`` not found\n        :raise: ``NullArgument`` -- ``recurring_event_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "recurring_event_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "cardinal", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_number_of_events_in_date_range", 
               "doc": {
                  "headline": "Gets the number of events in the recurring series between the given dates inclusive.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    recurring_event_id (osid.id.Id): ``Id`` of the recurring\n                ``Event``\n        arg:    from (osid.calendaring.DateTime): start date\n        arg:    to (osid.calendaring.DateTime): end date\n", 
               "return_doc": "        return: (cardinal) - the number of meeting times", 
               "error_doc": "        raise:  InvalidArgument - ``to`` is less than ``from``\n        raise:  NotFound - ``recurring_event_id was`` not found\n        raise:  NullArgument - ``recurring_event_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param recurring_event_id: ``Id`` of the recurring ``Event``\n        :type recurring_event_id: ``osid.id.Id``\n        :param from: start date\n        :type from: ``osid.calendaring.DateTime``\n        :param to: end date\n        :type to: ``osid.calendaring.DateTime``\n", 
               "sphinx_return_doc": "        :return: the number of meeting times\n        :rtype: ``cardinal``", 
               "sphinx_error_doc": "        :raise: ``InvalidArgument`` -- ``to`` is less than ``from``\n        :raise: ``NotFound`` -- ``recurring_event_id was`` not found\n        :raise: ``NullArgument`` -- ``recurring_event_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "recurring_event_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.calendaring.DateTime", 
                     "var_name": "from_", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.calendaring.DateTime", 
                     "var_name": "to", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "osid.calendaring.DateTime", 
                  "osid.calendaring.DateTime"
               ], 
               "return_type": "cardinal", 
               "errors": {
                  "INVALID_ARGUMENT": "ConsumerContract", 
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.calendaring.RecurringEventQuerySession", 
         "shortname": "RecurringEventQuerySession", 
         "category": "sessions", 
         "doc": {
            "headline": "This session provides methods for searching ``RecurringEvent`` objects.", 
            "body": "    The search query is constructed using the ``RecurringEventQuery``.\n    The recurring event record ``Type`` also specifies the record for\n    the recurring event query.\n\n    This session defines views that offer differing behaviors for\n    searching.\n    \n      * federated calendar view: searches include recurring events in\n        calendars of which this calendar is an ancestor in the calendar\n        hierarchy\n      * isolated calendar view: searches are restricted to recurring\n        events in this calendar\n\n    \n    ``RecurringEvents`` may have a query record indicated by their\n    respective record types. The query ecord is accessed via the\n    ``RecurringEventQuery``."
         }, 
         "inherit_fullnames": [
            "osid.OsidSession"
         ], 
         "inherit_shortnames": [
            "OsidSession"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidSession"
            }
         ], 
         "method_names": [
            "get_calendar_id", 
            "get_calendar", 
            "can_search_recurring_events", 
            "use_federated_calendar_view", 
            "use_isolated_calendar_view", 
            "get_recurring_event_query", 
            "get_recurring_events_by_query"
         ], 
         "methods": [
            {
               "name": "get_calendar_id", 
               "doc": {
                  "headline": "Gets the ``Calendar``  ``Id`` associated with this session.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.id.Id) - the ``Calendar Id`` associated with this\n                session", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the ``Calendar Id`` associated with this session\n        :rtype: ``osid.id.Id``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.id.Id", 
               "errors": {}
            }, 
            {
               "name": "get_calendar", 
               "doc": {
                  "headline": "Gets the ``Calendar`` associated with this session.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.Calendar) - the ``Calendar``\n                associated with this session", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the ``Calendar`` associated with this session\n        :rtype: ``osid.calendaring.Calendar``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.Calendar", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "can_search_recurring_events", 
               "doc": {
                  "headline": "Tests if this user can perform ``RecurringEvents`` searches.", 
                  "body": "        A return of true does not guarantee successful authorization. A\n        return of false indicates that it is known all methods in this\n        session will result in a ``PermissionDenied``. This is intended\n        as a hint to an application that may opt not to offer search\n        operations to unauthorized users."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``false`` if search methods are not\n                authorized, ``true`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``false`` if search methods are not authorized, ``true`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "use_federated_calendar_view", 
               "doc": {
                  "headline": "Federates the view for methods in this session.", 
                  "body": "        A federated view will include recurring events in calendars\n        which are children of this calendar in the calendar hierarchy."
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "use_isolated_calendar_view", 
               "doc": {
                  "headline": "Isolates the view for methods in this session.", 
                  "body": "        An isolated view restricts searches to this calendar only."
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "get_recurring_event_query", 
               "doc": {
                  "headline": "Gets a recurring event query.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.RecurringEventQuery) - the recurring\n                event query", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the recurring event query\n        :rtype: ``osid.calendaring.RecurringEventQuery``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.RecurringEventQuery", 
               "errors": {}
            }, 
            {
               "name": "get_recurring_events_by_query", 
               "doc": {
                  "headline": "Gets a list of ``RecurringEvents`` matching the given recurring event query.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    recurring_event_query\n                (osid.calendaring.RecurringEventQuery): the recurring\n                event query\n", 
               "return_doc": "        return: (osid.calendaring.RecurringEventList) - the returned\n                ``RecurringEventList``", 
               "error_doc": "        raise:  NullArgument - ``recurring_event_query`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        raise:  Unsupported - ``recurring_event_query`` is not of this\n                service", 
               "sphinx_param_doc": "        :param recurring_event_query: the recurring event query\n        :type recurring_event_query: ``osid.calendaring.RecurringEventQuery``\n", 
               "sphinx_return_doc": "        :return: the returned ``RecurringEventList``\n        :rtype: ``osid.calendaring.RecurringEventList``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``recurring_event_query`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure\n        :raise: ``Unsupported`` -- ``recurring_event_query`` is not of this service", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.calendaring.RecurringEventQuery", 
                     "var_name": "recurring_event_query", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.calendaring.RecurringEventQuery"
               ], 
               "return_type": "osid.calendaring.RecurringEventList", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.calendaring.RecurringEventSearchSession", 
         "shortname": "RecurringEventSearchSession", 
         "category": "sessions", 
         "doc": {
            "headline": "This session provides methods for searching ``RecurringEvent`` objects.", 
            "body": "    The search query is constructed using the ``RecurringEventQuery``.\n    The recurring event record ``Type`` also specifies the record for\n    the recurring event query.\n\n    ``get_recurring_events_by_query()`` is the basic search method and\n    returns a list of ``RecurringEvents``. A more advanced search may be\n    performed with ``geRecurringEventsBySearch()``. It accepts a\n    ``RecurringEventSearch`` in addition to the query for the purpose of\n    specifying additional options affecting the entire search, such as\n    ordering. ``get_recurring_events_by_search()`` returns a\n    ``RecurringEventSearchResults`` that can be used to access the\n    resulting ``RecurringEventList`` or be used to perform a search\n    within the result set through ``RecurringEventSearch``.\n    \n    This session defines views that offer differing behaviors for\n    searching.\n    \n      * federated calendar view: searches include recurring events in\n        calendars of which this calendar is a ancestor in the calendar\n        hierarchy\n      * isolated calendar view: searches are restricted to recurring\n        events in this calendar\n\n    \n    Recurring events may have a query record indicated by their\n    respective record types. The query record is accessed via the\n    ``RecurringEventQuery``."
         }, 
         "inherit_fullnames": [
            "osid.calendaring.RecurringEventQuerySession"
         ], 
         "inherit_shortnames": [
            "RecurringEventQuerySession"
         ], 
         "inherit_pkg_names": [
            "calendaring"
         ], 
         "inheritance": [
            {
               "pkg_name": "calendaring", 
               "name": "RecurringEventQuerySession"
            }
         ], 
         "method_names": [
            "get_recurring_event_search", 
            "get_recurring_event_search_order", 
            "get_recurring_events_by_search", 
            "get_recurring_event_query_from_inspector"
         ], 
         "methods": [
            {
               "name": "get_recurring_event_search", 
               "doc": {
                  "headline": "Gets a recurring event search.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.RecurringEventSearch) - the recurring\n                event search", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the recurring event search\n        :rtype: ``osid.calendaring.RecurringEventSearch``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.RecurringEventSearch", 
               "errors": {}
            }, 
            {
               "name": "get_recurring_event_search_order", 
               "doc": {
                  "headline": "Gets a recurring event search order.", 
                  "body": "        The ``RecurringEventSearchOrder`` is supplied to a\n        ``RecurringEventSearch`` to specify the ordering of results."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.RecurringEventSearchOrder) - the\n                recurring event search order", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the recurring event search order\n        :rtype: ``osid.calendaring.RecurringEventSearchOrder``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.RecurringEventSearchOrder", 
               "errors": {}
            }, 
            {
               "name": "get_recurring_events_by_search", 
               "doc": {
                  "headline": "Gets the search results matching the given search query using the given search.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    recurring_event_query\n                (osid.calendaring.RecurringEventQuery): the recurring\n                event search query\n        arg:    recurring_event_search\n                (osid.calendaring.RecurringEventSearch): the recurring\n                event search\n", 
               "return_doc": "        return: (osid.calendaring.RecurringEventSearchResults) - the\n                recurring event search results", 
               "error_doc": "        raise:  NullArgument - ``recurring_event_query`` or\n                ``recurring_event_search`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        raise:  Unsupported - ``recurring_event_search`` or\n                ``recurring_event_query`` is not of this service", 
               "sphinx_param_doc": "        :param recurring_event_query: the recurring event search query\n        :type recurring_event_query: ``osid.calendaring.RecurringEventQuery``\n        :param recurring_event_search: the recurring event search\n        :type recurring_event_search: ``osid.calendaring.RecurringEventSearch``\n", 
               "sphinx_return_doc": "        :return: the recurring event search results\n        :rtype: ``osid.calendaring.RecurringEventSearchResults``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``recurring_event_query`` or ``recurring_event_search`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure\n        :raise: ``Unsupported`` -- ``recurring_event_search`` or ``recurring_event_query`` is not of this service", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.calendaring.RecurringEventQuery", 
                     "var_name": "recurring_event_query", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.calendaring.RecurringEventSearch", 
                     "var_name": "recurring_event_search", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.calendaring.RecurringEventQuery", 
                  "osid.calendaring.RecurringEventSearch"
               ], 
               "return_type": "osid.calendaring.RecurringEventSearchResults", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_recurring_event_query_from_inspector", 
               "doc": {
                  "headline": "Gets a recurring event query from an inspector.", 
                  "body": "        The inspector is available from a\n        ``RecurringEventSearchResults``."
               }, 
               "arg_doc": "        arg:    recurring_event_query_inspector\n                (osid.calendaring.RecurringEventQueryInspector): a\n                recurring event query inspector\n", 
               "return_doc": "        return: (osid.calendaring.RecurringEventQuery) - the recurring\n                event query", 
               "error_doc": "        raise:  NullArgument - ``recurring_event_query_inspector`` is\n                ``null``\n        raise:  Unsupported - ``recurring_event_query_inspector`` is not\n                of this service", 
               "sphinx_param_doc": "        :param recurring_event_query_inspector: a recurring event query inspector\n        :type recurring_event_query_inspector: ``osid.calendaring.RecurringEventQueryInspector``\n", 
               "sphinx_return_doc": "        :return: the recurring event query\n        :rtype: ``osid.calendaring.RecurringEventQuery``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``recurring_event_query_inspector`` is ``null``\n        :raise: ``Unsupported`` -- ``recurring_event_query_inspector`` is not of this service", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.calendaring.RecurringEventQueryInspector", 
                     "var_name": "recurring_event_query_inspector", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.calendaring.RecurringEventQueryInspector"
               ], 
               "return_type": "osid.calendaring.RecurringEventQuery", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.calendaring.RecurringEventAdminSession", 
         "shortname": "RecurringEventAdminSession", 
         "category": "sessions", 
         "doc": {
            "headline": "This session creates, updates, and deletes ``RecurringEvents``.", 
            "body": "    The data for create and update is provided by the consumer via the\n    form object. ``OsidForms`` are requested for each create or update\n    and may not be reused.\n\n    Create and update operations differ in their usage. To create a\n    ``RecurringEvent,`` a ``RecurringEventForm`` is requested using\n    ``get_recurring_event_form_for_create()`` specifying the desired\n    relationship peers and record ``Types`` or none if no record\n    ``Types`` are needed. The returned ``RecurringEventForm`` will\n    indicate that it is to be used with a create operation and can be\n    used to examine metdata or validate data prior to creation. Once the\n    ``RecurringEventForm`` is submiited to a create operation, it cannot\n    be reused with another create operation unless the first operation\n    was unsuccessful. Each ``RecurringEventForm`` corresponds to an\n    attempted transaction.\n    \n    For updates, ``RecurringEventForms`` are requested to the\n    ``RecurringEvent``  ``Id`` that is to be updated using\n    ``getRecurringEventFormForUpdate()``. Similarly, the\n    ``RecurringEventForm`` has metadata about the data that can be\n    updated and it can perform validation before submitting the update.\n    The ``RecurringEventForm`` can only be used once for a successful\n    update and cannot be reused.\n    \n    The delete operations delete ``Recurring Events``. To unmap a\n    ``RecurringEvent`` from the current ``Calendar,`` the\n    ``RecurringEventCalendarAssignmentSession`` should be used. These\n    delete operations attempt to remove the ``Event`` itself thus\n    removing it from all known ``Calendar`` catalogs.\n    \n    This session includes an ``Id`` aliasing mechanism to assign an\n    external ``Id`` to an internally assigned Id."
         }, 
         "inherit_fullnames": [
            "osid.OsidSession"
         ], 
         "inherit_shortnames": [
            "OsidSession"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidSession"
            }
         ], 
         "method_names": [
            "get_calendar_id", 
            "get_calendar", 
            "can_create_recurring_events", 
            "can_create_recurring_event_with_record_types", 
            "get_recurring_event_form_for_create", 
            "create_recurring_event", 
            "can_update_recurring_events", 
            "get_recurring_event_form_for_update", 
            "update_recurring_event", 
            "can_delete_recurring_events", 
            "delete_recurring_event", 
            "can_manage_recurring_event_aliases", 
            "alias_recurring_event", 
            "can_schedule_recurring_events", 
            "add_schedule", 
            "remove_schedule", 
            "add_specific_date", 
            "add_specific_date_with_location", 
            "clear_specific_dates", 
            "add_event", 
            "remove_event", 
            "add_blackout", 
            "clear_blackout"
         ], 
         "methods": [
            {
               "name": "get_calendar_id", 
               "doc": {
                  "headline": "Gets the ``Calendar``  ``Id`` associated with this session.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.id.Id) - the ``Calendar Id`` associated with this\n                session", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the ``Calendar Id`` associated with this session\n        :rtype: ``osid.id.Id``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.id.Id", 
               "errors": {}
            }, 
            {
               "name": "get_calendar", 
               "doc": {
                  "headline": "Gets the ``Calendar`` associated with this session.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.Calendar) - the ``Calendar``\n                associated with this session", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the ``Calendar`` associated with this session\n        :rtype: ``osid.calendaring.Calendar``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.Calendar", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "can_create_recurring_events", 
               "doc": {
                  "headline": "Tests if this user can create ``RecurringEvents``.", 
                  "body": "        A return of true does not guarantee successful authorization. A\n        return of false indicates that it is known creating a\n        ``RecurringEvent`` will result in a ``PermissionDenied``. This\n        is intended as a hint to an application that may opt not to\n        offer create operations to an unauthorized user."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``false`` if ``RecurringEvent`` creation is\n                not authorized, ``true`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``false`` if ``RecurringEvent`` creation is not authorized, ``true`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "can_create_recurring_event_with_record_types", 
               "doc": {
                  "headline": "Tests if this user can create a single ``RecurringEvent`` using the desired record types.", 
                  "body": "        While ``CalendaringManager.getRecurringEventRecordTypes()`` can\n        be used to examine which records are supported, this method\n        tests which record(s) are required for creating a specific\n        ``RecurringEvent``. Providing an empty array tests if a\n        ``RecurringEvent`` can be created with no records."
               }, 
               "arg_doc": "        arg:    recurring_event_record_types (osid.type.Type[]): array\n                of recurring event types\n", 
               "return_doc": "        return: (boolean) - ``true`` if ``RecurringEvent`` creation\n                using the specified record ``Types`` is supported,\n                ``false`` otherwise", 
               "error_doc": "        raise:  NullArgument - ``recurring_event_record_types`` is\n                ``null``", 
               "sphinx_param_doc": "        :param recurring_event_record_types: array of recurring event types\n        :type recurring_event_record_types: ``osid.type.Type[]``\n", 
               "sphinx_return_doc": "        :return: ``true`` if ``RecurringEvent`` creation using the specified record ``Types`` is supported, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``recurring_event_record_types`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type[]", 
                     "var_name": "recurring_event_record_types", 
                     "array": true
                  }
               ], 
               "arg_types": [
                  "osid.type.Type[]"
               ], 
               "return_type": "boolean", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "get_recurring_event_form_for_create", 
               "doc": {
                  "headline": "Gets the recurring event form for creating new recurring events.", 
                  "body": "        A new form should be requested for each create transaction."
               }, 
               "arg_doc": "        arg:    recurring_event_record_types (osid.type.Type[]): array\n                of recurring event types\n", 
               "return_doc": "        return: (osid.calendaring.RecurringEventForm) - the recurring\n                event form", 
               "error_doc": "        raise:  NullArgument - ``recurring_event_record_types`` is\n                ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        raise:  Unsupported - unable to get form for requested record\n                types", 
               "sphinx_param_doc": "        :param recurring_event_record_types: array of recurring event types\n        :type recurring_event_record_types: ``osid.type.Type[]``\n", 
               "sphinx_return_doc": "        :return: the recurring event form\n        :rtype: ``osid.calendaring.RecurringEventForm``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``recurring_event_record_types`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure\n        :raise: ``Unsupported`` -- unable to get form for requested record types", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type[]", 
                     "var_name": "recurring_event_record_types", 
                     "array": true
                  }
               ], 
               "arg_types": [
                  "osid.type.Type[]"
               ], 
               "return_type": "osid.calendaring.RecurringEventForm", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }, 
            {
               "name": "create_recurring_event", 
               "doc": {
                  "headline": "Creates a new ``RecurringEvent``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    recurring_event_form\n                (osid.calendaring.RecurringEventForm): the form for this\n                ``RecurringEvent``\n", 
               "return_doc": "        return: (osid.calendaring.RecurringEvent) - the new\n                ``RecurringEvent``", 
               "error_doc": "        raise:  IllegalState - ``recurring_event_form`` already used in\n                a create transaction\n        raise:  InvalidArgument - one or more of the form elements is\n                invalid\n        raise:  NullArgument - ``recurring_event_form`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        raise:  Unsupported - ``recurring_event_form`` did not originate\n                in a create transaction", 
               "sphinx_param_doc": "        :param recurring_event_form: the form for this ``RecurringEvent``\n        :type recurring_event_form: ``osid.calendaring.RecurringEventForm``\n", 
               "sphinx_return_doc": "        :return: the new ``RecurringEvent``\n        :rtype: ``osid.calendaring.RecurringEvent``", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- ``recurring_event_form`` already used in a create transaction\n        :raise: ``InvalidArgument`` -- one or more of the form elements is invalid\n        :raise: ``NullArgument`` -- ``recurring_event_form`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure\n        :raise: ``Unsupported`` -- ``recurring_event_form`` did not originate in a create transaction", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.calendaring.RecurringEventForm", 
                     "var_name": "recurring_event_form", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.calendaring.RecurringEventForm"
               ], 
               "return_type": "osid.calendaring.RecurringEvent", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract", 
                  "INVALID_ARGUMENT": "ConsumerContract", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }, 
            {
               "name": "can_update_recurring_events", 
               "doc": {
                  "headline": "Tests if this user can update ``RecurringEvents``.", 
                  "body": "        A return of true does not guarantee successful authorization. A\n        return of false indicates that it is known updating a\n        ``RecurringEvent`` will result in a ``PermissionDenied``. This\n        is intended as a hint to an application that may opt not to\n        offer update operations to an unauthorized user."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``false`` if recurring event modification is\n                not authorized, ``true`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``false`` if recurring event modification is not authorized, ``true`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "get_recurring_event_form_for_update", 
               "doc": {
                  "headline": "Gets the recurring event form for updating an existing recurring event.", 
                  "body": "        A new recurring event form should be requested for each update\n        transaction."
               }, 
               "arg_doc": "        arg:    recurring_event_id (osid.id.Id): the ``Id`` of the\n                ``RecurringEvent``\n", 
               "return_doc": "        return: (osid.calendaring.RecurringEventForm) - the recurring\n                event form", 
               "error_doc": "        raise:  NotFound - ``recurring_event_id`` is not found\n        raise:  NullArgument - ``recurring_event_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param recurring_event_id: the ``Id`` of the ``RecurringEvent``\n        :type recurring_event_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: the recurring event form\n        :rtype: ``osid.calendaring.RecurringEventForm``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``recurring_event_id`` is not found\n        :raise: ``NullArgument`` -- ``recurring_event_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "recurring_event_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "osid.calendaring.RecurringEventForm", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "update_recurring_event", 
               "doc": {
                  "headline": "Updates an existing recurring event.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    recurring_event_form\n                (osid.calendaring.RecurringEventForm): the form\n                containing the elements to be updated\n", 
               "return_doc": "", 
               "error_doc": "        raise:  IllegalState - ``recurring_event_form`` already used in\n                an update transaction\n        raise:  InvalidArgument - the form contains an invalid value\n        raise:  NullArgument - ``recurring_event_form`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        raise:  Unsupported - ``recurring_event_form`` did not originate\n                in an update transaction", 
               "sphinx_param_doc": "        :param recurring_event_form: the form containing the elements to be updated\n        :type recurring_event_form: ``osid.calendaring.RecurringEventForm``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- ``recurring_event_form`` already used in an update transaction\n        :raise: ``InvalidArgument`` -- the form contains an invalid value\n        :raise: ``NullArgument`` -- ``recurring_event_form`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure\n        :raise: ``Unsupported`` -- ``recurring_event_form`` did not originate in an update transaction", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.calendaring.RecurringEventForm", 
                     "var_name": "recurring_event_form", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.calendaring.RecurringEventForm"
               ], 
               "return_type": "", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract", 
                  "INVALID_ARGUMENT": "ConsumerContract", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }, 
            {
               "name": "can_delete_recurring_events", 
               "doc": {
                  "headline": "Tests if this user can delete ``RecurringEvents``.", 
                  "body": "        A return of true does not guarantee successful authorization. A\n        return of false indicates that it is known deleting a\n        ``RecurringEvent`` will result in a ``PermissionDenied``. This\n        is intended as a hint to an application that may opt not to\n        offer delete operations to an unauthorized user."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``false`` if ``RecurringEvent`` deletion is\n                not authorized, ``true`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``false`` if ``RecurringEvent`` deletion is not authorized, ``true`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "delete_recurring_event", 
               "doc": {
                  "headline": "Deletes the ``RecurringEvent`` identified by the given ``Id``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    recurring_event_id (osid.id.Id): the ``Id`` of the\n                ``RecurringEvent`` to delete\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NotFound - a ``RecurringEvent`` was not found identified\n                by the given ``Id``\n        raise:  NullArgument - ``recurring_event_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param recurring_event_id: the ``Id`` of the ``RecurringEvent`` to delete\n        :type recurring_event_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- a ``RecurringEvent`` was not found identified by the given ``Id``\n        :raise: ``NullArgument`` -- ``recurring_event_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "recurring_event_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "can_manage_recurring_event_aliases", 
               "doc": {
                  "headline": "Tests if this user can manage ``Id`` aliases for ``RecurringEvents``.", 
                  "body": "        A return of true does not guarantee successful authorization. A\n        return of false indicates that it is known changing an alias\n        will result in a ``PermissionDenied``. This is intended as a\n        hint to an application that may opt not to offer alias\n        operations to an unauthorized user."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``false`` if ``RecurringEvent`` aliasing is\n                not authorized, ``true`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``false`` if ``RecurringEvent`` aliasing is not authorized, ``true`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "alias_recurring_event", 
               "doc": {
                  "headline": "Adds an ``Id`` to a ``RecurringEvent`` for the purpose of creating compatibility.", 
                  "body": "        The primary ``Id`` of the ``RecurringEvent`` is determined by\n        the provider. The new ``Id`` performs as an alias to the primary\n        ``Id``. If the alias is a pointer to another recurring event, it\n        is reassigned to the given recurring event ``Id``."
               }, 
               "arg_doc": "        arg:    recurring_event_id (osid.id.Id): the ``Id`` of a\n                ``RecurringEvent``\n        arg:    alias_id (osid.id.Id): the alias ``Id``\n", 
               "return_doc": "", 
               "error_doc": "        raise:  AlreadyExists - ``alias_id`` is already assigned\n        raise:  NotFound - ``recurring_event_id`` not found\n        raise:  NullArgument - ``recurring_event_id`` or ``alias_id`` is\n                ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param recurring_event_id: the ``Id`` of a ``RecurringEvent``\n        :type recurring_event_id: ``osid.id.Id``\n        :param alias_id: the alias ``Id``\n        :type alias_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``AlreadyExists`` -- ``alias_id`` is already assigned\n        :raise: ``NotFound`` -- ``recurring_event_id`` not found\n        :raise: ``NullArgument`` -- ``recurring_event_id`` or ``alias_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "recurring_event_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "alias_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {
                  "ALREADY_EXISTS": "User", 
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "can_schedule_recurring_events", 
               "doc": {
                  "headline": "Tests if this user can schedule recurring events.", 
                  "body": "        A return of true does not guarantee successful authorization. A\n        return of false indicates that it is known recurring event\n        methods in this session will result in a ``PermissionDenied``.\n        This is intended as a hint to an application that may opt not to\n        offer create operations to an unauthorized user."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``false`` if recurring event scheduling is\n                not authorized, ``true`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``false`` if recurring event scheduling is not authorized, ``true`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "add_schedule", 
               "doc": {
                  "headline": "Adds a schedule to the given recurring event.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    recurring_event_id (osid.id.Id): a recurring event\n                ``Id``\n        arg:    schedule_id (osid.id.Id): a schedule ``Id``\n", 
               "return_doc": "        return: (osid.id.Id) - the ``Id`` of the schedule", 
               "error_doc": "        raise:  AlreadyExists - schedule is already part of recurring\n                event\n        raise:  NotFound - ``recurring_event_id`` or ``schedule_id`` is\n                not found\n        raise:  NullArgument - ``recurring_event_id`` or ``schedule_id``\n                is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param recurring_event_id: a recurring event ``Id``\n        :type recurring_event_id: ``osid.id.Id``\n        :param schedule_id: a schedule ``Id``\n        :type schedule_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: the ``Id`` of the schedule\n        :rtype: ``osid.id.Id``", 
               "sphinx_error_doc": "        :raise: ``AlreadyExists`` -- schedule is already part of recurring event\n        :raise: ``NotFound`` -- ``recurring_event_id`` or ``schedule_id`` is not found\n        :raise: ``NullArgument`` -- ``recurring_event_id`` or ``schedule_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "recurring_event_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "schedule_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "osid.id.Id"
               ], 
               "return_type": "osid.id.Id", 
               "errors": {
                  "ALREADY_EXISTS": "User", 
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "remove_schedule", 
               "doc": {
                  "headline": "Removes a schedule from a given recurring event.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    recurring_event_id (osid.id.Id): a recurring event\n                ``Id``\n        arg:    schedule_id (osid.id.Id): the schedule ``Id``\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NotFound - schedule not part of recurring event\n        raise:  NullArgument - ``recurring_event_id`` or ``schedule_id``\n                is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param recurring_event_id: a recurring event ``Id``\n        :type recurring_event_id: ``osid.id.Id``\n        :param schedule_id: the schedule ``Id``\n        :type schedule_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- schedule not part of recurring event\n        :raise: ``NullArgument`` -- ``recurring_event_id`` or ``schedule_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "recurring_event_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "schedule_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "add_specific_date", 
               "doc": {
                  "headline": "Adds a specific date to the given recurring event.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    recurring_event_id (osid.id.Id): a recurring event\n                ``Id``\n        arg:    date (osid.calendaring.DateTime): a date\n        arg:    location_description (osid.locale.DisplayText): location\n                description\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NotFound - ``recurring_event_id`` is not found\n        raise:  NullArgument - ``recurring_event_id, date`` , or\n                ``location_description`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param recurring_event_id: a recurring event ``Id``\n        :type recurring_event_id: ``osid.id.Id``\n        :param date: a date\n        :type date: ``osid.calendaring.DateTime``\n        :param location_description: location description\n        :type location_description: ``osid.locale.DisplayText``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``recurring_event_id`` is not found\n        :raise: ``NullArgument`` -- ``recurring_event_id, date`` , or ``location_description`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "recurring_event_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.calendaring.DateTime", 
                     "var_name": "date", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.locale.DisplayText", 
                     "var_name": "location_description", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "osid.calendaring.DateTime", 
                  "osid.locale.DisplayText"
               ], 
               "return_type": "", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "add_specific_date_with_location", 
               "doc": {
                  "headline": "Adds a specific date to the given recurring event.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    recurring_event_id (osid.id.Id): a recurring event\n                ``Id``\n        arg:    date (osid.calendaring.DateTime): a date\n        arg:    location_id (osid.id.Id): a location\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NotFound - ``recurring_event_id`` or ``location_id`` is\n                not found\n        raise:  NullArgument - ``recurring_event_id, date`` , or\n                ``location_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param recurring_event_id: a recurring event ``Id``\n        :type recurring_event_id: ``osid.id.Id``\n        :param date: a date\n        :type date: ``osid.calendaring.DateTime``\n        :param location_id: a location\n        :type location_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``recurring_event_id`` or ``location_id`` is not found\n        :raise: ``NullArgument`` -- ``recurring_event_id, date`` , or ``location_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "recurring_event_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.calendaring.DateTime", 
                     "var_name": "date", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "location_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "osid.calendaring.DateTime", 
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "clear_specific_dates", 
               "doc": {
                  "headline": "Clears any specific dates between the given dates inclusive.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    recurring_event_id (osid.id.Id): a recurring event\n                ``Id``\n        arg:    from (osid.calendaring.DateTime): start date inclusive\n        arg:    to (osid.calendaring.DateTime): end date inclusive\n", 
               "return_doc": "", 
               "error_doc": "        raise:  InvalidArgument - ``from`` is greater than ``to``\n        raise:  NotFound - ``recurring_event_id`` is not found\n        raise:  NullArgument - ``recurring_event_id, from`` or ``to`` is\n                ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param recurring_event_id: a recurring event ``Id``\n        :type recurring_event_id: ``osid.id.Id``\n        :param from: start date inclusive\n        :type from: ``osid.calendaring.DateTime``\n        :param to: end date inclusive\n        :type to: ``osid.calendaring.DateTime``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``InvalidArgument`` -- ``from`` is greater than ``to``\n        :raise: ``NotFound`` -- ``recurring_event_id`` is not found\n        :raise: ``NullArgument`` -- ``recurring_event_id, from`` or ``to`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "recurring_event_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.calendaring.DateTime", 
                     "var_name": "from_", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.calendaring.DateTime", 
                     "var_name": "to", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "osid.calendaring.DateTime", 
                  "osid.calendaring.DateTime"
               ], 
               "return_type": "", 
               "errors": {
                  "INVALID_ARGUMENT": "ConsumerContract", 
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "add_event", 
               "doc": {
                  "headline": "Adds another event as part of this recurring event.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    recurring_event_id (osid.id.Id): a recurring event\n                ``Id``\n        arg:    event_id (osid.id.Id): an event ``Id``\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NotFound - ``recurring_event_id`` or ``event_id`` is not\n                found\n        raise:  NullArgument - ``recurring_event_id`` or ``event_id`` is\n                ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param recurring_event_id: a recurring event ``Id``\n        :type recurring_event_id: ``osid.id.Id``\n        :param event_id: an event ``Id``\n        :type event_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``recurring_event_id`` or ``event_id`` is not found\n        :raise: ``NullArgument`` -- ``recurring_event_id`` or ``event_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "recurring_event_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "event_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "remove_event", 
               "doc": {
                  "headline": "Removes an event as part of this recurring event.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    recurring_event_id (osid.id.Id): a recurring event\n                ``Id``\n        arg:    event_id (osid.id.Id): an event ``Id``\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NotFound - ``recurring_event_id`` or ``event_id`` is not\n                found or ``event_id`` not part of ``recurring_event_id``\n        raise:  NullArgument - ``recurring_event_id`` or ``event_id`` is\n                ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param recurring_event_id: a recurring event ``Id``\n        :type recurring_event_id: ``osid.id.Id``\n        :param event_id: an event ``Id``\n        :type event_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``recurring_event_id`` or ``event_id`` is not found or ``event_id`` not part of ``recurring_event_id``\n        :raise: ``NullArgument`` -- ``recurring_event_id`` or ``event_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "recurring_event_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "event_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "add_blackout", 
               "doc": {
                  "headline": "Adds a blackout to the given recurring event that blocks events in the series.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    recurring_event_id (osid.id.Id): a recurring event\n                ``Id``\n        arg:    from (osid.calendaring.DateTime): start date inclusive\n        arg:    to (osid.calendaring.DateTime): end date inclusive\n", 
               "return_doc": "", 
               "error_doc": "        raise:  InvalidArgument - ``from`` is greater than ``to``\n        raise:  NotFound - ``recurring_event_id`` is not found\n        raise:  NullArgument - ``recurring_event_id, from`` or ``to`` is\n                ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param recurring_event_id: a recurring event ``Id``\n        :type recurring_event_id: ``osid.id.Id``\n        :param from: start date inclusive\n        :type from: ``osid.calendaring.DateTime``\n        :param to: end date inclusive\n        :type to: ``osid.calendaring.DateTime``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``InvalidArgument`` -- ``from`` is greater than ``to``\n        :raise: ``NotFound`` -- ``recurring_event_id`` is not found\n        :raise: ``NullArgument`` -- ``recurring_event_id, from`` or ``to`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "recurring_event_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.calendaring.DateTime", 
                     "var_name": "from_", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.calendaring.DateTime", 
                     "var_name": "to", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "osid.calendaring.DateTime", 
                  "osid.calendaring.DateTime"
               ], 
               "return_type": "", 
               "errors": {
                  "INVALID_ARGUMENT": "ConsumerContract", 
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "clear_blackout", 
               "doc": {
                  "headline": "Clears any blackouts between the given dates inclusive.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    recurring_event_id (osid.id.Id): a recurring event\n                ``Id``\n        arg:    from (osid.calendaring.DateTime): start date inclusive\n        arg:    to (osid.calendaring.DateTime): end date inclusive\n", 
               "return_doc": "", 
               "error_doc": "        raise:  InvalidArgument - ``from`` is greater than ``to``\n        raise:  NotFound - ``recurring_event_id`` is not found\n        raise:  NullArgument - ``recurring_event_id, from`` or ``to`` is\n                ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param recurring_event_id: a recurring event ``Id``\n        :type recurring_event_id: ``osid.id.Id``\n        :param from: start date inclusive\n        :type from: ``osid.calendaring.DateTime``\n        :param to: end date inclusive\n        :type to: ``osid.calendaring.DateTime``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``InvalidArgument`` -- ``from`` is greater than ``to``\n        :raise: ``NotFound`` -- ``recurring_event_id`` is not found\n        :raise: ``NullArgument`` -- ``recurring_event_id, from`` or ``to`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "recurring_event_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.calendaring.DateTime", 
                     "var_name": "from_", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.calendaring.DateTime", 
                     "var_name": "to", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "osid.calendaring.DateTime", 
                  "osid.calendaring.DateTime"
               ], 
               "return_type": "", 
               "errors": {
                  "INVALID_ARGUMENT": "ConsumerContract", 
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.calendaring.RecurringEventNotificationSession", 
         "shortname": "RecurringEventNotificationSession", 
         "category": "sessions", 
         "doc": {
            "headline": "This session defines methods to receive asynchronous notifications on adds/changes to ``RecurringEvent`` objects.", 
            "body": "    This session is intended for consumers needing to synchronize their\n    state with this service without the use of polling. Notifications\n    are cancelled when this session is closed.\n\n    The views defined in this session correspond to the views in the\n    ``RecurringEventLookupSession``."
         }, 
         "inherit_fullnames": [
            "osid.OsidSession"
         ], 
         "inherit_shortnames": [
            "OsidSession"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidSession"
            }
         ], 
         "method_names": [
            "get_calendar_id", 
            "get_calendar", 
            "can_register_for_recurring_event_notifications", 
            "use_federated_calendar_view", 
            "use_isolated_calendar_view", 
            "register_for_new_recurring_events", 
            "register_for_changed_recurring_events", 
            "register_for_changed_recurring_event", 
            "register_for_deleted_recurring_events", 
            "register_for_deleted_recurring_event"
         ], 
         "methods": [
            {
               "name": "get_calendar_id", 
               "doc": {
                  "headline": "Gets the ``Calendar``  ``Id`` associated with this session.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.id.Id) - the ``Calendar Id`` associated with this\n                session", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the ``Calendar Id`` associated with this session\n        :rtype: ``osid.id.Id``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.id.Id", 
               "errors": {}
            }, 
            {
               "name": "get_calendar", 
               "doc": {
                  "headline": "Gets the ``Calendar`` associated with this session.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.Calendar) - the ``Calendar``\n                associated with this session", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the ``Calendar`` associated with this session\n        :rtype: ``osid.calendaring.Calendar``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.Calendar", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "can_register_for_recurring_event_notifications", 
               "doc": {
                  "headline": "Tests if this user can register for ``RecurringEvent`` notifications.", 
                  "body": "        A return of true does not guarantee successful authorization. A\n        return of false indicates that it is known all methods in this\n        session will result in a ``PermissionDenied``. This is intended\n        as a hint to an application that may opt not to offer\n        notification operations."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``false`` if notification methods are not\n                authorized, ``true`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``false`` if notification methods are not authorized, ``true`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "use_federated_calendar_view", 
               "doc": {
                  "headline": "Federates the view for methods in this session.", 
                  "body": "        A federated view will include notifications for events in\n        calendars which are children of this calendar in the calendar\n        hierarchy."
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "use_isolated_calendar_view", 
               "doc": {
                  "headline": "Isolates the view for methods in this session.", 
                  "body": "        An isolated view restricts notifications to this calendar only."
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "register_for_new_recurring_events", 
               "doc": {
                  "headline": "Register for notifications of new recurring events.", 
                  "body": "        ``RecurringEventReceiver.newRecurringEvent()`` is invoked when a\n        new recurring event is created."
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "register_for_changed_recurring_events", 
               "doc": {
                  "headline": "Registers for notification of updated recurring events.", 
                  "body": "        ``RecurringEventReceiver.changedRecurringEvent()`` is invoked\n        when a recurring event is changed."
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "register_for_changed_recurring_event", 
               "doc": {
                  "headline": "Registers for notification of an updated recurring event.", 
                  "body": "        ``RecurringEventReceiver.changedRecurringEvent()`` is invoked\n        when the specified recurring event is changed."
               }, 
               "arg_doc": "        arg:    recurring_event_id (osid.id.Id): the ``Id`` of the\n                ``RecurringEvent`` to monitor\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``recurring_event_id is null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param recurring_event_id: the ``Id`` of the ``RecurringEvent`` to monitor\n        :type recurring_event_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``recurring_event_id is null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "recurring_event_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "register_for_deleted_recurring_events", 
               "doc": {
                  "headline": "Registers for notification of deleted recurring events.", 
                  "body": "        ``RecurringEventReceiver.deletedRecurringEvent()`` is invoked\n        when a recurring event is removed from this calendar."
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "register_for_deleted_recurring_event", 
               "doc": {
                  "headline": "Registers for notification of a deleted recurring event.", 
                  "body": "        ``RecurringEventReceiver.changedRecurringEvent()`` is invoked\n        when the specified recurring event is removed from this\n        calendar."
               }, 
               "arg_doc": "        arg:    recurring_event_id (osid.id.Id): the ``Id`` of the\n                ``RecurringEvent`` to monitor\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``recurring_event_id is null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param recurring_event_id: the ``Id`` of the ``RecurringEvent`` to monitor\n        :type recurring_event_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``recurring_event_id is null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "recurring_event_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.calendaring.RecurringEventCalendarSession", 
         "shortname": "RecurringEventCalendarSession", 
         "category": "sessions", 
         "doc": {
            "headline": "This session provides methods to retrieve ``RecurringEvent`` to ``Calendar`` mappings.", 
            "body": "    A ``RecurringEvent`` may appear in multiple ``Calendars``. Each\n    ``Calendar`` may have its own authorizations governing who is\n    allowed to look at it.\n\n    This lookup session defines two views:\n    \n      * comparative view: elements may be silently omitted or re-ordered\n      * plenary view: provides a complete result set or is an error\n        condition\n      * normalized event view: a single recurring event is used to\n        represent a series of events\n      * denormalized view: recurring events are expanded into individual\n        events\n"
         }, 
         "inherit_fullnames": [
            "osid.OsidSession"
         ], 
         "inherit_shortnames": [
            "OsidSession"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidSession"
            }
         ], 
         "method_names": [
            "can_lookup_recurring_event_calendar_mappings", 
            "use_comparative_calendar_view", 
            "use_plenary_calendar_view", 
            "get_recurring_event_ids_by_calendar", 
            "get_recurring_events_by_calendar", 
            "get_recurring_event_ids_by_calendars", 
            "get_recurring_events_by_calendars", 
            "get_calendar_ids_by_recurring_event", 
            "get_calendars_by_recurring_event"
         ], 
         "methods": [
            {
               "name": "can_lookup_recurring_event_calendar_mappings", 
               "doc": {
                  "headline": "Tests if this user can perform lookups of recurring event/calendar mappings.", 
                  "body": "        A return of true does not guarantee successful authorization. A\n        return of false indicates that it is known lookup methods in\n        this session will result in a ``PermissionDenied``. This is\n        intended as a hint to an application that may opt not to offer\n        lookup operations to unauthorized users."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``false`` if looking up mappings is not\n                authorized, ``true`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``false`` if looking up mappings is not authorized, ``true`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "use_comparative_calendar_view", 
               "doc": {
                  "headline": "The returns from the lookup methods may omit or translate elements based on this session, such as authorization, and not result in an error.", 
                  "body": "        This view is used when greater interoperability is desired at\n        the expense of precision."
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "use_plenary_calendar_view", 
               "doc": {
                  "headline": "A complete view of the ``Event`` and ``Calendar`` returns is desired.", 
                  "body": "        Methods will return what is requested or result in an error.\n        This view is used when greater precision is desired at the\n        expense of interoperability."
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "get_recurring_event_ids_by_calendar", 
               "doc": {
                  "headline": "Gets the list of ``RecurringEvent``  ``Ids`` associated with a ``Calendar``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    calendar_id (osid.id.Id): ``Id`` of the ``Calendar``\n", 
               "return_doc": "        return: (osid.id.IdList) - list of related recurring event\n                ``Ids``", 
               "error_doc": "        raise:  NotFound - ``calendar_id`` is not found\n        raise:  NullArgument - ``calendar_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param calendar_id: ``Id`` of the ``Calendar``\n        :type calendar_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: list of related recurring event ``Ids``\n        :rtype: ``osid.id.IdList``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``calendar_id`` is not found\n        :raise: ``NullArgument`` -- ``calendar_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "calendar_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "osid.id.IdList", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_recurring_events_by_calendar", 
               "doc": {
                  "headline": "Gets the list of ``RecurringEvents`` associated with a ``Calendar``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    calendar_id (osid.id.Id): ``Id`` of the ``Calendar``\n", 
               "return_doc": "        return: (osid.calendaring.RecurringEventList) - list of related\n                recurring events", 
               "error_doc": "        raise:  NotFound - ``calendar_id`` is not found\n        raise:  NullArgument - ``calendar_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param calendar_id: ``Id`` of the ``Calendar``\n        :type calendar_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: list of related recurring events\n        :rtype: ``osid.calendaring.RecurringEventList``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``calendar_id`` is not found\n        :raise: ``NullArgument`` -- ``calendar_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "calendar_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "osid.calendaring.RecurringEventList", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_recurring_event_ids_by_calendars", 
               "doc": {
                  "headline": "Gets the list of ``RecurringEvent Ids`` corresponding to a list of ``Calendars``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    calendar_ids (osid.id.IdList): list of calendar ``Ids``\n", 
               "return_doc": "        return: (osid.id.IdList) - list of recurring event ``Ids``", 
               "error_doc": "        raise:  NullArgument - ``calendar_ids`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param calendar_ids: list of calendar ``Ids``\n        :type calendar_ids: ``osid.id.IdList``\n", 
               "sphinx_return_doc": "        :return: list of recurring event ``Ids``\n        :rtype: ``osid.id.IdList``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``calendar_ids`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.IdList", 
                     "var_name": "calendar_ids", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.IdList"
               ], 
               "return_type": "osid.id.IdList", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_recurring_events_by_calendars", 
               "doc": {
                  "headline": "Gets the list of ``RecurringEvents`` corresponding to a list of ``Calendars``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    calendar_ids (osid.id.IdList): list of calendar ``Ids``\n", 
               "return_doc": "        return: (osid.calendaring.RecurringEventList) - list of\n                recurring events", 
               "error_doc": "        raise:  NullArgument - ``calendar_ids`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param calendar_ids: list of calendar ``Ids``\n        :type calendar_ids: ``osid.id.IdList``\n", 
               "sphinx_return_doc": "        :return: list of recurring events\n        :rtype: ``osid.calendaring.RecurringEventList``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``calendar_ids`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.IdList", 
                     "var_name": "calendar_ids", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.IdList"
               ], 
               "return_type": "osid.calendaring.RecurringEventList", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_calendar_ids_by_recurring_event", 
               "doc": {
                  "headline": "Gets the list of ``Calendar``  ``Ids`` mapped to a ``RecurringEvent``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    recurring_event_id (osid.id.Id): ``Id`` of a\n                ``RecurringEvent``\n", 
               "return_doc": "        return: (osid.id.IdList) - list of calendar ``Ids``", 
               "error_doc": "        raise:  NotFound - ``recurring_event_id`` is not found\n        raise:  NullArgument - ``recurring_event_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param recurring_event_id: ``Id`` of a ``RecurringEvent``\n        :type recurring_event_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: list of calendar ``Ids``\n        :rtype: ``osid.id.IdList``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``recurring_event_id`` is not found\n        :raise: ``NullArgument`` -- ``recurring_event_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "recurring_event_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "osid.id.IdList", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_calendars_by_recurring_event", 
               "doc": {
                  "headline": "Gets the list of ``Calendars`` mapped to a ``RecurringEvent``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    recurring_event_id (osid.id.Id): ``Id`` of a\n                ``RecurringEvent``\n", 
               "return_doc": "        return: (osid.calendaring.CalendarList) - list of calendar", 
               "error_doc": "        raise:  NotFound - ``recurring_event_id`` is not found\n        raise:  NullArgument - ``recurring_event_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param recurring_event_id: ``Id`` of a ``RecurringEvent``\n        :type recurring_event_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: list of calendar\n        :rtype: ``osid.calendaring.CalendarList``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``recurring_event_id`` is not found\n        :raise: ``NullArgument`` -- ``recurring_event_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "recurring_event_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "osid.calendaring.CalendarList", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.calendaring.RecurringEventCalendarAssignmentSession", 
         "shortname": "RecurringEventCalendarAssignmentSession", 
         "category": "sessions", 
         "doc": {
            "headline": "This session provides methods to re-assign ``RecurringEvents`` to ``Calendars``.", 
            "body": "    A ``RecurringEvent`` may map to multiple ``Calendars`` and removing\n    the last reference to a ``RecurringEvent`` is the equivalent of\n    deleting it. Each ``Calendar`` may have its own authorizations\n    governing who is allowed to operate on it.\n\n    Moving or adding a reference of a ``RecurringEvent`` to another\n    ``Calendar`` is not a copy operation (eg: does not change its ``Id``\n    )."
         }, 
         "inherit_fullnames": [
            "osid.OsidSession"
         ], 
         "inherit_shortnames": [
            "OsidSession"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidSession"
            }
         ], 
         "method_names": [
            "can_assign_recurring_events", 
            "can_assign_recurring_events_to_calendar", 
            "get_assignable_calendar_ids", 
            "get_assignable_calendar_ids_for_recurring_event", 
            "assign_recurring_event_to_calendar", 
            "unassign_recurring_event_from_calendar"
         ], 
         "methods": [
            {
               "name": "can_assign_recurring_events", 
               "doc": {
                  "headline": "Tests if this user can alter recurring event/calendar mappings.", 
                  "body": "        A return of true does not guarantee successful authorization. A\n        return of false indicates that it is known mapping methods in\n        this session will result in a ``PermissionDenied``. This is\n        intended as a hint to an application that may opt not to offer\n        assignment operations to unauthorized users."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``false`` if mapping is not authorized,\n                ``true`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``false`` if mapping is not authorized, ``true`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "can_assign_recurring_events_to_calendar", 
               "doc": {
                  "headline": "Tests if this user can alter recurring event/calendar mappings.", 
                  "body": "        A return of true does not guarantee successful authorization. A\n        return of false indicates that it is known mapping methods in\n        this session will result in a ``PermissionDenied``. This is\n        intended as a hint to an application that may opt not to offer\n        assignment operations to unauthorized users."
               }, 
               "arg_doc": "        arg:    calendar_id (osid.id.Id): the ``Id`` of the ``Calendar``\n", 
               "return_doc": "        return: (boolean) - ``false`` if mapping is not authorized,\n                ``true`` otherwise", 
               "error_doc": "        raise:  NullArgument - ``calendar_id`` is ``null``", 
               "sphinx_param_doc": "        :param calendar_id: the ``Id`` of the ``Calendar``\n        :type calendar_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: ``false`` if mapping is not authorized, ``true`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``calendar_id`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "calendar_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "boolean", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "get_assignable_calendar_ids", 
               "doc": {
                  "headline": "Gets a list of calendars including and under the given calendar node in which any recurring event can be assigned.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    calendar_id (osid.id.Id): the ``Id`` of the ``Calendar``\n", 
               "return_doc": "        return: (osid.id.IdList) - list of assignable calendar ``Ids``", 
               "error_doc": "        raise:  NullArgument - ``calendar_id`` is ``null``\n        raise:  OperationFailed - unable to complete request", 
               "sphinx_param_doc": "        :param calendar_id: the ``Id`` of the ``Calendar``\n        :type calendar_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: list of assignable calendar ``Ids``\n        :rtype: ``osid.id.IdList``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``calendar_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "calendar_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "osid.id.IdList", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational"
               }
            }, 
            {
               "name": "get_assignable_calendar_ids_for_recurring_event", 
               "doc": {
                  "headline": "Gets a list of calendars including and under the given calendar node in which a specific recurring event can be assigned.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    calendar_id (osid.id.Id): the ``Id`` of the ``Calendar``\n        arg:    recurring_event_id (osid.id.Id): the ``Id`` of the\n                ``recurring_event_id``\n", 
               "return_doc": "        return: (osid.id.IdList) - list of assignable calendar ``Ids``", 
               "error_doc": "        raise:  NullArgument - ``calendar_id`` or ``recurring_event_id``\n                is ``null``\n        raise:  OperationFailed - unable to complete request", 
               "sphinx_param_doc": "        :param calendar_id: the ``Id`` of the ``Calendar``\n        :type calendar_id: ``osid.id.Id``\n        :param recurring_event_id: the ``Id`` of the ``recurring_event_id``\n        :type recurring_event_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: list of assignable calendar ``Ids``\n        :rtype: ``osid.id.IdList``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``calendar_id`` or ``recurring_event_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "calendar_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "recurring_event_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "osid.id.Id"
               ], 
               "return_type": "osid.id.IdList", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational"
               }
            }, 
            {
               "name": "assign_recurring_event_to_calendar", 
               "doc": {
                  "headline": "Adds an existing ``RecurringEvent`` to a ``Calendar``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    recurring_event_id (osid.id.Id): the ``Id`` of the\n                ``RecurringEvent``\n        arg:    calendar_id (osid.id.Id): the ``Id`` of the ``Calendar``\n", 
               "return_doc": "", 
               "error_doc": "        raise:  AlreadyExists - ``recurring_event_id`` is already\n                assigned to ``calendar_id``\n        raise:  NotFound - ``recurring_event_id`` or ``calendar_id`` not\n                found\n        raise:  NullArgument - ``recurring_event_id`` or ``calendar_id``\n                is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param recurring_event_id: the ``Id`` of the ``RecurringEvent``\n        :type recurring_event_id: ``osid.id.Id``\n        :param calendar_id: the ``Id`` of the ``Calendar``\n        :type calendar_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``AlreadyExists`` -- ``recurring_event_id`` is already assigned to ``calendar_id``\n        :raise: ``NotFound`` -- ``recurring_event_id`` or ``calendar_id`` not found\n        :raise: ``NullArgument`` -- ``recurring_event_id`` or ``calendar_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "recurring_event_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "calendar_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {
                  "ALREADY_EXISTS": "User", 
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "unassign_recurring_event_from_calendar", 
               "doc": {
                  "headline": "Removes a ``RecurringEvent`` from a ``Calendar``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    recurring_event_id (osid.id.Id): the ``Id`` of the\n                ``RecurringEvent``\n        arg:    calendar_id (osid.id.Id): the ``Id`` of the ``Calendar``\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NotFound - ``recurring_event_id`` or ``calendar_id`` not\n                found or ``recurring_event_id`` not assigned to\n                ``calendar_id``\n        raise:  NullArgument - ``recurring_event_id`` or ``calendar_id``\n                is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param recurring_event_id: the ``Id`` of the ``RecurringEvent``\n        :type recurring_event_id: ``osid.id.Id``\n        :param calendar_id: the ``Id`` of the ``Calendar``\n        :type calendar_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``recurring_event_id`` or ``calendar_id`` not found or ``recurring_event_id`` not assigned to ``calendar_id``\n        :raise: ``NullArgument`` -- ``recurring_event_id`` or ``calendar_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "recurring_event_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "calendar_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.calendaring.RecurringEventSmartCalendarSession", 
         "shortname": "RecurringEventSmartCalendarSession", 
         "category": "sessions", 
         "doc": {
            "headline": "This session manages queries and sequencing to create \"smart\" dynamic catalogs.", 
            "body": "    A ``RecurringEventQuery`` can be retrieved from this session and\n    mapped to this ``Calendar`` to create a virtual collection of\n    ``RecurringEvents``. The entries may be sequenced using the\n    ``RecurringEventSearchOrder`` from this session.\n\n    This ``Calendar`` has a default query that matches any recurring\n    event and a default search order that specifies no sequencing. The\n    queries may be examined using a ``RecurringEventQueryInspector``.\n    The query may be modified by converting the inspector back to a\n    ``RecurringEventQuery``."
         }, 
         "inherit_fullnames": [
            "osid.OsidSession"
         ], 
         "inherit_shortnames": [
            "OsidSession"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidSession"
            }
         ], 
         "method_names": [
            "get_calendar_id", 
            "get_calendar", 
            "can_manage_smart_calendars", 
            "get_recurring_event_query", 
            "get_recurring_event_search_order", 
            "apply_recurring_event_query", 
            "inspect_recurring_event_query", 
            "apply_recurring_event_sequencing", 
            "get_recurring_event_query_from_inspector"
         ], 
         "methods": [
            {
               "name": "get_calendar_id", 
               "doc": {
                  "headline": "Gets the ``Calendar``  ``Id`` associated with this session.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.id.Id) - the ``Calendar Id`` associated with this\n                session", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the ``Calendar Id`` associated with this session\n        :rtype: ``osid.id.Id``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.id.Id", 
               "errors": {}
            }, 
            {
               "name": "get_calendar", 
               "doc": {
                  "headline": "Gets the ``Calendar`` associated with this session.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.Calendar) - the ``Calendar``\n                associated with this session", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the ``Calendar`` associated with this session\n        :rtype: ``osid.calendaring.Calendar``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.Calendar", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "can_manage_smart_calendars", 
               "doc": {
                  "headline": "Tests if this user can manage smart calendars.", 
                  "body": "        A return of true does not guarantee successful authorization. A\n        return of false indicates that it is known all methods in this\n        session will result in a ``PermissionDenied``. This is intended\n        as a hint to an application that may opt not to offer smart\n        operations."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``false`` if smart calendar methods are not\n                authorized, ``true`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``false`` if smart calendar methods are not authorized, ``true`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "get_recurring_event_query", 
               "doc": {
                  "headline": "Gets a recurring event query.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.RecurringEventQuery) - the recurring\n                event query", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the recurring event query\n        :rtype: ``osid.calendaring.RecurringEventQuery``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.RecurringEventQuery", 
               "errors": {}
            }, 
            {
               "name": "get_recurring_event_search_order", 
               "doc": {
                  "headline": "Gets a recurring event search order.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.RecurringEventSearchOrder) - the\n                recurring event search order", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the recurring event search order\n        :rtype: ``osid.calendaring.RecurringEventSearchOrder``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.RecurringEventSearchOrder", 
               "errors": {}
            }, 
            {
               "name": "apply_recurring_event_query", 
               "doc": {
                  "headline": "Applies a recurring event query to this calendar.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    recurring_event_query\n                (osid.calendaring.RecurringEventQuery): the recurring\n                event query\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``recurring_event_query`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure occurred\n        raise:  Unsupported - ``recurring_event_query`` not of this\n                service", 
               "sphinx_param_doc": "        :param recurring_event_query: the recurring event query\n        :type recurring_event_query: ``osid.calendaring.RecurringEventQuery``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``recurring_event_query`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure occurred\n        :raise: ``Unsupported`` -- ``recurring_event_query`` not of this service", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.calendaring.RecurringEventQuery", 
                     "var_name": "recurring_event_query", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.calendaring.RecurringEventQuery"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }, 
            {
               "name": "inspect_recurring_event_query", 
               "doc": {
                  "headline": "Gets a recurring event query inspector for this calendar.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.RecurringEventQueryInspector) - the\n                recruring event query inspector", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure occurred", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the recruring event query inspector\n        :rtype: ``osid.calendaring.RecurringEventQueryInspector``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure occurred", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.RecurringEventQueryInspector", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "apply_recurring_event_sequencing", 
               "doc": {
                  "headline": "Applies a recurring event search order to this calendar.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    recurring_event_search_order\n                (osid.calendaring.RecurringEventSearchOrder): the\n                recurring event search order\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``recurring_event_search_order`` is\n                ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure occurred\n        raise:  Unsupported - ``recurring_event_search_order`` not of\n                this service", 
               "sphinx_param_doc": "        :param recurring_event_search_order: the recurring event search order\n        :type recurring_event_search_order: ``osid.calendaring.RecurringEventSearchOrder``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``recurring_event_search_order`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure occurred\n        :raise: ``Unsupported`` -- ``recurring_event_search_order`` not of this service", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.calendaring.RecurringEventSearchOrder", 
                     "var_name": "recurring_event_search_order", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.calendaring.RecurringEventSearchOrder"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_recurring_event_query_from_inspector", 
               "doc": {
                  "headline": "Gets a recurring event query from an inspector.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    recurring_event_query_inspector\n                (osid.calendaring.RecurringEventQueryInspector): a\n                recurring event query inspector\n", 
               "return_doc": "        return: (osid.calendaring.RecurringEventQuery) - the recurring\n                event query", 
               "error_doc": "        raise:  NullArgument - ``recruring_event_query_inspector`` is\n                ``null``\n        raise:  Unsupported - ``recurring_event_query_inspector`` is not\n                of this service", 
               "sphinx_param_doc": "        :param recurring_event_query_inspector: a recurring event query inspector\n        :type recurring_event_query_inspector: ``osid.calendaring.RecurringEventQueryInspector``\n", 
               "sphinx_return_doc": "        :return: the recurring event query\n        :rtype: ``osid.calendaring.RecurringEventQuery``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``recruring_event_query_inspector`` is ``null``\n        :raise: ``Unsupported`` -- ``recurring_event_query_inspector`` is not of this service", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.calendaring.RecurringEventQueryInspector", 
                     "var_name": "recurring_event_query_inspector", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.calendaring.RecurringEventQueryInspector"
               ], 
               "return_type": "osid.calendaring.RecurringEventQuery", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.calendaring.SupersedingEventLookupSession", 
         "shortname": "SupersedingEventLookupSession", 
         "category": "sessions", 
         "doc": {
            "headline": "This session provides methods for retrieving ``SupersedingEvents``.", 
            "body": ""
         }, 
         "inherit_fullnames": [
            "osid.OsidSession"
         ], 
         "inherit_shortnames": [
            "OsidSession"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidSession"
            }
         ], 
         "method_names": [
            "get_calendar_id", 
            "get_calendar", 
            "can_lookup_superseding_events", 
            "use_comparative_superseding_event_view", 
            "use_plenary_superseding_event_view", 
            "use_federated_calendar_view", 
            "use_isolated_calendar_view", 
            "use_active_superseding_event_view", 
            "use_any_status_superseding_event_view", 
            "get_superseding_event", 
            "get_superseding_events_by_ids", 
            "get_superseding_events_by_genus_type", 
            "get_superseding_events_by_parent_genus_type", 
            "get_superseding_events_by_record_type", 
            "get_superseding_events_by_superseded_event", 
            "get_superseding_events"
         ], 
         "methods": [
            {
               "name": "get_calendar_id", 
               "doc": {
                  "headline": "Gets the ``Calendar``  ``Id`` associated with this session.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.id.Id) - the ``Calendar Id`` associated with this\n                session", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the ``Calendar Id`` associated with this session\n        :rtype: ``osid.id.Id``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.id.Id", 
               "errors": {}
            }, 
            {
               "name": "get_calendar", 
               "doc": {
                  "headline": "Gets the ``Calendar`` associated with this session.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.Calendar) - the ``Calendar``\n                associated with this session", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the ``Calendar`` associated with this session\n        :rtype: ``osid.calendaring.Calendar``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.Calendar", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "can_lookup_superseding_events", 
               "doc": {
                  "headline": "Tests if this user can perform ``SupersedingEvent`` lookups.", 
                  "body": "        A return of true does not guarantee successful authorization. A\n        return of false indicates that it is known all methods in this\n        session will result in a ``PermissionDenied``. This is intended\n        as a hint to an application that may opt not to offer lookup\n        operations to unauthorized users."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``false`` if lookup methods are not\n                authorized, ``true`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``false`` if lookup methods are not authorized, ``true`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "use_comparative_superseding_event_view", 
               "doc": {
                  "headline": "The returns from the lookup methods may omit or translate elements based on this session, such as authorization, and not result in an error.", 
                  "body": "        This view is used when greater interoperability is desired at\n        the expense of precision."
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "use_plenary_superseding_event_view", 
               "doc": {
                  "headline": "A complete view of the ``SupersedingEvent`` returns is desired.", 
                  "body": "        Methods will return what is requested or result in an error.\n        This view is used when greater precision is desired at the\n        expense of interoperability."
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "use_federated_calendar_view", 
               "doc": {
                  "headline": "Federates the view for methods in this session.", 
                  "body": "        A federated view will include supserseding events in calendars\n        which are children of this calendar in the calendar hierarchy."
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "use_isolated_calendar_view", 
               "doc": {
                  "headline": "Isolates the view for methods in this session.", 
                  "body": "        An isolated view restricts lookups to this calendar only."
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "use_active_superseding_event_view", 
               "doc": {
                  "headline": "Only active superseding events are returned by methods in this session.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "use_any_status_superseding_event_view", 
               "doc": {
                  "headline": "All active and inactive superseding events are returned by methods in this session.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "get_superseding_event", 
               "doc": {
                  "headline": "Gets the ``Superseding`` specified by its ``Id``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    superseding_event_id (osid.id.Id): ``Id`` of the\n                ``SupersedingEvent``\n", 
               "return_doc": "        return: (osid.calendaring.SupersedingEvent) - the superseding\n                event", 
               "error_doc": "        raise:  NotFound - ``supersedng_event_id`` not found\n        raise:  NullArgument - ``superseding_event_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param superseding_event_id: ``Id`` of the ``SupersedingEvent``\n        :type superseding_event_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: the superseding event\n        :rtype: ``osid.calendaring.SupersedingEvent``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``supersedng_event_id`` not found\n        :raise: ``NullArgument`` -- ``superseding_event_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "superseding_event_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "osid.calendaring.SupersedingEvent", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_superseding_events_by_ids", 
               "doc": {
                  "headline": "Gets a ``SupersedingEventList`` corresponding to the given ``IdList``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    superseding_event_ids (osid.id.IdList): the list of\n                ``Ids`` to retrieve\n", 
               "return_doc": "        return: (osid.calendaring.SupersedingEventList) - the returned\n                ``SupersedingEvent`` list", 
               "error_doc": "        raise:  NotFound - an ``Id was`` not found\n        raise:  NullArgument - ``superseding_event_ids`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param superseding_event_ids: the list of ``Ids`` to retrieve\n        :type superseding_event_ids: ``osid.id.IdList``\n", 
               "sphinx_return_doc": "        :return: the returned ``SupersedingEvent`` list\n        :rtype: ``osid.calendaring.SupersedingEventList``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- an ``Id was`` not found\n        :raise: ``NullArgument`` -- ``superseding_event_ids`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.IdList", 
                     "var_name": "superseding_event_ids", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.IdList"
               ], 
               "return_type": "osid.calendaring.SupersedingEventList", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_superseding_events_by_genus_type", 
               "doc": {
                  "headline": "Gets a ``SupersedingEventList`` corresponding to the given superseding event genus ``Type`` which does not include superseding events of genus types derived from the specified ``Type``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    superseding_event_genus_type (osid.type.Type): a\n                superseding event genus type\n", 
               "return_doc": "        return: (osid.calendaring.SupersedingEventList) - the returned\n                ``SupersedingEvent`` list", 
               "error_doc": "        raise:  NullArgument - ``superseding_event_genus_type`` is\n                ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param superseding_event_genus_type: a superseding event genus type\n        :type superseding_event_genus_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "        :return: the returned ``SupersedingEvent`` list\n        :rtype: ``osid.calendaring.SupersedingEventList``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``superseding_event_genus_type`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "superseding_event_genus_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "osid.calendaring.SupersedingEventList", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_superseding_events_by_parent_genus_type", 
               "doc": {
                  "headline": "Gets a ``SupersedingEventList`` corresponding to the given superseding event genus ``Type`` and include any additional superseding event with genus types derived from the specified ``Type``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    superseding_event_genus_type (osid.type.Type): a\n                superseding event genus type\n", 
               "return_doc": "        return: (osid.calendaring.SupersedingEventList) - the returned\n                ``SupersedingEvent`` list", 
               "error_doc": "        raise:  NullArgument - ``superseding_event_genus_type`` is\n                ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param superseding_event_genus_type: a superseding event genus type\n        :type superseding_event_genus_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "        :return: the returned ``SupersedingEvent`` list\n        :rtype: ``osid.calendaring.SupersedingEventList``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``superseding_event_genus_type`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "superseding_event_genus_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "osid.calendaring.SupersedingEventList", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_superseding_events_by_record_type", 
               "doc": {
                  "headline": "Gets a ``SupersedingEventList`` containing the given superseding event record ``Type``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    superseding_event_record_type (osid.type.Type): a\n                superseding event record type\n", 
               "return_doc": "        return: (osid.calendaring.SupersedingEventList) - the returned\n                ``SupersedingEvent`` list", 
               "error_doc": "        raise:  NullArgument - ``superseding_event_record_type`` is\n                ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param superseding_event_record_type: a superseding event record type\n        :type superseding_event_record_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "        :return: the returned ``SupersedingEvent`` list\n        :rtype: ``osid.calendaring.SupersedingEventList``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``superseding_event_record_type`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "superseding_event_record_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "osid.calendaring.SupersedingEventList", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_superseding_events_by_superseded_event", 
               "doc": {
                  "headline": "Gets the ``SupersedingEvents`` related to the relative event ``Id``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    superseded_event_id (osid.id.Id): ``Id`` of the related\n                event\n", 
               "return_doc": "        return: (osid.calendaring.SupersedingEventList) - the\n                superseding events", 
               "error_doc": "        raise:  NotFound - ``superseded_event_id`` not found\n        raise:  NullArgument - ``superseded_event_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param superseded_event_id: ``Id`` of the related event\n        :type superseded_event_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: the superseding events\n        :rtype: ``osid.calendaring.SupersedingEventList``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``superseded_event_id`` not found\n        :raise: ``NullArgument`` -- ``superseded_event_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "superseded_event_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "osid.calendaring.SupersedingEventList", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_superseding_events", 
               "doc": {
                  "headline": "Gets all ``SupersedingEvents``.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.SupersedingEventList) - a\n                ``SupersedingEventList``", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: a ``SupersedingEventList``\n        :rtype: ``osid.calendaring.SupersedingEventList``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.SupersedingEventList", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.calendaring.SupersedingEventQuerySession", 
         "shortname": "SupersedingEventQuerySession", 
         "category": "sessions", 
         "doc": {
            "headline": "This session provides methods for searching ``SupersedingEvent`` objects.", 
            "body": "    The search query is constructed using the ``SupersedingEventQuery``.\n    The superseding event record ``Type`` also specifies the record for\n    the superseding event query.\n\n    This session defines views that offer differing behaviors for\n    searching.\n    \n      * federated calendar view: searches include superseding events in\n        calendars of which this calendar is an ancestor in the calendar\n        hierarchy\n      * isolated calendar view: searches are restricted to superseding\n        events in this calendar\n\n    \n    ``SupersedingEvents`` may have a query record indicated by their\n    respective record types. The query record is accessed via the\n    SupersedingE ``ventQuery``."
         }, 
         "inherit_fullnames": [
            "osid.OsidSession"
         ], 
         "inherit_shortnames": [
            "OsidSession"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidSession"
            }
         ], 
         "method_names": [
            "get_calendar_id", 
            "get_calendar", 
            "can_search_superseding_events", 
            "use_federated_calendar_view", 
            "use_isolated_calendar_view", 
            "get_superseding_event_query", 
            "get_superseding_events_by_query"
         ], 
         "methods": [
            {
               "name": "get_calendar_id", 
               "doc": {
                  "headline": "Gets the ``Calendar``  ``Id`` associated with this session.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.id.Id) - the ``Calendar Id`` associated with this\n                session", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the ``Calendar Id`` associated with this session\n        :rtype: ``osid.id.Id``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.id.Id", 
               "errors": {}
            }, 
            {
               "name": "get_calendar", 
               "doc": {
                  "headline": "Gets the ``Calendar`` associated with this session.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.Calendar) - the ``Calendar``\n                associated with this session", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the ``Calendar`` associated with this session\n        :rtype: ``osid.calendaring.Calendar``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.Calendar", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "can_search_superseding_events", 
               "doc": {
                  "headline": "Tests if this user can perform ``SupersedingEvents`` searches.", 
                  "body": "        A return of true does not guarantee successful authorization. A\n        return of false indicates that it is known all methods in this\n        session will result in a ``PermissionDenied``. This is intended\n        as a hint to an application that may opt not to offer search\n        operations to unauthorized users."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``false`` if search methods are not\n                authorized, ``true`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``false`` if search methods are not authorized, ``true`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "use_federated_calendar_view", 
               "doc": {
                  "headline": "Federates the view for methods in this session.", 
                  "body": "        A federated view will include superseding events in calendars\n        which are children of this calendar in the calendar hierarchy."
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "use_isolated_calendar_view", 
               "doc": {
                  "headline": "Isolates the view for methods in this session.", 
                  "body": "        An isolated view restricts searches to this calendar only."
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "get_superseding_event_query", 
               "doc": {
                  "headline": "Gets a superseding event query.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.SupersedingEventQuery) - the\n                superseding event query", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the superseding event query\n        :rtype: ``osid.calendaring.SupersedingEventQuery``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.SupersedingEventQuery", 
               "errors": {}
            }, 
            {
               "name": "get_superseding_events_by_query", 
               "doc": {
                  "headline": "Gets a list of ``SupersedingEvents`` matching the given superseding event query.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    superseding_event_query\n                (osid.calendaring.SupersedingEventQuery): the\n                superseding event query\n", 
               "return_doc": "        return: (osid.calendaring.SupersedingEventList) - the returned\n                ``SupersedingEventList``", 
               "error_doc": "        raise:  NullArgument - ``superseding_event_query`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        raise:  Unsupported - ``superseding_event_query`` is not of this\n                service", 
               "sphinx_param_doc": "        :param superseding_event_query: the superseding event query\n        :type superseding_event_query: ``osid.calendaring.SupersedingEventQuery``\n", 
               "sphinx_return_doc": "        :return: the returned ``SupersedingEventList``\n        :rtype: ``osid.calendaring.SupersedingEventList``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``superseding_event_query`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure\n        :raise: ``Unsupported`` -- ``superseding_event_query`` is not of this service", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.calendaring.SupersedingEventQuery", 
                     "var_name": "superseding_event_query", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.calendaring.SupersedingEventQuery"
               ], 
               "return_type": "osid.calendaring.SupersedingEventList", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.calendaring.SupersedingEventSearchSession", 
         "shortname": "SupersedingEventSearchSession", 
         "category": "sessions", 
         "doc": {
            "headline": "This session provides methods for searching ``SupersedingEvent`` objects.", 
            "body": "    The search query is constructed using the ``SupersedingEventQuery``.\n    The superseding event record ``Type`` also specifies the record for\n    the superseding event query.\n\n    ``get_superseding_events_by_query()`` is the basic search method and\n    returns a list of ``SupersedingEvents``. A more advanced search may\n    be performed with ``getSupersedingEventsBySearch()``. It accepts a\n    ``SupersedingEventSearch`` in addition to the query for the purpose\n    of specifying additional options affecting the entire search, such\n    as ordering. ``get_superseding_events_by_search()`` returns a\n    ``SupersedingEventSearchResults`` that can be used to access the\n    resulting ``SupersedingEventList`` or be used to perform a search\n    within the result set through ``SupersedingEventSearch``.\n    \n    This session defines views that offer differing behaviors for\n    searching.\n    \n      * federated calendar view: searches include superseding events in\n        calendars of which this calendar is a ancestor in the calendar\n        hierarchy\n      * isolated calendar view: searches are restricted to superseding\n        events in this calendar\n\n    \n    Superseding events may have a query record indicated by their\n    respective record types. The query record is accessed via the\n    ``SupersedingEventQuery``."
         }, 
         "inherit_fullnames": [
            "osid.calendaring.SupersedingEventQuerySession"
         ], 
         "inherit_shortnames": [
            "SupersedingEventQuerySession"
         ], 
         "inherit_pkg_names": [
            "calendaring"
         ], 
         "inheritance": [
            {
               "pkg_name": "calendaring", 
               "name": "SupersedingEventQuerySession"
            }
         ], 
         "method_names": [
            "get_superseding_event_search", 
            "get_superseding_event_search_order", 
            "get_superseding_events_by_search", 
            "get_superseding_event_query_from_inspector"
         ], 
         "methods": [
            {
               "name": "get_superseding_event_search", 
               "doc": {
                  "headline": "Gets a superseding event search.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.SupersedingEventSearch) - the\n                superseding event search", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the superseding event search\n        :rtype: ``osid.calendaring.SupersedingEventSearch``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.SupersedingEventSearch", 
               "errors": {}
            }, 
            {
               "name": "get_superseding_event_search_order", 
               "doc": {
                  "headline": "Gets a superseding event search order.", 
                  "body": "        The ``SupersedingEventSearchOrder`` is supplied to a\n        ``SupersedingEventSearch`` to specify the ordering of results."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.SupersedingEventSearchOrder) - the\n                superseding event search order", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the superseding event search order\n        :rtype: ``osid.calendaring.SupersedingEventSearchOrder``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.SupersedingEventSearchOrder", 
               "errors": {}
            }, 
            {
               "name": "get_superseding_events_by_search", 
               "doc": {
                  "headline": "Gets the search results matching the given search query using the given search.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    superseding_event_query\n                (osid.calendaring.SupersedingEventQuery): the\n                superseding search query\n        arg:    superseding_event_search\n                (osid.calendaring.SupersedingEventSearch): the\n                superseding search\n", 
               "return_doc": "        return: (osid.calendaring.SupersedingEventSearchResults) - the\n                returned search results", 
               "error_doc": "        raise:  NullArgument - ``superseding_event_query`` or\n                ``superseding_event_search`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        raise:  Unsupported - ``superseding_event_query`` is not of this\n                service", 
               "sphinx_param_doc": "        :param superseding_event_query: the superseding search query\n        :type superseding_event_query: ``osid.calendaring.SupersedingEventQuery``\n        :param superseding_event_search: the superseding search\n        :type superseding_event_search: ``osid.calendaring.SupersedingEventSearch``\n", 
               "sphinx_return_doc": "        :return: the returned search results\n        :rtype: ``osid.calendaring.SupersedingEventSearchResults``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``superseding_event_query`` or ``superseding_event_search`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure\n        :raise: ``Unsupported`` -- ``superseding_event_query`` is not of this service", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.calendaring.SupersedingEventQuery", 
                     "var_name": "superseding_event_query", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.calendaring.SupersedingEventSearch", 
                     "var_name": "superseding_event_search", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.calendaring.SupersedingEventQuery", 
                  "osid.calendaring.SupersedingEventSearch"
               ], 
               "return_type": "osid.calendaring.SupersedingEventSearchResults", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_superseding_event_query_from_inspector", 
               "doc": {
                  "headline": "Gets a superseding event query from an inspector.", 
                  "body": "        The inspector is available from a\n        ``SupersedingEventSearchResults``."
               }, 
               "arg_doc": "        arg:    superseding_event_query_inspector\n                (osid.calendaring.SupersedingEventQueryInspector): a\n                superseding event query inspector\n", 
               "return_doc": "        return: (osid.calendaring.SupersedingEventQuery) - the\n                superseding event query", 
               "error_doc": "        raise:  NullArgument - ``superseding_event_query_inspector`` is\n                ``null``\n        raise:  Unsupported - ``superseding_event_query_inspector`` is\n                not of this service", 
               "sphinx_param_doc": "        :param superseding_event_query_inspector: a superseding event query inspector\n        :type superseding_event_query_inspector: ``osid.calendaring.SupersedingEventQueryInspector``\n", 
               "sphinx_return_doc": "        :return: the superseding event query\n        :rtype: ``osid.calendaring.SupersedingEventQuery``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``superseding_event_query_inspector`` is ``null``\n        :raise: ``Unsupported`` -- ``superseding_event_query_inspector`` is not of this service", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.calendaring.SupersedingEventQueryInspector", 
                     "var_name": "superseding_event_query_inspector", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.calendaring.SupersedingEventQueryInspector"
               ], 
               "return_type": "osid.calendaring.SupersedingEventQuery", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.calendaring.SupersedingEventAdminSession", 
         "shortname": "SupersedingEventAdminSession", 
         "category": "sessions", 
         "doc": {
            "headline": "This session creates, updates, and deletes ``Superseding Events``.", 
            "body": "    The data for create and update is provided by the consumer via the\n    form object. ``OsidForms`` are requested for each create or update\n    and may not be reused.\n\n    Create and update operations differ in their usage. To create a\n    ``SupersedingEvent,`` a ``SupersedingEventForm`` is requested using\n    ``get_superseding_event_form_for_create()`` specifying the desired\n    relationship peers and record ``Types`` or none if no record\n    ``Types`` are needed. The returned ``SupersedingEventForm`` will\n    indicate that it is to be used with a create operation and can be\n    used to examine metdata or validate data prior to creation. Once the\n    ``SupersedingEventForm`` is submiited to a create operation, it\n    cannot be reused with another create operation unless the first\n    operation was unsuccessful. Each ``SupersedingEventForm``\n    corresponds to an attempted transaction.\n    \n    For updates, ``SupersedingEventForms`` are requested to the\n    ``SupersedingEvent``  ``Id`` that is to be updated using\n    ``getSupersedingEventFormForUpdate()``. Similarly, the\n    ``SupersedingEventForm`` has metadata about the data that can be\n    updated and it can perform validation before submitting the update.\n    The ``SupersedingEventForm`` can only be used once for a successful\n    update and cannot be reused.\n    \n    The delete operations delete ``Superseding Events``. To unmap a\n    ``SupersedingEvent`` from the current ``Calendar,`` the\n    ``SupersedingEventCalendarAssignmentSession`` should be used. These\n    delete operations attempt to remove the ``SupersedingEvent`` itself\n    thus removing it from all known ``Calendar`` catalogs.\n    \n    This session includes an ``Id`` aliasing mechanism to assign an\n    external ``Id`` to an internally assigned Id."
         }, 
         "inherit_fullnames": [
            "osid.OsidSession"
         ], 
         "inherit_shortnames": [
            "OsidSession"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidSession"
            }
         ], 
         "method_names": [
            "get_calendar_id", 
            "get_calendar", 
            "can_create_superseding_events", 
            "can_create_superseding_event_with_record_types", 
            "get_superseding_event_form_for_create", 
            "create_superseding_event", 
            "can_update_superseding_events", 
            "get_superseding_event_form_for_update", 
            "update_superseding_event", 
            "can_delete_superseding_events", 
            "delete_superseding_event", 
            "can_manage_superseding_event_aliases", 
            "alias_superseding_event"
         ], 
         "methods": [
            {
               "name": "get_calendar_id", 
               "doc": {
                  "headline": "Gets the ``Calendar``  ``Id`` associated with this session.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.id.Id) - the ``Calendar Id`` associated with this\n                session", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the ``Calendar Id`` associated with this session\n        :rtype: ``osid.id.Id``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.id.Id", 
               "errors": {}
            }, 
            {
               "name": "get_calendar", 
               "doc": {
                  "headline": "Gets the ``Calendar`` associated with this session.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.Calendar) - the ``Calendar``\n                associated with this session", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the ``Calendar`` associated with this session\n        :rtype: ``osid.calendaring.Calendar``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.Calendar", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "can_create_superseding_events", 
               "doc": {
                  "headline": "Tests if this user can create ``SupersedingEvents``.", 
                  "body": "        A return of true does not guarantee successful authorization. A\n        return of false indicates that it is known creating an Event\n        will result in a ``PermissionDenied``. This is intended as a\n        hint to an application that may opt not to offer create\n        operations to an unauthorized user."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``false`` if ``Event`` creation is not\n                authorized, ``true`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``false`` if ``Event`` creation is not authorized, ``true`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "can_create_superseding_event_with_record_types", 
               "doc": {
                  "headline": "Tests if this user can create a single ``SupersedingEvent`` using the desired record types.", 
                  "body": "        While ``CalendaringManager.getSupersedingEventRecordTypes()``\n        can be used to examine which records are supported, this method\n        tests which record(s) are required for creating a specific\n        ``SupersedingEvent``. Providing an empty array tests if a\n        ``RecurringEvent`` can be created with no records."
               }, 
               "arg_doc": "        arg:    supersdeing_event_record_types (osid.type.Type[]): array\n                of superseding evnt record types\n", 
               "return_doc": "        return: (boolean) - ``true`` if ``SupersedingEvent`` creation\n                using the specified record ``Types`` is supported,\n                ``false`` otherwise", 
               "error_doc": "        raise:  NullArgument - ``superseding_event_record_types`` is\n                ``null``", 
               "sphinx_param_doc": "        :param supersdeing_event_record_types: array of superseding evnt record types\n        :type supersdeing_event_record_types: ``osid.type.Type[]``\n", 
               "sphinx_return_doc": "        :return: ``true`` if ``SupersedingEvent`` creation using the specified record ``Types`` is supported, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``superseding_event_record_types`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type[]", 
                     "var_name": "supersdeing_event_record_types", 
                     "array": true
                  }
               ], 
               "arg_types": [
                  "osid.type.Type[]"
               ], 
               "return_type": "boolean", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "get_superseding_event_form_for_create", 
               "doc": {
                  "headline": "Gets the superseding event form for creating new events.", 
                  "body": "        A new form should be requested for each create transaction."
               }, 
               "arg_doc": "        arg:    superseded_event_id (osid.id.Id): the ``Id`` of the\n                superseded event\n        arg:    superseding_event_id (osid.id.Id): the ``Id`` of the\n                superseding event\n        arg:    supersdeing_event_record_types (osid.type.Type[]): array\n                of superseding evnt record types\n", 
               "return_doc": "        return: (osid.calendaring.SupersedingEventForm) - the\n                superseding event form", 
               "error_doc": "        raise:  NotFound - ``superseded_event_id`` or\n                ``superseding_event_id`` not found\n        raise:  NullArgument - ``superseded_event_id,\n                superseding_event_id,`` or\n                ``supersdeing_event_record_types`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        raise:  Unsupported - unable to get form for requested record\n                types", 
               "sphinx_param_doc": "        :param superseded_event_id: the ``Id`` of the superseded event\n        :type superseded_event_id: ``osid.id.Id``\n        :param superseding_event_id: the ``Id`` of the superseding event\n        :type superseding_event_id: ``osid.id.Id``\n        :param supersdeing_event_record_types: array of superseding evnt record types\n        :type supersdeing_event_record_types: ``osid.type.Type[]``\n", 
               "sphinx_return_doc": "        :return: the superseding event form\n        :rtype: ``osid.calendaring.SupersedingEventForm``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``superseded_event_id`` or ``superseding_event_id`` not found\n        :raise: ``NullArgument`` -- ``superseded_event_id, superseding_event_id,`` or ``supersdeing_event_record_types`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure\n        :raise: ``Unsupported`` -- unable to get form for requested record types", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "superseded_event_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "superseding_event_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.type.Type[]", 
                     "var_name": "supersdeing_event_record_types", 
                     "array": true
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "osid.id.Id", 
                  "osid.type.Type[]"
               ], 
               "return_type": "osid.calendaring.SupersedingEventForm", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }, 
            {
               "name": "create_superseding_event", 
               "doc": {
                  "headline": "Creates a new ``SupersedingEvent``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    superseding_event_form\n                (osid.calendaring.SupersedingEventForm): the form for\n                this ``SupersedingEvent``\n", 
               "return_doc": "        return: (osid.calendaring.SupersedingEvent) - the new\n                ``SupersedingEvent``", 
               "error_doc": "        raise:  IllegalState - ``supersdeing_event_form`` already used\n                in a create transaction\n        raise:  InvalidArgument - one or more of the form elements is\n                invalid\n        raise:  NullArgument - ``supersdeing_event_form`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        raise:  Unsupported - ``superseding_event_form`` did not\n                originate from\n                ``get_superseding_event_form_for_create()``", 
               "sphinx_param_doc": "        :param superseding_event_form: the form for this ``SupersedingEvent``\n        :type superseding_event_form: ``osid.calendaring.SupersedingEventForm``\n", 
               "sphinx_return_doc": "        :return: the new ``SupersedingEvent``\n        :rtype: ``osid.calendaring.SupersedingEvent``", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- ``supersdeing_event_form`` already used in a create transaction\n        :raise: ``InvalidArgument`` -- one or more of the form elements is invalid\n        :raise: ``NullArgument`` -- ``supersdeing_event_form`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure\n        :raise: ``Unsupported`` -- ``superseding_event_form`` did not originate from ``get_superseding_event_form_for_create()``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.calendaring.SupersedingEventForm", 
                     "var_name": "superseding_event_form", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.calendaring.SupersedingEventForm"
               ], 
               "return_type": "osid.calendaring.SupersedingEvent", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract", 
                  "INVALID_ARGUMENT": "ConsumerContract", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }, 
            {
               "name": "can_update_superseding_events", 
               "doc": {
                  "headline": "Tests if this user can update ``SupersedingEvents``.", 
                  "body": "        A return of true does not guarantee successful authorization. A\n        return of false indicates that it is known updating a\n        ``SupersedingEvent`` will result in a ``PermissionDenied``. This\n        is intended as a hint to an application that may opt not to\n        offer update operations to an unauthorized user."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``false`` if superseding event modification\n                is not authorized, ``true`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``false`` if superseding event modification is not authorized, ``true`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "get_superseding_event_form_for_update", 
               "doc": {
                  "headline": "Gets the superseding event form for updating an existing superseding event.", 
                  "body": "        A new superseding event form should be requested for each update\n        transaction."
               }, 
               "arg_doc": "        arg:    superseding_event_id (osid.id.Id): the ``Id`` of the\n                ``SupersedingEvent``\n", 
               "return_doc": "        return: (osid.calendaring.SupersedingEventForm) - the\n                superseding event form", 
               "error_doc": "        raise:  NotFound - ``superseding_event_id`` is not found\n        raise:  NullArgument - ``superseding_event_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param superseding_event_id: the ``Id`` of the ``SupersedingEvent``\n        :type superseding_event_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: the superseding event form\n        :rtype: ``osid.calendaring.SupersedingEventForm``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``superseding_event_id`` is not found\n        :raise: ``NullArgument`` -- ``superseding_event_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "superseding_event_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "osid.calendaring.SupersedingEventForm", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "update_superseding_event", 
               "doc": {
                  "headline": "Updates an existing superseding event.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    superseding_event_form\n                (osid.calendaring.SupersedingEventForm): the form\n                containing the elements to be updated\n", 
               "return_doc": "", 
               "error_doc": "        raise:  IllegalState - ``supersdeing_event_form`` already used\n                in an update transaction\n        raise:  InvalidArgument - the form contains an invalid value\n        raise:  NullArgument - ``superseding_event_form`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        raise:  Unsupported - ``superseding_event_form`` did not\n                originate from\n                ``get_superseding_event_form_for_update()``", 
               "sphinx_param_doc": "        :param superseding_event_form: the form containing the elements to be updated\n        :type superseding_event_form: ``osid.calendaring.SupersedingEventForm``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- ``supersdeing_event_form`` already used in an update transaction\n        :raise: ``InvalidArgument`` -- the form contains an invalid value\n        :raise: ``NullArgument`` -- ``superseding_event_form`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure\n        :raise: ``Unsupported`` -- ``superseding_event_form`` did not originate from ``get_superseding_event_form_for_update()``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.calendaring.SupersedingEventForm", 
                     "var_name": "superseding_event_form", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.calendaring.SupersedingEventForm"
               ], 
               "return_type": "", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract", 
                  "INVALID_ARGUMENT": "ConsumerContract", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }, 
            {
               "name": "can_delete_superseding_events", 
               "doc": {
                  "headline": "Tests if this user can delete ``SupersedingEvents``.", 
                  "body": "        A return of true does not guarantee successful authorization. A\n        return of false indicates that it is known deleting a\n        ``SupersedingEvent`` will result in a ``PermissionDenied``. This\n        is intended as a hint to an application that may opt not to\n        offer delete operations to an unauthorized user."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``false`` if ``SupersedingEvent`` deletion\n                is not authorized, ``true`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``false`` if ``SupersedingEvent`` deletion is not authorized, ``true`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "delete_superseding_event", 
               "doc": {
                  "headline": "Deletes the ``SupersedingEvent`` identified by the given ``Id``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    superseding_event_id (osid.id.Id): the ``Id`` of the\n                ``SupersedingEvent`` to delete\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NotFound - a ``SupersedingEvent`` was not found\n                identified by the given ``Id``\n        raise:  NullArgument - ``superseding_event_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param superseding_event_id: the ``Id`` of the ``SupersedingEvent`` to delete\n        :type superseding_event_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- a ``SupersedingEvent`` was not found identified by the given ``Id``\n        :raise: ``NullArgument`` -- ``superseding_event_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "superseding_event_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "can_manage_superseding_event_aliases", 
               "doc": {
                  "headline": "Tests if this user can manage ``Id`` aliases for ``SupersedingEvents``.", 
                  "body": "        A return of true does not guarantee successful authorization. A\n        return of false indicates that it is known changing an alias\n        will result in a ``PermissionDenied``. This is intended as a\n        hint to an application that may opt not to offer alias\n        operations to an unauthorized user."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``false`` if ``SupersedingEvent`` aliasing\n                is not authorized, ``true`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``false`` if ``SupersedingEvent`` aliasing is not authorized, ``true`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "alias_superseding_event", 
               "doc": {
                  "headline": "Adds an ``Id`` to a ``SupersedingEvent`` for the purpose of creating compatibility.", 
                  "body": "        The primary ``Id`` of the ``SupersedingEvent`` is determined by\n        the provider. The new ``Id`` performs as an alias to the primary\n        ``Id``. If the alias is a pointer to another superseding event,\n        it is reassigned to the given superseding event ``Id``."
               }, 
               "arg_doc": "        arg:    superseding_event_id (osid.id.Id): the ``Id`` of a\n                ``SupersedingEvent``\n        arg:    alias_id (osid.id.Id): the alias ``Id``\n", 
               "return_doc": "", 
               "error_doc": "        raise:  AlreadyExists - ``alias_id`` is already assigned\n        raise:  NotFound - ``superseding_event_id`` not found\n        raise:  NullArgument - ``superseding_event_id`` or ``alias_id``\n                is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param superseding_event_id: the ``Id`` of a ``SupersedingEvent``\n        :type superseding_event_id: ``osid.id.Id``\n        :param alias_id: the alias ``Id``\n        :type alias_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``AlreadyExists`` -- ``alias_id`` is already assigned\n        :raise: ``NotFound`` -- ``superseding_event_id`` not found\n        :raise: ``NullArgument`` -- ``superseding_event_id`` or ``alias_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "superseding_event_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "alias_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {
                  "ALREADY_EXISTS": "User", 
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.calendaring.SupersedingEventNotificationSession", 
         "shortname": "SupersedingEventNotificationSession", 
         "category": "sessions", 
         "doc": {
            "headline": "This session defines methods to receive asynchronous notifications on adds/changes to ``SupersedingEvent`` objects.", 
            "body": "    This session is intended for consumers needing to synchronize their\n    state with this service without the use of polling. Notifications\n    are cancelled when this session is closed.\n\n    The views defined in this session correspond to the views in the\n    ``SupersedingEventLookupSession``."
         }, 
         "inherit_fullnames": [
            "osid.OsidSession"
         ], 
         "inherit_shortnames": [
            "OsidSession"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidSession"
            }
         ], 
         "method_names": [
            "get_calendar_id", 
            "get_calendar", 
            "can_register_for_superseding_event_notifications", 
            "use_federated_calendar_view", 
            "use_isolated_calendar_view", 
            "register_for_new_superseding_events", 
            "register_for_changed_superseding_events", 
            "register_for_changed_superseding_event", 
            "register_for_deleted_superseding_events", 
            "register_for_deleted_superseding_event"
         ], 
         "methods": [
            {
               "name": "get_calendar_id", 
               "doc": {
                  "headline": "Gets the ``Calendar``  ``Id`` associated with this session.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.id.Id) - the ``Calendar Id`` associated with this\n                session", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the ``Calendar Id`` associated with this session\n        :rtype: ``osid.id.Id``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.id.Id", 
               "errors": {}
            }, 
            {
               "name": "get_calendar", 
               "doc": {
                  "headline": "Gets the ``Calendar`` associated with this session.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.Calendar) - the ``Calendar``\n                associated with this session", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the ``Calendar`` associated with this session\n        :rtype: ``osid.calendaring.Calendar``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.Calendar", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "can_register_for_superseding_event_notifications", 
               "doc": {
                  "headline": "Tests if this user can register for ``SupersedingEvent`` notifications.", 
                  "body": "        A return of true does not guarantee successful authorization. A\n        return of false indicates that it is known all methods in this\n        session will result in a ``PermissionDenied``. This is intended\n        as a hint to an application that may opt not to offer\n        notification operations."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``false`` if notification methods are not\n                authorized, ``true`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``false`` if notification methods are not authorized, ``true`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "use_federated_calendar_view", 
               "doc": {
                  "headline": "Federates the view for methods in this session.", 
                  "body": "        A federated view will include notifications for events in\n        calendars which are children of this calendar in the calendar\n        hierarchy."
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "use_isolated_calendar_view", 
               "doc": {
                  "headline": "Isolates the view for methods in this session.", 
                  "body": "        An isolated view restricts notifications to this calendar only."
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "register_for_new_superseding_events", 
               "doc": {
                  "headline": "Register for notifications of new superseding events.", 
                  "body": "        ``SupersedingEventReceiver.newSupersedingEvent()`` is invoked\n        when a new superseding event is created."
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "register_for_changed_superseding_events", 
               "doc": {
                  "headline": "Registers for notification of updated superseding events.", 
                  "body": "        ``SupersedingEventReceiver.changedSupersedingEvent()`` is\n        invoked when a superseding event is changed."
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "register_for_changed_superseding_event", 
               "doc": {
                  "headline": "Registers for notification of an updated superseding event.", 
                  "body": "        ``SupersedingEventReceiver.changedSupersedingEvent()`` is\n        invoked when the specified superseding event is changed."
               }, 
               "arg_doc": "        arg:    superseding_event_id (osid.id.Id): the ``Id`` of the\n                ``Superseding`` to monitor\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``superseding_event_id is null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param superseding_event_id: the ``Id`` of the ``Superseding`` to monitor\n        :type superseding_event_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``superseding_event_id is null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "superseding_event_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "register_for_deleted_superseding_events", 
               "doc": {
                  "headline": "Registers for notification of deleted superseding events.", 
                  "body": "        ``SupersedingEventReceiver.deletedSupersedingEvent()`` is\n        invoked when a superseding event is removed from this calendar."
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "register_for_deleted_superseding_event", 
               "doc": {
                  "headline": "Registers for notification of a deleted superseding event.", 
                  "body": "        ``SupersedingEventReceiver.changedSupersedingEvent()`` is\n        invoked when the specified superseding event is removed from\n        this calendar."
               }, 
               "arg_doc": "        arg:    superseding_event_id (osid.id.Id): the ``Id`` of the\n                ``Superseding`` to monitor\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``superseding_event_id is null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param superseding_event_id: the ``Id`` of the ``Superseding`` to monitor\n        :type superseding_event_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``superseding_event_id is null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "superseding_event_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.calendaring.SupersedingEventCalendarSession", 
         "shortname": "SupersedingEventCalendarSession", 
         "category": "sessions", 
         "doc": {
            "headline": "This session provides methods to retrieve ``SupersedingEvent`` to ``Calendar`` mappings.", 
            "body": "    A ``SupersedingEvent`` may appear in multiple ``Calendars``. Each\n    ``Calendar`` may have its own authorizations governing who is\n    allowed to look at it.\n\n    This lookup session defines two views:\n    \n      * comparative view: elements may be silently omitted or re-ordered\n      * plenary view: provides a complete result set or is an error\n        condition\n      * normalized event view: a single superseding event is used to\n        represent a series of events\n      * denormalized view: superseding events are expanded into\n        individual events\n"
         }, 
         "inherit_fullnames": [
            "osid.OsidSession"
         ], 
         "inherit_shortnames": [
            "OsidSession"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidSession"
            }
         ], 
         "method_names": [
            "can_lookup_superseding_event_calendar_mappings", 
            "use_comparative_calendar_view", 
            "use_plenary_calendar_view", 
            "get_superseding_event_ids_by_calendar", 
            "get_superseding_events_by_calendar", 
            "get_superseding_event_ids_by_calendars", 
            "get_superseding_events_by_calendars", 
            "get_superseding_ids_by_recurring_event", 
            "get_calendars_by_superseding_event"
         ], 
         "methods": [
            {
               "name": "can_lookup_superseding_event_calendar_mappings", 
               "doc": {
                  "headline": "Tests if this user can perform lookups of superseding event/calendar mappings.", 
                  "body": "        A return of true does not guarantee successful authorization. A\n        return of false indicates that it is known lookup methods in\n        this session will result in a ``PermissionDenied``. This is\n        intended as a hint to an application that may opt not to offer\n        lookup operations to unauthorized users."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``false`` if looking up mappings is not\n                authorized, ``true`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``false`` if looking up mappings is not authorized, ``true`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "use_comparative_calendar_view", 
               "doc": {
                  "headline": "The returns from the lookup methods may omit or translate elements based on this session, such as authorization, and not result in an error.", 
                  "body": "        This view is used when greater interoperability is desired at\n        the expense of precision."
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "use_plenary_calendar_view", 
               "doc": {
                  "headline": "A complete view of the ``Event`` and ``Calendar`` returns is desired.", 
                  "body": "        Methods will return what is requested or result in an error.\n        This view is used when greater precision is desired at the\n        expense of interoperability."
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "get_superseding_event_ids_by_calendar", 
               "doc": {
                  "headline": "Gets the list of ``SupersedingEvent``  ``Ids`` associated with a ``Calendar``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    calendar_id (osid.id.Id): ``Id`` of the ``Calendar``\n", 
               "return_doc": "        return: (osid.id.IdList) - list of related superseding event\n                ``Ids``", 
               "error_doc": "        raise:  NotFound - ``calendar_id`` is not found\n        raise:  NullArgument - ``calendar_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param calendar_id: ``Id`` of the ``Calendar``\n        :type calendar_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: list of related superseding event ``Ids``\n        :rtype: ``osid.id.IdList``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``calendar_id`` is not found\n        :raise: ``NullArgument`` -- ``calendar_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "calendar_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "osid.id.IdList", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_superseding_events_by_calendar", 
               "doc": {
                  "headline": "Gets the list of ``SupersedingEvents`` associated with a ``Calendar``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    calendar_id (osid.id.Id): ``Id`` of the ``Calendar``\n", 
               "return_doc": "        return: (osid.calendaring.SupersedingEventList) - list of\n                related superseding events", 
               "error_doc": "        raise:  NotFound - ``calendar_id`` is not found\n        raise:  NullArgument - ``calendar_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param calendar_id: ``Id`` of the ``Calendar``\n        :type calendar_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: list of related superseding events\n        :rtype: ``osid.calendaring.SupersedingEventList``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``calendar_id`` is not found\n        :raise: ``NullArgument`` -- ``calendar_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "calendar_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "osid.calendaring.SupersedingEventList", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_superseding_event_ids_by_calendars", 
               "doc": {
                  "headline": "Gets the list of ``SupersedingEvent Ids`` corresponding to a list of ``Calendars``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    calendar_ids (osid.id.IdList): list of calendar ``Ids``\n", 
               "return_doc": "        return: (osid.id.IdList) - list of superseding event ``Ids``", 
               "error_doc": "        raise:  NullArgument - ``calendar_ids`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param calendar_ids: list of calendar ``Ids``\n        :type calendar_ids: ``osid.id.IdList``\n", 
               "sphinx_return_doc": "        :return: list of superseding event ``Ids``\n        :rtype: ``osid.id.IdList``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``calendar_ids`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.IdList", 
                     "var_name": "calendar_ids", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.IdList"
               ], 
               "return_type": "osid.id.IdList", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_superseding_events_by_calendars", 
               "doc": {
                  "headline": "Gets the list of ``SupersedingEvents`` corresponding to a list of ``Calendars``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    calendar_ids (osid.id.IdList): list of calendar ``Ids``\n", 
               "return_doc": "        return: (osid.calendaring.SupersedingEventList) - list of\n                superseding events", 
               "error_doc": "        raise:  NullArgument - ``calendar_ids`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param calendar_ids: list of calendar ``Ids``\n        :type calendar_ids: ``osid.id.IdList``\n", 
               "sphinx_return_doc": "        :return: list of superseding events\n        :rtype: ``osid.calendaring.SupersedingEventList``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``calendar_ids`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.IdList", 
                     "var_name": "calendar_ids", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.IdList"
               ], 
               "return_type": "osid.calendaring.SupersedingEventList", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_superseding_ids_by_recurring_event", 
               "doc": {
                  "headline": "Gets the list of ``Calendar``  ``Ids`` mapped to a ``SupersedingEvent``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    superseding_event_id (osid.id.Id): ``Id`` of a\n                ``SupersedingEvent``\n", 
               "return_doc": "        return: (osid.id.IdList) - list of calendar ``Ids``", 
               "error_doc": "        raise:  NotFound - ``superseding_event_id`` is not found\n        raise:  NullArgument - ``supesreding_event_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param superseding_event_id: ``Id`` of a ``SupersedingEvent``\n        :type superseding_event_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: list of calendar ``Ids``\n        :rtype: ``osid.id.IdList``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``superseding_event_id`` is not found\n        :raise: ``NullArgument`` -- ``supesreding_event_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "superseding_event_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "osid.id.IdList", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_calendars_by_superseding_event", 
               "doc": {
                  "headline": "Gets the list of ``Calendars`` mapped to a ``SupersedingEvent``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    superseding_event_id (osid.id.Id): ``Id`` of a\n                ``SupersedingEvent``\n", 
               "return_doc": "        return: (osid.calendaring.CalendarList) - list of calendar", 
               "error_doc": "        raise:  NotFound - ``superseding_event_id`` is not found\n        raise:  NullArgument - ``supesreding_event_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param superseding_event_id: ``Id`` of a ``SupersedingEvent``\n        :type superseding_event_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: list of calendar\n        :rtype: ``osid.calendaring.CalendarList``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``superseding_event_id`` is not found\n        :raise: ``NullArgument`` -- ``supesreding_event_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "superseding_event_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "osid.calendaring.CalendarList", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.calendaring.SupersedingEventCalendarAssignmentSession", 
         "shortname": "SupersedingEventCalendarAssignmentSession", 
         "category": "sessions", 
         "doc": {
            "headline": "This session provides methods to re-assign ``SupersedingEvents`` to ``Calendars``.", 
            "body": "    A ``SupersedingEvent`` may map to multiple ``Calendars`` and\n    removing the last reference to a ``SupersedingEvent`` is the\n    equivalent of deleting it. Each ``Calendar`` may have its own\n    authorizations governing who is allowed to operate on it.\n\n    Moving or adding a reference of a ``SupersedingEvent`` to another\n    ``Calendar`` is not a copy operation (eg: does not change its ``Id``\n    )."
         }, 
         "inherit_fullnames": [
            "osid.OsidSession"
         ], 
         "inherit_shortnames": [
            "OsidSession"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidSession"
            }
         ], 
         "method_names": [
            "can_assign_superseding_events", 
            "can_assign_superseding_events_to_calendar", 
            "get_assignable_calendar_ids", 
            "get_assignable_calendar_ids_for_superseding_event", 
            "assign_superseding_event_to_calendar", 
            "unassign_superseding_event_from_calendar"
         ], 
         "methods": [
            {
               "name": "can_assign_superseding_events", 
               "doc": {
                  "headline": "Tests if this user can alter superseding event/calendar mappings.", 
                  "body": "        A return of true does not guarantee successful authorization. A\n        return of false indicates that it is known mapping methods in\n        this session will result in a ``PermissionDenied``. This is\n        intended as a hint to an application that may opt not to offer\n        assignment operations to unauthorized users."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``false`` if mapping is not authorized,\n                ``true`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``false`` if mapping is not authorized, ``true`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "can_assign_superseding_events_to_calendar", 
               "doc": {
                  "headline": "Tests if this user can alter superseding event/calendar mappings.", 
                  "body": "        A return of true does not guarantee successful authorization. A\n        return of false indicates that it is known mapping methods in\n        this session will result in a ``PermissionDenied``. This is\n        intended as a hint to an application that may opt not to offer\n        assignment operations to unauthorized users."
               }, 
               "arg_doc": "        arg:    calendar_id (osid.id.Id): the ``Id`` of the ``Calendar``\n", 
               "return_doc": "        return: (boolean) - ``false`` if mapping is not authorized,\n                ``true`` otherwise", 
               "error_doc": "        raise:  NullArgument - ``calendar_id`` is ``null``", 
               "sphinx_param_doc": "        :param calendar_id: the ``Id`` of the ``Calendar``\n        :type calendar_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: ``false`` if mapping is not authorized, ``true`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``calendar_id`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "calendar_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "boolean", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "get_assignable_calendar_ids", 
               "doc": {
                  "headline": "Gets a list of calendars including and under the given calendar node in which any superseding event can be assigned.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    calendar_id (osid.id.Id): the ``Id`` of the ``Calendar``\n", 
               "return_doc": "        return: (osid.id.IdList) - list of assignable calendar ``Ids``", 
               "error_doc": "        raise:  NullArgument - ``calendar_id`` is ``null``\n        raise:  OperationFailed - unable to complete request", 
               "sphinx_param_doc": "        :param calendar_id: the ``Id`` of the ``Calendar``\n        :type calendar_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: list of assignable calendar ``Ids``\n        :rtype: ``osid.id.IdList``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``calendar_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "calendar_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "osid.id.IdList", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational"
               }
            }, 
            {
               "name": "get_assignable_calendar_ids_for_superseding_event", 
               "doc": {
                  "headline": "Gets a list of calendars including and under the given calendar node in which a specific superseding event can be assigned.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    calendar_id (osid.id.Id): the ``Id`` of the ``Calendar``\n        arg:    superseding_event_id (osid.id.Id): the ``Id`` of the\n                ``superseding_event_id``\n", 
               "return_doc": "        return: (osid.id.IdList) - list of assignable calendar ``Ids``", 
               "error_doc": "        raise:  NullArgument - ``calendar_id`` or\n                ``superseding_event_id`` is ``null``\n        raise:  OperationFailed - unable to complete request", 
               "sphinx_param_doc": "        :param calendar_id: the ``Id`` of the ``Calendar``\n        :type calendar_id: ``osid.id.Id``\n        :param superseding_event_id: the ``Id`` of the ``superseding_event_id``\n        :type superseding_event_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: list of assignable calendar ``Ids``\n        :rtype: ``osid.id.IdList``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``calendar_id`` or ``superseding_event_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "calendar_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "superseding_event_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "osid.id.Id"
               ], 
               "return_type": "osid.id.IdList", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational"
               }
            }, 
            {
               "name": "assign_superseding_event_to_calendar", 
               "doc": {
                  "headline": "Adds an existing ``SupersedingEvent`` to a ``Calendar``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    superseding_event_id (osid.id.Id): the ``Id`` of the\n                ``SupersedingEvent``\n        arg:    calendar_id (osid.id.Id): the ``Id`` of the ``Calendar``\n", 
               "return_doc": "", 
               "error_doc": "        raise:  AlreadyExists - ``superseding_event_id`` is already\n                assigned to ``calendar_id``\n        raise:  NotFound - ``superseding_event_id`` or ``calendar_id``\n                not found\n        raise:  NullArgument - ``superseding_event_id`` or\n                ``calendar_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param superseding_event_id: the ``Id`` of the ``SupersedingEvent``\n        :type superseding_event_id: ``osid.id.Id``\n        :param calendar_id: the ``Id`` of the ``Calendar``\n        :type calendar_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``AlreadyExists`` -- ``superseding_event_id`` is already assigned to ``calendar_id``\n        :raise: ``NotFound`` -- ``superseding_event_id`` or ``calendar_id`` not found\n        :raise: ``NullArgument`` -- ``superseding_event_id`` or ``calendar_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "superseding_event_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "calendar_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {
                  "ALREADY_EXISTS": "User", 
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "unassign_superseding_event_from_calendar", 
               "doc": {
                  "headline": "Removes a ``SupersedingEvent`` from a ``Calendar``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    superseding_event_id (osid.id.Id): the ``Id`` of the\n                ``SupersedingEvent``\n        arg:    calendar_id (osid.id.Id): the ``Id`` of the ``Calendar``\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NotFound - ``superseding_event_id`` or ``calendar_id``\n                not found or ``superseding_event_id`` not assigned to\n                ``calendar_id``\n        raise:  NullArgument - ``superseding_event_id`` or\n                ``calendar_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param superseding_event_id: the ``Id`` of the ``SupersedingEvent``\n        :type superseding_event_id: ``osid.id.Id``\n        :param calendar_id: the ``Id`` of the ``Calendar``\n        :type calendar_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``superseding_event_id`` or ``calendar_id`` not found or ``superseding_event_id`` not assigned to ``calendar_id``\n        :raise: ``NullArgument`` -- ``superseding_event_id`` or ``calendar_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "superseding_event_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "calendar_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.calendaring.SupersedingEventSmartCalendarSession", 
         "shortname": "SupersedingEventSmartCalendarSession", 
         "category": "sessions", 
         "doc": {
            "headline": "This session manages queries and sequencing to create \"smart\" dynamic catalogs.", 
            "body": "    A ``SupersedingEventQuery`` can be retrieved from this session and\n    mapped to this ``Calendar`` to create a virtual collection of\n    ``SupersedingEvents``. The entries may be sequenced using the\n    ``SupersedingEventSearchOrder`` from this session.\n\n    This ``Calendar`` has a default query that matches any superseding\n    event and a default search order that specifies no sequencing. The\n    queries may be examined using a ``SupersedingEventQueryInspector``.\n    The query may be modified by converting the inspector back to a\n    ``SupersedingEventQuery``."
         }, 
         "inherit_fullnames": [
            "osid.OsidSession"
         ], 
         "inherit_shortnames": [
            "OsidSession"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidSession"
            }
         ], 
         "method_names": [
            "get_calendar_id", 
            "get_calendar", 
            "can_manage_smart_calendars", 
            "get_superseding_event_query", 
            "get_superseding_event_search_order", 
            "apply_superseding_event_query", 
            "inspect_superseding_event_query", 
            "apply_superseding_event_sequencing", 
            "get_superseding_event_query_from_inspector"
         ], 
         "methods": [
            {
               "name": "get_calendar_id", 
               "doc": {
                  "headline": "Gets the ``Calendar``  ``Id`` associated with this session.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.id.Id) - the ``Calendar Id`` associated with this\n                session", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the ``Calendar Id`` associated with this session\n        :rtype: ``osid.id.Id``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.id.Id", 
               "errors": {}
            }, 
            {
               "name": "get_calendar", 
               "doc": {
                  "headline": "Gets the ``Calendar`` associated with this session.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.Calendar) - the ``Calendar``\n                associated with this session", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the ``Calendar`` associated with this session\n        :rtype: ``osid.calendaring.Calendar``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.Calendar", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "can_manage_smart_calendars", 
               "doc": {
                  "headline": "Tests if this user can manage smart calendars.", 
                  "body": "        A return of true does not guarantee successful authorization. A\n        return of false indicates that it is known all methods in this\n        session will result in a ``PermissionDenied``. This is intended\n        as a hint to an application that may opt not to offer smart\n        operations."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``false`` if smart calendar methods are not\n                authorized, ``true`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``false`` if smart calendar methods are not authorized, ``true`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "get_superseding_event_query", 
               "doc": {
                  "headline": "Gets a superseding event query.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.SupersedingEventQuery) - the\n                superseding event query", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the superseding event query\n        :rtype: ``osid.calendaring.SupersedingEventQuery``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.SupersedingEventQuery", 
               "errors": {}
            }, 
            {
               "name": "get_superseding_event_search_order", 
               "doc": {
                  "headline": "Gets a superseding event search order.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.SupersedingEventSearchOrder) - the\n                superseding event search order", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the superseding event search order\n        :rtype: ``osid.calendaring.SupersedingEventSearchOrder``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.SupersedingEventSearchOrder", 
               "errors": {}
            }, 
            {
               "name": "apply_superseding_event_query", 
               "doc": {
                  "headline": "Applies a superseding event query to this calendar.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    superseding_event_query\n                (osid.calendaring.SupersedingEventQuery): the\n                superseding event query\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``superseding_event_query`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure occurred\n        raise:  Unsupported - ``superseding_event_query`` not of this\n                service", 
               "sphinx_param_doc": "        :param superseding_event_query: the superseding event query\n        :type superseding_event_query: ``osid.calendaring.SupersedingEventQuery``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``superseding_event_query`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure occurred\n        :raise: ``Unsupported`` -- ``superseding_event_query`` not of this service", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.calendaring.SupersedingEventQuery", 
                     "var_name": "superseding_event_query", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.calendaring.SupersedingEventQuery"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }, 
            {
               "name": "inspect_superseding_event_query", 
               "doc": {
                  "headline": "Gets a superseding event query inspector for this calendar.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.SupersedingEventQueryInspector) - the\n                superseding event query inspector", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure occurred", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the superseding event query inspector\n        :rtype: ``osid.calendaring.SupersedingEventQueryInspector``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure occurred", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.SupersedingEventQueryInspector", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "apply_superseding_event_sequencing", 
               "doc": {
                  "headline": "Applies a superseding event search order to this calendar.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    superseding_event_search_order\n                (osid.calendaring.SupersedingEventSearchOrder): the\n                superseding event search order\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``superseding_event_search_order`` is\n                ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure occurred\n        raise:  Unsupported - ``superseding_event_search_order`` not of\n                this service", 
               "sphinx_param_doc": "        :param superseding_event_search_order: the superseding event search order\n        :type superseding_event_search_order: ``osid.calendaring.SupersedingEventSearchOrder``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``superseding_event_search_order`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure occurred\n        :raise: ``Unsupported`` -- ``superseding_event_search_order`` not of this service", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.calendaring.SupersedingEventSearchOrder", 
                     "var_name": "superseding_event_search_order", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.calendaring.SupersedingEventSearchOrder"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_superseding_event_query_from_inspector", 
               "doc": {
                  "headline": "Gets a superseding event query from an inspector.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    superseding_event_query_inspector\n                (osid.calendaring.SupersedingEventQueryInspector): a\n                superseding event query inspector\n", 
               "return_doc": "        return: (osid.calendaring.SupersedingEventQuery) - the\n                superseding event query", 
               "error_doc": "        raise:  NullArgument - ``superseding_event_query_inspector`` is\n                ``null``\n        raise:  Unsupported - ``superseding_event_query_inspector`` is\n                not of this service", 
               "sphinx_param_doc": "        :param superseding_event_query_inspector: a superseding event query inspector\n        :type superseding_event_query_inspector: ``osid.calendaring.SupersedingEventQueryInspector``\n", 
               "sphinx_return_doc": "        :return: the superseding event query\n        :rtype: ``osid.calendaring.SupersedingEventQuery``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``superseding_event_query_inspector`` is ``null``\n        :raise: ``Unsupported`` -- ``superseding_event_query_inspector`` is not of this service", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.calendaring.SupersedingEventQueryInspector", 
                     "var_name": "superseding_event_query_inspector", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.calendaring.SupersedingEventQueryInspector"
               ], 
               "return_type": "osid.calendaring.SupersedingEventQuery", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.calendaring.OffsetEventLookupSession", 
         "shortname": "OffsetEventLookupSession", 
         "category": "sessions", 
         "doc": {
            "headline": "This session provides methods for retrieving ``OffsetEvents``.", 
            "body": ""
         }, 
         "inherit_fullnames": [
            "osid.OsidSession"
         ], 
         "inherit_shortnames": [
            "OsidSession"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidSession"
            }
         ], 
         "method_names": [
            "get_calendar_id", 
            "get_calendar", 
            "can_lookup_offset_events", 
            "use_comparative_offset_event_view", 
            "use_plenary_offset_event_view", 
            "use_federated_calendar_view", 
            "use_isolated_calendar_view", 
            "use_active_offset_event_view", 
            "use_any_status_offset_event_view", 
            "get_offset_event", 
            "get_offset_events_by_ids", 
            "get_offset_events_by_genus_type", 
            "get_offset_events_by_parent_genus_type", 
            "get_offset_events_by_record_type", 
            "get_offset_events_by_event", 
            "get_offset_events"
         ], 
         "methods": [
            {
               "name": "get_calendar_id", 
               "doc": {
                  "headline": "Gets the ``Calendar``  ``Id`` associated with this session.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.id.Id) - the ``Calendar Id`` associated with this\n                session", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the ``Calendar Id`` associated with this session\n        :rtype: ``osid.id.Id``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.id.Id", 
               "errors": {}
            }, 
            {
               "name": "get_calendar", 
               "doc": {
                  "headline": "Gets the ``Calendar`` associated with this session.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.Calendar) - the ``Calendar``\n                associated with this session", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the ``Calendar`` associated with this session\n        :rtype: ``osid.calendaring.Calendar``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.Calendar", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "can_lookup_offset_events", 
               "doc": {
                  "headline": "Tests if this user can perform ``OffsetEvent`` lookups.", 
                  "body": "        A return of true does not guarantee successful authorization. A\n        return of false indicates that it is known all methods in this\n        session will result in a ``PermissionDenied``. This is intended\n        as a hint to an application that may opt not to offer lookup\n        operations to unauthorized users."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``false`` if lookup methods are not\n                authorized, ``true`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``false`` if lookup methods are not authorized, ``true`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "use_comparative_offset_event_view", 
               "doc": {
                  "headline": "The returns from the lookup methods may omit or translate elements based on this session, such as authorization, and not result in an error.", 
                  "body": "        This view is used when greater interoperability is desired at\n        the expense of precision."
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "use_plenary_offset_event_view", 
               "doc": {
                  "headline": "A complete view of the ``OffsetEvent`` returns is desired.", 
                  "body": "        Methods will return what is requested or result in an error.\n        This view is used when greater precision is desired at the\n        expense of interoperability."
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "use_federated_calendar_view", 
               "doc": {
                  "headline": "Federates the view for methods in this session.", 
                  "body": "        A federated view will include offset events in calendars which\n        are children of this calendar in the calendar hierarchy."
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "use_isolated_calendar_view", 
               "doc": {
                  "headline": "Isolates the view for methods in this session.", 
                  "body": "        An isolated view restricts lookups to this calendar only."
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "use_active_offset_event_view", 
               "doc": {
                  "headline": "Only active offset events are returned by methods in this session.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "use_any_status_offset_event_view", 
               "doc": {
                  "headline": "All active and inactive offset events are returned by methods in this session.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "get_offset_event", 
               "doc": {
                  "headline": "Gets the ``OffsetEvent`` specified by its ``Id``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    offset_event_id (osid.id.Id): ``Id`` of the\n                ``OffsetEvent``\n", 
               "return_doc": "        return: (osid.calendaring.OffsetEvent) - the offset event", 
               "error_doc": "        raise:  NotFound - ``offset_event_id`` not found\n        raise:  NullArgument - ``offset_event_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param offset_event_id: ``Id`` of the ``OffsetEvent``\n        :type offset_event_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: the offset event\n        :rtype: ``osid.calendaring.OffsetEvent``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``offset_event_id`` not found\n        :raise: ``NullArgument`` -- ``offset_event_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "offset_event_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "osid.calendaring.OffsetEvent", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_offset_events_by_ids", 
               "doc": {
                  "headline": "Gets an ``OffsetEventList`` corresponding to the given ``IdList``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    offset_event_ids (osid.id.IdList): the list of ``Ids``\n                to retrieve\n", 
               "return_doc": "        return: (osid.calendaring.OffsetEventList) - the returned\n                ``OffsetEvent`` list", 
               "error_doc": "        raise:  NotFound - an ``Id was`` not found\n        raise:  NullArgument - ``offset_event_ids`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param offset_event_ids: the list of ``Ids`` to retrieve\n        :type offset_event_ids: ``osid.id.IdList``\n", 
               "sphinx_return_doc": "        :return: the returned ``OffsetEvent`` list\n        :rtype: ``osid.calendaring.OffsetEventList``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- an ``Id was`` not found\n        :raise: ``NullArgument`` -- ``offset_event_ids`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.IdList", 
                     "var_name": "offset_event_ids", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.IdList"
               ], 
               "return_type": "osid.calendaring.OffsetEventList", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_offset_events_by_genus_type", 
               "doc": {
                  "headline": "Gets an ``OffsetEventList`` corresponding to the given offset event genus ``Type`` which does not include offset events of genus types derived from the specified ``Type``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    offset_event_genus_type (osid.type.Type): an offset\n                event genus type\n", 
               "return_doc": "        return: (osid.calendaring.OffsetEventList) - the returned\n                ``OffsetEvent`` list", 
               "error_doc": "        raise:  NullArgument - ``offset_event_genus_type`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param offset_event_genus_type: an offset event genus type\n        :type offset_event_genus_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "        :return: the returned ``OffsetEvent`` list\n        :rtype: ``osid.calendaring.OffsetEventList``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``offset_event_genus_type`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "offset_event_genus_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "osid.calendaring.OffsetEventList", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_offset_events_by_parent_genus_type", 
               "doc": {
                  "headline": "Gets an ``OffsetEventList`` corresponding to the given offset event genus ``Type`` and include any additional offset event with genus types derived from the specified ``Type``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    offset_event_genus_type (osid.type.Type): an offset\n                event genus type\n", 
               "return_doc": "        return: (osid.calendaring.OffsetEventList) - the returned\n                ``OffsetEvent`` list", 
               "error_doc": "        raise:  NullArgument - ``offset_event_genus_type`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param offset_event_genus_type: an offset event genus type\n        :type offset_event_genus_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "        :return: the returned ``OffsetEvent`` list\n        :rtype: ``osid.calendaring.OffsetEventList``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``offset_event_genus_type`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "offset_event_genus_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "osid.calendaring.OffsetEventList", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_offset_events_by_record_type", 
               "doc": {
                  "headline": "Gets an ``OffsetEventList`` containing the given offset event record ``Type``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    offset_eventrecord_type (osid.type.Type): an offset\n                event record type\n", 
               "return_doc": "        return: (osid.calendaring.OffsetEventList) - the returned\n                ``OffsetEvent`` list", 
               "error_doc": "        raise:  NullArgument - ``offset_event_record_type`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param offset_eventrecord_type: an offset event record type\n        :type offset_eventrecord_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "        :return: the returned ``OffsetEvent`` list\n        :rtype: ``osid.calendaring.OffsetEventList``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``offset_event_record_type`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "offset_eventrecord_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "osid.calendaring.OffsetEventList", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_offset_events_by_event", 
               "doc": {
                  "headline": "Gets the ``OffsetEvents`` using the given event as a start or ending offset.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    event_id (osid.id.Id): ``Id`` of the related event\n", 
               "return_doc": "        return: (osid.calendaring.OffsetEventList) - the offset events", 
               "error_doc": "        raise:  NullArgument - ``event_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param event_id: ``Id`` of the related event\n        :type event_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: the offset events\n        :rtype: ``osid.calendaring.OffsetEventList``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``event_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "event_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "osid.calendaring.OffsetEventList", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_offset_events", 
               "doc": {
                  "headline": "Gets all ``OffsetEvents``.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.OffsetEventList) - an\n                ``OffsetEventList``", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: an ``OffsetEventList``\n        :rtype: ``osid.calendaring.OffsetEventList``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.OffsetEventList", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.calendaring.OffsetEventQuerySession", 
         "shortname": "OffsetEventQuerySession", 
         "category": "sessions", 
         "doc": {
            "headline": "This session provides methods for searching ``OffsetEvent`` objects.", 
            "body": "    The search query is constructed using the ``OffsetEventQuery``. The\n    offset event record ``Type`` also specifies the record for the\n    offset event query.\n\n    This session defines views that offer differing behaviors for\n    searching.\n    \n      * federated calendar view: searches include offset events in\n        calendars of which this calendar is an ancestor in the calendar\n        hierarchy\n      * isolated calendar view: searches are restricted to offset events\n        in this calendar\n\n    \n    ``OffsetEvents`` may have a query record indicated by their\n    respective record types. The query record is accessed via the\n    ``OffsetEventQuery``."
         }, 
         "inherit_fullnames": [
            "osid.OsidSession"
         ], 
         "inherit_shortnames": [
            "OsidSession"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidSession"
            }
         ], 
         "method_names": [
            "get_calendar_id", 
            "get_calendar", 
            "can_search_offset_events", 
            "use_federated_calendar_view", 
            "use_isolated_calendar_view", 
            "get_offset_event_query", 
            "get_offset_events_by_query"
         ], 
         "methods": [
            {
               "name": "get_calendar_id", 
               "doc": {
                  "headline": "Gets the ``Calendar``  ``Id`` associated with this session.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.id.Id) - the ``Calendar Id`` associated with this\n                session", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the ``Calendar Id`` associated with this session\n        :rtype: ``osid.id.Id``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.id.Id", 
               "errors": {}
            }, 
            {
               "name": "get_calendar", 
               "doc": {
                  "headline": "Gets the ``Calendar`` associated with this session.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.Calendar) - the ``Calendar``\n                associated with this session", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the ``Calendar`` associated with this session\n        :rtype: ``osid.calendaring.Calendar``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.Calendar", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "can_search_offset_events", 
               "doc": {
                  "headline": "Tests if this user can perform ``OffsetEvents`` searches.", 
                  "body": "        A return of true does not guarantee successful authorization. A\n        return of false indicates that it is known all methods in this\n        session will result in a ``PermissionDenied``. This is intended\n        as a hint to an application that may opt not to offer search\n        operations to unauthorized users."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``false`` if search methods are not\n                authorized, ``true`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``false`` if search methods are not authorized, ``true`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "use_federated_calendar_view", 
               "doc": {
                  "headline": "Federates the view for methods in this session.", 
                  "body": "        A federated view will include offset events in calendars which\n        are children of this calendar in the calendar hierarchy."
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "use_isolated_calendar_view", 
               "doc": {
                  "headline": "Isolates the view for methods in this session.", 
                  "body": "        An isolated view restricts searches to this calendar only."
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "get_offset_event_query", 
               "doc": {
                  "headline": "Gets an offset event query.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.OffsetEventQuery) - the offset event\n                query", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the offset event query\n        :rtype: ``osid.calendaring.OffsetEventQuery``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.OffsetEventQuery", 
               "errors": {}
            }, 
            {
               "name": "get_offset_events_by_query", 
               "doc": {
                  "headline": "Gets a list of ``OffsetEvents`` matching the given offset event query.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    offset_event_query (osid.calendaring.OffsetEventQuery):\n                the offset event query\n", 
               "return_doc": "        return: (osid.calendaring.OffsetEventList) - the returned\n                ``OffsetEventList``", 
               "error_doc": "        raise:  NullArgument - ``offset_event_query`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        raise:  Unsupported - ``offset_event_query`` is not of this\n                service", 
               "sphinx_param_doc": "        :param offset_event_query: the offset event query\n        :type offset_event_query: ``osid.calendaring.OffsetEventQuery``\n", 
               "sphinx_return_doc": "        :return: the returned ``OffsetEventList``\n        :rtype: ``osid.calendaring.OffsetEventList``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``offset_event_query`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure\n        :raise: ``Unsupported`` -- ``offset_event_query`` is not of this service", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.calendaring.OffsetEventQuery", 
                     "var_name": "offset_event_query", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.calendaring.OffsetEventQuery"
               ], 
               "return_type": "osid.calendaring.OffsetEventList", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.calendaring.OffsetEventSearchSession", 
         "shortname": "OffsetEventSearchSession", 
         "category": "sessions", 
         "doc": {
            "headline": "This session provides methods for searching ``OffsetEvent`` objects.", 
            "body": "    The search query is constructed using the ``OffsetEventQuery``. The\n    offset event record ``Type`` also specifies the record for the\n    offset event query.\n\n    ``get_offset_events_by_query()`` is the basic search method and\n    returns a list of ``OffsetEvents``. A more advanced search may be\n    performed with ``getOffsetEventsBySearch()``. It accepts an\n    ``OffsetEventSearch`` in addition to the query for the purpose of\n    specifying additional options affecting the entire search, such as\n    ordering. ``get_offset_events_by_search()`` returns an\n    ``OffsetEventSearchResults`` that can be used to access the\n    resulting ``OffsetEventList`` or be used to perform a search within\n    the result set through ``OffsetEventSearch``.\n    \n    This session defines views that offer differing behaviors for\n    searching.\n    \n      * federated calendar view: searches include offset events in\n        calendars of which this calendar is a ancestor in the calendar\n        hierarchy\n      * isolated calendar view: searches are restricted to offset events\n        in this calendar\n\n    \n    Offset events may have a query record indicated by their respective\n    record types. The query record is accessed via the\n    ``OffsetEventQuery``."
         }, 
         "inherit_fullnames": [
            "osid.calendaring.OffsetEventQuerySession"
         ], 
         "inherit_shortnames": [
            "OffsetEventQuerySession"
         ], 
         "inherit_pkg_names": [
            "calendaring"
         ], 
         "inheritance": [
            {
               "pkg_name": "calendaring", 
               "name": "OffsetEventQuerySession"
            }
         ], 
         "method_names": [
            "get_offset_event_search", 
            "get_offset_event_search_order", 
            "get_offset_events_by_search", 
            "get_offset_event_query_from_inspector"
         ], 
         "methods": [
            {
               "name": "get_offset_event_search", 
               "doc": {
                  "headline": "Gets an offset event search.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.OffsetEventSearch) - the offset event\n                search", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the offset event search\n        :rtype: ``osid.calendaring.OffsetEventSearch``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.OffsetEventSearch", 
               "errors": {}
            }, 
            {
               "name": "get_offset_event_search_order", 
               "doc": {
                  "headline": "Gets an offset event search order.", 
                  "body": "        The ``OffsetEventSearchOrder`` is supplied to an\n        ``OffsetEventSearch`` to specify the ordering of results."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.OffsetEventSearchOrder) - the offset\n                event search order", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the offset event search order\n        :rtype: ``osid.calendaring.OffsetEventSearchOrder``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.OffsetEventSearchOrder", 
               "errors": {}
            }, 
            {
               "name": "get_offset_events_by_search", 
               "doc": {
                  "headline": "Gets the search results matching the given search query using the given search.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    offset_event_query (osid.calendaring.OffsetEventQuery):\n                the offset event search query\n        arg:    offset_event_search\n                (osid.calendaring.OffsetEventSearch): the offset event\n                search\n", 
               "return_doc": "        return: (osid.calendaring.OffsetEventSearchResults) - the\n                returned search results", 
               "error_doc": "        raise:  NullArgument - ``offset_event_query`` or\n                ``offset_event_search`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        raise:  Unsupported - ``offset_event_query`` is not of this\n                service", 
               "sphinx_param_doc": "        :param offset_event_query: the offset event search query\n        :type offset_event_query: ``osid.calendaring.OffsetEventQuery``\n        :param offset_event_search: the offset event search\n        :type offset_event_search: ``osid.calendaring.OffsetEventSearch``\n", 
               "sphinx_return_doc": "        :return: the returned search results\n        :rtype: ``osid.calendaring.OffsetEventSearchResults``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``offset_event_query`` or ``offset_event_search`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure\n        :raise: ``Unsupported`` -- ``offset_event_query`` is not of this service", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.calendaring.OffsetEventQuery", 
                     "var_name": "offset_event_query", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.calendaring.OffsetEventSearch", 
                     "var_name": "offset_event_search", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.calendaring.OffsetEventQuery", 
                  "osid.calendaring.OffsetEventSearch"
               ], 
               "return_type": "osid.calendaring.OffsetEventSearchResults", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_offset_event_query_from_inspector", 
               "doc": {
                  "headline": "Gets an offset event query from an inspector.", 
                  "body": "        The inspector is available from an ``OffsetEventSearchResults``."
               }, 
               "arg_doc": "        arg:    offset_event_query_inspector\n                (osid.calendaring.OffsetEventQueryInspector): an offset\n                event query inspector\n", 
               "return_doc": "        return: (osid.calendaring.OffsetEventQuery) - the offset event\n                query", 
               "error_doc": "        raise:  NullArgument - ``offset_event_query_inspector`` is\n                ``null``\n        raise:  Unsupported - ``offset_event_query_inspector`` is not of\n                this service", 
               "sphinx_param_doc": "        :param offset_event_query_inspector: an offset event query inspector\n        :type offset_event_query_inspector: ``osid.calendaring.OffsetEventQueryInspector``\n", 
               "sphinx_return_doc": "        :return: the offset event query\n        :rtype: ``osid.calendaring.OffsetEventQuery``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``offset_event_query_inspector`` is ``null``\n        :raise: ``Unsupported`` -- ``offset_event_query_inspector`` is not of this service", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.calendaring.OffsetEventQueryInspector", 
                     "var_name": "offset_event_query_inspector", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.calendaring.OffsetEventQueryInspector"
               ], 
               "return_type": "osid.calendaring.OffsetEventQuery", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.calendaring.OffsetEventAdminSession", 
         "shortname": "OffsetEventAdminSession", 
         "category": "sessions", 
         "doc": {
            "headline": "This session creates, updates, and deletes ``Offset Events``.", 
            "body": "    The data for create and update is provided by the consumer via the\n    form object. ``OsidForms`` are requested for each create or update\n    and may not be reused.\n\n    Create and update operations differ in their usage. To create an\n    ``OffsetEvent,`` an ``OffsetEventForm`` is requested using\n    ``get_offset_event_form_for_create()`` specifying the desired record\n    ``Types`` or none if no record ``Types`` are needed. The returned\n    ``OffsetEventForm`` will indicate that it is to be used with a\n    create operation and can be used to examine metdata or validate data\n    prior to creation. Once the ``OffsetEventForm`` is submiited to a\n    create operation, it cannot be reused with another create operation\n    unless the first operation was unsuccessful. Each\n    ``OffsetEventForm`` corresponds to an attempted transaction.\n    \n    For updates, ``OffsetEventForms`` are requested to the\n    ``OffsetEvent``  ``Id`` that is to be updated using\n    ``getOffsetEventFormForUpdate()``. Similarly, the ``OffsetventForm``\n    has metadata about the data that can be updated and it can perform\n    validation before submitting the update. The ``OffsetEventForm`` can\n    only be used once for a successful update and cannot be reused.\n    \n    The delete operations delete ``Offset Events``. To unmap an\n    ``OffsetEvent`` from the current ``Calendar,`` the\n    ``OffstEventCalendarAssignmentSession`` should be used. These delete\n    operations attempt to remove the ``OffsetEvent`` itself thus\n    removing it from all known ``Calendar`` catalogs.\n    \n    This session includes an ``Id`` aliasing mechanism to assign an\n    external ``Id`` to an internally assigned Id."
         }, 
         "inherit_fullnames": [
            "osid.OsidSession"
         ], 
         "inherit_shortnames": [
            "OsidSession"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidSession"
            }
         ], 
         "method_names": [
            "get_calendar_id", 
            "get_calendar", 
            "can_create_offset_events", 
            "can_create_offset_event_with_record_types", 
            "get_offset_event_form_for_create", 
            "create_offset_event", 
            "can_update_offset_events", 
            "get_offset_event_form_for_update", 
            "update_offset_event", 
            "can_delete_offset_events", 
            "delete_offset_event", 
            "can_manage_offset_event_aliases", 
            "alias_offset_event"
         ], 
         "methods": [
            {
               "name": "get_calendar_id", 
               "doc": {
                  "headline": "Gets the ``Calendar``  ``Id`` associated with this session.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.id.Id) - the ``Calendar Id`` associated with this\n                session", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the ``Calendar Id`` associated with this session\n        :rtype: ``osid.id.Id``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.id.Id", 
               "errors": {}
            }, 
            {
               "name": "get_calendar", 
               "doc": {
                  "headline": "Gets the ``Calendar`` associated with this session.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.Calendar) - the ``Calendar``\n                associated with this session", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the ``Calendar`` associated with this session\n        :rtype: ``osid.calendaring.Calendar``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.Calendar", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "can_create_offset_events", 
               "doc": {
                  "headline": "Tests if this user can create ``OffsetEvents``.", 
                  "body": "        A return of true does not guarantee successful authorization. A\n        return of false indicates that it is known creating an\n        ``OffsetEvent`` will result in a ``PermissionDenied``. This is\n        intended as a hint to an application that may opt not to offer\n        create operations to an unauthorized user."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``false`` if ``OffsetEvent`` creation is not\n                authorized, ``true`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``false`` if ``OffsetEvent`` creation is not authorized, ``true`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "can_create_offset_event_with_record_types", 
               "doc": {
                  "headline": "Tests if this user can create a single ``OffsetEvent`` using the desired record types.", 
                  "body": "        While ``CalendaringManager.getOffsetEventRecordTypes()`` can be\n        used to examine which records are supported, this method tests\n        which record(s) are required for creating a specific\n        ``OffsetEvent``. Providing an empty array tests if an\n        ``OffsetEvent`` can be created with no records."
               }, 
               "arg_doc": "        arg:    offset_event_record_types (osid.type.Type[]): array of\n                offset event record types\n", 
               "return_doc": "        return: (boolean) - ``true`` if ``OffsetEvent`` creation using\n                the specified record ``Types`` is supported, ``false``\n                otherwise", 
               "error_doc": "        raise:  NullArgument - ``offset_event_record_types`` is ``null``", 
               "sphinx_param_doc": "        :param offset_event_record_types: array of offset event record types\n        :type offset_event_record_types: ``osid.type.Type[]``\n", 
               "sphinx_return_doc": "        :return: ``true`` if ``OffsetEvent`` creation using the specified record ``Types`` is supported, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``offset_event_record_types`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type[]", 
                     "var_name": "offset_event_record_types", 
                     "array": true
                  }
               ], 
               "arg_types": [
                  "osid.type.Type[]"
               ], 
               "return_type": "boolean", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "get_offset_event_form_for_create", 
               "doc": {
                  "headline": "Gets the offset event form for creating new offset events.", 
                  "body": "        A new form should be requested for each create transaction."
               }, 
               "arg_doc": "        arg:    offset_event_record_types (osid.type.Type[]): array of\n                offset event record types\n", 
               "return_doc": "        return: (osid.calendaring.OffsetEventForm) - the offset event\n                form", 
               "error_doc": "        raise:  NullArgument - ``offset_event_record_types`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        raise:  Unsupported - unable to get form for requested recod\n                types", 
               "sphinx_param_doc": "        :param offset_event_record_types: array of offset event record types\n        :type offset_event_record_types: ``osid.type.Type[]``\n", 
               "sphinx_return_doc": "        :return: the offset event form\n        :rtype: ``osid.calendaring.OffsetEventForm``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``offset_event_record_types`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure\n        :raise: ``Unsupported`` -- unable to get form for requested recod types", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type[]", 
                     "var_name": "offset_event_record_types", 
                     "array": true
                  }
               ], 
               "arg_types": [
                  "osid.type.Type[]"
               ], 
               "return_type": "osid.calendaring.OffsetEventForm", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }, 
            {
               "name": "create_offset_event", 
               "doc": {
                  "headline": "Creates a new ``OffsetEvent``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    offset_event_form (osid.calendaring.OffsetEventForm):\n                the form for this ``OffsetEvent``\n", 
               "return_doc": "        return: (osid.calendaring.OffsetEvent) - the new ``OffsetEvent``", 
               "error_doc": "        raise:  IllegalState - ``offset_event_form`` already used in a\n                create transaction\n        raise:  InvalidArgument - one or more of the form elements is\n                invalid\n        raise:  NullArgument - ``offset_event_form`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        raise:  Unsupported - ``offset_event_form`` did not originate\n                from ``get_offset_event_form_for_create()``", 
               "sphinx_param_doc": "        :param offset_event_form: the form for this ``OffsetEvent``\n        :type offset_event_form: ``osid.calendaring.OffsetEventForm``\n", 
               "sphinx_return_doc": "        :return: the new ``OffsetEvent``\n        :rtype: ``osid.calendaring.OffsetEvent``", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- ``offset_event_form`` already used in a create transaction\n        :raise: ``InvalidArgument`` -- one or more of the form elements is invalid\n        :raise: ``NullArgument`` -- ``offset_event_form`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure\n        :raise: ``Unsupported`` -- ``offset_event_form`` did not originate from ``get_offset_event_form_for_create()``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.calendaring.OffsetEventForm", 
                     "var_name": "offset_event_form", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.calendaring.OffsetEventForm"
               ], 
               "return_type": "osid.calendaring.OffsetEvent", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract", 
                  "INVALID_ARGUMENT": "ConsumerContract", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }, 
            {
               "name": "can_update_offset_events", 
               "doc": {
                  "headline": "Tests if this user can update ``OffsetEvents``.", 
                  "body": "        A return of true does not guarantee successful authorization. A\n        return of false indicates that it is known updating an\n        ``OffsetEvent`` will result in a ``PermissionDenied``. This is\n        intended as a hint to an application that may opt not to offer\n        update operations to an unauthorized user."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``false`` if offset event modification is\n                not authorized, ``true`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``false`` if offset event modification is not authorized, ``true`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "get_offset_event_form_for_update", 
               "doc": {
                  "headline": "Gets the offset event form for updating an existing offset event.", 
                  "body": "        A new offset event form should be requested for each update\n        transaction."
               }, 
               "arg_doc": "        arg:    offset_event_id (osid.id.Id): the ``Id`` of the\n                ``OffsetEvent``\n", 
               "return_doc": "        return: (osid.calendaring.OffsetEventForm) - the offset event\n                form", 
               "error_doc": "        raise:  NotFound - ``offset_event_id`` is not found\n        raise:  NullArgument - ``offset_event_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param offset_event_id: the ``Id`` of the ``OffsetEvent``\n        :type offset_event_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: the offset event form\n        :rtype: ``osid.calendaring.OffsetEventForm``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``offset_event_id`` is not found\n        :raise: ``NullArgument`` -- ``offset_event_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "offset_event_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "osid.calendaring.OffsetEventForm", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "update_offset_event", 
               "doc": {
                  "headline": "Updates an existing offset event.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    offset_event_form (osid.calendaring.OffsetEventForm):\n                the form containing the elements to be updated\n", 
               "return_doc": "", 
               "error_doc": "        raise:  IllegalState - ``offset_event_form`` already used in an\n                update transaction\n        raise:  InvalidArgument - the form contains an invalid value\n        raise:  NullArgument - ``offset_event_form`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        raise:  Unsupported - ``offset_event_form`` did not originate\n                from ``get_offset_event_form_for_update()``", 
               "sphinx_param_doc": "        :param offset_event_form: the form containing the elements to be updated\n        :type offset_event_form: ``osid.calendaring.OffsetEventForm``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- ``offset_event_form`` already used in an update transaction\n        :raise: ``InvalidArgument`` -- the form contains an invalid value\n        :raise: ``NullArgument`` -- ``offset_event_form`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure\n        :raise: ``Unsupported`` -- ``offset_event_form`` did not originate from ``get_offset_event_form_for_update()``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.calendaring.OffsetEventForm", 
                     "var_name": "offset_event_form", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.calendaring.OffsetEventForm"
               ], 
               "return_type": "", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract", 
                  "INVALID_ARGUMENT": "ConsumerContract", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }, 
            {
               "name": "can_delete_offset_events", 
               "doc": {
                  "headline": "Tests if this user can delete ``OffsetEvents``.", 
                  "body": "        A return of true does not guarantee successful authorization. A\n        return of false indicates that it is known deleting an\n        ``OffsetEvent`` will result in a ``PermissionDenied``. This is\n        intended as a hint to an application that may opt not to offer\n        delete operations to an unauthorized user."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``false`` if ``OffsetEvent`` deletion is not\n                authorized, ``true`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``false`` if ``OffsetEvent`` deletion is not authorized, ``true`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "delete_offset_event", 
               "doc": {
                  "headline": "Deletes the ``OffsetEvent`` identified by the given ``Id``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    offset_event_id (osid.id.Id): the ``Id`` of the\n                ``OffsetEvent`` to delete\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NotFound - an ``OffsetEvent`` was not found identified\n                by the given ``Id``\n        raise:  NullArgument - ``offset_event_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param offset_event_id: the ``Id`` of the ``OffsetEvent`` to delete\n        :type offset_event_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- an ``OffsetEvent`` was not found identified by the given ``Id``\n        :raise: ``NullArgument`` -- ``offset_event_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "offset_event_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "can_manage_offset_event_aliases", 
               "doc": {
                  "headline": "Tests if this user can manage ``Id`` aliases for ``OffsetEvents``.", 
                  "body": "        A return of true does not guarantee successful authorization. A\n        return of false indicates that it is known changing an alias\n        will result in a ``PermissionDenied``. This is intended as a\n        hint to an application that may opt not to offer alias\n        operations to an unauthorized user."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``false`` if ``OffsetEvent`` aliasing is not\n                authorized, ``true`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``false`` if ``OffsetEvent`` aliasing is not authorized, ``true`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "alias_offset_event", 
               "doc": {
                  "headline": "Adds an ``Id`` to an ``OffsetEvent`` for the purpose of creating compatibility.", 
                  "body": "        The primary ``Id`` of the ``OffsetEvent`` is determined by the\n        provider. The new ``Id`` performs as an alias to the primary\n        ``Id``. If the alias is a pointer to another offset event, it is\n        reassigned to the given offset event ``Id``."
               }, 
               "arg_doc": "        arg:    offset_event_id (osid.id.Id): the ``Id`` of an\n                ``OffsetEvent``\n        arg:    alias_id (osid.id.Id): the alias ``Id``\n", 
               "return_doc": "", 
               "error_doc": "        raise:  AlreadyExists - ``alias_id`` is already assigned\n        raise:  NotFound - ``offset_event_id`` not found\n        raise:  NullArgument - ``offset_event_id`` or ``alias_id`` is\n                ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param offset_event_id: the ``Id`` of an ``OffsetEvent``\n        :type offset_event_id: ``osid.id.Id``\n        :param alias_id: the alias ``Id``\n        :type alias_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``AlreadyExists`` -- ``alias_id`` is already assigned\n        :raise: ``NotFound`` -- ``offset_event_id`` not found\n        :raise: ``NullArgument`` -- ``offset_event_id`` or ``alias_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "offset_event_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "alias_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {
                  "ALREADY_EXISTS": "User", 
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.calendaring.OffsetEventNotificationSession", 
         "shortname": "OffsetEventNotificationSession", 
         "category": "sessions", 
         "doc": {
            "headline": "This session defines methods to receive asynchronous notifications on adds/changes to ``OffsetEvent`` objects.", 
            "body": "    This session is intended for consumers needing to synchronize their\n    state with this service without the use of polling. Notifications\n    are cancelled when this session is closed.\n\n    The views defined in this session correspond to the views in the\n    ``OffsetEventLookupSession``."
         }, 
         "inherit_fullnames": [
            "osid.OsidSession"
         ], 
         "inherit_shortnames": [
            "OsidSession"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidSession"
            }
         ], 
         "method_names": [
            "get_calendar_id", 
            "get_calendar", 
            "can_register_for_offset_event_notifications", 
            "use_federated_calendar_view", 
            "use_isolated_calendar_view", 
            "register_for_new_offset_events", 
            "register_for_changed_offset_events", 
            "register_for_changed_offset_event", 
            "register_for_deleted_offset_events", 
            "register_for_deleted_offset_event"
         ], 
         "methods": [
            {
               "name": "get_calendar_id", 
               "doc": {
                  "headline": "Gets the ``Calendar``  ``Id`` associated with this session.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.id.Id) - the ``Calendar Id`` associated with this\n                session", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the ``Calendar Id`` associated with this session\n        :rtype: ``osid.id.Id``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.id.Id", 
               "errors": {}
            }, 
            {
               "name": "get_calendar", 
               "doc": {
                  "headline": "Gets the ``Calendar`` associated with this session.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.Calendar) - the ``Calendar``\n                associated with this session", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the ``Calendar`` associated with this session\n        :rtype: ``osid.calendaring.Calendar``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.Calendar", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "can_register_for_offset_event_notifications", 
               "doc": {
                  "headline": "Tests if this user can register for ``OffsetEvent`` notifications.", 
                  "body": "        A return of true does not guarantee successful authorization. A\n        return of false indicates that it is known all methods in this\n        session will result in a ``PermissionDenied``. This is intended\n        as a hint to an application that may opt not to offer\n        notification operations."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``false`` if notification methods are not\n                authorized, ``true`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``false`` if notification methods are not authorized, ``true`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "use_federated_calendar_view", 
               "doc": {
                  "headline": "Federates the view for methods in this session.", 
                  "body": "        A federated view will include notifications for events in\n        calendars which are children of this calendar in the calendar\n        hierarchy."
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "use_isolated_calendar_view", 
               "doc": {
                  "headline": "Isolates the view for methods in this session.", 
                  "body": "        An isolated view restricts notifications to this calendar only."
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "register_for_new_offset_events", 
               "doc": {
                  "headline": "Register for notifications of new offset events.", 
                  "body": "        ``OffsetEventReceiver.newOffsetEvent()`` is invoked when a new\n        offset event is created."
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "register_for_changed_offset_events", 
               "doc": {
                  "headline": "Registers for notification of updated offset events.", 
                  "body": "        ``OffsetEventReceiver.changedOffsetEvent()`` is invoked when an\n        offset event is changed."
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "register_for_changed_offset_event", 
               "doc": {
                  "headline": "Registers for notification of an updated offset event.", 
                  "body": "        ``OffsetEventReceiver.changedOffsetEvent()`` is invoked when the\n        specified offset event is changed."
               }, 
               "arg_doc": "        arg:    offset_event_id (osid.id.Id): the ``Id`` of the\n                ``OffsetEventId`` to monitor\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``offset_event_id is null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param offset_event_id: the ``Id`` of the ``OffsetEventId`` to monitor\n        :type offset_event_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``offset_event_id is null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "offset_event_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "register_for_deleted_offset_events", 
               "doc": {
                  "headline": "Registers for notification of deleted offset events.", 
                  "body": "        ``OffsetEventReceiver.deletedOffsetEvent()`` is invoked when an\n        offset event is removed from this calendar."
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "register_for_deleted_offset_event", 
               "doc": {
                  "headline": "Registers for notification of a deleted offset event.", 
                  "body": "        ``OffsetEventReceiver.changedOffsetEvent()`` is invoked when the\n        specified offset event is removed from this calendar."
               }, 
               "arg_doc": "        arg:    offset_event_id (osid.id.Id): the ``Id`` of the\n                ``OffsetEvent`` to monitor\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``offset_eventid is null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param offset_event_id: the ``Id`` of the ``OffsetEvent`` to monitor\n        :type offset_event_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``offset_eventid is null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "offset_event_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.calendaring.OffsetEventCalendarSession", 
         "shortname": "OffsetEventCalendarSession", 
         "category": "sessions", 
         "doc": {
            "headline": "This session provides methods to retrieve ``OffsetEvent`` to ``Calendar`` mappings.", 
            "body": "    An ``OffsetEvent`` may appear in multiple ``Calendars``. Each\n    ``Calendar`` may have its own authorizations governing who is\n    allowed to look at it.\n\n    This lookup session defines two views:\n    \n      * comparative view: elements may be silently omitted or re-ordered\n      * plenary view: provides a complete result set or is an error\n        condition\n"
         }, 
         "inherit_fullnames": [
            "osid.OsidSession"
         ], 
         "inherit_shortnames": [
            "OsidSession"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidSession"
            }
         ], 
         "method_names": [
            "can_lookup_event_calendar_mappings", 
            "use_comparative_calendar_view", 
            "use_plenary_calendar_view", 
            "get_offset_event_ids_by_calendar", 
            "get_offset_events_by_calendar", 
            "get_offset_event_ids_by_calendars", 
            "get_offset_events_by_calendars", 
            "get_calendar_ids_by_offset_event", 
            "get_calendars_by_offset_event"
         ], 
         "methods": [
            {
               "name": "can_lookup_event_calendar_mappings", 
               "doc": {
                  "headline": "Tests if this user can perform lookups of event/calendar mappings.", 
                  "body": "        A return of true does not guarantee successful authorization. A\n        return of false indicates that it is known lookup methods in\n        this session will result in a ``PermissionDenied``. This is\n        intended as a hint to an application that may opt not to offer\n        lookup operations to unauthorized users."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``false`` if looking up mappings is not\n                authorized, ``true`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``false`` if looking up mappings is not authorized, ``true`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "use_comparative_calendar_view", 
               "doc": {
                  "headline": "The returns from the lookup methods may omit or translate elements based on this session, such as authorization, and not result in an error.", 
                  "body": "        This view is used when greater interoperability is desired at\n        the expense of precision."
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "use_plenary_calendar_view", 
               "doc": {
                  "headline": "A complete view of the ``Event`` and ``Calendar`` returns is desired.", 
                  "body": "        Methods will return what is requested or result in an error.\n        This view is used when greater precision is desired at the\n        expense of interoperability."
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "get_offset_event_ids_by_calendar", 
               "doc": {
                  "headline": "Gets the list of ``OffsetEvent``  ``Ids`` associated with a ``Calendar``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    calendar_id (osid.id.Id): ``Id`` of the ``Calendar``\n", 
               "return_doc": "        return: (osid.id.IdList) - list of related offset event ``Ids``", 
               "error_doc": "        raise:  NotFound - ``calendar_id`` is not found\n        raise:  NullArgument - ``calendar_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param calendar_id: ``Id`` of the ``Calendar``\n        :type calendar_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: list of related offset event ``Ids``\n        :rtype: ``osid.id.IdList``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``calendar_id`` is not found\n        :raise: ``NullArgument`` -- ``calendar_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "calendar_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "osid.id.IdList", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_offset_events_by_calendar", 
               "doc": {
                  "headline": "Gets the list of ``OffsetEvents`` associated with a ``Calendar``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    calendar_id (osid.id.Id): ``Id`` of the ``Calendar``\n", 
               "return_doc": "        return: (osid.calendaring.OffsetEventList) - list of related\n                offset events", 
               "error_doc": "        raise:  NotFound - ``calendar_id`` is not found\n        raise:  NullArgument - ``calendar_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param calendar_id: ``Id`` of the ``Calendar``\n        :type calendar_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: list of related offset events\n        :rtype: ``osid.calendaring.OffsetEventList``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``calendar_id`` is not found\n        :raise: ``NullArgument`` -- ``calendar_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "calendar_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "osid.calendaring.OffsetEventList", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_offset_event_ids_by_calendars", 
               "doc": {
                  "headline": "Gets the list of ``OffsetEvent Ids`` corresponding to a list of ``Calendars``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    calendar_ids (osid.id.IdList): list of calendar ``Ids``\n", 
               "return_doc": "        return: (osid.id.IdList) - list of offset event ``Ids``", 
               "error_doc": "        raise:  NullArgument - ``calendar_ids`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param calendar_ids: list of calendar ``Ids``\n        :type calendar_ids: ``osid.id.IdList``\n", 
               "sphinx_return_doc": "        :return: list of offset event ``Ids``\n        :rtype: ``osid.id.IdList``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``calendar_ids`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.IdList", 
                     "var_name": "calendar_ids", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.IdList"
               ], 
               "return_type": "osid.id.IdList", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_offset_events_by_calendars", 
               "doc": {
                  "headline": "Gets the list of ``OffsetEvents`` corresponding to a list of ``Calendars``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    calendar_ids (osid.id.IdList): list of calendar ``Ids``\n", 
               "return_doc": "        return: (osid.calendaring.OffsetEventList) - list of offset\n                events", 
               "error_doc": "        raise:  NullArgument - ``calendar_ids`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param calendar_ids: list of calendar ``Ids``\n        :type calendar_ids: ``osid.id.IdList``\n", 
               "sphinx_return_doc": "        :return: list of offset events\n        :rtype: ``osid.calendaring.OffsetEventList``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``calendar_ids`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.IdList", 
                     "var_name": "calendar_ids", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.IdList"
               ], 
               "return_type": "osid.calendaring.OffsetEventList", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_calendar_ids_by_offset_event", 
               "doc": {
                  "headline": "Gets the list of ``Calendar``  ``Ids`` mapped to an ``OffsetEvent``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    offset_event_id (osid.id.Id): ``Id`` of an\n                ``OffsetEvent``\n", 
               "return_doc": "        return: (osid.id.IdList) - list of calendar ``Ids``", 
               "error_doc": "        raise:  NotFound - ``offset_event_id`` is not found\n        raise:  NullArgument - ``offset_event_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param offset_event_id: ``Id`` of an ``OffsetEvent``\n        :type offset_event_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: list of calendar ``Ids``\n        :rtype: ``osid.id.IdList``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``offset_event_id`` is not found\n        :raise: ``NullArgument`` -- ``offset_event_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "offset_event_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "osid.id.IdList", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_calendars_by_offset_event", 
               "doc": {
                  "headline": "Gets the list of ``Calendars`` mapped to an ``OffsetEvent``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    offset_e_vent_id (osid.id.Id): ``Id`` of an\n                ``OffsetEvent``\n", 
               "return_doc": "        return: (osid.calendaring.CalendarList) - list of calendars", 
               "error_doc": "        raise:  NotFound - ``offset_event_id`` is not found\n        raise:  NullArgument - ``offset_event_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param offset_e_vent_id: ``Id`` of an ``OffsetEvent``\n        :type offset_e_vent_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: list of calendars\n        :rtype: ``osid.calendaring.CalendarList``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``offset_event_id`` is not found\n        :raise: ``NullArgument`` -- ``offset_event_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "offset_e_vent_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "osid.calendaring.CalendarList", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.calendaring.OffsetEventCalendarAssignmentSession", 
         "shortname": "OffsetEventCalendarAssignmentSession", 
         "category": "sessions", 
         "doc": {
            "headline": "This session provides methods to re-assign ``OffsetEvents`` to ``Calendars``.", 
            "body": "    An ``OffsetEvent`` may map to multiple ``Calendars`` and removing\n    the last reference to an ``OffsetEvent`` is the equivalent of\n    deleting it. Each ``Calendar`` may have its own authorizations\n    governing who is allowed to operate on it.\n\n    Moving or adding a reference of an ``OffsetEvent`` to another\n    ``Calendar`` is not a copy operation (eg: does not change its ``Id``\n    )."
         }, 
         "inherit_fullnames": [
            "osid.OsidSession"
         ], 
         "inherit_shortnames": [
            "OsidSession"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidSession"
            }
         ], 
         "method_names": [
            "can_assign_offset_events", 
            "can_assign_offset_events_to_calendar", 
            "get_assignable_calendar_ids", 
            "get_assignable_calendar_ids_for_offset_event", 
            "assign_offset_event_to_calendar", 
            "unassign_offset_event_from_calendar"
         ], 
         "methods": [
            {
               "name": "can_assign_offset_events", 
               "doc": {
                  "headline": "Tests if this user can alter offset event/calendar mappings.", 
                  "body": "        A return of true does not guarantee successful authorization. A\n        return of false indicates that it is known mapping methods in\n        this session will result in a ``PermissionDenied``. This is\n        intended as a hint to an application that may opt not to offer\n        assignment operations to unauthorized users."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``false`` if mapping is not authorized,\n                ``true`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``false`` if mapping is not authorized, ``true`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "can_assign_offset_events_to_calendar", 
               "doc": {
                  "headline": "Tests if this user can alter offset event/calendar mappings.", 
                  "body": "        A return of true does not guarantee successful authorization. A\n        return of false indicates that it is known mapping methods in\n        this session will result in a ``PermissionDenied``. This is\n        intended as a hint to an application that may opt not to offer\n        assignment operations to unauthorized users."
               }, 
               "arg_doc": "        arg:    calendar_id (osid.id.Id): the ``Id`` of the ``Calendar``\n", 
               "return_doc": "        return: (boolean) - ``false`` if mapping is not authorized,\n                ``true`` otherwise", 
               "error_doc": "        raise:  NullArgument - ``calendar_id`` is ``null``", 
               "sphinx_param_doc": "        :param calendar_id: the ``Id`` of the ``Calendar``\n        :type calendar_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: ``false`` if mapping is not authorized, ``true`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``calendar_id`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "calendar_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "boolean", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "get_assignable_calendar_ids", 
               "doc": {
                  "headline": "Gets a list of calendars including and under the given calendar node in which any offset event can be assigned.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    calendar_id (osid.id.Id): the ``Id`` of the ``Calendar``\n", 
               "return_doc": "        return: (osid.id.IdList) - list of assignable calendar ``Ids``", 
               "error_doc": "        raise:  NullArgument - ``calendar_id`` is ``null``\n        raise:  OperationFailed - unable to complete request", 
               "sphinx_param_doc": "        :param calendar_id: the ``Id`` of the ``Calendar``\n        :type calendar_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: list of assignable calendar ``Ids``\n        :rtype: ``osid.id.IdList``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``calendar_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "calendar_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "osid.id.IdList", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational"
               }
            }, 
            {
               "name": "get_assignable_calendar_ids_for_offset_event", 
               "doc": {
                  "headline": "Gets a list of calendars including and under the given calendar node in which a specific offset event can be assigned.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    calendar_id (osid.id.Id): the ``Id`` of the ``Calendar``\n        arg:    offset_event_id (osid.id.Id): the ``Id`` of the\n                ``offset_event_id``\n", 
               "return_doc": "        return: (osid.id.IdList) - list of assignable calendar ``Ids``", 
               "error_doc": "        raise:  NullArgument - ``calendar_id`` or ``offset_event_id`` is\n                ``null``\n        raise:  OperationFailed - unable to complete request", 
               "sphinx_param_doc": "        :param calendar_id: the ``Id`` of the ``Calendar``\n        :type calendar_id: ``osid.id.Id``\n        :param offset_event_id: the ``Id`` of the ``offset_event_id``\n        :type offset_event_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: list of assignable calendar ``Ids``\n        :rtype: ``osid.id.IdList``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``calendar_id`` or ``offset_event_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "calendar_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "offset_event_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "osid.id.Id"
               ], 
               "return_type": "osid.id.IdList", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational"
               }
            }, 
            {
               "name": "assign_offset_event_to_calendar", 
               "doc": {
                  "headline": "Adds an existing ``OffsetEvent`` to a ``Calendar``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    offset_event_id (osid.id.Id): the ``Id`` of the\n                ``OffsetEvent``\n        arg:    calendar_id (osid.id.Id): the ``Id`` of the ``Calendar``\n", 
               "return_doc": "", 
               "error_doc": "        raise:  AlreadyExists - ``offset_event_id`` is already assigned\n                to ``calendar_id``\n        raise:  NotFound - ``offset_event_id`` or ``calendar_id`` not\n                found\n        raise:  NullArgument - ``offset_event_id`` or ``calendar_id`` is\n                ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param offset_event_id: the ``Id`` of the ``OffsetEvent``\n        :type offset_event_id: ``osid.id.Id``\n        :param calendar_id: the ``Id`` of the ``Calendar``\n        :type calendar_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``AlreadyExists`` -- ``offset_event_id`` is already assigned to ``calendar_id``\n        :raise: ``NotFound`` -- ``offset_event_id`` or ``calendar_id`` not found\n        :raise: ``NullArgument`` -- ``offset_event_id`` or ``calendar_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "offset_event_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "calendar_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {
                  "ALREADY_EXISTS": "User", 
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "unassign_offset_event_from_calendar", 
               "doc": {
                  "headline": "Removes an ``OffsetEvent`` from a ``Calendar``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    offset_event_id (osid.id.Id): the ``Id`` of the\n                ``OffsetEvent``\n        arg:    calendar_id (osid.id.Id): the ``Id`` of the ``Calendar``\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NotFound - ``offset_event_id`` or ``calendar_id`` not\n                found or ``offset_event_id`` not assigned to\n                ``calendar_id``\n        raise:  NullArgument - ``offset_event_id`` or ``calendar_id`` is\n                ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param offset_event_id: the ``Id`` of the ``OffsetEvent``\n        :type offset_event_id: ``osid.id.Id``\n        :param calendar_id: the ``Id`` of the ``Calendar``\n        :type calendar_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``offset_event_id`` or ``calendar_id`` not found or ``offset_event_id`` not assigned to ``calendar_id``\n        :raise: ``NullArgument`` -- ``offset_event_id`` or ``calendar_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "offset_event_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "calendar_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.calendaring.OffsetEventSmartCalendarSession", 
         "shortname": "OffsetEventSmartCalendarSession", 
         "category": "sessions", 
         "doc": {
            "headline": "This session manages queries and sequencing to create \"smart\" dynamic catalogs.", 
            "body": "    An ``OffsetEventQuery`` can be retrieved from this session and\n    mapped to this ``Calendar`` to create a virtual collection of\n    ``OffsetEvents``. The entries may be sequenced using the\n    ``OffsetEventSearchOrder`` from this session.\n\n    This ``Calendar`` has a default query that matches any offset event\n    and a default search order that specifies no sequencing. The queries\n    may be examined using an ``OffsetEventQueryInspector``. The query\n    may be modified by converting the inspector back to an\n    ``OffsetEventQuery``."
         }, 
         "inherit_fullnames": [
            "osid.OsidSession"
         ], 
         "inherit_shortnames": [
            "OsidSession"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidSession"
            }
         ], 
         "method_names": [
            "get_calendar_id", 
            "get_calendar", 
            "can_manage_smart_calendars", 
            "get_offset_event_query", 
            "get_offset_event_search_order", 
            "apply_offset_event_query", 
            "inspect_offset_event_query", 
            "apply_offset_event_sequencing", 
            "get_offset_event_query_from_inspector"
         ], 
         "methods": [
            {
               "name": "get_calendar_id", 
               "doc": {
                  "headline": "Gets the ``Calendar``  ``Id`` associated with this session.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.id.Id) - the ``Calendar Id`` associated with this\n                session", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the ``Calendar Id`` associated with this session\n        :rtype: ``osid.id.Id``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.id.Id", 
               "errors": {}
            }, 
            {
               "name": "get_calendar", 
               "doc": {
                  "headline": "Gets the ``Calendar`` associated with this session.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.Calendar) - the ``Calendar``\n                associated with this session", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the ``Calendar`` associated with this session\n        :rtype: ``osid.calendaring.Calendar``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.Calendar", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "can_manage_smart_calendars", 
               "doc": {
                  "headline": "Tests if this user can manage smart calendars.", 
                  "body": "        A return of true does not guarantee successful authorization. A\n        return of false indicates that it is known all methods in this\n        session will result in a ``PermissionDenied``. This is intended\n        as a hint to an application that may opt not to offer smart\n        operations."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``false`` if smart calendar methods are not\n                authorized, ``true`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``false`` if smart calendar methods are not authorized, ``true`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "get_offset_event_query", 
               "doc": {
                  "headline": "Gets an offset event query.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.OffsetEventQuery) - the offset event\n                query", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the offset event query\n        :rtype: ``osid.calendaring.OffsetEventQuery``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.OffsetEventQuery", 
               "errors": {}
            }, 
            {
               "name": "get_offset_event_search_order", 
               "doc": {
                  "headline": "Gets an offset event search order.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.OffsetEventSearchOrder) - the offset\n                event search order", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the offset event search order\n        :rtype: ``osid.calendaring.OffsetEventSearchOrder``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.OffsetEventSearchOrder", 
               "errors": {}
            }, 
            {
               "name": "apply_offset_event_query", 
               "doc": {
                  "headline": "Applies an offset event query to this calendar.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    offset_event_query (osid.calendaring.OffsetEventQuery):\n                the offset event query\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``offset_event_query`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure occurred\n        raise:  Unsupported - ``offset_event_query`` not of this service", 
               "sphinx_param_doc": "        :param offset_event_query: the offset event query\n        :type offset_event_query: ``osid.calendaring.OffsetEventQuery``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``offset_event_query`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure occurred\n        :raise: ``Unsupported`` -- ``offset_event_query`` not of this service", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.calendaring.OffsetEventQuery", 
                     "var_name": "offset_event_query", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.calendaring.OffsetEventQuery"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }, 
            {
               "name": "inspect_offset_event_query", 
               "doc": {
                  "headline": "Gets an offset event query inspector for this calendar.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.OffsetEventQueryInspector) - the\n                offset event query inspector", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure occurred", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the offset event query inspector\n        :rtype: ``osid.calendaring.OffsetEventQueryInspector``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure occurred", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.OffsetEventQueryInspector", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "apply_offset_event_sequencing", 
               "doc": {
                  "headline": "Applies an offset event search order to this calendar.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    offset_event_search_order\n                (osid.calendaring.OffsetEventSearchOrder): the offset\n                event search order\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``offset_event_search_order`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure occurred\n        raise:  Unsupported - ``offset_event_search_order`` not of this\n                service", 
               "sphinx_param_doc": "        :param offset_event_search_order: the offset event search order\n        :type offset_event_search_order: ``osid.calendaring.OffsetEventSearchOrder``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``offset_event_search_order`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure occurred\n        :raise: ``Unsupported`` -- ``offset_event_search_order`` not of this service", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.calendaring.OffsetEventSearchOrder", 
                     "var_name": "offset_event_search_order", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.calendaring.OffsetEventSearchOrder"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_offset_event_query_from_inspector", 
               "doc": {
                  "headline": "Gets an offset event query from an inspector.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    offset_event_query_inspector\n                (osid.calendaring.OffsetEventQueryInspector): an offset\n                event query inspector\n", 
               "return_doc": "        return: (osid.calendaring.OffsetEventQuery) - the offset event\n                query", 
               "error_doc": "        raise:  NullArgument - ``offset_event_query_inspector`` is\n                ``null``\n        raise:  Unsupported - ``offset_event_query_inspector`` is not of\n                this service", 
               "sphinx_param_doc": "        :param offset_event_query_inspector: an offset event query inspector\n        :type offset_event_query_inspector: ``osid.calendaring.OffsetEventQueryInspector``\n", 
               "sphinx_return_doc": "        :return: the offset event query\n        :rtype: ``osid.calendaring.OffsetEventQuery``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``offset_event_query_inspector`` is ``null``\n        :raise: ``Unsupported`` -- ``offset_event_query_inspector`` is not of this service", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.calendaring.OffsetEventQueryInspector", 
                     "var_name": "offset_event_query_inspector", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.calendaring.OffsetEventQueryInspector"
               ], 
               "return_type": "osid.calendaring.OffsetEventQuery", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.calendaring.ScheduleLookupSession", 
         "shortname": "ScheduleLookupSession", 
         "category": "sessions", 
         "doc": {
            "headline": "This session provides methods for retrieving ``Schedules``.", 
            "body": ""
         }, 
         "inherit_fullnames": [
            "osid.OsidSession"
         ], 
         "inherit_shortnames": [
            "OsidSession"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidSession"
            }
         ], 
         "method_names": [
            "get_calendar_id", 
            "get_calendar", 
            "can_lookup_schedules", 
            "use_comparative_schedule_view", 
            "use_plenary_schedule_view", 
            "use_federated_calendar_view", 
            "use_isolated_calendar_view", 
            "get_schedule", 
            "get_schedules_by_ids", 
            "get_schedules_by_genus_type", 
            "get_schedules_by_parent_genus_type", 
            "get_schedules_by_record_type", 
            "get_schedules_by_schedule_slot", 
            "get_schedules_by_location", 
            "get_schedules_by_date", 
            "get_schedules_by_date_range", 
            "get_schedules"
         ], 
         "methods": [
            {
               "name": "get_calendar_id", 
               "doc": {
                  "headline": "Gets the ``Calendar``  ``Id`` associated with this session.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.id.Id) - the ``Calendar Id`` associated with this\n                session", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the ``Calendar Id`` associated with this session\n        :rtype: ``osid.id.Id``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.id.Id", 
               "errors": {}
            }, 
            {
               "name": "get_calendar", 
               "doc": {
                  "headline": "Gets the ``Calendar`` associated with this session.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.Calendar) - the ``Calendar``\n                associated with this session", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the ``Calendar`` associated with this session\n        :rtype: ``osid.calendaring.Calendar``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.Calendar", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "can_lookup_schedules", 
               "doc": {
                  "headline": "Tests if this user can perform ``Schedule`` lookups.", 
                  "body": "        A return of true does not guarantee successful authorization. A\n        return of false indicates that it is known all methods in this\n        session will result in a ``PermissionDenied``. This is intended\n        as a hint to an application that may opt not to offer lookup\n        operations to unauthorized users."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``false`` if lookup methods are not\n                authorized, ``true`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``false`` if lookup methods are not authorized, ``true`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "use_comparative_schedule_view", 
               "doc": {
                  "headline": "The returns from the lookup methods may omit or translate elements based on this session, such as authorization, and not result in an error.", 
                  "body": "        This view is used when greater interoperability is desired at\n        the expense of precision."
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "use_plenary_schedule_view", 
               "doc": {
                  "headline": "A complete view of the ``Schedule`` returns is desired.", 
                  "body": "        Methods will return what is requested or result in an error.\n        This view is used when greater precision is desired at the\n        expense of interoperability."
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "use_federated_calendar_view", 
               "doc": {
                  "headline": "Federates the view for methods in this session.", 
                  "body": "        A federated view will include schedules in calendars which are\n        children of this calendar in the calendar hierarchy."
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "use_isolated_calendar_view", 
               "doc": {
                  "headline": "Isolates the view for methods in this session.", 
                  "body": "        An isolated view restricts lookups to this calendar only."
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "get_schedule", 
               "doc": {
                  "headline": "Gets the ``Schedule`` specified by its ``Id``.", 
                  "body": "        In plenary mode, the exact ``Id`` is found or a ``NotFound``\n        results. Otherwise, the returned ``Schedule`` may have a\n        different ``Id`` than requested, such as the case where a\n        duplicate ``Id`` was assigned to a ``Schedule`` and retained for\n        compatibility."
               }, 
               "arg_doc": "        arg:    schedule_id (osid.id.Id): ``Id`` of the ``Schedule``\n", 
               "return_doc": "        return: (osid.calendaring.Schedule) - the schedule", 
               "error_doc": "        raise:  NotFound - ``schedule_id`` not found\n        raise:  NullArgument - ``schedule_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param schedule_id: ``Id`` of the ``Schedule``\n        :type schedule_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: the schedule\n        :rtype: ``osid.calendaring.Schedule``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``schedule_id`` not found\n        :raise: ``NullArgument`` -- ``schedule_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "schedule_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "osid.calendaring.Schedule", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_schedules_by_ids", 
               "doc": {
                  "headline": "Gets a ``ScheduleList`` corresponding to the given ``IdList``.", 
                  "body": "        In plenary mode, the returned list contains all of the schedule\n        specified in the ``Id`` list, in the order of the list,\n        including duplicates, or an error results if an ``Id`` in the\n        supplied list is not found or inaccessible. Otherwise,\n        inaccessible ``Schedules`` may be omitted from the list and may\n        present the elements in any order including returning a unique\n        set."
               }, 
               "arg_doc": "        arg:    schedule_ids (osid.id.IdList): the list of ``Ids`` to\n                retrieve\n", 
               "return_doc": "        return: (osid.calendaring.ScheduleList) - the returned\n                ``Schedule`` list", 
               "error_doc": "        raise:  NotFound - an ``Id was`` not found\n        raise:  NullArgument - ``schedule_ids`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param schedule_ids: the list of ``Ids`` to retrieve\n        :type schedule_ids: ``osid.id.IdList``\n", 
               "sphinx_return_doc": "        :return: the returned ``Schedule`` list\n        :rtype: ``osid.calendaring.ScheduleList``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- an ``Id was`` not found\n        :raise: ``NullArgument`` -- ``schedule_ids`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.IdList", 
                     "var_name": "schedule_ids", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.IdList"
               ], 
               "return_type": "osid.calendaring.ScheduleList", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_schedules_by_genus_type", 
               "doc": {
                  "headline": "Gets a ``ScheduleList`` corresponding to the given schedule genus ``Type`` which does not include schedule of genus types derived from the specified ``Type``.", 
                  "body": "        In plenary mode, the returned list contains all known schedule\n        or an error results. Otherwise, the returned list may contain\n        only those schedule that are accessible through this session."
               }, 
               "arg_doc": "        arg:    schedule_genus_type (osid.type.Type): a schedule genus\n                type\n", 
               "return_doc": "        return: (osid.calendaring.ScheduleList) - the returned\n                ``Schedule`` list", 
               "error_doc": "        raise:  NullArgument - ``schedule_genus_type`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param schedule_genus_type: a schedule genus type\n        :type schedule_genus_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "        :return: the returned ``Schedule`` list\n        :rtype: ``osid.calendaring.ScheduleList``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``schedule_genus_type`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "schedule_genus_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "osid.calendaring.ScheduleList", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_schedules_by_parent_genus_type", 
               "doc": {
                  "headline": "Gets a ``ScheduleList`` corresponding to the given schedule genus ``Type`` and include any additional schedule with genus types derived from the specified ``Type``.", 
                  "body": "        In plenary mode, the returned list contains all known schedule\n        or an error results. Otherwise, the returned list may contain\n        only those schedule that are accessible through this session."
               }, 
               "arg_doc": "        arg:    schedule_genus_type (osid.type.Type): a schedule genus\n                type\n", 
               "return_doc": "        return: (osid.calendaring.ScheduleList) - the returned\n                ``Schedule`` list", 
               "error_doc": "        raise:  NullArgument - ``schedule_genus_type`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param schedule_genus_type: a schedule genus type\n        :type schedule_genus_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "        :return: the returned ``Schedule`` list\n        :rtype: ``osid.calendaring.ScheduleList``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``schedule_genus_type`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "schedule_genus_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "osid.calendaring.ScheduleList", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_schedules_by_record_type", 
               "doc": {
                  "headline": "Gets a ``ScheduleList`` containing the given schedule record ``Type``.", 
                  "body": "        In plenary mode, the returned list contains all known schedule\n        or an error results. Otherwise, the returned list may contain\n        only those schedule that are accessible through this session."
               }, 
               "arg_doc": "        arg:    schedule_record_type (osid.type.Type): a schedule record\n                type\n", 
               "return_doc": "        return: (osid.calendaring.ScheduleList) - the returned\n                ``Schedule`` list", 
               "error_doc": "        raise:  NullArgument - ``schedule_record_type`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param schedule_record_type: a schedule record type\n        :type schedule_record_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "        :return: the returned ``Schedule`` list\n        :rtype: ``osid.calendaring.ScheduleList``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``schedule_record_type`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "schedule_record_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "osid.calendaring.ScheduleList", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_schedules_by_schedule_slot", 
               "doc": {
                  "headline": "Gets a ``ScheduleList`` directly containing the given shedule slot.", 
                  "body": "        In plenary mode, the returned list contains all known schedule\n        or an error results. Otherwise, the returned list may contain\n        only those schedule that are accessible through this session."
               }, 
               "arg_doc": "        arg:    schedule_slot_id (osid.id.Id): a schedule slot ``Id``\n", 
               "return_doc": "        return: (osid.calendaring.ScheduleList) - the returned\n                ``Schedule`` list", 
               "error_doc": "        raise:  NullArgument - ``schedule_slot_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param schedule_slot_id: a schedule slot ``Id``\n        :type schedule_slot_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: the returned ``Schedule`` list\n        :rtype: ``osid.calendaring.ScheduleList``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``schedule_slot_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "schedule_slot_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "osid.calendaring.ScheduleList", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_schedules_by_location", 
               "doc": {
                  "headline": "Gets a ``ScheduleList`` containing the given location.", 
                  "body": "        In plenary mode, the returned list contains all known schedule\n        or an error results. Otherwise, the returned list may contain\n        only those schedule that are accessible through this session."
               }, 
               "arg_doc": "        arg:    location_id (osid.id.Id): a location ``Id``\n", 
               "return_doc": "        return: (osid.calendaring.ScheduleList) - the returned\n                ``Schedule`` list", 
               "error_doc": "        raise:  NullArgument - ``location_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param location_id: a location ``Id``\n        :type location_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: the returned ``Schedule`` list\n        :rtype: ``osid.calendaring.ScheduleList``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``location_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "location_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "osid.calendaring.ScheduleList", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_schedules_by_date", 
               "doc": {
                  "headline": "Gets a ``ScheduleList`` containing the given date.", 
                  "body": "        In plenary mode, the returned list contains all known schedule\n        or an error results. Otherwise, the returned list may contain\n        only those schedule that are accessible through this session."
               }, 
               "arg_doc": "        arg:    date (osid.calendaring.DateTime): a date\n", 
               "return_doc": "        return: (osid.calendaring.ScheduleList) - the returned\n                ``Schedule`` list", 
               "error_doc": "        raise:  NullArgument - ``date`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param date: a date\n        :type date: ``osid.calendaring.DateTime``\n", 
               "sphinx_return_doc": "        :return: the returned ``Schedule`` list\n        :rtype: ``osid.calendaring.ScheduleList``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``date`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.calendaring.DateTime", 
                     "var_name": "date", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.calendaring.DateTime"
               ], 
               "return_type": "osid.calendaring.ScheduleList", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_schedules_by_date_range", 
               "doc": {
                  "headline": "Gets a ``ScheduleList`` contained by the given date range inclusive.", 
                  "body": "        In plenary mode, the returned list contains all known schedule\n        or an error results. Otherwise, the returned list may contain\n        only those schedule that are accessible through this session."
               }, 
               "arg_doc": "        arg:    from (osid.calendaring.DateTime): start of date range\n        arg:    to (osid.calendaring.DateTime): end of date range\n", 
               "return_doc": "        return: (osid.calendaring.ScheduleList) - the returned\n                ``Schedule`` list", 
               "error_doc": "        raise:  InvalidArgument - ``from`` is greater than ``to``\n        raise:  NullArgument - ``from`` or ``to`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param from: start of date range\n        :type from: ``osid.calendaring.DateTime``\n        :param to: end of date range\n        :type to: ``osid.calendaring.DateTime``\n", 
               "sphinx_return_doc": "        :return: the returned ``Schedule`` list\n        :rtype: ``osid.calendaring.ScheduleList``", 
               "sphinx_error_doc": "        :raise: ``InvalidArgument`` -- ``from`` is greater than ``to``\n        :raise: ``NullArgument`` -- ``from`` or ``to`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.calendaring.DateTime", 
                     "var_name": "from_", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.calendaring.DateTime", 
                     "var_name": "to", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.calendaring.DateTime", 
                  "osid.calendaring.DateTime"
               ], 
               "return_type": "osid.calendaring.ScheduleList", 
               "errors": {
                  "INVALID_ARGUMENT": "ConsumerContract", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_schedules", 
               "doc": {
                  "headline": "Gets all ``Schedules``.", 
                  "body": "        In plenary mode, the returned list contains all known schedule\n        or an error results. Otherwise, the returned list may contain\n        only those schedule that are accessible through this session."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.ScheduleList) - a ``ScheduleList``", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: a ``ScheduleList``\n        :rtype: ``osid.calendaring.ScheduleList``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.ScheduleList", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.calendaring.ScheduleQuerySession", 
         "shortname": "ScheduleQuerySession", 
         "category": "sessions", 
         "doc": {
            "headline": "This session provides methods for searching ``Schedule`` objects.", 
            "body": "    The search query is constructed using the ``ScheduleQuery``. The\n    schedule record ``Type`` also specifies the record for the schedule\n    query.\n\n    This session defines views that offer differing behaviors for\n    searching.\n    \n      * federated calendar view: searches include schedules in calendars\n        of which this calendar is an ancestor in the calendar hierarchy\n      * isolated calendar view: searches are restricted to schedules in\n        this calendar\n\n    \n    Schedules may have a query record indicated by their respective\n    record types. The query record is accessed via the\n    ``ScheduleQuery``."
         }, 
         "inherit_fullnames": [
            "osid.OsidSession"
         ], 
         "inherit_shortnames": [
            "OsidSession"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidSession"
            }
         ], 
         "method_names": [
            "get_calendar_id", 
            "get_calendar", 
            "can_search_schedules", 
            "use_federated_calendar_view", 
            "use_isolated_calendar_view", 
            "get_schedule_query", 
            "get_schedules_by_query"
         ], 
         "methods": [
            {
               "name": "get_calendar_id", 
               "doc": {
                  "headline": "Gets the ``Calendar``  ``Id`` associated with this session.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.id.Id) - the ``Calendar Id`` associated with this\n                session", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the ``Calendar Id`` associated with this session\n        :rtype: ``osid.id.Id``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.id.Id", 
               "errors": {}
            }, 
            {
               "name": "get_calendar", 
               "doc": {
                  "headline": "Gets the ``Calendar`` associated with this session.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.Calendar) - the ``Calendar``\n                associated with this session", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the ``Calendar`` associated with this session\n        :rtype: ``osid.calendaring.Calendar``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.Calendar", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "can_search_schedules", 
               "doc": {
                  "headline": "Tests if this user can perform ``Schedules`` searches.", 
                  "body": "        A return of true does not guarantee successful authorization. A\n        return of false indicates that it is known all methods in this\n        session will result in a ``PermissionDenied``. This is intended\n        as a hint to an application that may opt not to offer search\n        operations to unauthorized users."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``false`` if search methods are not\n                authorized, ``true`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``false`` if search methods are not authorized, ``true`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "use_federated_calendar_view", 
               "doc": {
                  "headline": "Federates the view for methods in this session.", 
                  "body": "        A federated view will include schedules in calendars which are\n        children of this calendar in the calendar hierarchy."
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "use_isolated_calendar_view", 
               "doc": {
                  "headline": "Isolates the view for methods in this session.", 
                  "body": "        An isolated view restricts searches to this calendar only."
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "get_schedule_query", 
               "doc": {
                  "headline": "Gets a schedule query.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.ScheduleQuery) - the schedule query", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the schedule query\n        :rtype: ``osid.calendaring.ScheduleQuery``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.ScheduleQuery", 
               "errors": {}
            }, 
            {
               "name": "get_schedules_by_query", 
               "doc": {
                  "headline": "Gets a list of ``Schedules`` matching the given schedle query.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    schedule_query (osid.calendaring.ScheduleQuery): the\n                schedule query\n", 
               "return_doc": "        return: (osid.calendaring.ScheduleList) - the returned\n                ``ScheduleList``", 
               "error_doc": "        raise:  NullArgument - ``schedule_query`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        raise:  Unsupported - ``schedule_query`` is not of this service", 
               "sphinx_param_doc": "        :param schedule_query: the schedule query\n        :type schedule_query: ``osid.calendaring.ScheduleQuery``\n", 
               "sphinx_return_doc": "        :return: the returned ``ScheduleList``\n        :rtype: ``osid.calendaring.ScheduleList``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``schedule_query`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure\n        :raise: ``Unsupported`` -- ``schedule_query`` is not of this service", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.calendaring.ScheduleQuery", 
                     "var_name": "schedule_query", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.calendaring.ScheduleQuery"
               ], 
               "return_type": "osid.calendaring.ScheduleList", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.calendaring.ScheduleSearchSession", 
         "shortname": "ScheduleSearchSession", 
         "category": "sessions", 
         "doc": {
            "headline": "This session provides methods for searching ``Schedule`` objects.", 
            "body": "    The search query is constructed using the ``ScheduleQuery``. The\n    schedule record ``Type`` also specifies the record for the schedule\n    query.\n\n    ``get_schedules_by_query()`` is the basic search method and returns\n    a list of ``Schedules``. A more advanced search may be performed\n    with ``getSchedulesBySearch()``. It accepts a ``ScheduleSearch`` in\n    addition to the query for the purpose of specifying additional\n    options affecting the entire search, such as ordering.\n    ``get_schedules_by_search()`` returns a ``ScheduleSearchResults``\n    that can be used to access the resulting ``SchedulesList`` or be\n    used to perform a search within the result set through\n    ``ScheduleSearch``.\n    \n    This session defines views that offer differing behaviors for\n    searching.\n    \n      * federated calendar view: searches include schedules in calendars\n        of which this calendar is a ancestor in the calendar hierarchy\n      * isolated calendar view: searches are restricted to schedules in\n        this calendar\n\n    \n    Schedules may have a query record indicated by their respective\n    record types. The query record is accessed via the\n    ``ScheduleQuery``."
         }, 
         "inherit_fullnames": [
            "osid.calendaring.ScheduleQuerySession"
         ], 
         "inherit_shortnames": [
            "ScheduleQuerySession"
         ], 
         "inherit_pkg_names": [
            "calendaring"
         ], 
         "inheritance": [
            {
               "pkg_name": "calendaring", 
               "name": "ScheduleQuerySession"
            }
         ], 
         "method_names": [
            "get_schedule_search", 
            "get_schedule_search_order", 
            "get_schedules_by_search", 
            "get_schedule_query_from_inspector"
         ], 
         "methods": [
            {
               "name": "get_schedule_search", 
               "doc": {
                  "headline": "Gets a schedule search.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.ScheduleSearch) - the schedule search", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the schedule search\n        :rtype: ``osid.calendaring.ScheduleSearch``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.ScheduleSearch", 
               "errors": {}
            }, 
            {
               "name": "get_schedule_search_order", 
               "doc": {
                  "headline": "Gets a schedule search order.", 
                  "body": "        The ``ScheduleSearchOrder`` is supplied to a ``ScheduleSearch``\n        to specify the ordering of results."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.ScheduleSearchOrder) - the schedule\n                search order", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the schedule search order\n        :rtype: ``osid.calendaring.ScheduleSearchOrder``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.ScheduleSearchOrder", 
               "errors": {}
            }, 
            {
               "name": "get_schedules_by_search", 
               "doc": {
                  "headline": "Gets the search results matching the given search query using the given search.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    schedule_query (osid.calendaring.ScheduleQuery): the\n                schedule query\n        arg:    schedule_search (osid.calendaring.ScheduleSearch): the\n                schedule search\n", 
               "return_doc": "        return: (osid.calendaring.ScheduleSearchResults) - the schedule\n                search results", 
               "error_doc": "        raise:  NullArgument - ``schedule_query`` or ``schedule_search``\n                is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        raise:  Unsupported - ``schedule_search`` or ``schedule_query``\n                is not of this service", 
               "sphinx_param_doc": "        :param schedule_query: the schedule query\n        :type schedule_query: ``osid.calendaring.ScheduleQuery``\n        :param schedule_search: the schedule search\n        :type schedule_search: ``osid.calendaring.ScheduleSearch``\n", 
               "sphinx_return_doc": "        :return: the schedule search results\n        :rtype: ``osid.calendaring.ScheduleSearchResults``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``schedule_query`` or ``schedule_search`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure\n        :raise: ``Unsupported`` -- ``schedule_search`` or ``schedule_query`` is not of this service", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.calendaring.ScheduleQuery", 
                     "var_name": "schedule_query", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.calendaring.ScheduleSearch", 
                     "var_name": "schedule_search", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.calendaring.ScheduleQuery", 
                  "osid.calendaring.ScheduleSearch"
               ], 
               "return_type": "osid.calendaring.ScheduleSearchResults", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_schedule_query_from_inspector", 
               "doc": {
                  "headline": "Gets a schedule query from an inspector.", 
                  "body": "        The inspector is available from an ``ScheduleSearchResults``."
               }, 
               "arg_doc": "        arg:    schedule_query_inspector\n                (osid.calendaring.ScheduleQueryInspector): a schedule\n                query inspector\n", 
               "return_doc": "        return: (osid.calendaring.ScheduleQuery) - the schedule query", 
               "error_doc": "        raise:  NullArgument - ``schedule_query_inspector`` is ``null``\n        raise:  Unsupported - ``schedule_query_inspector`` is not of\n                this service", 
               "sphinx_param_doc": "        :param schedule_query_inspector: a schedule query inspector\n        :type schedule_query_inspector: ``osid.calendaring.ScheduleQueryInspector``\n", 
               "sphinx_return_doc": "        :return: the schedule query\n        :rtype: ``osid.calendaring.ScheduleQuery``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``schedule_query_inspector`` is ``null``\n        :raise: ``Unsupported`` -- ``schedule_query_inspector`` is not of this service", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.calendaring.ScheduleQueryInspector", 
                     "var_name": "schedule_query_inspector", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.calendaring.ScheduleQueryInspector"
               ], 
               "return_type": "osid.calendaring.ScheduleQuery", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.calendaring.ScheduleAdminSession", 
         "shortname": "ScheduleAdminSession", 
         "category": "sessions", 
         "doc": {
            "headline": "This session creates, updates, and deletes ``Schedules``.", 
            "body": "    The data for create and update is provided by the consumer via the\n    form object. ``OsidForms`` are requested for each create or update\n    and may not be reused.\n\n    Create and update operations differ in their usage. To create a\n    ``Schedule,`` a ``ScheduleForm`` is requested using\n    ``get_schedule_form_for_create()`` specifying the desired record\n    ``Types`` or none if no record ``Types`` are needed. The returned\n    ``ScheduleForm`` will indicate that it is to be used with a create\n    operation and can be used to examine metdata or validate data prior\n    to creation. Once the ``ScheduleForm`` is submiited to a create\n    operation, it cannot be reused with another create operation unless\n    the first operation was unsuccessful. Each ``ScheduleForm``\n    corresponds to an attempted transaction.\n    \n    For updates, ``ScheduleForms`` are requested to the ``Schedule``\n    ``Id`` that is to be updated using ``getScheduleFormForUpdate()``.\n    Similarly, the ``ScheduleForm`` has metadata about the data that can\n    be updated and it can perform validation before submitting the\n    update. The ``ScheduleForm`` can only be used once for a successful\n    update and cannot be reused.\n    \n    The delete operations delete ``Schedules``. To unmap a ``Schedule``\n    from the current ``Calendar,`` the\n    ``ScheduleSCalendarAssignmentSession`` should be used. These delete\n    operations attempt to remove the ``Schedule`` itself thus removing\n    it from all known ``Calendar`` catalogs.\n    \n    This session includes an ``Id`` aliasing mechanism to assign an\n    external ``Id`` to an internally assigned Id."
         }, 
         "inherit_fullnames": [
            "osid.OsidSession"
         ], 
         "inherit_shortnames": [
            "OsidSession"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidSession"
            }
         ], 
         "method_names": [
            "get_calendar_id", 
            "get_calendar", 
            "can_create_schedules", 
            "can_create_schedule_with_record_types", 
            "get_schedule_form_for_create", 
            "create_schedule", 
            "can_update_schedules", 
            "get_schedule_form_for_update", 
            "update_schedule", 
            "can_delete_schedules", 
            "delete_schedule", 
            "can_manage_schedule_aliases", 
            "alias_schedule"
         ], 
         "methods": [
            {
               "name": "get_calendar_id", 
               "doc": {
                  "headline": "Gets the ``Calendar``  ``Id`` associated with this session.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.id.Id) - the ``Calendar Id`` associated with this\n                session", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the ``Calendar Id`` associated with this session\n        :rtype: ``osid.id.Id``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.id.Id", 
               "errors": {}
            }, 
            {
               "name": "get_calendar", 
               "doc": {
                  "headline": "Gets the ``Calendar`` associated with this session.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.Calendar) - the ``Calendar``\n                associated with this session", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the ``Calendar`` associated with this session\n        :rtype: ``osid.calendaring.Calendar``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.Calendar", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "can_create_schedules", 
               "doc": {
                  "headline": "Tests if this user can create ``Schedules``.", 
                  "body": "        A return of true does not guarantee successful authorization. A\n        return of false indicates that it is known creating a\n        ``Schedule`` will result in a ``PermissionDenied``. This is\n        intended as a hint to an application that may opt not to offer\n        create operations to an unauthorized user."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``false`` if ``Schedule`` creation is not\n                authorized, ``true`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``false`` if ``Schedule`` creation is not authorized, ``true`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "can_create_schedule_with_record_types", 
               "doc": {
                  "headline": "Tests if this user can create a single ``Schedule`` using the desired record types.", 
                  "body": "        While ``CalendaringManager.getScheduleRecordTypes()`` can be\n        used to examine which records are supported, this method tests\n        which record(s) are required for creating a specific\n        ``Schedule``. Providing an empty array tests if a ``Schedule``\n        can be created with no records."
               }, 
               "arg_doc": "        arg:    schedule_record_types (osid.type.Type[]): array of\n                schedule record types\n", 
               "return_doc": "        return: (boolean) - ``true`` if ``Schedule`` creation using the\n                specified record ``Types`` is supported, ``false``\n                otherwise", 
               "error_doc": "        raise:  NullArgument - ``schedule_record_types`` is ``null``", 
               "sphinx_param_doc": "        :param schedule_record_types: array of schedule record types\n        :type schedule_record_types: ``osid.type.Type[]``\n", 
               "sphinx_return_doc": "        :return: ``true`` if ``Schedule`` creation using the specified record ``Types`` is supported, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``schedule_record_types`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type[]", 
                     "var_name": "schedule_record_types", 
                     "array": true
                  }
               ], 
               "arg_types": [
                  "osid.type.Type[]"
               ], 
               "return_type": "boolean", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "get_schedule_form_for_create", 
               "doc": {
                  "headline": "Gets the schedule form for creating new schedules.", 
                  "body": "        A new form should be requested for each create transaction."
               }, 
               "arg_doc": "        arg:    schedule_record_types (osid.type.Type[]): array of\n                schedule record types\n", 
               "return_doc": "        return: (osid.calendaring.ScheduleForm) - the schedule form", 
               "error_doc": "        raise:  NullArgument - ``schedule_record_types`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        raise:  Unsupported - unable to get form for requested record\n                types", 
               "sphinx_param_doc": "        :param schedule_record_types: array of schedule record types\n        :type schedule_record_types: ``osid.type.Type[]``\n", 
               "sphinx_return_doc": "        :return: the schedule form\n        :rtype: ``osid.calendaring.ScheduleForm``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``schedule_record_types`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure\n        :raise: ``Unsupported`` -- unable to get form for requested record types", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type[]", 
                     "var_name": "schedule_record_types", 
                     "array": true
                  }
               ], 
               "arg_types": [
                  "osid.type.Type[]"
               ], 
               "return_type": "osid.calendaring.ScheduleForm", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }, 
            {
               "name": "create_schedule", 
               "doc": {
                  "headline": "Creates a new ``Schedule``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    schedule_form (osid.calendaring.ScheduleForm): the form\n                for this ``Schedule``\n", 
               "return_doc": "        return: (osid.calendaring.Schedule) - the new ``Schedule``", 
               "error_doc": "        raise:  IllegalState - ``schedule_form`` already used in a\n                create transaction\n        raise:  InvalidArgument - one or more of the form elements is\n                invalid\n        raise:  NullArgument - ``schedule_form`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        raise:  Unsupported - ``schedule_form`` did not originate from\n                ``get_schedule_form_for_create()``", 
               "sphinx_param_doc": "        :param schedule_form: the form for this ``Schedule``\n        :type schedule_form: ``osid.calendaring.ScheduleForm``\n", 
               "sphinx_return_doc": "        :return: the new ``Schedule``\n        :rtype: ``osid.calendaring.Schedule``", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- ``schedule_form`` already used in a create transaction\n        :raise: ``InvalidArgument`` -- one or more of the form elements is invalid\n        :raise: ``NullArgument`` -- ``schedule_form`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure\n        :raise: ``Unsupported`` -- ``schedule_form`` did not originate from ``get_schedule_form_for_create()``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.calendaring.ScheduleForm", 
                     "var_name": "schedule_form", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.calendaring.ScheduleForm"
               ], 
               "return_type": "osid.calendaring.Schedule", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract", 
                  "INVALID_ARGUMENT": "ConsumerContract", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }, 
            {
               "name": "can_update_schedules", 
               "doc": {
                  "headline": "Tests if this user can update ``Schedules``.", 
                  "body": "        A return of true does not guarantee successful authorization. A\n        return of false indicates that it is known updating a\n        ``Schedule`` will result in a ``PermissionDenied``. This is\n        intended as a hint to an application that may opt not to offer\n        update operations to an unauthorized user."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``false`` if schedule modification is not\n                authorized, ``true`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``false`` if schedule modification is not authorized, ``true`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "get_schedule_form_for_update", 
               "doc": {
                  "headline": "Gets the schedule form for updating an existing schedules.", 
                  "body": "        A new schedule form should be requested for each update\n        transaction."
               }, 
               "arg_doc": "        arg:    schedule_id (osid.id.Id): the ``Id`` of the ``Schedule``\n", 
               "return_doc": "        return: (osid.calendaring.ScheduleForm) - the schedule form", 
               "error_doc": "        raise:  NotFound - ``schedule_id`` is not found\n        raise:  NullArgument - ``schedule_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param schedule_id: the ``Id`` of the ``Schedule``\n        :type schedule_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: the schedule form\n        :rtype: ``osid.calendaring.ScheduleForm``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``schedule_id`` is not found\n        :raise: ``NullArgument`` -- ``schedule_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "schedule_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "osid.calendaring.ScheduleForm", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "update_schedule", 
               "doc": {
                  "headline": "Updates an existing schedule.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    schedule_form (osid.calendaring.ScheduleForm): the form\n                containing the elements to be updated\n", 
               "return_doc": "", 
               "error_doc": "        raise:  IllegalState - ``schedule_form`` already used in an\n                update transaction\n        raise:  InvalidArgument - the form contains an invalid value\n        raise:  NullArgument - ``schedule_form`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        raise:  Unsupported - ``schedule_form`` did not originate from\n                ``get_schedule_form_for_update()``", 
               "sphinx_param_doc": "        :param schedule_form: the form containing the elements to be updated\n        :type schedule_form: ``osid.calendaring.ScheduleForm``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- ``schedule_form`` already used in an update transaction\n        :raise: ``InvalidArgument`` -- the form contains an invalid value\n        :raise: ``NullArgument`` -- ``schedule_form`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure\n        :raise: ``Unsupported`` -- ``schedule_form`` did not originate from ``get_schedule_form_for_update()``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.calendaring.ScheduleForm", 
                     "var_name": "schedule_form", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.calendaring.ScheduleForm"
               ], 
               "return_type": "", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract", 
                  "INVALID_ARGUMENT": "ConsumerContract", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }, 
            {
               "name": "can_delete_schedules", 
               "doc": {
                  "headline": "Tests if this user can delete ``Schedules``.", 
                  "body": "        A return of true does not guarantee successful authorization. A\n        return of false indicates that it is known deleting a\n        ``Schedule`` will result in a ``PermissionDenied``. This is\n        intended as a hint to an application that may opt not to offer\n        delete operations to an unauthorized user."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``false`` if ``Schedule`` deletion is not\n                authorized, ``true`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``false`` if ``Schedule`` deletion is not authorized, ``true`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "delete_schedule", 
               "doc": {
                  "headline": "Deletes the ``Schedule`` identified by the given ``Id``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    schedule_id (osid.id.Id): the ``Id`` of the ``Schedule``\n                to delete\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NotFound - a ``Schedule`` was not found identified by\n                the given ``Id``\n        raise:  NullArgument - ``schedule_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param schedule_id: the ``Id`` of the ``Schedule`` to delete\n        :type schedule_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- a ``Schedule`` was not found identified by the given ``Id``\n        :raise: ``NullArgument`` -- ``schedule_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "schedule_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "can_manage_schedule_aliases", 
               "doc": {
                  "headline": "Tests if this user can manage ``Id`` aliases for ``Schedules``.", 
                  "body": "        A return of true does not guarantee successful authorization. A\n        return of false indicates that it is known changing an alias\n        will result in a ``PermissionDenied``. This is intended as a\n        hint to an application that may opt not to offer alias\n        operations to an unauthorized user."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``false`` if ``Schedule`` aliasing is not\n                authorized, ``true`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``false`` if ``Schedule`` aliasing is not authorized, ``true`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "alias_schedule", 
               "doc": {
                  "headline": "Adds an ``Id`` to a ``Schedule`` for the purpose of creating compatibility.", 
                  "body": "        The primary ``Id`` of the ``Schedule`` is determined by the\n        provider. The new ``Id`` performs as an alias to the primary\n        ``Id``. If the alias is a pointer to another schedule, it is\n        reassigned to the given schedule ``Id``."
               }, 
               "arg_doc": "        arg:    schedule_id (osid.id.Id): the ``Id`` of a ``Schedule``\n        arg:    alias_id (osid.id.Id): the alias ``Id``\n", 
               "return_doc": "", 
               "error_doc": "        raise:  AlreadyExists - ``alias_id`` is already assigned\n        raise:  NotFound - ``schedule_id`` not found\n        raise:  NullArgument - ``schedule_id`` or ``alias_id`` is\n                ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param schedule_id: the ``Id`` of a ``Schedule``\n        :type schedule_id: ``osid.id.Id``\n        :param alias_id: the alias ``Id``\n        :type alias_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``AlreadyExists`` -- ``alias_id`` is already assigned\n        :raise: ``NotFound`` -- ``schedule_id`` not found\n        :raise: ``NullArgument`` -- ``schedule_id`` or ``alias_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "schedule_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "alias_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {
                  "ALREADY_EXISTS": "User", 
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.calendaring.ScheduleNotificationSession", 
         "shortname": "ScheduleNotificationSession", 
         "category": "sessions", 
         "doc": {
            "headline": "This session defines methods to receive asynchronous notifications on adds/changes to ``Schedule`` objects.", 
            "body": "    This session is intended for consumers needing to synchronize their\n    state with this service without the use of polling. Notifications\n    are cancelled when this session is closed.\n\n    The views defined in this session correspond to the views in the\n    ``ScheduleLookupSession``."
         }, 
         "inherit_fullnames": [
            "osid.OsidSession"
         ], 
         "inherit_shortnames": [
            "OsidSession"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidSession"
            }
         ], 
         "method_names": [
            "get_calendar_id", 
            "get_calendar", 
            "can_register_for_schedule_notifications", 
            "use_federated_calendar_view", 
            "use_isolated_calendar_view", 
            "register_for_new_schedules", 
            "register_for_changed_schedules", 
            "register_for_changed_schedule", 
            "register_for_deleted_schedules", 
            "register_for_deleted_schedule"
         ], 
         "methods": [
            {
               "name": "get_calendar_id", 
               "doc": {
                  "headline": "Gets the ``Calendar``  ``Id`` associated with this session.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.id.Id) - the ``Calendar Id`` associated with this\n                session", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the ``Calendar Id`` associated with this session\n        :rtype: ``osid.id.Id``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.id.Id", 
               "errors": {}
            }, 
            {
               "name": "get_calendar", 
               "doc": {
                  "headline": "Gets the ``Calendar`` associated with this session.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.Calendar) - the ``Calendar``\n                associated with this session", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the ``Calendar`` associated with this session\n        :rtype: ``osid.calendaring.Calendar``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.Calendar", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "can_register_for_schedule_notifications", 
               "doc": {
                  "headline": "Tests if this user can register for ``Schedule`` notifications.", 
                  "body": "        A return of true does not guarantee successful authorization. A\n        return of false indicates that it is known all methods in this\n        session will result in a ``PermissionDenied``. This is intended\n        as a hint to an application that may opt not to offer\n        notification operations."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``false`` if notification methods are not\n                authorized, ``true`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``false`` if notification methods are not authorized, ``true`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "use_federated_calendar_view", 
               "doc": {
                  "headline": "Federates the view for methods in this session.", 
                  "body": "        A federated view will include notifications for schedules in\n        calendars which are children of this calendar in the calendar\n        hierarchy."
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "use_isolated_calendar_view", 
               "doc": {
                  "headline": "Isolates the view for methods in this session.", 
                  "body": "        An isolated view restricts notifications to this calendar only."
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "register_for_new_schedules", 
               "doc": {
                  "headline": "Register for notifications of new schedules.", 
                  "body": "        ``ScheduleReceiver.newSchedule()`` is invoked when a new\n        schedule is created."
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "register_for_changed_schedules", 
               "doc": {
                  "headline": "Registers for notification of updated schedule schedules.", 
                  "body": "        ``ScheduleReceiver.changedSchedule()`` is invoked when a\n        schedule is changed."
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "register_for_changed_schedule", 
               "doc": {
                  "headline": "Registers for notification of an updated schedule.", 
                  "body": "        ``ScheduleReceiver.changedSchedule()`` is invoked when the\n        specified schedule is changed."
               }, 
               "arg_doc": "        arg:    schedule_id (osid.id.Id): the ``Id`` of the ``Schedule``\n                to monitor\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``schedule_id is null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param schedule_id: the ``Id`` of the ``Schedule`` to monitor\n        :type schedule_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``schedule_id is null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "schedule_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "register_for_deleted_schedules", 
               "doc": {
                  "headline": "Registers for notification of deleted schedules.", 
                  "body": "        ``ScheduleReceiver.deletedSchedule()`` is invoked when a\n        schedule is removed from this calendar."
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "register_for_deleted_schedule", 
               "doc": {
                  "headline": "Registers for notification of a deleted schedule.", 
                  "body": "        ``ScheduleReceiver.changedSchedule()`` is invoked when the\n        specified schedule is removed from this calendar."
               }, 
               "arg_doc": "        arg:    schedule_id (osid.id.Id): the ``Id`` of the ``Schedule``\n                to monitor\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``schedule_id is null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param schedule_id: the ``Id`` of the ``Schedule`` to monitor\n        :type schedule_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``schedule_id is null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "schedule_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.calendaring.ScheduleCalendarSession", 
         "shortname": "ScheduleCalendarSession", 
         "category": "sessions", 
         "doc": {
            "headline": "This session provides methods to retrieve ``Schedule`` to ``Calendar`` mappings.", 
            "body": "    A ``Schedule`` may appear in multiple ``Calendars``. Each\n    ``Calendar`` may have its own authorizations governing who is\n    allowed to look at it.\n\n    This lookup session defines two views:\n    \n      * comparative view: elements may be silently omitted or re-ordered\n      * plenary view: provides a complete result set or is an error\n        condition\n"
         }, 
         "inherit_fullnames": [
            "osid.OsidSession"
         ], 
         "inherit_shortnames": [
            "OsidSession"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidSession"
            }
         ], 
         "method_names": [
            "can_lookup_schedule_calendar_mappings", 
            "use_comparative_calendar_view", 
            "use_plenary_calendar_view", 
            "get_schedule_ids_by_calendar", 
            "get_schedules_by_calendar", 
            "get_schedule_ids_by_calendars", 
            "get_schedules_by_calendars", 
            "get_calendar_ids_by_schedule", 
            "get_calendars_by_schedule"
         ], 
         "methods": [
            {
               "name": "can_lookup_schedule_calendar_mappings", 
               "doc": {
                  "headline": "Tests if this user can perform lookups of schedule/calendar mappings.", 
                  "body": "        A return of true does not guarantee successful authorization. A\n        return of false indicates that it is known lookup methods in\n        this session will result in a ``PermissionDenied``. This is\n        intended as a hint to an application that may opt not to offer\n        lookup operations to unauthorized users."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``false`` if looking up mappings is not\n                authorized, ``true`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``false`` if looking up mappings is not authorized, ``true`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "use_comparative_calendar_view", 
               "doc": {
                  "headline": "The returns from the lookup methods may omit or translate elements based on this session, such as authorization, and not result in an error.", 
                  "body": "        This view is used when greater interoperability is desired at\n        the expense of precision."
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "use_plenary_calendar_view", 
               "doc": {
                  "headline": "A complete view of the ``Schedule`` and ``Calendar`` returns is desired.", 
                  "body": "        Methods will return what is requested or result in an error.\n        This view is used when greater precision is desired at the\n        expense of interoperability."
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "get_schedule_ids_by_calendar", 
               "doc": {
                  "headline": "Gets the list of ``Schedule``  ``Ids`` associated with a ``Calendar``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    calendar_id (osid.id.Id): ``Id`` of the ``Calendar``\n", 
               "return_doc": "        return: (osid.id.IdList) - list of related schedule ``Ids``", 
               "error_doc": "        raise:  NotFound - ``calendar_id`` is not found\n        raise:  NullArgument - ``calendar_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param calendar_id: ``Id`` of the ``Calendar``\n        :type calendar_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: list of related schedule ``Ids``\n        :rtype: ``osid.id.IdList``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``calendar_id`` is not found\n        :raise: ``NullArgument`` -- ``calendar_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "calendar_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "osid.id.IdList", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_schedules_by_calendar", 
               "doc": {
                  "headline": "Gets the list of ``Schedules`` associated with a ``Calendar``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    calendar_id (osid.id.Id): ``Id`` of the ``Calendar``\n", 
               "return_doc": "        return: (osid.calendaring.ScheduleList) - list of related\n                schedules", 
               "error_doc": "        raise:  NotFound - ``calendar_id`` is not found\n        raise:  NullArgument - ``calendar_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param calendar_id: ``Id`` of the ``Calendar``\n        :type calendar_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: list of related schedules\n        :rtype: ``osid.calendaring.ScheduleList``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``calendar_id`` is not found\n        :raise: ``NullArgument`` -- ``calendar_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "calendar_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "osid.calendaring.ScheduleList", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_schedule_ids_by_calendars", 
               "doc": {
                  "headline": "Gets the list of ``Schedule Ids`` corresponding to a list of ``Calendars``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    calendar_ids (osid.id.IdList): list of calendar ``Ids``\n", 
               "return_doc": "        return: (osid.id.IdList) - list of schedule ``Ids``", 
               "error_doc": "        raise:  NullArgument - ``calendar_ids`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param calendar_ids: list of calendar ``Ids``\n        :type calendar_ids: ``osid.id.IdList``\n", 
               "sphinx_return_doc": "        :return: list of schedule ``Ids``\n        :rtype: ``osid.id.IdList``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``calendar_ids`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.IdList", 
                     "var_name": "calendar_ids", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.IdList"
               ], 
               "return_type": "osid.id.IdList", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_schedules_by_calendars", 
               "doc": {
                  "headline": "Gets the list of ``Schedules`` corresponding to a list of ``Calendars``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    calendar_ids (osid.id.IdList): list of calendar ``Ids``\n", 
               "return_doc": "        return: (osid.calendaring.ScheduleList) - list of schedules", 
               "error_doc": "        raise:  NullArgument - ``calendar_ids`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param calendar_ids: list of calendar ``Ids``\n        :type calendar_ids: ``osid.id.IdList``\n", 
               "sphinx_return_doc": "        :return: list of schedules\n        :rtype: ``osid.calendaring.ScheduleList``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``calendar_ids`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.IdList", 
                     "var_name": "calendar_ids", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.IdList"
               ], 
               "return_type": "osid.calendaring.ScheduleList", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_calendar_ids_by_schedule", 
               "doc": {
                  "headline": "Gets the list of ``Calendar``  ``Ids`` mapped to a ``Schedule``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    schedule_id (osid.id.Id): ``Id`` of a ``Schedule``\n", 
               "return_doc": "        return: (osid.id.IdList) - list of calendar ``Ids``", 
               "error_doc": "        raise:  NotFound - ``schedule_id`` is not found\n        raise:  NullArgument - ``schedule_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param schedule_id: ``Id`` of a ``Schedule``\n        :type schedule_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: list of calendar ``Ids``\n        :rtype: ``osid.id.IdList``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``schedule_id`` is not found\n        :raise: ``NullArgument`` -- ``schedule_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "schedule_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "osid.id.IdList", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_calendars_by_schedule", 
               "doc": {
                  "headline": "Gets the list of ``Calendars`` mapped to a ``Schedule``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    schedule_id (osid.id.Id): ``Id`` of a ``Schedule``\n", 
               "return_doc": "        return: (osid.calendaring.CalendarList) - list of calendars", 
               "error_doc": "        raise:  NotFound - ``schedule_id`` is not found\n        raise:  NullArgument - ``schedule_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param schedule_id: ``Id`` of a ``Schedule``\n        :type schedule_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: list of calendars\n        :rtype: ``osid.calendaring.CalendarList``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``schedule_id`` is not found\n        :raise: ``NullArgument`` -- ``schedule_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "schedule_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "osid.calendaring.CalendarList", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.calendaring.ScheduleCalendarAssignmentSession", 
         "shortname": "ScheduleCalendarAssignmentSession", 
         "category": "sessions", 
         "doc": {
            "headline": "This session provides methods to re-assign ``Schedules`` to ``Calendars``.", 
            "body": "    A ``Schedule`` may map to multiple ``Calendars`` and removing the\n    last reference to a ``Schedule`` is the equivalent of deleting it.\n    Each ``Calendar`` may have its own authorizations governing who is\n    allowed to operate on it.\n\n    Moving or adding a reference of a ``Schedule`` to another\n    ``Calendar`` is not a copy operation (eg: does not change its ``Id``\n    )."
         }, 
         "inherit_fullnames": [
            "osid.OsidSession"
         ], 
         "inherit_shortnames": [
            "OsidSession"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidSession"
            }
         ], 
         "method_names": [
            "can_assign_schedules", 
            "can_assign_schedules_to_calendar", 
            "get_assignable_calendar_ids", 
            "get_assignable_calendar_ids_for_schedule", 
            "assign_schedule_to_calendar", 
            "unassign_schedule_from_calendar"
         ], 
         "methods": [
            {
               "name": "can_assign_schedules", 
               "doc": {
                  "headline": "Tests if this user can alter schedule/calendar mappings.", 
                  "body": "        A return of true does not guarantee successful authorization. A\n        return of false indicates that it is known mapping methods in\n        this session will result in a ``PermissionDenied``. This is\n        intended as a hint to an application that may opt not to offer\n        assignment operations to unauthorized users."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``false`` if mapping is not authorized,\n                ``true`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``false`` if mapping is not authorized, ``true`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "can_assign_schedules_to_calendar", 
               "doc": {
                  "headline": "Tests if this user can alter schedule/calendar mappings.", 
                  "body": "        A return of true does not guarantee successful authorization. A\n        return of false indicates that it is known mapping methods in\n        this session will result in a ``PermissionDenied``. This is\n        intended as a hint to an application that may opt not to offer\n        assignment operations to unauthorized users."
               }, 
               "arg_doc": "        arg:    calendar_id (osid.id.Id): the ``Id`` of the ``Calendar``\n", 
               "return_doc": "        return: (boolean) - ``false`` if mapping is not authorized,\n                ``true`` otherwise", 
               "error_doc": "        raise:  NullArgument - ``calendar_id`` is ``null``", 
               "sphinx_param_doc": "        :param calendar_id: the ``Id`` of the ``Calendar``\n        :type calendar_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: ``false`` if mapping is not authorized, ``true`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``calendar_id`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "calendar_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "boolean", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "get_assignable_calendar_ids", 
               "doc": {
                  "headline": "Gets a list of calendars including and under the given calendar node in which any schedule can be assigned.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    calendar_id (osid.id.Id): the ``Id`` of the ``Calendar``\n", 
               "return_doc": "        return: (osid.id.IdList) - list of assignable calendar ``Ids``", 
               "error_doc": "        raise:  NullArgument - ``calendar_id`` is ``null``\n        raise:  OperationFailed - unable to complete request", 
               "sphinx_param_doc": "        :param calendar_id: the ``Id`` of the ``Calendar``\n        :type calendar_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: list of assignable calendar ``Ids``\n        :rtype: ``osid.id.IdList``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``calendar_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "calendar_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "osid.id.IdList", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational"
               }
            }, 
            {
               "name": "get_assignable_calendar_ids_for_schedule", 
               "doc": {
                  "headline": "Gets a list of calendars including and under the given calendar node in which a specific schedule can be assigned.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    calendar_id (osid.id.Id): the ``Id`` of the ``Calendar``\n        arg:    schedule_id (osid.id.Id): the ``Id`` of the ``Schedule``\n", 
               "return_doc": "        return: (osid.id.IdList) - list of assignable calendar ``Ids``", 
               "error_doc": "        raise:  NullArgument - ``calendar_id`` or ``schedule_id`` is\n                ``null``\n        raise:  OperationFailed - unable to complete request", 
               "sphinx_param_doc": "        :param calendar_id: the ``Id`` of the ``Calendar``\n        :type calendar_id: ``osid.id.Id``\n        :param schedule_id: the ``Id`` of the ``Schedule``\n        :type schedule_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: list of assignable calendar ``Ids``\n        :rtype: ``osid.id.IdList``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``calendar_id`` or ``schedule_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "calendar_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "schedule_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "osid.id.Id"
               ], 
               "return_type": "osid.id.IdList", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational"
               }
            }, 
            {
               "name": "assign_schedule_to_calendar", 
               "doc": {
                  "headline": "Adds an existing ``Schedule`` to a ``Calendar``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    schedule_id (osid.id.Id): the ``Id`` of the ``Schedule``\n        arg:    calendar_id (osid.id.Id): the ``Id`` of the ``Calendar``\n", 
               "return_doc": "", 
               "error_doc": "        raise:  AlreadyExists - ``schedule_id`` is already assigned to\n                ``calendar_id``\n        raise:  NotFound - ``schedule_id`` or ``calendar_id`` not found\n        raise:  NullArgument - ``schedule_id`` or ``calendar_id`` is\n                ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param schedule_id: the ``Id`` of the ``Schedule``\n        :type schedule_id: ``osid.id.Id``\n        :param calendar_id: the ``Id`` of the ``Calendar``\n        :type calendar_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``AlreadyExists`` -- ``schedule_id`` is already assigned to ``calendar_id``\n        :raise: ``NotFound`` -- ``schedule_id`` or ``calendar_id`` not found\n        :raise: ``NullArgument`` -- ``schedule_id`` or ``calendar_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "schedule_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "calendar_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {
                  "ALREADY_EXISTS": "User", 
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "unassign_schedule_from_calendar", 
               "doc": {
                  "headline": "Removes a ``Schedule`` from a ``Calendar``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    schedule_id (osid.id.Id): the ``Id`` of the ``Schedule``\n        arg:    calendar_id (osid.id.Id): the ``Id`` of the ``Calendar``\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NotFound - ``schedule_id`` or ``calendar_id`` not found\n                or ``schedule_id`` not assigned to ``calendar_id``\n        raise:  NullArgument - ``schedule_id`` or ``calendar_id`` is\n                ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param schedule_id: the ``Id`` of the ``Schedule``\n        :type schedule_id: ``osid.id.Id``\n        :param calendar_id: the ``Id`` of the ``Calendar``\n        :type calendar_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``schedule_id`` or ``calendar_id`` not found or ``schedule_id`` not assigned to ``calendar_id``\n        :raise: ``NullArgument`` -- ``schedule_id`` or ``calendar_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "schedule_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "calendar_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.calendaring.ScheduleSmartCalendarSession", 
         "shortname": "ScheduleSmartCalendarSession", 
         "category": "sessions", 
         "doc": {
            "headline": "This session manages queries and sequencing to create \"smart\" dynamic catalogs.", 
            "body": "    A ``ScheduleQuery`` can be retrieved from this session and mapped to\n    this ``Calendar`` to create a virtual collection of ``Schedules``.\n    The entries may be sequenced using the ``ScheduleSearchOrder`` from\n    this session.\n\n    This ``Calendar`` has a default query that matches any schedule and\n    a default search order that specifies no sequencing. The queries may\n    be examined using a ``ScheduleQueryInspector``. The query may be\n    modified by converting the inspector back to a ``ScheduleQuery``."
         }, 
         "inherit_fullnames": [
            "osid.OsidSession"
         ], 
         "inherit_shortnames": [
            "OsidSession"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidSession"
            }
         ], 
         "method_names": [
            "get_calendar_id", 
            "get_calendar", 
            "can_manage_smart_calendars", 
            "get_schedule_query", 
            "get_schedule_search_order", 
            "apply_schedule_query", 
            "inspect_schedule_query", 
            "apply_schedule_sequencing", 
            "get_schedule_query_from_inspector"
         ], 
         "methods": [
            {
               "name": "get_calendar_id", 
               "doc": {
                  "headline": "Gets the ``Calendar``  ``Id`` associated with this session.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.id.Id) - the ``Calendar Id`` associated with this\n                session", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the ``Calendar Id`` associated with this session\n        :rtype: ``osid.id.Id``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.id.Id", 
               "errors": {}
            }, 
            {
               "name": "get_calendar", 
               "doc": {
                  "headline": "Gets the ``Calendar`` associated with this session.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.Calendar) - the ``Calendar``\n                associated with this session", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the ``Calendar`` associated with this session\n        :rtype: ``osid.calendaring.Calendar``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.Calendar", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "can_manage_smart_calendars", 
               "doc": {
                  "headline": "Tests if this user can manage smart calendars.", 
                  "body": "        A return of true does not guarantee successful authorization. A\n        return of false indicates that it is known all methods in this\n        session will result in a ``PermissionDenied``. This is intended\n        as a hint to an application that may opt not to offer smart\n        operations."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``false`` if smart calendar methods are not\n                authorized, ``true`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``false`` if smart calendar methods are not authorized, ``true`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "get_schedule_query", 
               "doc": {
                  "headline": "Gets a schedule query.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.ScheduleQuery) - the schedule query", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the schedule query\n        :rtype: ``osid.calendaring.ScheduleQuery``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.ScheduleQuery", 
               "errors": {}
            }, 
            {
               "name": "get_schedule_search_order", 
               "doc": {
                  "headline": "Gets a schedule search order.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.ScheduleSearchOrder) - the schedule\n                search order", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the schedule search order\n        :rtype: ``osid.calendaring.ScheduleSearchOrder``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.ScheduleSearchOrder", 
               "errors": {}
            }, 
            {
               "name": "apply_schedule_query", 
               "doc": {
                  "headline": "Applies a schedule query to this calendar.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    schedule_query (osid.calendaring.ScheduleQuery): the\n                schedule query\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``schedule_query`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure occurred\n        raise:  Unsupported - ``schedule_query`` not of this service", 
               "sphinx_param_doc": "        :param schedule_query: the schedule query\n        :type schedule_query: ``osid.calendaring.ScheduleQuery``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``schedule_query`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure occurred\n        :raise: ``Unsupported`` -- ``schedule_query`` not of this service", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.calendaring.ScheduleQuery", 
                     "var_name": "schedule_query", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.calendaring.ScheduleQuery"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }, 
            {
               "name": "inspect_schedule_query", 
               "doc": {
                  "headline": "Gets a schedule query inspector for this calendar.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.ScheduleQueryInspector) - the schedule\n                query inspector", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure occurred", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the schedule query inspector\n        :rtype: ``osid.calendaring.ScheduleQueryInspector``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure occurred", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.ScheduleQueryInspector", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "apply_schedule_sequencing", 
               "doc": {
                  "headline": "Applies a schedule search order to this calendar.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    schedule_search_order\n                (osid.calendaring.ScheduleSearchOrder): the schedule\n                search order\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``schedule_search_order`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure occurred\n        raise:  Unsupported - ``schedule_search_order`` not of this\n                service", 
               "sphinx_param_doc": "        :param schedule_search_order: the schedule search order\n        :type schedule_search_order: ``osid.calendaring.ScheduleSearchOrder``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``schedule_search_order`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure occurred\n        :raise: ``Unsupported`` -- ``schedule_search_order`` not of this service", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.calendaring.ScheduleSearchOrder", 
                     "var_name": "schedule_search_order", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.calendaring.ScheduleSearchOrder"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_schedule_query_from_inspector", 
               "doc": {
                  "headline": "Gets a schedule query from an inspector.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    schedule_query_inspector\n                (osid.calendaring.ScheduleQueryInspector): a schedule\n                query inspector\n", 
               "return_doc": "        return: (osid.calendaring.ScheduleQuery) - the schedule query", 
               "error_doc": "        raise:  NullArgument - ``schedule_query_inspector`` is ``null``\n        raise:  Unsupported - ``schedule_query_inspector`` is not of\n                this service", 
               "sphinx_param_doc": "        :param schedule_query_inspector: a schedule query inspector\n        :type schedule_query_inspector: ``osid.calendaring.ScheduleQueryInspector``\n", 
               "sphinx_return_doc": "        :return: the schedule query\n        :rtype: ``osid.calendaring.ScheduleQuery``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``schedule_query_inspector`` is ``null``\n        :raise: ``Unsupported`` -- ``schedule_query_inspector`` is not of this service", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.calendaring.ScheduleQueryInspector", 
                     "var_name": "schedule_query_inspector", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.calendaring.ScheduleQueryInspector"
               ], 
               "return_type": "osid.calendaring.ScheduleQuery", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.calendaring.ScheduleSlotLookupSession", 
         "shortname": "ScheduleSlotLookupSession", 
         "category": "sessions", 
         "doc": {
            "headline": "This session provides methods for retrieving ``ScheduleSlots``.", 
            "body": ""
         }, 
         "inherit_fullnames": [
            "osid.OsidSession"
         ], 
         "inherit_shortnames": [
            "OsidSession"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidSession"
            }
         ], 
         "method_names": [
            "get_calendar_id", 
            "get_calendar", 
            "can_lookup_schedule_slots", 
            "use_comparative_schedule_slot_view", 
            "use_plenary_schedule_slot_view", 
            "use_federated_calendar_view", 
            "use_isolated_calendar_view", 
            "use_sequestered_schedule_slot_view", 
            "use_unsequestered_schedule_slot_view", 
            "get_schedule_slot", 
            "get_schedule_slots_by_ids", 
            "get_schedule_slots_by_genus_type", 
            "get_schedule_slots_by_parent_genus_type", 
            "get_schedule_slots_by_record_type", 
            "get_schedule_slots_by_weekdays", 
            "get_schedule_slots_by_time", 
            "get_schedule_slots"
         ], 
         "methods": [
            {
               "name": "get_calendar_id", 
               "doc": {
                  "headline": "Gets the ``Calendar``  ``Id`` associated with this session.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.id.Id) - the ``Calendar Id`` associated with this\n                session", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the ``Calendar Id`` associated with this session\n        :rtype: ``osid.id.Id``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.id.Id", 
               "errors": {}
            }, 
            {
               "name": "get_calendar", 
               "doc": {
                  "headline": "Gets the ``Calendar`` associated with this session.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.Calendar) - the ``Calendar``\n                associated with this session", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the ``Calendar`` associated with this session\n        :rtype: ``osid.calendaring.Calendar``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.Calendar", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "can_lookup_schedule_slots", 
               "doc": {
                  "headline": "Tests if this user can perform ``ScheduleSlot`` lookups.", 
                  "body": "        A return of true does not guarantee successful authorization. A\n        return of false indicates that it is known all methods in this\n        session will result in a ``PermissionDenied``. This is intended\n        as a hint to an application that may opt not to offer lookup\n        operations to unauthorized users."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``false`` if lookup methods are not\n                authorized, ``true`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``false`` if lookup methods are not authorized, ``true`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "use_comparative_schedule_slot_view", 
               "doc": {
                  "headline": "The returns from the lookup methods may omit or translate elements based on this session, such as authorization, and not result in an error.", 
                  "body": "        This view is used when greater interoperability is desired at\n        the expense of precision."
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "use_plenary_schedule_slot_view", 
               "doc": {
                  "headline": "A complete view of the ``ScheduleSlot`` returns is desired.", 
                  "body": "        Methods will return what is requested or result in an error.\n        This view is used when greater precision is desired at the\n        expense of interoperability."
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "use_federated_calendar_view", 
               "doc": {
                  "headline": "Federates the view for methods in this session.", 
                  "body": "        A federated view will include schedules in calendars which are\n        children of this calendar in the calendar hierarchy."
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "use_isolated_calendar_view", 
               "doc": {
                  "headline": "Isolates the view for methods in this session.", 
                  "body": "        An isolated view restricts lookups to this calendar only."
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "use_sequestered_schedule_slot_view", 
               "doc": {
                  "headline": "The returns from the lookup methods omit sequestered schedule slots.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "use_unsequestered_schedule_slot_view", 
               "doc": {
                  "headline": "All schedule slots are returned including sequestered schedule slots.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "get_schedule_slot", 
               "doc": {
                  "headline": "Gets the ``ScheduleSlot`` specified by its ``Id``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    schedule_slot_id (osid.id.Id): ``Id`` of the\n                ``ScheduleSlot``\n", 
               "return_doc": "        return: (osid.calendaring.ScheduleSlot) - the schedule slot", 
               "error_doc": "        raise:  NotFound - ``schedule_slot_id`` not found\n        raise:  NullArgument - ``schedule_slot_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param schedule_slot_id: ``Id`` of the ``ScheduleSlot``\n        :type schedule_slot_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: the schedule slot\n        :rtype: ``osid.calendaring.ScheduleSlot``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``schedule_slot_id`` not found\n        :raise: ``NullArgument`` -- ``schedule_slot_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "schedule_slot_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "osid.calendaring.ScheduleSlot", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_schedule_slots_by_ids", 
               "doc": {
                  "headline": "Gets a ``ScheduleSlotList`` corresponding to the given ``IdList``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    schedule_slot_ids (osid.id.IdList): the list of ``Ids``\n                to retrieve\n", 
               "return_doc": "        return: (osid.calendaring.ScheduleSlotList) - the returned\n                ``ScheduleSlot`` list", 
               "error_doc": "        raise:  NotFound - an ``Id was`` not found\n        raise:  NullArgument - ``schedule_slot_ids`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param schedule_slot_ids: the list of ``Ids`` to retrieve\n        :type schedule_slot_ids: ``osid.id.IdList``\n", 
               "sphinx_return_doc": "        :return: the returned ``ScheduleSlot`` list\n        :rtype: ``osid.calendaring.ScheduleSlotList``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- an ``Id was`` not found\n        :raise: ``NullArgument`` -- ``schedule_slot_ids`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.IdList", 
                     "var_name": "schedule_slot_ids", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.IdList"
               ], 
               "return_type": "osid.calendaring.ScheduleSlotList", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_schedule_slots_by_genus_type", 
               "doc": {
                  "headline": "Gets a ``ScheduleSlotList`` corresponding to the given schedule slot genus ``Type`` which does not include schedule slots of genus types derived from the specified ``Type``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    schedule_slot_genus_type (osid.type.Type): a schedule\n                slot genus type\n", 
               "return_doc": "        return: (osid.calendaring.ScheduleSlotList) - the returned\n                ``ScheduleSlot`` list", 
               "error_doc": "        raise:  NullArgument - ``schedule_slot_genus_type`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param schedule_slot_genus_type: a schedule slot genus type\n        :type schedule_slot_genus_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "        :return: the returned ``ScheduleSlot`` list\n        :rtype: ``osid.calendaring.ScheduleSlotList``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``schedule_slot_genus_type`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "schedule_slot_genus_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "osid.calendaring.ScheduleSlotList", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_schedule_slots_by_parent_genus_type", 
               "doc": {
                  "headline": "Gets a ``ScheduleSlotList`` corresponding to the given schedule slot genus ``Type`` and include any additional schedule slots with genus types derived from the specified ``Type``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    schedule_slot_genus_type (osid.type.Type): a schedule\n                slot genus type\n", 
               "return_doc": "        return: (osid.calendaring.ScheduleSlotList) - the returned\n                ``ScheduleSlot`` list", 
               "error_doc": "        raise:  NullArgument - ``schedule_slot_genus_type`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param schedule_slot_genus_type: a schedule slot genus type\n        :type schedule_slot_genus_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "        :return: the returned ``ScheduleSlot`` list\n        :rtype: ``osid.calendaring.ScheduleSlotList``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``schedule_slot_genus_type`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "schedule_slot_genus_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "osid.calendaring.ScheduleSlotList", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_schedule_slots_by_record_type", 
               "doc": {
                  "headline": "Gets a ``ScheduleSlotList`` containing the given schedule record ``Type``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    schedule_slot_record_type (osid.type.Type): a schedule\n                slot record type\n", 
               "return_doc": "        return: (osid.calendaring.ScheduleSlotList) - the returned\n                ``ScheduleSlot`` list", 
               "error_doc": "        raise:  NullArgument - ``schedule_slot_record_type`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param schedule_slot_record_type: a schedule slot record type\n        :type schedule_slot_record_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "        :return: the returned ``ScheduleSlot`` list\n        :rtype: ``osid.calendaring.ScheduleSlotList``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``schedule_slot_record_type`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "schedule_slot_record_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "osid.calendaring.ScheduleSlotList", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_schedule_slots_by_weekdays", 
               "doc": {
                  "headline": "Gets a ``ScheduleSlotList`` containing the given set of weekdays.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    weekdays (cardinal[]): a set of weekdays\n", 
               "return_doc": "        return: (osid.calendaring.ScheduleSlotList) - the returned\n                ``ScheduleSlot`` list", 
               "error_doc": "        raise:  InvalidArgument - a ``weekday`` is negative\n        raise:  NullArgument - ``weekdays`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param weekdays: a set of weekdays\n        :type weekdays: ``cardinal[]``\n", 
               "sphinx_return_doc": "        :return: the returned ``ScheduleSlot`` list\n        :rtype: ``osid.calendaring.ScheduleSlotList``", 
               "sphinx_error_doc": "        :raise: ``InvalidArgument`` -- a ``weekday`` is negative\n        :raise: ``NullArgument`` -- ``weekdays`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "cardinal[]", 
                     "var_name": "weekdays", 
                     "array": true
                  }
               ], 
               "arg_types": [
                  "cardinal[]"
               ], 
               "return_type": "osid.calendaring.ScheduleSlotList", 
               "errors": {
                  "INVALID_ARGUMENT": "ConsumerContract", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_schedule_slots_by_time", 
               "doc": {
                  "headline": "Gets a ``ScheduleSlotList`` matching the given time.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    time (osid.calendaring.Time): a time\n", 
               "return_doc": "        return: (osid.calendaring.ScheduleSlotList) - the returned\n                ``ScheduleSlot`` list", 
               "error_doc": "        raise:  NullArgument - ``time`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param time: a time\n        :type time: ``osid.calendaring.Time``\n", 
               "sphinx_return_doc": "        :return: the returned ``ScheduleSlot`` list\n        :rtype: ``osid.calendaring.ScheduleSlotList``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``time`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.calendaring.Time", 
                     "var_name": "time", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.calendaring.Time"
               ], 
               "return_type": "osid.calendaring.ScheduleSlotList", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_schedule_slots", 
               "doc": {
                  "headline": "Gets all ``ScheduleSlots``.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.ScheduleSlotList) - a\n                ``ScheduleSlotList``", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: a ``ScheduleSlotList``\n        :rtype: ``osid.calendaring.ScheduleSlotList``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.ScheduleSlotList", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.calendaring.ScheduleSlotQuerySession", 
         "shortname": "ScheduleSlotQuerySession", 
         "category": "sessions", 
         "doc": {
            "headline": "This session provides methods for searching ``ScheduleSlot`` objects.", 
            "body": "    The search query is constructed using the ``ScheduleSlotQuery``. The\n    schedule slot record ``Type`` also specifies the record for the\n    schedule slot query.\n\n    This session defines views that offer differing behaviors for\n    searching.\n    \n      * federated calendar view: searches include schedule slots in\n        calendars of which this calendar is an ancestor in the calendar\n        hierarchy\n      * isolated calendar view: searches are restricted to schedule\n        slots in this calendar\n      * sequestered schedule slot viiew: All schedule slot methods\n        suppress sequestered schedule slots.\n      * unsequestered schedule slot view: All schedule slot methods\n        return all schedule slots.\n\n    \n    Schedule slots may have a query record indicated by their respective\n    record types. The query record is accessed via the\n    ``ScheduleSlotQuery``."
         }, 
         "inherit_fullnames": [
            "osid.OsidSession"
         ], 
         "inherit_shortnames": [
            "OsidSession"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidSession"
            }
         ], 
         "method_names": [
            "get_calendar_id", 
            "get_calendar", 
            "can_search_schedule_slots", 
            "use_federated_calendar_view", 
            "use_isolated_calendar_view", 
            "use_sequestered_schedule_slot_view", 
            "use_unsequestered_schedule_slot_view", 
            "get_schedule_slot_query", 
            "get_schedule_slots_by_query"
         ], 
         "methods": [
            {
               "name": "get_calendar_id", 
               "doc": {
                  "headline": "Gets the ``Calendar``  ``Id`` associated with this session.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.id.Id) - the ``Calendar Id`` associated with this\n                session", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the ``Calendar Id`` associated with this session\n        :rtype: ``osid.id.Id``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.id.Id", 
               "errors": {}
            }, 
            {
               "name": "get_calendar", 
               "doc": {
                  "headline": "Gets the ``Calendar`` associated with this session.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.Calendar) - the ``Calendar``\n                associated with this session", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the ``Calendar`` associated with this session\n        :rtype: ``osid.calendaring.Calendar``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.Calendar", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "can_search_schedule_slots", 
               "doc": {
                  "headline": "Tests if this user can perform ``ScheduleSlots`` searches.", 
                  "body": "        A return of true does not guarantee successful authorization. A\n        return of false indicates that it is known all methods in this\n        session will result in a ``PermissionDenied``. This is intended\n        as a hint to an application that may opt not to offer search\n        operations to unauthorized users."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``false`` if search methods are not\n                authorized, ``true`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``false`` if search methods are not authorized, ``true`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "use_federated_calendar_view", 
               "doc": {
                  "headline": "Federates the view for methods in this session.", 
                  "body": "        A federated view will include schedules in calendars which are\n        children of this calendar in the calendar hierarchy."
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "use_isolated_calendar_view", 
               "doc": {
                  "headline": "Isolates the view for methods in this session.", 
                  "body": "        An isolated view restricts searches to this calendar only."
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "use_sequestered_schedule_slot_view", 
               "doc": {
                  "headline": "The returns from the search methods omit sequestered schedule slots.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "use_unsequestered_schedule_slot_view", 
               "doc": {
                  "headline": "All schedule slots are returned including sequestered schedule slots.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "get_schedule_slot_query", 
               "doc": {
                  "headline": "Gets a schedule slot query.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.ScheduleSlotQuery) - the schedule slot\n                query", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the schedule slot query\n        :rtype: ``osid.calendaring.ScheduleSlotQuery``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.ScheduleSlotQuery", 
               "errors": {}
            }, 
            {
               "name": "get_schedule_slots_by_query", 
               "doc": {
                  "headline": "Gets a list of ``ScheduleSlots`` matching the given schedule slot query.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    schedule_slot_query\n                (osid.calendaring.ScheduleSlotQuery): the schedule slot\n                query\n", 
               "return_doc": "        return: (osid.calendaring.ScheduleSlotList) - the returned\n                ``ScheduleSlotList``", 
               "error_doc": "        raise:  NullArgument - ``schedule_slot_query`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        raise:  Unsupported - ``schedule_slot_query`` is not of this\n                service", 
               "sphinx_param_doc": "        :param schedule_slot_query: the schedule slot query\n        :type schedule_slot_query: ``osid.calendaring.ScheduleSlotQuery``\n", 
               "sphinx_return_doc": "        :return: the returned ``ScheduleSlotList``\n        :rtype: ``osid.calendaring.ScheduleSlotList``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``schedule_slot_query`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure\n        :raise: ``Unsupported`` -- ``schedule_slot_query`` is not of this service", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.calendaring.ScheduleSlotQuery", 
                     "var_name": "schedule_slot_query", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.calendaring.ScheduleSlotQuery"
               ], 
               "return_type": "osid.calendaring.ScheduleSlotList", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.calendaring.ScheduleSlotSearchSession", 
         "shortname": "ScheduleSlotSearchSession", 
         "category": "sessions", 
         "doc": {
            "headline": "This session provides methods for searching ``ScheduleSlot`` objects.", 
            "body": "    The search query is constructed using the ``ScheduleSlotQuery``. The\n    schedule slot record ``Type`` also specifies the record for the\n    schedule slot query.\n\n    ``get_schedule_slots_by_query()`` is the basic search method and\n    returns a list of ``ScheduleSlots``. A more advanced search may be\n    performed with ``getScheduleSlotsBySearch()``. It accepts a\n    ``ScheduleSlotSearch`` in addition to the query for the purpose of\n    specifying additional options affecting the entire search, such as\n    ordering. ``get_schedule_slots_by_search()`` returns a\n    ``ScheduleSlotSearchResults`` that can be used to access the\n    resulting ``ScheduleSlotsList`` or be used to perform a search\n    within the result set through ``ScheduleSlotSearch``.\n    \n    This session defines views that offer differing behaviors for\n    searching.\n    \n      * federated calendar view: searches include schedule slots in\n        calendars of which this calendar is a ancestor in the calendar\n        hierarchy\n      * isolated calendar view: searches are restricted to schedule\n        slots in this calendar\n\n    \n    Schedule slots may have a query record indicated by their respective\n    record types. The query record is accessed via the\n    ``ScheduleSlotQuery``."
         }, 
         "inherit_fullnames": [
            "osid.calendaring.ScheduleSlotQuerySession"
         ], 
         "inherit_shortnames": [
            "ScheduleSlotQuerySession"
         ], 
         "inherit_pkg_names": [
            "calendaring"
         ], 
         "inheritance": [
            {
               "pkg_name": "calendaring", 
               "name": "ScheduleSlotQuerySession"
            }
         ], 
         "method_names": [
            "get_schedule_slot_search", 
            "get_schedule_slot_search_order", 
            "get_schedule_slots_by_search", 
            "get_schedule_slot_query_from_inspector"
         ], 
         "methods": [
            {
               "name": "get_schedule_slot_search", 
               "doc": {
                  "headline": "Gets a schedule slot search.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.ScheduleSlotSearch) - the schedule\n                slot search", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the schedule slot search\n        :rtype: ``osid.calendaring.ScheduleSlotSearch``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.ScheduleSlotSearch", 
               "errors": {}
            }, 
            {
               "name": "get_schedule_slot_search_order", 
               "doc": {
                  "headline": "Gets a schedule slot search order.", 
                  "body": "        The ``ScheduleSlotSearchOrder`` is supplied to a\n        ``ScheduleSlotSearch`` to specify the ordering of results."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.ScheduleSlotSearchOrder) - the\n                schedule slot search order", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the schedule slot search order\n        :rtype: ``osid.calendaring.ScheduleSlotSearchOrder``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.ScheduleSlotSearchOrder", 
               "errors": {}
            }, 
            {
               "name": "get_schedule_slots_by_search", 
               "doc": {
                  "headline": "Gets the search results matching the given search query using the given search.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    schedule_slot_query\n                (osid.calendaring.ScheduleSlotQuery): the schedule slot\n                query\n        arg:    schedule_slot_search\n                (osid.calendaring.ScheduleSlotSearch): the schedule slot\n                search\n", 
               "return_doc": "        return: (osid.calendaring.ScheduleSearchResults) - the schedule\n                slot search results", 
               "error_doc": "        raise:  NullArgument - ``schedule_slot_query`` or\n                ``schedule_slot_search`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        raise:  Unsupported - ``schedule_slot_search`` or\n                ``schedule_slot_query`` is not of this service", 
               "sphinx_param_doc": "        :param schedule_slot_query: the schedule slot query\n        :type schedule_slot_query: ``osid.calendaring.ScheduleSlotQuery``\n        :param schedule_slot_search: the schedule slot search\n        :type schedule_slot_search: ``osid.calendaring.ScheduleSlotSearch``\n", 
               "sphinx_return_doc": "        :return: the schedule slot search results\n        :rtype: ``osid.calendaring.ScheduleSearchResults``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``schedule_slot_query`` or ``schedule_slot_search`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure\n        :raise: ``Unsupported`` -- ``schedule_slot_search`` or ``schedule_slot_query`` is not of this service", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.calendaring.ScheduleSlotQuery", 
                     "var_name": "schedule_slot_query", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.calendaring.ScheduleSlotSearch", 
                     "var_name": "schedule_slot_search", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.calendaring.ScheduleSlotQuery", 
                  "osid.calendaring.ScheduleSlotSearch"
               ], 
               "return_type": "osid.calendaring.ScheduleSearchResults", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_schedule_slot_query_from_inspector", 
               "doc": {
                  "headline": "Gets a schedule slot query from an inspector.", 
                  "body": "        The inspector is available from an\n        ``ScheduleSlotSearchResults``."
               }, 
               "arg_doc": "        arg:    schedule_slot_query_inspector\n                (osid.calendaring.ScheduleSlotQueryInspector): a\n                schedule slot query inspector\n", 
               "return_doc": "        return: (osid.calendaring.ScheduleSlotQuery) - the schedule\n                query", 
               "error_doc": "        raise:  NullArgument - ``schedule_slot_query_inspector`` is\n                ``null``\n        raise:  Unsupported - ``schedule_slot_query_inspector`` is not\n                of this service", 
               "sphinx_param_doc": "        :param schedule_slot_query_inspector: a schedule slot query inspector\n        :type schedule_slot_query_inspector: ``osid.calendaring.ScheduleSlotQueryInspector``\n", 
               "sphinx_return_doc": "        :return: the schedule query\n        :rtype: ``osid.calendaring.ScheduleSlotQuery``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``schedule_slot_query_inspector`` is ``null``\n        :raise: ``Unsupported`` -- ``schedule_slot_query_inspector`` is not of this service", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.calendaring.ScheduleSlotQueryInspector", 
                     "var_name": "schedule_slot_query_inspector", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.calendaring.ScheduleSlotQueryInspector"
               ], 
               "return_type": "osid.calendaring.ScheduleSlotQuery", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.calendaring.ScheduleSlotAdminSession", 
         "shortname": "ScheduleSlotAdminSession", 
         "category": "sessions", 
         "doc": {
            "headline": "This session creates, updates, and deletes ``Schedule Slots``.", 
            "body": "    The data for create and update is provided by the consumer via the\n    form object. ``OsidForms`` are requested for each create or update\n    and may not be reused.\n\n    Create and update operations differ in their usage. To create a\n    ``ScheduleSlot,`` a ``ScheduleSlotForm`` is requested using\n    ``get_schedule_slot_form_for_create()`` specifying the desired\n    record ``Types`` or none if no record ``Types`` are needed. The\n    returned ``ScheduleSlotForm`` will indicate that it is to be used\n    with a create operation and can be used to examine metdata or\n    validate data prior to creation. Once the ``ScheduleSlotForm`` is\n    submiited to a create operation, it cannot be reused with another\n    create operation unless the first operation was unsuccessful. Each\n    ``ScheduleSlotForm`` corresponds to an attempted transaction.\n    \n    For updates, ``ScheduleSlotForms`` are requested to the\n    ``ScheduleSlot``  ``Id`` that is to be updated using\n    ``getScheduleSlotFormForUpdate()``. Similarly, the\n    ``ScheduleSlotForm`` has metadata about the data that can be updated\n    and it can perform validation before submitting the update. The\n    ``ScheduleSlotForm`` can only be used once for a successful update\n    and cannot be reused.\n    \n    The delete operations delete ``Schedule Slots``. To unmap a\n    ``ScheduleSlot`` from the current ``Calendar,`` the\n    ``ScheduleSlotCalendarAssignmentSession`` should be used. These\n    delete operations attempt to remove the ``ScheduleSlot`` itself thus\n    removing it from all known ``Calendar`` catalogs.\n    \n    This session includes an ``Id`` aliasing mechanism to assign an\n    external ``Id`` to an internally assigned Id."
         }, 
         "inherit_fullnames": [
            "osid.OsidSession"
         ], 
         "inherit_shortnames": [
            "OsidSession"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidSession"
            }
         ], 
         "method_names": [
            "get_calendar_id", 
            "get_calendar", 
            "can_create_schedule_slots", 
            "can_create_schedule_slot_with_record_types", 
            "get_schedule_slot_form_for_create", 
            "create_schedule_slot", 
            "can_update_schedule_slots", 
            "get_schedule_slot_form_for_update", 
            "update_schedule_slot", 
            "can_delete_schedule_slots", 
            "delete_schedule_slot", 
            "can_manage_schedule_slot_aliases", 
            "alias_schedule_slot"
         ], 
         "methods": [
            {
               "name": "get_calendar_id", 
               "doc": {
                  "headline": "Gets the ``Calendar``  ``Id`` associated with this session.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.id.Id) - the ``Calendar Id`` associated with this\n                session", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the ``Calendar Id`` associated with this session\n        :rtype: ``osid.id.Id``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.id.Id", 
               "errors": {}
            }, 
            {
               "name": "get_calendar", 
               "doc": {
                  "headline": "Gets the ``Calendar`` associated with this session.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.Calendar) - the ``Calendar``\n                associated with this session", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the ``Calendar`` associated with this session\n        :rtype: ``osid.calendaring.Calendar``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.Calendar", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "can_create_schedule_slots", 
               "doc": {
                  "headline": "Tests if this user can create ``ScheduleSlots``.", 
                  "body": "        A return of true does not guarantee successful authorization. A\n        return of false indicates that it is known creating a\n        ``ScheduleSlot`` will result in a ``PermissionDenied``. This is\n        intended as a hint to an application that may opt not to offer\n        create operations to an unauthorized user."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``false`` if ``ScheduleSlot`` creation is\n                not authorized, ``true`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``false`` if ``ScheduleSlot`` creation is not authorized, ``true`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "can_create_schedule_slot_with_record_types", 
               "doc": {
                  "headline": "Tests if this user can create a single ``ScheduleSlot`` using the desired record types.", 
                  "body": "        While ``CalendaringManager.getScheduleSlotRecordTypes()`` can be\n        used to examine which records are supported, this method tests\n        which record(s) are required for creating a specific\n        ``ScheduleSlot``. Providing an empty array tests if a\n        ``ScheduleSlot`` can be created with no records."
               }, 
               "arg_doc": "        arg:    schedule_slot_record_types (osid.type.Type[]): array of\n                schedule slot record types\n", 
               "return_doc": "        return: (boolean) - ``true`` if ``ScheduleSlot`` creation using\n                the specified record ``Types`` is supported, ``false``\n                otherwise", 
               "error_doc": "        raise:  NullArgument - ``schedule_slot_record_types`` is\n                ``null``", 
               "sphinx_param_doc": "        :param schedule_slot_record_types: array of schedule slot record types\n        :type schedule_slot_record_types: ``osid.type.Type[]``\n", 
               "sphinx_return_doc": "        :return: ``true`` if ``ScheduleSlot`` creation using the specified record ``Types`` is supported, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``schedule_slot_record_types`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type[]", 
                     "var_name": "schedule_slot_record_types", 
                     "array": true
                  }
               ], 
               "arg_types": [
                  "osid.type.Type[]"
               ], 
               "return_type": "boolean", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "get_schedule_slot_form_for_create", 
               "doc": {
                  "headline": "Gets the schedule slot form for creating new schedule slots.", 
                  "body": "        A new form should be requested for each create transaction."
               }, 
               "arg_doc": "        arg:    schedule_slot_record_types (osid.type.Type[]): array of\n                schedule slot record types\n", 
               "return_doc": "        return: (osid.calendaring.ScheduleSlotForm) - the schedule slot\n                form", 
               "error_doc": "        raise:  NullArgument - ``schedule_slot_record_types`` is\n                ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        raise:  Unsupported - unable to get form for requested record\n                types", 
               "sphinx_param_doc": "        :param schedule_slot_record_types: array of schedule slot record types\n        :type schedule_slot_record_types: ``osid.type.Type[]``\n", 
               "sphinx_return_doc": "        :return: the schedule slot form\n        :rtype: ``osid.calendaring.ScheduleSlotForm``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``schedule_slot_record_types`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure\n        :raise: ``Unsupported`` -- unable to get form for requested record types", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type[]", 
                     "var_name": "schedule_slot_record_types", 
                     "array": true
                  }
               ], 
               "arg_types": [
                  "osid.type.Type[]"
               ], 
               "return_type": "osid.calendaring.ScheduleSlotForm", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }, 
            {
               "name": "create_schedule_slot", 
               "doc": {
                  "headline": "Creates a new ``ScheduleSlot``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    schedule_slot_form (osid.calendaring.ScheduleSlotForm):\n                the form for this ``ScheduleSlot``\n", 
               "return_doc": "        return: (osid.calendaring.ScheduleSlot) - the new\n                ``ScheduleSlot``", 
               "error_doc": "        raise:  IllegalState - ``schedule_slot_form`` already used in a\n                create transaction\n        raise:  InvalidArgument - one or more of the form elements is\n                invalid\n        raise:  NullArgument - ``schedule_slot_form`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        raise:  Unsupported - ``schedule_slot_form`` did not originate\n                from ``get_schedule_slot_form_for_create()``", 
               "sphinx_param_doc": "        :param schedule_slot_form: the form for this ``ScheduleSlot``\n        :type schedule_slot_form: ``osid.calendaring.ScheduleSlotForm``\n", 
               "sphinx_return_doc": "        :return: the new ``ScheduleSlot``\n        :rtype: ``osid.calendaring.ScheduleSlot``", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- ``schedule_slot_form`` already used in a create transaction\n        :raise: ``InvalidArgument`` -- one or more of the form elements is invalid\n        :raise: ``NullArgument`` -- ``schedule_slot_form`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure\n        :raise: ``Unsupported`` -- ``schedule_slot_form`` did not originate from ``get_schedule_slot_form_for_create()``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.calendaring.ScheduleSlotForm", 
                     "var_name": "schedule_slot_form", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.calendaring.ScheduleSlotForm"
               ], 
               "return_type": "osid.calendaring.ScheduleSlot", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract", 
                  "INVALID_ARGUMENT": "ConsumerContract", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }, 
            {
               "name": "can_update_schedule_slots", 
               "doc": {
                  "headline": "Tests if this user can update ``ScheduleSlots``.", 
                  "body": "        A return of true does not guarantee successful authorization. A\n        return of false indicates that it is known updating a\n        ``ScheduleSlot`` will result in a ``PermissionDenied``. This is\n        intended as a hint to an application that may opt not to offer\n        update operations to an unauthorized user."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``false`` if schedule slot modification is\n                not authorized, ``true`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``false`` if schedule slot modification is not authorized, ``true`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "get_schedule_slot_form_for_update", 
               "doc": {
                  "headline": "Gets the schedule slot form for updating an existing schedule slot.", 
                  "body": "        A new schedule slot form should be requested for each update\n        transaction."
               }, 
               "arg_doc": "        arg:    schedule_slot_id (osid.id.Id): the ``Id`` of the\n                ``ScheduleSlot``\n", 
               "return_doc": "        return: (osid.calendaring.ScheduleSlotForm) - the schedule slot\n                form", 
               "error_doc": "        raise:  NotFound - ``schedule_slot_id`` is not found\n        raise:  NullArgument - ``schedule_slot_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param schedule_slot_id: the ``Id`` of the ``ScheduleSlot``\n        :type schedule_slot_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: the schedule slot form\n        :rtype: ``osid.calendaring.ScheduleSlotForm``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``schedule_slot_id`` is not found\n        :raise: ``NullArgument`` -- ``schedule_slot_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "schedule_slot_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "osid.calendaring.ScheduleSlotForm", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "update_schedule_slot", 
               "doc": {
                  "headline": "Updates an existing schedule slot.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    schedule_slot_form (osid.calendaring.ScheduleSlotForm):\n                the form containing the elements to be updated\n", 
               "return_doc": "", 
               "error_doc": "        raise:  IllegalState - ``schedule_slot_form`` already used in an\n                update transaction\n        raise:  InvalidArgument - the form contains an invalid value\n        raise:  NullArgument - ``schedule_slot_form`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        raise:  Unsupported - ``schedule_slot_form`` did not originate\n                from ``get_schedule_slot_form_for_update()``", 
               "sphinx_param_doc": "        :param schedule_slot_form: the form containing the elements to be updated\n        :type schedule_slot_form: ``osid.calendaring.ScheduleSlotForm``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- ``schedule_slot_form`` already used in an update transaction\n        :raise: ``InvalidArgument`` -- the form contains an invalid value\n        :raise: ``NullArgument`` -- ``schedule_slot_form`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure\n        :raise: ``Unsupported`` -- ``schedule_slot_form`` did not originate from ``get_schedule_slot_form_for_update()``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.calendaring.ScheduleSlotForm", 
                     "var_name": "schedule_slot_form", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.calendaring.ScheduleSlotForm"
               ], 
               "return_type": "", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract", 
                  "INVALID_ARGUMENT": "ConsumerContract", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }, 
            {
               "name": "can_delete_schedule_slots", 
               "doc": {
                  "headline": "Tests if this user can delete ``ScheduleSlots``.", 
                  "body": "        A return of true does not guarantee successful authorization. A\n        return of false indicates that it is known deleting a\n        ``ScheduleSlot`` will result in a ``PermissionDenied``. This is\n        intended as a hint to an application that may opt not to offer\n        delete operations to an unauthorized user."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``false`` if ``ScheduleSlot`` deletion is\n                not authorized, ``true`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``false`` if ``ScheduleSlot`` deletion is not authorized, ``true`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "delete_schedule_slot", 
               "doc": {
                  "headline": "Deletes the ``ScheduleSlot`` identified by the given ``Id``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    schedule_slot_id (osid.id.Id): the ``Id`` of the\n                ``ScheduleSlot`` to delete\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NotFound - a ``ScheduleSlot`` was not found identified\n                by the given ``Id``\n        raise:  NullArgument - ``schedule_slot_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param schedule_slot_id: the ``Id`` of the ``ScheduleSlot`` to delete\n        :type schedule_slot_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- a ``ScheduleSlot`` was not found identified by the given ``Id``\n        :raise: ``NullArgument`` -- ``schedule_slot_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "schedule_slot_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "can_manage_schedule_slot_aliases", 
               "doc": {
                  "headline": "Tests if this user can manage ``Id`` aliases for ``ScheduleSlots``.", 
                  "body": "        A return of true does not guarantee successful authorization. A\n        return of false indicates that it is known changing an alias\n        will result in a ``PermissionDenied``. This is intended as a\n        hint to an application that may opt not to offer alias\n        operations to an unauthorized user."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``false`` if ``ScheduleSlot`` aliasing is\n                not authorized, ``true`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``false`` if ``ScheduleSlot`` aliasing is not authorized, ``true`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "alias_schedule_slot", 
               "doc": {
                  "headline": "Adds an ``Id`` to a ``ScheduleSlot`` for the purpose of creating compatibility.", 
                  "body": "        The primary ``Id`` of the ``ScheduleSlot`` is determined by the\n        provider. The new ``Id`` performs as an alias to the primary\n        ``Id``. If the alias is a pointer to another schedule slot, it\n        is reassigned to the given schedule slot ``Id``."
               }, 
               "arg_doc": "        arg:    schedule_slot_id (osid.id.Id): the ``Id`` of a\n                ``ScheduleSlot``\n        arg:    alias_id (osid.id.Id): the alias ``Id``\n", 
               "return_doc": "", 
               "error_doc": "        raise:  AlreadyExists - ``alias_id`` is already assigned\n        raise:  NotFound - ``schedule_slot_id`` not found\n        raise:  NullArgument - ``schedule_slot_id`` or ``alias_id`` is\n                ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param schedule_slot_id: the ``Id`` of a ``ScheduleSlot``\n        :type schedule_slot_id: ``osid.id.Id``\n        :param alias_id: the alias ``Id``\n        :type alias_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``AlreadyExists`` -- ``alias_id`` is already assigned\n        :raise: ``NotFound`` -- ``schedule_slot_id`` not found\n        :raise: ``NullArgument`` -- ``schedule_slot_id`` or ``alias_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "schedule_slot_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "alias_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {
                  "ALREADY_EXISTS": "User", 
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.calendaring.ScheduleSlotNotificationSession", 
         "shortname": "ScheduleSlotNotificationSession", 
         "category": "sessions", 
         "doc": {
            "headline": "This session defines methods to receive asynchronous notifications on adds/changes to ``ScheduleSlot`` objects.", 
            "body": "    This session is intended for consumers needing to synchronize their\n    state with this service without the use of polling. Notifications\n    are cancelled when this session is closed.\n\n    The views defined in this session correspond to the views in the\n    ``ScheduleSlotLookupSession``."
         }, 
         "inherit_fullnames": [
            "osid.OsidSession"
         ], 
         "inherit_shortnames": [
            "OsidSession"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidSession"
            }
         ], 
         "method_names": [
            "get_calendar_id", 
            "get_calendar", 
            "can_register_for_schedule_slot_notifications", 
            "use_federated_calendar_view", 
            "use_isolated_calendar_view", 
            "register_for_new_schedule_slots", 
            "register_for_changed_schedule_slots", 
            "register_for_changed_schedule_slot", 
            "register_for_deleted_schedule_slots", 
            "register_for_deleted_schedule_slot"
         ], 
         "methods": [
            {
               "name": "get_calendar_id", 
               "doc": {
                  "headline": "Gets the ``Calendar``  ``Id`` associated with this session.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.id.Id) - the ``Calendar Id`` associated with this\n                session", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the ``Calendar Id`` associated with this session\n        :rtype: ``osid.id.Id``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.id.Id", 
               "errors": {}
            }, 
            {
               "name": "get_calendar", 
               "doc": {
                  "headline": "Gets the ``Calendar`` associated with this session.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.Calendar) - the ``Calendar``\n                associated with this session", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the ``Calendar`` associated with this session\n        :rtype: ``osid.calendaring.Calendar``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.Calendar", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "can_register_for_schedule_slot_notifications", 
               "doc": {
                  "headline": "Tests if this user can register for ``ScheduleSlot`` notifications.", 
                  "body": "        A return of true does not guarantee successful authorization. A\n        return of false indicates that it is known all methods in this\n        session will result in a ``PermissionDenied``. This is intended\n        as a hint to an application that may opt not to offer\n        notification operations."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``false`` if notification methods are not\n                authorized, ``true`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``false`` if notification methods are not authorized, ``true`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "use_federated_calendar_view", 
               "doc": {
                  "headline": "Federates the view for methods in this session.", 
                  "body": "        A federated view will include notifications for schedules in\n        calendars which are children of this calendar in the calendar\n        hierarchy."
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "use_isolated_calendar_view", 
               "doc": {
                  "headline": "Isolates the view for methods in this session.", 
                  "body": "        An isolated view restricts notifications to this calendar only."
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "register_for_new_schedule_slots", 
               "doc": {
                  "headline": "Register for notifications of new schedule slots.", 
                  "body": "        ``ScheduleSlotReceiver.newScheduleSlot()`` is invoked when a new\n        schedule slot is created."
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "register_for_changed_schedule_slots", 
               "doc": {
                  "headline": "Registers for notification of updated schedule schedule slots.", 
                  "body": "        ``ScheduleSlotReceiver.changedScheduleSlot()`` is invoked when a\n        schedule slot is changed."
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "register_for_changed_schedule_slot", 
               "doc": {
                  "headline": "Registers for notification of an updated schedule slot.", 
                  "body": "        ``ScheduleSlotReceiver.changedSchedulSlote()`` is invoked when\n        the specified schedule slot is changed."
               }, 
               "arg_doc": "        arg:    schedule_slot_id (osid.id.Id): the ``Id`` of the\n                ``ScheduleSlot`` to monitor\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``schedule_slot_id is null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param schedule_slot_id: the ``Id`` of the ``ScheduleSlot`` to monitor\n        :type schedule_slot_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``schedule_slot_id is null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "schedule_slot_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "register_for_deleted_schedule_slots", 
               "doc": {
                  "headline": "Registers for notification of deleted schedule slots.", 
                  "body": "        ``ScheduleSlotReceiver.deletedScheduleSlot()`` is invoked when a\n        schedule slot is removed from this calendar."
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "register_for_deleted_schedule_slot", 
               "doc": {
                  "headline": "Registers for notification of a deleted schedule slot.", 
                  "body": "        ``ScheduleSlotReceiver.changedScheduleSlot()`` is invoked when\n        the specified schedule slot is removed from this calendar."
               }, 
               "arg_doc": "        arg:    schedule_slot_id (osid.id.Id): the ``Id`` of the\n                ``ScheduleSlot`` to monitor\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``schedule_slot_id is null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param schedule_slot_id: the ``Id`` of the ``ScheduleSlot`` to monitor\n        :type schedule_slot_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``schedule_slot_id is null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "schedule_slot_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.calendaring.ScheduleSlotCalendarSession", 
         "shortname": "ScheduleSlotCalendarSession", 
         "category": "sessions", 
         "doc": {
            "headline": "This session provides methods to retrieve ``ScheduleSlot`` to ``Calendar`` mappings.", 
            "body": "    A ``ScheduleSlot`` may appear in multiple ``Calendars``. Each\n    ``Calendar`` may have its own authorizations governing who is\n    allowed to look at it.\n\n    This lookup session defines two views:\n    \n      * comparative view: elements may be silently omitted or re-ordered\n      * plenary view: provides a complete result set or is an error\n        condition\n"
         }, 
         "inherit_fullnames": [
            "osid.OsidSession"
         ], 
         "inherit_shortnames": [
            "OsidSession"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidSession"
            }
         ], 
         "method_names": [
            "can_lookup_schedule_slot_calendar_mappings", 
            "use_comparative_calendar_view", 
            "use_plenary_calendar_view", 
            "get_schedule_slot_ids_by_calendar", 
            "get_schedule_slots_by_calendar", 
            "get_schedule_slot_ids_by_calendars", 
            "get_schedule_slots_by_calendars", 
            "get_calendar_ids_by_schedule_slot", 
            "get_calendars_by_schedule_slot"
         ], 
         "methods": [
            {
               "name": "can_lookup_schedule_slot_calendar_mappings", 
               "doc": {
                  "headline": "Tests if this user can perform lookups of schedule slot/calendar mappings.", 
                  "body": "        A return of true does not guarantee successful authorization. A\n        return of false indicates that it is known lookup methods in\n        this session will result in a ``PermissionDenied``. This is\n        intended as a hint to an application that may opt not to offer\n        lookup operations to unauthorized users."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``false`` if looking up mappings is not\n                authorized, ``true`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``false`` if looking up mappings is not authorized, ``true`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "use_comparative_calendar_view", 
               "doc": {
                  "headline": "The returns from the lookup methods may omit or translate elements based on this session, such as authorization, and not result in an error.", 
                  "body": "        This view is used when greater interoperability is desired at\n        the expense of precision."
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "use_plenary_calendar_view", 
               "doc": {
                  "headline": "A complete view of the ``ScheduleSlot`` and ``Calendar`` returns is desired.", 
                  "body": "        Methods will return what is requested or result in an error.\n        This view is used when greater precision is desired at the\n        expense of interoperability."
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "get_schedule_slot_ids_by_calendar", 
               "doc": {
                  "headline": "Gets the list of ``ScheduleSlot``  ``Ids`` associated with a ``Calendar``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    calendar_id (osid.id.Id): ``Id`` of the ``Calendar``\n", 
               "return_doc": "        return: (osid.id.IdList) - list of related schedule slot ``Ids``", 
               "error_doc": "        raise:  NotFound - ``calendar_id`` is not found\n        raise:  NullArgument - ``calendar_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param calendar_id: ``Id`` of the ``Calendar``\n        :type calendar_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: list of related schedule slot ``Ids``\n        :rtype: ``osid.id.IdList``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``calendar_id`` is not found\n        :raise: ``NullArgument`` -- ``calendar_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "calendar_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "osid.id.IdList", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_schedule_slots_by_calendar", 
               "doc": {
                  "headline": "Gets the list of ``ScheduleSlots`` associated with a ``Calendar``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    calendar_id (osid.id.Id): ``Id`` of the ``Calendar``\n", 
               "return_doc": "        return: (osid.calendaring.ScheduleSlotList) - list of related\n                schedule slot", 
               "error_doc": "        raise:  NotFound - ``calendar_id`` is not found\n        raise:  NullArgument - ``calendar_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param calendar_id: ``Id`` of the ``Calendar``\n        :type calendar_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: list of related schedule slot\n        :rtype: ``osid.calendaring.ScheduleSlotList``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``calendar_id`` is not found\n        :raise: ``NullArgument`` -- ``calendar_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "calendar_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "osid.calendaring.ScheduleSlotList", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_schedule_slot_ids_by_calendars", 
               "doc": {
                  "headline": "Gets the list of ``ScheduleSlot Ids`` corresponding to a list of ``Calendars``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    calendar_ids (osid.id.IdList): list of calendar ``Ids``\n", 
               "return_doc": "        return: (osid.id.IdList) - list of schedule slot ``Ids``", 
               "error_doc": "        raise:  NullArgument - ``calendar_ids`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param calendar_ids: list of calendar ``Ids``\n        :type calendar_ids: ``osid.id.IdList``\n", 
               "sphinx_return_doc": "        :return: list of schedule slot ``Ids``\n        :rtype: ``osid.id.IdList``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``calendar_ids`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.IdList", 
                     "var_name": "calendar_ids", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.IdList"
               ], 
               "return_type": "osid.id.IdList", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_schedule_slots_by_calendars", 
               "doc": {
                  "headline": "Gets the list of ``ScheduleSlots`` corresponding to a list of ``Calendars``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    calendar_ids (osid.id.IdList): list of calendar ``Ids``\n", 
               "return_doc": "        return: (osid.calendaring.ScheduleSlotList) - list of schedule\n                slots", 
               "error_doc": "        raise:  NullArgument - ``calendar_ids`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param calendar_ids: list of calendar ``Ids``\n        :type calendar_ids: ``osid.id.IdList``\n", 
               "sphinx_return_doc": "        :return: list of schedule slots\n        :rtype: ``osid.calendaring.ScheduleSlotList``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``calendar_ids`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.IdList", 
                     "var_name": "calendar_ids", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.IdList"
               ], 
               "return_type": "osid.calendaring.ScheduleSlotList", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_calendar_ids_by_schedule_slot", 
               "doc": {
                  "headline": "Gets the list of ``Calendar``  ``Ids`` mapped to a ``ScheduleSlot``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    schedule_slot_id (osid.id.Id): ``Id`` of a\n                ``ScheduleSlot``\n", 
               "return_doc": "        return: (osid.id.IdList) - list of calendar ``Ids``", 
               "error_doc": "        raise:  NotFound - ``schedule_slot_id`` is not found\n        raise:  NullArgument - ``schedule_slot_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param schedule_slot_id: ``Id`` of a ``ScheduleSlot``\n        :type schedule_slot_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: list of calendar ``Ids``\n        :rtype: ``osid.id.IdList``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``schedule_slot_id`` is not found\n        :raise: ``NullArgument`` -- ``schedule_slot_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "schedule_slot_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "osid.id.IdList", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_calendars_by_schedule_slot", 
               "doc": {
                  "headline": "Gets the list of ``Calendars`` mapped to a ``ScheduleSlot``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    schedule_slot_id (osid.id.Id): ``Id`` of a\n                ``ScheduleSlot``\n", 
               "return_doc": "        return: (osid.calendaring.CalendarList) - list of calendars", 
               "error_doc": "        raise:  NotFound - ``schedule_slot_id`` is not found\n        raise:  NullArgument - ``schedule_slot_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param schedule_slot_id: ``Id`` of a ``ScheduleSlot``\n        :type schedule_slot_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: list of calendars\n        :rtype: ``osid.calendaring.CalendarList``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``schedule_slot_id`` is not found\n        :raise: ``NullArgument`` -- ``schedule_slot_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "schedule_slot_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "osid.calendaring.CalendarList", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.calendaring.ScheduleSlotCalendarAssignmentSession", 
         "shortname": "ScheduleSlotCalendarAssignmentSession", 
         "category": "sessions", 
         "doc": {
            "headline": "This session provides methods to re-assign ``ScheduleSlots`` to ``Calendars``.", 
            "body": "    A ``ScheduleSlot`` may map to multiple ``Calendars`` and removing\n    the last reference to a ``ScheduleSlot`` is the equivalent of\n    deleting it. Each ``Calendar`` may have its own authorizations\n    governing who is allowed to operate on it.\n\n    Moving or adding a reference of a ``ScheduleSlot`` to another\n    ``Calendar`` is not a copy operation (eg: does not change its ``Id``\n    )."
         }, 
         "inherit_fullnames": [
            "osid.OsidSession"
         ], 
         "inherit_shortnames": [
            "OsidSession"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidSession"
            }
         ], 
         "method_names": [
            "can_assign_schedule_slots", 
            "can_assign_schedule_slots_to_calendar", 
            "get_assignable_calendar_ids", 
            "get_assignable_calendar_ids_for_schedule_slot", 
            "assign_schedule_slot_to_calendar", 
            "unassign_schedule_slot_from_calendar"
         ], 
         "methods": [
            {
               "name": "can_assign_schedule_slots", 
               "doc": {
                  "headline": "Tests if this user can alter schedule slot/calendar mappings.", 
                  "body": "        A return of true does not guarantee successful authorization. A\n        return of false indicates that it is known mapping methods in\n        this session will result in a ``PermissionDenied``. This is\n        intended as a hint to an application that may opt not to offer\n        assignment operations to unauthorized users."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``false`` if mapping is not authorized,\n                ``true`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``false`` if mapping is not authorized, ``true`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "can_assign_schedule_slots_to_calendar", 
               "doc": {
                  "headline": "Tests if this user can alter schedule slot/calendar mappings.", 
                  "body": "        A return of true does not guarantee successful authorization. A\n        return of false indicates that it is known mapping methods in\n        this session will result in a PERMISSION_DENIED. This is\n        intended as a hint to an application that may opt not to offer\n        assignment operations to unauthorized users."
               }, 
               "arg_doc": "        arg:    calendar_id (osid.id.Id): the ``Id`` of the ``Calendar``\n", 
               "return_doc": "        return: (boolean) - ``false`` if mapping is not authorized,\n                ``true`` otherwise", 
               "error_doc": "        raise:  NullArgument - ``calendar_id`` is ``null``", 
               "sphinx_param_doc": "        :param calendar_id: the ``Id`` of the ``Calendar``\n        :type calendar_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: ``false`` if mapping is not authorized, ``true`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``calendar_id`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "calendar_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "boolean", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "get_assignable_calendar_ids", 
               "doc": {
                  "headline": "Gets a list of calendars including and under the given calendar node in which any schedule slot can be assigned.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    calendar_id (osid.id.Id): the ``Id`` of the ``Calendar``\n", 
               "return_doc": "        return: (osid.id.IdList) - list of assignable calendar ``Ids``", 
               "error_doc": "        raise:  NullArgument - ``calendar_id`` is ``null``\n        raise:  OperationFailed - unable to complete request", 
               "sphinx_param_doc": "        :param calendar_id: the ``Id`` of the ``Calendar``\n        :type calendar_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: list of assignable calendar ``Ids``\n        :rtype: ``osid.id.IdList``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``calendar_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "calendar_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "osid.id.IdList", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational"
               }
            }, 
            {
               "name": "get_assignable_calendar_ids_for_schedule_slot", 
               "doc": {
                  "headline": "Gets a list of calendars including and under the given calendar node in which a specific schedule slot can be assigned.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    calendar_id (osid.id.Id): the ``Id`` of the ``Calendar``\n        arg:    schedule_slot_id (osid.id.Id): the ``Id`` of the\n                ``ScheduleSlot``\n", 
               "return_doc": "        return: (osid.id.IdList) - list of assignable calendar ``Ids``", 
               "error_doc": "        raise:  NullArgument - ``calendar_id`` or ``schedule_slot_id``\n                is ``null``\n        raise:  OperationFailed - unable to complete request", 
               "sphinx_param_doc": "        :param calendar_id: the ``Id`` of the ``Calendar``\n        :type calendar_id: ``osid.id.Id``\n        :param schedule_slot_id: the ``Id`` of the ``ScheduleSlot``\n        :type schedule_slot_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: list of assignable calendar ``Ids``\n        :rtype: ``osid.id.IdList``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``calendar_id`` or ``schedule_slot_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "calendar_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "schedule_slot_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "osid.id.Id"
               ], 
               "return_type": "osid.id.IdList", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational"
               }
            }, 
            {
               "name": "assign_schedule_slot_to_calendar", 
               "doc": {
                  "headline": "Adds an existing ``ScheduleSlot`` to a ``Calendar``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    schedule_slot_id (osid.id.Id): the ``Id`` of the\n                ``ScheduleSlot``\n        arg:    calendar_id (osid.id.Id): the ``Id`` of the ``Calendar``\n", 
               "return_doc": "", 
               "error_doc": "        raise:  AlreadyExists - ``schedule_slot_id`` is already assigned\n                to ``calendar_id``\n        raise:  NotFound - ``schedule_slot_id`` or ``calendar_id`` not\n                found\n        raise:  NullArgument - ``schedule_slot_id`` or ``calendar_id``\n                is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param schedule_slot_id: the ``Id`` of the ``ScheduleSlot``\n        :type schedule_slot_id: ``osid.id.Id``\n        :param calendar_id: the ``Id`` of the ``Calendar``\n        :type calendar_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``AlreadyExists`` -- ``schedule_slot_id`` is already assigned to ``calendar_id``\n        :raise: ``NotFound`` -- ``schedule_slot_id`` or ``calendar_id`` not found\n        :raise: ``NullArgument`` -- ``schedule_slot_id`` or ``calendar_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "schedule_slot_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "calendar_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {
                  "ALREADY_EXISTS": "User", 
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "unassign_schedule_slot_from_calendar", 
               "doc": {
                  "headline": "Removes a ``ScheduleSlot`` from a ``Calendar``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    schedule_slot_id (osid.id.Id): the ``Id`` of the\n                ``ScheduleSlot``\n        arg:    calendar_id (osid.id.Id): the ``Id`` of the ``Calendar``\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NotFound - ``schedule_slot_id`` or ``calendar_id`` not\n                found or ``schedule_slot_id`` not assigned to\n                ``calendar_id``\n        raise:  NullArgument - ``schedule_slot_id`` or ``calendar_id``\n                is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param schedule_slot_id: the ``Id`` of the ``ScheduleSlot``\n        :type schedule_slot_id: ``osid.id.Id``\n        :param calendar_id: the ``Id`` of the ``Calendar``\n        :type calendar_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``schedule_slot_id`` or ``calendar_id`` not found or ``schedule_slot_id`` not assigned to ``calendar_id``\n        :raise: ``NullArgument`` -- ``schedule_slot_id`` or ``calendar_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "schedule_slot_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "calendar_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.calendaring.ScheduleSlotSmartCalendarSession", 
         "shortname": "ScheduleSlotSmartCalendarSession", 
         "category": "sessions", 
         "doc": {
            "headline": "This session manages queries and sequencing to create \"smart\" dynamic catalogs.", 
            "body": "    A ``ScheduleSlotQuery`` can be retrieved from this session and\n    mapped to this ``Calendar`` to create a virtual collection of\n    ``ScheduleSlots``. The entries may be sequenced using the\n    ``ScheduleSlotSearchOrder`` from this session.\n\n    This ``Calendar`` has a default query that matches any schedule slot\n    and a default search order that specifies no sequencing. The queries\n    may be examined using a ``ScheduleSlotQueryInspector``. The query\n    may be modified by converting the inspector back to a\n    ``ScheduleSlotQuery``."
         }, 
         "inherit_fullnames": [
            "osid.OsidSession"
         ], 
         "inherit_shortnames": [
            "OsidSession"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidSession"
            }
         ], 
         "method_names": [
            "get_calendar_id", 
            "get_calendar", 
            "can_manage_smart_calendars", 
            "get_schedule_slot_query", 
            "get_schedule_slot_search_order", 
            "apply_schedule_slot_query", 
            "inspect_schedule_slot_query", 
            "apply_schedule_slot_sequencing", 
            "get_schedule_slot_query_from_inspector"
         ], 
         "methods": [
            {
               "name": "get_calendar_id", 
               "doc": {
                  "headline": "Gets the ``Calendar``  ``Id`` associated with this session.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.id.Id) - the ``Calendar Id`` associated with this\n                session", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the ``Calendar Id`` associated with this session\n        :rtype: ``osid.id.Id``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.id.Id", 
               "errors": {}
            }, 
            {
               "name": "get_calendar", 
               "doc": {
                  "headline": "Gets the ``Calendar`` associated with this session.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.Calendar) - the ``Calendar``\n                associated with this session", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the ``Calendar`` associated with this session\n        :rtype: ``osid.calendaring.Calendar``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.Calendar", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "can_manage_smart_calendars", 
               "doc": {
                  "headline": "Tests if this user can manage smart calendars.", 
                  "body": "        A return of true does not guarantee successful authorization. A\n        return of false indicates that it is known all methods in this\n        session will result in a ``PermissionDenied``. This is intended\n        as a hint to an application that may opt not to offer smart\n        operations."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``false`` if smart calendar methods are not\n                authorized, ``true`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``false`` if smart calendar methods are not authorized, ``true`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "get_schedule_slot_query", 
               "doc": {
                  "headline": "Gets a schedule slot query.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.ScheduleSlotQuery) - the schedule slot\n                query", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the schedule slot query\n        :rtype: ``osid.calendaring.ScheduleSlotQuery``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.ScheduleSlotQuery", 
               "errors": {}
            }, 
            {
               "name": "get_schedule_slot_search_order", 
               "doc": {
                  "headline": "Gets a schedule slot search order.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.ScheduleSlotSearchOrder) - the\n                schedule slot search order", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the schedule slot search order\n        :rtype: ``osid.calendaring.ScheduleSlotSearchOrder``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.ScheduleSlotSearchOrder", 
               "errors": {}
            }, 
            {
               "name": "apply_schedule_slot_query", 
               "doc": {
                  "headline": "Applies a schedule slot query to this calendar.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    schedule_slot_query\n                (osid.calendaring.ScheduleSlotQuery): the schedule slot\n                query\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``schedule_slot_query`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure occurred\n        raise:  Unsupported - ``schedule_slot_query`` not of this\n                service", 
               "sphinx_param_doc": "        :param schedule_slot_query: the schedule slot query\n        :type schedule_slot_query: ``osid.calendaring.ScheduleSlotQuery``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``schedule_slot_query`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure occurred\n        :raise: ``Unsupported`` -- ``schedule_slot_query`` not of this service", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.calendaring.ScheduleSlotQuery", 
                     "var_name": "schedule_slot_query", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.calendaring.ScheduleSlotQuery"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }, 
            {
               "name": "inspect_schedule_slot_query", 
               "doc": {
                  "headline": "Gets a schedule slot query inspector for this calendar.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.ScheduleSlotQueryInspector) - the\n                schedule slot query inspector", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure occurred", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the schedule slot query inspector\n        :rtype: ``osid.calendaring.ScheduleSlotQueryInspector``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure occurred", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.ScheduleSlotQueryInspector", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "apply_schedule_slot_sequencing", 
               "doc": {
                  "headline": "Applies a schedule slot search order to this calendar.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    schedule_slot_search_order\n                (osid.calendaring.ScheduleSlotSearchOrder): the schedule\n                slot search order\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``schedule_slot_search_order`` is\n                ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure occurred\n        raise:  Unsupported - ``schedule_slot_search_order`` not of this\n                service", 
               "sphinx_param_doc": "        :param schedule_slot_search_order: the schedule slot search order\n        :type schedule_slot_search_order: ``osid.calendaring.ScheduleSlotSearchOrder``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``schedule_slot_search_order`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure occurred\n        :raise: ``Unsupported`` -- ``schedule_slot_search_order`` not of this service", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.calendaring.ScheduleSlotSearchOrder", 
                     "var_name": "schedule_slot_search_order", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.calendaring.ScheduleSlotSearchOrder"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_schedule_slot_query_from_inspector", 
               "doc": {
                  "headline": "Gets a schedule slot query from an inspector.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    schedule_slot_query_inspector\n                (osid.calendaring.ScheduleSlotQueryInspector): a\n                schedule slot query inspector\n", 
               "return_doc": "        return: (osid.calendaring.ScheduleSlotQuery) - the schedule slot\n                query", 
               "error_doc": "        raise:  NullArgument - ``schedule_slot_query_inspector`` is\n                ``null``\n        raise:  Unsupported - ``schedule_slot_query_inspector`` is not\n                of this service", 
               "sphinx_param_doc": "        :param schedule_slot_query_inspector: a schedule slot query inspector\n        :type schedule_slot_query_inspector: ``osid.calendaring.ScheduleSlotQueryInspector``\n", 
               "sphinx_return_doc": "        :return: the schedule slot query\n        :rtype: ``osid.calendaring.ScheduleSlotQuery``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``schedule_slot_query_inspector`` is ``null``\n        :raise: ``Unsupported`` -- ``schedule_slot_query_inspector`` is not of this service", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.calendaring.ScheduleSlotQueryInspector", 
                     "var_name": "schedule_slot_query_inspector", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.calendaring.ScheduleSlotQueryInspector"
               ], 
               "return_type": "osid.calendaring.ScheduleSlotQuery", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.calendaring.CommitmentLookupSession", 
         "shortname": "CommitmentLookupSession", 
         "category": "sessions", 
         "doc": {
            "headline": "This session provides methods for examining event commitments.", 
            "body": ""
         }, 
         "inherit_fullnames": [
            "osid.OsidSession"
         ], 
         "inherit_shortnames": [
            "OsidSession"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidSession"
            }
         ], 
         "method_names": [
            "get_calendar_id", 
            "get_calendar", 
            "can_lookup_commitments", 
            "use_comparative_commitment_view", 
            "use_plenary_commitment_view", 
            "use_federated_calendar_view", 
            "use_isolated_calendar_view", 
            "use_effective_commitment_view", 
            "use_any_effective_commitment_view", 
            "get_commitment", 
            "get_commitments_by_ids", 
            "get_commitments_by_genus_type", 
            "get_commitments_by_parent_genus_type", 
            "get_commitments_by_record_type", 
            "get_commitments_on_date", 
            "get_commitments_by_genus_type_on_date", 
            "get_commitments_for_event", 
            "get_commitments_for_event_on_date", 
            "get_commitments_by_genus_type_for_event", 
            "get_commitments_by_genus_type_for_event_on_date", 
            "get_commitments_for_resource", 
            "get_commitments_for_resource_on_date", 
            "get_commitments_by_genus_type_for_resource", 
            "get_commitments_by_genus_type_for_resource_on_date", 
            "get_commitments_for_event_and_resource", 
            "get_commitments_for_event_and_resource_on_date", 
            "get_commitments_by_genus_type_for_event_and_resource", 
            "get_commitments_by_genus_type_for_event_and_resource_on_date", 
            "get_commitments"
         ], 
         "methods": [
            {
               "name": "get_calendar_id", 
               "doc": {
                  "headline": "Gets the ``Calendar``  ``Id`` associated with this session.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.id.Id) - the ``Calendar Id`` associated with this\n                session", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the ``Calendar Id`` associated with this session\n        :rtype: ``osid.id.Id``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.id.Id", 
               "errors": {}
            }, 
            {
               "name": "get_calendar", 
               "doc": {
                  "headline": "Gets the ``Calendar`` associated with this session.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.Calendar) - the ``Calendar``\n                associated with this session", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the ``Calendar`` associated with this session\n        :rtype: ``osid.calendaring.Calendar``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.Calendar", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "can_lookup_commitments", 
               "doc": {
                  "headline": "Tests if this user can lookup event commitments.", 
                  "body": "        A return of true does not guarantee successful authorization. A\n        return of false indicates that it is known all methods in this\n        session will result in a ``PermissionDenied``. This is intended\n        as a hint to an application that may opt not to offer lookup\n        operations to unauthorized users."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``false`` if lookup methods are not\n                authorized, ``true`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``false`` if lookup methods are not authorized, ``true`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "use_comparative_commitment_view", 
               "doc": {
                  "headline": "The returns from the lookup methods may omit or translate elements based on this session, such as authorization, and not result in an error.", 
                  "body": "        This view is used when greater interoperability is desired at\n        the expense of precision."
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "use_plenary_commitment_view", 
               "doc": {
                  "headline": "A complete view of the ``Commitment`` returns is desired.", 
                  "body": "        Methods will return what is requested or result in an error.\n        This view is used when greater precision is desired at the\n        expense of interoperability."
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "use_federated_calendar_view", 
               "doc": {
                  "headline": "Federates the view for methods in this session.", 
                  "body": "        A federated view will include commitments in calendars which are\n        children of this calendar in the calendar hierarchy."
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "use_isolated_calendar_view", 
               "doc": {
                  "headline": "Isolates the view for methods in this session.", 
                  "body": "        An isolated view restricts lookups to this calendar only."
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "use_effective_commitment_view", 
               "doc": {
                  "headline": "The commitments in this lookup session return only commitments currently in effect.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "use_any_effective_commitment_view", 
               "doc": {
                  "headline": "The commitments in this lookup session return both effective and ineffective commitments.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "get_commitment", 
               "doc": {
                  "headline": "Gets the ``Commitment`` specified by its ``Id``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    commitment_id (osid.id.Id): ``Id`` of the ``Commitment``\n", 
               "return_doc": "        return: (osid.calendaring.Commitment) - the commitment", 
               "error_doc": "        raise:  NotFound - ``commitment_id`` not found\n        raise:  NullArgument - ``commitment_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param commitment_id: ``Id`` of the ``Commitment``\n        :type commitment_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: the commitment\n        :rtype: ``osid.calendaring.Commitment``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``commitment_id`` not found\n        :raise: ``NullArgument`` -- ``commitment_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "commitment_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "osid.calendaring.Commitment", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_commitments_by_ids", 
               "doc": {
                  "headline": "Gets a ``CommitmentList`` corresponding to the given ``IdList``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    commitment_ids (osid.id.IdList): the list of ``Ids`` to\n                retrieve\n", 
               "return_doc": "        return: (osid.calendaring.CommitmentList) - the returned\n                ``Commitment`` list", 
               "error_doc": "        raise:  NotFound - an ``Id`` was not found\n        raise:  NullArgument - ``commitment_ids`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param commitment_ids: the list of ``Ids`` to retrieve\n        :type commitment_ids: ``osid.id.IdList``\n", 
               "sphinx_return_doc": "        :return: the returned ``Commitment`` list\n        :rtype: ``osid.calendaring.CommitmentList``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- an ``Id`` was not found\n        :raise: ``NullArgument`` -- ``commitment_ids`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.IdList", 
                     "var_name": "commitment_ids", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.IdList"
               ], 
               "return_type": "osid.calendaring.CommitmentList", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_commitments_by_genus_type", 
               "doc": {
                  "headline": "Gets the commitments for the given event genus type.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    commitment_genus_type (osid.type.Type): commitment genus\n                type\n", 
               "return_doc": "        return: (osid.calendaring.CommitmentList) - list of commitments", 
               "error_doc": "        raise:  NullArgument - ``commitment_genus_type`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param commitment_genus_type: commitment genus type\n        :type commitment_genus_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "        :return: list of commitments\n        :rtype: ``osid.calendaring.CommitmentList``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``commitment_genus_type`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "commitment_genus_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "osid.calendaring.CommitmentList", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_commitments_by_parent_genus_type", 
               "doc": {
                  "headline": "Gets the commitments for the given event genus type and include any commitments with a genus type derived from the specified genus type.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    commitment_genus_type (osid.type.Type): commitment genus\n                type\n", 
               "return_doc": "        return: (osid.calendaring.CommitmentList) - list of commitments", 
               "error_doc": "        raise:  NullArgument - ``commitment_genus_type`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param commitment_genus_type: commitment genus type\n        :type commitment_genus_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "        :return: list of commitments\n        :rtype: ``osid.calendaring.CommitmentList``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``commitment_genus_type`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "commitment_genus_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "osid.calendaring.CommitmentList", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_commitments_by_record_type", 
               "doc": {
                  "headline": "Gets a ``CommitmentList`` containing the given event commitment record ``Type``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    commitment_record_type (osid.type.Type): a commitment\n                record type\n", 
               "return_doc": "        return: (osid.calendaring.CommitmentList) - list of commitments", 
               "error_doc": "        raise:  NullArgument - ``event_record_type`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param commitment_record_type: a commitment record type\n        :type commitment_record_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "        :return: list of commitments\n        :rtype: ``osid.calendaring.CommitmentList``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``event_record_type`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "commitment_record_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "osid.calendaring.CommitmentList", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_commitments_on_date", 
               "doc": {
                  "headline": "Gets a ``CommitmentList`` effective during the entire given date range inclusive but not confined to the date range.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    from (osid.calendaring.DateTime): starting date\n        arg:    to (osid.calendaring.DateTime): ending date\n", 
               "return_doc": "        return: (osid.calendaring.CommitmentList) - list of commitments", 
               "error_doc": "        raise:  InvalidArgument - ``from`` is greater than ``to``\n        raise:  NullArgument - ``from`` or ``to`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param from: starting date\n        :type from: ``osid.calendaring.DateTime``\n        :param to: ending date\n        :type to: ``osid.calendaring.DateTime``\n", 
               "sphinx_return_doc": "        :return: list of commitments\n        :rtype: ``osid.calendaring.CommitmentList``", 
               "sphinx_error_doc": "        :raise: ``InvalidArgument`` -- ``from`` is greater than ``to``\n        :raise: ``NullArgument`` -- ``from`` or ``to`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.calendaring.DateTime", 
                     "var_name": "from_", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.calendaring.DateTime", 
                     "var_name": "to", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.calendaring.DateTime", 
                  "osid.calendaring.DateTime"
               ], 
               "return_type": "osid.calendaring.CommitmentList", 
               "errors": {
                  "INVALID_ARGUMENT": "ConsumerContract", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_commitments_by_genus_type_on_date", 
               "doc": {
                  "headline": "Gets a ``CommitmentList`` of the given genus type and effective during the entire given date range inclusive but not confined to the date range.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    commitment_genus_type (osid.type.Type): a commitment\n                genus type\n        arg:    from (osid.calendaring.DateTime): starting date\n        arg:    to (osid.calendaring.DateTime): ending date\n", 
               "return_doc": "        return: (osid.calendaring.CommitmentList) - list of commitments", 
               "error_doc": "        raise:  InvalidArgument - ``from`` is greater than ``to``\n        raise:  NullArgument - ``commitment_genus_type, from,`` or\n                ``to`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param commitment_genus_type: a commitment genus type\n        :type commitment_genus_type: ``osid.type.Type``\n        :param from: starting date\n        :type from: ``osid.calendaring.DateTime``\n        :param to: ending date\n        :type to: ``osid.calendaring.DateTime``\n", 
               "sphinx_return_doc": "        :return: list of commitments\n        :rtype: ``osid.calendaring.CommitmentList``", 
               "sphinx_error_doc": "        :raise: ``InvalidArgument`` -- ``from`` is greater than ``to``\n        :raise: ``NullArgument`` -- ``commitment_genus_type, from,`` or ``to`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "commitment_genus_type", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.calendaring.DateTime", 
                     "var_name": "from_", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.calendaring.DateTime", 
                     "var_name": "to", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type", 
                  "osid.calendaring.DateTime", 
                  "osid.calendaring.DateTime"
               ], 
               "return_type": "osid.calendaring.CommitmentList", 
               "errors": {
                  "INVALID_ARGUMENT": "ConsumerContract", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_commitments_for_event", 
               "doc": {
                  "headline": "Gets the commitments for the given event.", 
                  "body": "        If the event is a recurring event, the commitments are returned\n        for the recurring event only.\n\n        In plenary mode, the returned list contains all of the\n        commitments mapped to the event ``Id`` or an error results if an\n        Id in the supplied list is not found or inaccessible. Otherwise,\n        inaccessible ``Commitments`` may be omitted from the list and\n        may present the elements in any order including returning a\n        unique set.\n        \n        In effective mode, commitments are returned that are currently\n        effective. In any effective mode, effective commitments and\n        those currently expired are returned."
               }, 
               "arg_doc": "        arg:    event_id (osid.id.Id): ``Id`` of the ``Event``\n", 
               "return_doc": "        return: (osid.calendaring.CommitmentList) - list of commitments", 
               "error_doc": "        raise:  NullArgument - ``event_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param event_id: ``Id`` of the ``Event``\n        :type event_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: list of commitments\n        :rtype: ``osid.calendaring.CommitmentList``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``event_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "event_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "osid.calendaring.CommitmentList", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_commitments_for_event_on_date", 
               "doc": {
                  "headline": "Gets a ``CommitmentList`` for the given event and effective during the entire given date range inclusive but not confined to the date range.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    event_id (osid.id.Id): ``Id`` of the ``Event``\n        arg:    from (osid.calendaring.DateTime): starting date\n        arg:    to (osid.calendaring.DateTime): ending date\n", 
               "return_doc": "        return: (osid.calendaring.CommitmentList) - list of commitments", 
               "error_doc": "        raise:  InvalidArgument - ``from`` is greater than ``to``\n        raise:  NullArgument - ``event_id, from`` or ``to`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param event_id: ``Id`` of the ``Event``\n        :type event_id: ``osid.id.Id``\n        :param from: starting date\n        :type from: ``osid.calendaring.DateTime``\n        :param to: ending date\n        :type to: ``osid.calendaring.DateTime``\n", 
               "sphinx_return_doc": "        :return: list of commitments\n        :rtype: ``osid.calendaring.CommitmentList``", 
               "sphinx_error_doc": "        :raise: ``InvalidArgument`` -- ``from`` is greater than ``to``\n        :raise: ``NullArgument`` -- ``event_id, from`` or ``to`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "event_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.calendaring.DateTime", 
                     "var_name": "from_", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.calendaring.DateTime", 
                     "var_name": "to", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "osid.calendaring.DateTime", 
                  "osid.calendaring.DateTime"
               ], 
               "return_type": "osid.calendaring.CommitmentList", 
               "errors": {
                  "INVALID_ARGUMENT": "ConsumerContract", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_commitments_by_genus_type_for_event", 
               "doc": {
                  "headline": "Gets the commitments for the given event and commitment genus type including any genus types derived from the given genus type.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    event_id (osid.id.Id): ``Id`` of the ``Event``\n        arg:    commitment_genus_type (osid.type.Type): commitment genus\n                type\n", 
               "return_doc": "        return: (osid.calendaring.CommitmentList) - list of commitments", 
               "error_doc": "        raise:  NullArgument - ``event_id`` or ``commitment_genus_type``\n                is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param event_id: ``Id`` of the ``Event``\n        :type event_id: ``osid.id.Id``\n        :param commitment_genus_type: commitment genus type\n        :type commitment_genus_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "        :return: list of commitments\n        :rtype: ``osid.calendaring.CommitmentList``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``event_id`` or ``commitment_genus_type`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "event_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "commitment_genus_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "osid.type.Type"
               ], 
               "return_type": "osid.calendaring.CommitmentList", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_commitments_by_genus_type_for_event_on_date", 
               "doc": {
                  "headline": "Gets a ``CommitmentList`` for the given event and commitment genus type effective during the entire given date range inclusive but not confined to the date range.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    event_id (osid.id.Id): ``Id`` of the ``Event``\n        arg:    commitment_genus_type (osid.type.Type): commitment genus\n                type\n        arg:    from (osid.calendaring.DateTime): starting date\n        arg:    to (osid.calendaring.DateTime): ending date\n", 
               "return_doc": "        return: (osid.calendaring.CommitmentList) - list of commitments", 
               "error_doc": "        raise:  InvalidArgument - ``from`` is greater than ``to``\n        raise:  NullArgument - ``event_id, commitment_genus_type, from``\n                or ``to`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param event_id: ``Id`` of the ``Event``\n        :type event_id: ``osid.id.Id``\n        :param commitment_genus_type: commitment genus type\n        :type commitment_genus_type: ``osid.type.Type``\n        :param from: starting date\n        :type from: ``osid.calendaring.DateTime``\n        :param to: ending date\n        :type to: ``osid.calendaring.DateTime``\n", 
               "sphinx_return_doc": "        :return: list of commitments\n        :rtype: ``osid.calendaring.CommitmentList``", 
               "sphinx_error_doc": "        :raise: ``InvalidArgument`` -- ``from`` is greater than ``to``\n        :raise: ``NullArgument`` -- ``event_id, commitment_genus_type, from`` or ``to`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "event_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "commitment_genus_type", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.calendaring.DateTime", 
                     "var_name": "from_", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.calendaring.DateTime", 
                     "var_name": "to", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "osid.type.Type", 
                  "osid.calendaring.DateTime", 
                  "osid.calendaring.DateTime"
               ], 
               "return_type": "osid.calendaring.CommitmentList", 
               "errors": {
                  "INVALID_ARGUMENT": "ConsumerContract", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_commitments_for_resource", 
               "doc": {
                  "headline": "Gets the commitments for the given resource.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    resource_id (osid.id.Id): ``Id`` of a ``Resource``\n", 
               "return_doc": "        return: (osid.calendaring.CommitmentList) - list of commitments", 
               "error_doc": "        raise:  NullArgument - ``resource_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param resource_id: ``Id`` of a ``Resource``\n        :type resource_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: list of commitments\n        :rtype: ``osid.calendaring.CommitmentList``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``resource_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "resource_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "osid.calendaring.CommitmentList", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_commitments_for_resource_on_date", 
               "doc": {
                  "headline": "Gets a ``CommitmentList`` for the given resource and effective during the entire given date range inclusive but not confined to the date range.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    resource_id (osid.id.Id): ``Id`` of the ``Event``\n        arg:    from (osid.calendaring.DateTime): starting date\n        arg:    to (osid.calendaring.DateTime): ending date\n", 
               "return_doc": "        return: (osid.calendaring.CommitmentList) - list of commitments", 
               "error_doc": "        raise:  InvalidArgument - ``from`` is greater than ``to``\n        raise:  NullArgument - ``resource_id, from`` or ``to`` is\n                ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param resource_id: ``Id`` of the ``Event``\n        :type resource_id: ``osid.id.Id``\n        :param from: starting date\n        :type from: ``osid.calendaring.DateTime``\n        :param to: ending date\n        :type to: ``osid.calendaring.DateTime``\n", 
               "sphinx_return_doc": "        :return: list of commitments\n        :rtype: ``osid.calendaring.CommitmentList``", 
               "sphinx_error_doc": "        :raise: ``InvalidArgument`` -- ``from`` is greater than ``to``\n        :raise: ``NullArgument`` -- ``resource_id, from`` or ``to`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "resource_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.calendaring.DateTime", 
                     "var_name": "from_", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.calendaring.DateTime", 
                     "var_name": "to", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "osid.calendaring.DateTime", 
                  "osid.calendaring.DateTime"
               ], 
               "return_type": "osid.calendaring.CommitmentList", 
               "errors": {
                  "INVALID_ARGUMENT": "ConsumerContract", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_commitments_by_genus_type_for_resource", 
               "doc": {
                  "headline": "Gets the commitments for the given resource and commitment genus type including any genus types derived from the given genus type.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    resource_id (osid.id.Id): ``Id`` of a ``Resource``\n        arg:    commitment_genus_type (osid.type.Type): commitment genus\n                type\n", 
               "return_doc": "        return: (osid.calendaring.CommitmentList) - list of commitments", 
               "error_doc": "        raise:  NullArgument - ``resource_id`` or\n                ``commitment_genus_type`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param resource_id: ``Id`` of a ``Resource``\n        :type resource_id: ``osid.id.Id``\n        :param commitment_genus_type: commitment genus type\n        :type commitment_genus_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "        :return: list of commitments\n        :rtype: ``osid.calendaring.CommitmentList``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``resource_id`` or ``commitment_genus_type`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "resource_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "commitment_genus_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "osid.type.Type"
               ], 
               "return_type": "osid.calendaring.CommitmentList", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_commitments_by_genus_type_for_resource_on_date", 
               "doc": {
                  "headline": "Gets a ``CommitmentList`` for the given resource, commitment genus type, and effective during the entire given date range inclusive but not confined to the date range.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    resource_id (osid.id.Id): ``Id`` of the ``Event``\n        arg:    commitment_genus_type (osid.type.Type): commitment genus\n                type\n        arg:    from (osid.calendaring.DateTime): starting date\n        arg:    to (osid.calendaring.DateTime): ending date\n", 
               "return_doc": "        return: (osid.calendaring.CommitmentList) - list of commitments", 
               "error_doc": "        raise:  InvalidArgument - ``from`` is greater than ``to``\n        raise:  NullArgument - ``resource_id, commitment_genus_type,\n                from`` or ``to`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param resource_id: ``Id`` of the ``Event``\n        :type resource_id: ``osid.id.Id``\n        :param commitment_genus_type: commitment genus type\n        :type commitment_genus_type: ``osid.type.Type``\n        :param from: starting date\n        :type from: ``osid.calendaring.DateTime``\n        :param to: ending date\n        :type to: ``osid.calendaring.DateTime``\n", 
               "sphinx_return_doc": "        :return: list of commitments\n        :rtype: ``osid.calendaring.CommitmentList``", 
               "sphinx_error_doc": "        :raise: ``InvalidArgument`` -- ``from`` is greater than ``to``\n        :raise: ``NullArgument`` -- ``resource_id, commitment_genus_type, from`` or ``to`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "resource_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "commitment_genus_type", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.calendaring.DateTime", 
                     "var_name": "from_", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.calendaring.DateTime", 
                     "var_name": "to", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "osid.type.Type", 
                  "osid.calendaring.DateTime", 
                  "osid.calendaring.DateTime"
               ], 
               "return_type": "osid.calendaring.CommitmentList", 
               "errors": {
                  "INVALID_ARGUMENT": "ConsumerContract", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_commitments_for_event_and_resource", 
               "doc": {
                  "headline": "Gets the commitments for the given event and resource.", 
                  "body": "        If the event is a recurring event, the commitments are returned\n        for the recurring event only.\n\n        In plenary mode, the returned list contains all of the\n        commitments mapped to the event ``Id`` or an error results if an\n        Id in the supplied list is not found or inaccessible. Otherwise,\n        inaccessible ``Commitments`` may be omitted from the list and\n        may present the elements in any order including returning a\n        unique set.\n        \n        In effective mode, commitments are returned that are currently\n        effective. In any effective mode, effective commitments and\n        those currently expired are returned."
               }, 
               "arg_doc": "        arg:    event_id (osid.id.Id): ``Id`` of the ``Event``\n        arg:    resource_id (osid.id.Id): ``Id`` of a ``Resource``\n", 
               "return_doc": "        return: (osid.calendaring.CommitmentList) - list of commitments", 
               "error_doc": "        raise:  NullArgument - ``event_id`` or ``resource_id`` is\n                ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param event_id: ``Id`` of the ``Event``\n        :type event_id: ``osid.id.Id``\n        :param resource_id: ``Id`` of a ``Resource``\n        :type resource_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: list of commitments\n        :rtype: ``osid.calendaring.CommitmentList``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``event_id`` or ``resource_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "event_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "resource_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "osid.id.Id"
               ], 
               "return_type": "osid.calendaring.CommitmentList", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_commitments_for_event_and_resource_on_date", 
               "doc": {
                  "headline": "Gets a ``CommitmentList`` for the given event and resource and effective during the entire given date range inclusive but not confined to the date range.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    event_id (osid.id.Id): ``Id`` of the ``Event``\n        arg:    resource_id (osid.id.Id): ``Id`` of a ``Resource``\n        arg:    from (osid.calendaring.DateTime): starting date\n        arg:    to (osid.calendaring.DateTime): ending date\n", 
               "return_doc": "        return: (osid.calendaring.CommitmentList) - list of commitments", 
               "error_doc": "        raise:  InvalidArgument - ``from`` is greater than ``to``\n        raise:  NullArgument - ``event_id, resource_id, from`` or ``to``\n                is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param event_id: ``Id`` of the ``Event``\n        :type event_id: ``osid.id.Id``\n        :param resource_id: ``Id`` of a ``Resource``\n        :type resource_id: ``osid.id.Id``\n        :param from: starting date\n        :type from: ``osid.calendaring.DateTime``\n        :param to: ending date\n        :type to: ``osid.calendaring.DateTime``\n", 
               "sphinx_return_doc": "        :return: list of commitments\n        :rtype: ``osid.calendaring.CommitmentList``", 
               "sphinx_error_doc": "        :raise: ``InvalidArgument`` -- ``from`` is greater than ``to``\n        :raise: ``NullArgument`` -- ``event_id, resource_id, from`` or ``to`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "event_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "resource_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.calendaring.DateTime", 
                     "var_name": "from_", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.calendaring.DateTime", 
                     "var_name": "to", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "osid.id.Id", 
                  "osid.calendaring.DateTime", 
                  "osid.calendaring.DateTime"
               ], 
               "return_type": "osid.calendaring.CommitmentList", 
               "errors": {
                  "INVALID_ARGUMENT": "ConsumerContract", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_commitments_by_genus_type_for_event_and_resource", 
               "doc": {
                  "headline": "Gets the commitments of the given genus type for the given event, resource, and commitment genus type including any genus types derived from the given genus type.", 
                  "body": "        If the event is a recurring event, the commitments are returned\n        for the recurring event only.\n\n        In plenary mode, the returned list contains all of the\n        commitments mapped to the event ``Id`` or an error results if an\n        Id in the supplied list is not found or inaccessible. Otherwise,\n        inaccessible ``Commitments`` may be omitted from the list and\n        may present the elements in any order including returning a\n        unique set.\n        \n        In effective mode, commitments are returned that are currently\n        effective. In any effective mode, effective commitments and\n        those currently expired are returned."
               }, 
               "arg_doc": "        arg:    event_id (osid.id.Id): ``Id`` of the ``Event``\n        arg:    resource_id (osid.id.Id): ``Id`` of a ``Resource``\n        arg:    commitment_genus_type (osid.type.Type): commitment genus\n                type\n", 
               "return_doc": "        return: (osid.calendaring.CommitmentList) - list of commitments", 
               "error_doc": "        raise:  NullArgument - ``event_id, resource_id`` or\n                ``commitment_genus_type`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param event_id: ``Id`` of the ``Event``\n        :type event_id: ``osid.id.Id``\n        :param resource_id: ``Id`` of a ``Resource``\n        :type resource_id: ``osid.id.Id``\n        :param commitment_genus_type: commitment genus type\n        :type commitment_genus_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "        :return: list of commitments\n        :rtype: ``osid.calendaring.CommitmentList``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``event_id, resource_id`` or ``commitment_genus_type`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "event_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "resource_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "commitment_genus_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "osid.id.Id", 
                  "osid.type.Type"
               ], 
               "return_type": "osid.calendaring.CommitmentList", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_commitments_by_genus_type_for_event_and_resource_on_date", 
               "doc": {
                  "headline": "Gets a ``CommitmentList`` of the given genus type for the given event, resource, commitment genus type and effective during the entire given date range inclusive but not confined to the date range.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    event_id (osid.id.Id): ``Id`` of the ``Event``\n        arg:    resource_id (osid.id.Id): ``Id`` of a ``Resource``\n        arg:    commitment_genus_type (osid.type.Type): commitment genus\n                type\n        arg:    from (osid.calendaring.DateTime): starting date\n        arg:    to (osid.calendaring.DateTime): ending date\n", 
               "return_doc": "        return: (osid.calendaring.CommitmentList) - list of commitments", 
               "error_doc": "        raise:  InvalidArgument - ``from`` is greater than ``to``\n        raise:  NullArgument - ``event_id, resource_id,\n                commitment_genus_type, from`` or ``to`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param event_id: ``Id`` of the ``Event``\n        :type event_id: ``osid.id.Id``\n        :param resource_id: ``Id`` of a ``Resource``\n        :type resource_id: ``osid.id.Id``\n        :param commitment_genus_type: commitment genus type\n        :type commitment_genus_type: ``osid.type.Type``\n        :param from: starting date\n        :type from: ``osid.calendaring.DateTime``\n        :param to: ending date\n        :type to: ``osid.calendaring.DateTime``\n", 
               "sphinx_return_doc": "        :return: list of commitments\n        :rtype: ``osid.calendaring.CommitmentList``", 
               "sphinx_error_doc": "        :raise: ``InvalidArgument`` -- ``from`` is greater than ``to``\n        :raise: ``NullArgument`` -- ``event_id, resource_id, commitment_genus_type, from`` or ``to`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "event_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "resource_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "commitment_genus_type", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.calendaring.DateTime", 
                     "var_name": "from_", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.calendaring.DateTime", 
                     "var_name": "to", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "osid.id.Id", 
                  "osid.type.Type", 
                  "osid.calendaring.DateTime", 
                  "osid.calendaring.DateTime"
               ], 
               "return_type": "osid.calendaring.CommitmentList", 
               "errors": {
                  "INVALID_ARGUMENT": "ConsumerContract", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_commitments", 
               "doc": {
                  "headline": "Gets all commitments.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.CommitmentList) - list of commitments", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: list of commitments\n        :rtype: ``osid.calendaring.CommitmentList``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.CommitmentList", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.calendaring.CommitmentQuerySession", 
         "shortname": "CommitmentQuerySession", 
         "category": "sessions", 
         "doc": {
            "headline": "This session provides methods for searching ``Commitment`` objects.", 
            "body": "    The search query is constructed using the ``CommitmentQuery``. The\n    commitment record ``Type`` also specifies the record for the\n    commitment query.\n\n    This session defines views that offer differing behaviors for\n    searching.\n    \n      * federated calendar view: searches include commitments in\n        calendars of which this calendar is an ancestor in the calendar\n        hierarchy\n      * isolated calendar view: searches are restricted to commitments\n        in this calendar only\n\n    \n    Commitments may have a query record indicated by their respective\n    record types. The query record is accessed via the\n    ``CommitmentQuery``."
         }, 
         "inherit_fullnames": [
            "osid.OsidSession"
         ], 
         "inherit_shortnames": [
            "OsidSession"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidSession"
            }
         ], 
         "method_names": [
            "get_calendar_id", 
            "get_calendar", 
            "can_search_commitments", 
            "use_federated_calendar_view", 
            "use_isolated_calendar_view", 
            "get_commitment_query", 
            "get_commitments_by_query"
         ], 
         "methods": [
            {
               "name": "get_calendar_id", 
               "doc": {
                  "headline": "Gets the ``Calendar``  ``Id`` associated with this session.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.id.Id) - the ``Calendar Id`` associated with this\n                session", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the ``Calendar Id`` associated with this session\n        :rtype: ``osid.id.Id``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.id.Id", 
               "errors": {}
            }, 
            {
               "name": "get_calendar", 
               "doc": {
                  "headline": "Gets the ``Calendar`` associated with this session.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.Calendar) - the ``Calendar``\n                associated with this session", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the ``Calendar`` associated with this session\n        :rtype: ``osid.calendaring.Calendar``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.Calendar", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "can_search_commitments", 
               "doc": {
                  "headline": "Tests if this user can perform ``Commitment`` searches.", 
                  "body": "        A return of true does not guarantee successful authorization. A\n        return of false indicates that it is known all methods in this\n        session will result in a ``PermissionDenied``. This is intended\n        as a hint to an application that may opt not to offer search\n        operations to unauthorized users."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``false`` if search methods are not\n                authorized, ``true`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``false`` if search methods are not authorized, ``true`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "use_federated_calendar_view", 
               "doc": {
                  "headline": "Federates the view for methods in this session.", 
                  "body": "        A federated view will include commitments in calendars which are\n        children of this calendar in the calendar hierarchy."
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "use_isolated_calendar_view", 
               "doc": {
                  "headline": "Isolates the view for methods in this session.", 
                  "body": "        An isolated view restricts searches to this calendar only."
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "get_commitment_query", 
               "doc": {
                  "headline": "Gets a commitment query.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.CommitmentQuery) - the commitment\n                query", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the commitment query\n        :rtype: ``osid.calendaring.CommitmentQuery``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.CommitmentQuery", 
               "errors": {}
            }, 
            {
               "name": "get_commitments_by_query", 
               "doc": {
                  "headline": "Gets a list of ``Commitments`` matching the given commitment query.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    commitment_query (osid.calendaring.CommitmentQuery): the\n                commitment query\n", 
               "return_doc": "        return: (osid.calendaring.CommitmentList) - the returned\n                ``CommitmentList``", 
               "error_doc": "        raise:  NullArgument - ``commitment_query is null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        raise:  Unsupported - ``commitment_query`` is not of this\n                service", 
               "sphinx_param_doc": "        :param commitment_query: the commitment query\n        :type commitment_query: ``osid.calendaring.CommitmentQuery``\n", 
               "sphinx_return_doc": "        :return: the returned ``CommitmentList``\n        :rtype: ``osid.calendaring.CommitmentList``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``commitment_query is null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure\n        :raise: ``Unsupported`` -- ``commitment_query`` is not of this service", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.calendaring.CommitmentQuery", 
                     "var_name": "commitment_query", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.calendaring.CommitmentQuery"
               ], 
               "return_type": "osid.calendaring.CommitmentList", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.calendaring.CommitmentSearchSession", 
         "shortname": "CommitmentSearchSession", 
         "category": "sessions", 
         "doc": {
            "headline": "This session provides methods for searching ``Commitment`` objects.", 
            "body": "    The search query is constructed using the ``CommitmentQuery``. The\n    commitment record ``Type`` also specifies the record for the\n    commitment query.\n\n    ``get_commitments_by_query()`` is the basic search method and\n    returns a list of ``Commitments``. A more advanced search may be\n    performed with ``getCommitmentsBySearch()``. It accepts a\n    ``CommitmentSearch`` in addition to the query for the purpose of\n    specifying additional options affecting the entire search, such as\n    ordering. ``get_commitments_by_search()`` returns an\n    ``CommitmentSearchResults`` that can be used to access the resulting\n    ``CommitmentList`` or be used to perform a search within the result\n    set through ``CommitmentSearch``.\n    \n    This session defines views that offer differing behaviors for\n    searching.\n    \n      * federated calendar view: searches include commitments in\n        calendars of which this calendar is a ancestor in the calendar\n        hierarchy\n      * isolated calendar view: searches are restricted to commitments\n        in this calendar only\n\n    \n    Commitments may have a query record indicated by their respective\n    record types. The query record is accessed via the\n    ``CommitmentQuery``."
         }, 
         "inherit_fullnames": [
            "osid.calendaring.CommitmentQuerySession"
         ], 
         "inherit_shortnames": [
            "CommitmentQuerySession"
         ], 
         "inherit_pkg_names": [
            "calendaring"
         ], 
         "inheritance": [
            {
               "pkg_name": "calendaring", 
               "name": "CommitmentQuerySession"
            }
         ], 
         "method_names": [
            "get_commitment_search", 
            "get_commitment_search_order", 
            "get_commitments_by_search", 
            "get_commitment_query_from_inspector"
         ], 
         "methods": [
            {
               "name": "get_commitment_search", 
               "doc": {
                  "headline": "Gets a commitment search.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.CommitmentSearch) - the commitment\n                search", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the commitment search\n        :rtype: ``osid.calendaring.CommitmentSearch``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.CommitmentSearch", 
               "errors": {}
            }, 
            {
               "name": "get_commitment_search_order", 
               "doc": {
                  "headline": "Gets a commitment search order.", 
                  "body": "        The ``CommitmentSearchOrder`` is supplied to a\n        ``CommitmentSearch`` to specify the ordering of results."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.CommitmentSearchOrder) - the\n                commitment search order", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the commitment search order\n        :rtype: ``osid.calendaring.CommitmentSearchOrder``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.CommitmentSearchOrder", 
               "errors": {}
            }, 
            {
               "name": "get_commitments_by_search", 
               "doc": {
                  "headline": "Gets the search results matching the given search query using the given search.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    commitment_query (osid.calendaring.CommitmentQuery): the\n                commitment search query\n        arg:    commitment_search (osid.calendaring.CommitmentSearch):\n                the commitment search\n", 
               "return_doc": "        return: (osid.calendaring.CommitmentSearchResults) - the\n                commitment search results", 
               "error_doc": "        raise:  NullArgument - ``commitment_query`` or\n                ``commitment_search`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        raise:  Unsupported - ``commitment_search`` or\n                ``commitment_query`` is not of this service", 
               "sphinx_param_doc": "        :param commitment_query: the commitment search query\n        :type commitment_query: ``osid.calendaring.CommitmentQuery``\n        :param commitment_search: the commitment search\n        :type commitment_search: ``osid.calendaring.CommitmentSearch``\n", 
               "sphinx_return_doc": "        :return: the commitment search results\n        :rtype: ``osid.calendaring.CommitmentSearchResults``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``commitment_query`` or ``commitment_search`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure\n        :raise: ``Unsupported`` -- ``commitment_search`` or ``commitment_query`` is not of this service", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.calendaring.CommitmentQuery", 
                     "var_name": "commitment_query", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.calendaring.CommitmentSearch", 
                     "var_name": "commitment_search", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.calendaring.CommitmentQuery", 
                  "osid.calendaring.CommitmentSearch"
               ], 
               "return_type": "osid.calendaring.CommitmentSearchResults", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_commitment_query_from_inspector", 
               "doc": {
                  "headline": "Gets a commitment query from an inspector.", 
                  "body": "        The inspector is available from an ``CommitmentSearchResults``."
               }, 
               "arg_doc": "        arg:    commitment_query_inspector\n                (osid.calendaring.CommitmentQueryInspector): a\n                commitment query inspector\n", 
               "return_doc": "        return: (osid.calendaring.CommitmentQuery) - the commitment\n                query", 
               "error_doc": "        raise:  NullArgument - ``commitment_query_inspector`` is\n                ``null``\n        raise:  Unsupported - ``commitment_query_inspector`` is not of\n                this service", 
               "sphinx_param_doc": "        :param commitment_query_inspector: a commitment query inspector\n        :type commitment_query_inspector: ``osid.calendaring.CommitmentQueryInspector``\n", 
               "sphinx_return_doc": "        :return: the commitment query\n        :rtype: ``osid.calendaring.CommitmentQuery``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``commitment_query_inspector`` is ``null``\n        :raise: ``Unsupported`` -- ``commitment_query_inspector`` is not of this service", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.calendaring.CommitmentQueryInspector", 
                     "var_name": "commitment_query_inspector", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.calendaring.CommitmentQueryInspector"
               ], 
               "return_type": "osid.calendaring.CommitmentQuery", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.calendaring.CommitmentAdminSession", 
         "shortname": "CommitmentAdminSession", 
         "category": "sessions", 
         "doc": {
            "headline": "This session creates, updates, and deletes ``Commitments``.", 
            "body": "    The data for create and update is provided by the consumer via the\n    form object. ``OsidForms`` are requested for each create or update\n    and may not be reused.\n\n    Create and update operations differ in their usage. To create a\n    ``Commitment,`` a ``CommitmentForm`` is requested using\n    ``get_commitment_form_for_create()`` specifying the desired\n    relationship peers and record ``Types`` or none if no record\n    ``Types`` are needed. The returned ``CommitmentForm`` will indicate\n    that it is to be used with a create operation and can be used to\n    examine metdata or validate data prior to creation. Once the\n    ``CommitmentForm`` is submiited to a create operation, it cannot be\n    reused with another create operation unless the first operation was\n    unsuccessful. Each ``CommitmentForm`` corresponds to an attempted\n    transaction.\n    \n    For updates, ``CommitmentForms`` are requested to the ``Commitment``\n    ``Id`` that is to be updated using ``getCommitmentFormForUpdate()``.\n    Similarly, the ``CommitmentForm`` has metadata about the data that\n    can be updated and it can perform validation before submitting the\n    update. The ``CommitmentForm`` can only be used once for a\n    successful update and cannot be reused.\n    \n    The delete operations delete ``Commitment``. To unmap a\n    ``Commitment`` from the current ``Calendar,`` the\n    ``CommitmentCalendarAssignmentSession`` should be used. These delete\n    operations attempt to remove the ``Commitment`` itself thus removing\n    it from all known ``Calendar`` catalogs.\n    \n    This session includes an ``Id`` aliasing mechanism to assign an\n    external ``Id`` to an internally assigned Id."
         }, 
         "inherit_fullnames": [
            "osid.OsidSession"
         ], 
         "inherit_shortnames": [
            "OsidSession"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidSession"
            }
         ], 
         "method_names": [
            "get_calendar_id", 
            "get_calendar", 
            "can_create_commitments", 
            "can_create_commitment_with_record_types", 
            "get_commitment_form_for_create", 
            "create_commitment", 
            "can_update_commitments", 
            "get_commitment_form_for_update", 
            "update_commitment", 
            "can_delete_commitments", 
            "delete_commitment", 
            "can_manage_commitment_aliases", 
            "alias_commitment"
         ], 
         "methods": [
            {
               "name": "get_calendar_id", 
               "doc": {
                  "headline": "Gets the ``Calendar``  ``Id`` associated with this session.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.id.Id) - the ``Calendar Id`` associated with this\n                session", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the ``Calendar Id`` associated with this session\n        :rtype: ``osid.id.Id``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.id.Id", 
               "errors": {}
            }, 
            {
               "name": "get_calendar", 
               "doc": {
                  "headline": "Gets the ``Calendar`` associated with this session.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.Calendar) - the ``Calendar``\n                associated with this session", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the ``Calendar`` associated with this session\n        :rtype: ``osid.calendaring.Calendar``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.Calendar", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "can_create_commitments", 
               "doc": {
                  "headline": "Tests if this user can create ``Commitments``.", 
                  "body": "        A return of true does not guarantee successful authorization. A\n        return of false indicates that it is known creating a\n        ``Commitment`` will result in a ``PermissionDenied``. This is\n        intended as a hint to an application that may opt not to offer\n        create operations to an unauthorized user."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``false`` if ``Commitment`` creation is not\n                authorized, ``true`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``false`` if ``Commitment`` creation is not authorized, ``true`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "can_create_commitment_with_record_types", 
               "doc": {
                  "headline": "Tests if this user can create a single ``Commitment`` using the desired record types.", 
                  "body": "        While ``CalendaringManager.getCommitmentRecordTypes()`` can be\n        used to examine which records are supported, this method tests\n        which record(s) are required for creating a specific\n        ``Commitment``. Providing an empty array tests if a\n        ``Commitment`` can be created with no records."
               }, 
               "arg_doc": "        arg:    commitment_record_types (osid.type.Type[]): array of\n                comitment record types\n", 
               "return_doc": "        return: (boolean) - ``true`` if ``Commitment`` creation using\n                the specified record ``Types`` is supported, ``false``\n                otherwise", 
               "error_doc": "        raise:  NullArgument - ``commitment_record_types`` is ``null``", 
               "sphinx_param_doc": "        :param commitment_record_types: array of comitment record types\n        :type commitment_record_types: ``osid.type.Type[]``\n", 
               "sphinx_return_doc": "        :return: ``true`` if ``Commitment`` creation using the specified record ``Types`` is supported, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``commitment_record_types`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type[]", 
                     "var_name": "commitment_record_types", 
                     "array": true
                  }
               ], 
               "arg_types": [
                  "osid.type.Type[]"
               ], 
               "return_type": "boolean", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "get_commitment_form_for_create", 
               "doc": {
                  "headline": "Gets the commitment form for creating new commitments.", 
                  "body": "        A new form should be requested for each create transaction."
               }, 
               "arg_doc": "        arg:    event_id (osid.id.Id): the ``Id`` of the ``Event``\n        arg:    resource_id (osid.id.Id): the ``Id`` of the ``Resource``\n        arg:    commitment_record_types (osid.type.Type[]): array of\n                comitment record types\n", 
               "return_doc": "        return: (osid.calendaring.CommitmentForm) - the commitment form", 
               "error_doc": "        raise:  NotFound - ``event_id`` or ``resource_id`` is not found\n        raise:  NullArgument - ``event_id`` or ``resource_id`` or\n                ``commitment_record_types`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        raise:  Unsupported - unable to get form for requested recod\n                types", 
               "sphinx_param_doc": "        :param event_id: the ``Id`` of the ``Event``\n        :type event_id: ``osid.id.Id``\n        :param resource_id: the ``Id`` of the ``Resource``\n        :type resource_id: ``osid.id.Id``\n        :param commitment_record_types: array of comitment record types\n        :type commitment_record_types: ``osid.type.Type[]``\n", 
               "sphinx_return_doc": "        :return: the commitment form\n        :rtype: ``osid.calendaring.CommitmentForm``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``event_id`` or ``resource_id`` is not found\n        :raise: ``NullArgument`` -- ``event_id`` or ``resource_id`` or ``commitment_record_types`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure\n        :raise: ``Unsupported`` -- unable to get form for requested recod types", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "event_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "resource_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.type.Type[]", 
                     "var_name": "commitment_record_types", 
                     "array": true
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "osid.id.Id", 
                  "osid.type.Type[]"
               ], 
               "return_type": "osid.calendaring.CommitmentForm", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }, 
            {
               "name": "create_commitment", 
               "doc": {
                  "headline": "Creates a new ``Commitment``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    commitment_form (osid.calendaring.CommitmentForm): the\n                forms for this ``Commitment``\n", 
               "return_doc": "        return: (osid.calendaring.Commitment) - the new ``Commitment``", 
               "error_doc": "        raise:  IllegalState - ``commitment_form`` already used in a\n                create transaction\n        raise:  InvalidArgument - one or more of the form elements is\n                invalid\n        raise:  NullArgument - ``commitment_form`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        raise:  Unsupported - ``commitment_form`` did not originate from\n                ``get_commitment_form_for_create()``", 
               "sphinx_param_doc": "        :param commitment_form: the forms for this ``Commitment``\n        :type commitment_form: ``osid.calendaring.CommitmentForm``\n", 
               "sphinx_return_doc": "        :return: the new ``Commitment``\n        :rtype: ``osid.calendaring.Commitment``", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- ``commitment_form`` already used in a create transaction\n        :raise: ``InvalidArgument`` -- one or more of the form elements is invalid\n        :raise: ``NullArgument`` -- ``commitment_form`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure\n        :raise: ``Unsupported`` -- ``commitment_form`` did not originate from ``get_commitment_form_for_create()``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.calendaring.CommitmentForm", 
                     "var_name": "commitment_form", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.calendaring.CommitmentForm"
               ], 
               "return_type": "osid.calendaring.Commitment", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract", 
                  "INVALID_ARGUMENT": "ConsumerContract", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }, 
            {
               "name": "can_update_commitments", 
               "doc": {
                  "headline": "Tests if this user can update ``Commitments``.", 
                  "body": "        A return of true does not guarantee successful authorization. A\n        return of false indicates that it is known updating a\n        ``Commitment`` will result in a ``PermissionDenied``. This is\n        intended as a hint to an application that may opt not to offer\n        update operations to an unauthorized user."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``false`` if commitment modification is not\n                authorized, ``true`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``false`` if commitment modification is not authorized, ``true`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "get_commitment_form_for_update", 
               "doc": {
                  "headline": "Gets the commitment form for updating an existing commitment.", 
                  "body": "        A new commitment form should be requested for each update\n        transaction."
               }, 
               "arg_doc": "        arg:    commitment_id (osid.id.Id): the ``Id`` of the\n                ``Commitment``\n", 
               "return_doc": "        return: (osid.calendaring.CommitmentForm) - the commitment form", 
               "error_doc": "        raise:  NotFound - ``commitment_id`` is not found\n        raise:  NullArgument - ``commitmentid`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param commitment_id: the ``Id`` of the ``Commitment``\n        :type commitment_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: the commitment form\n        :rtype: ``osid.calendaring.CommitmentForm``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``commitment_id`` is not found\n        :raise: ``NullArgument`` -- ``commitmentid`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "commitment_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "osid.calendaring.CommitmentForm", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "update_commitment", 
               "doc": {
                  "headline": "Updates an existing commitment.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    commitment_form (osid.calendaring.CommitmentForm): the\n                form containing the elements to be updated\n", 
               "return_doc": "", 
               "error_doc": "        raise:  IllegalState - ``commitment_form`` already used in an\n                update transaction\n        raise:  InvalidArgument - the form contains an invalid value\n        raise:  NullArgument - ``commitment_form`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        raise:  Unsupported - ``commitment_form`` did not originate from\n                ``get_commitment_form_for_update()``", 
               "sphinx_param_doc": "        :param commitment_form: the form containing the elements to be updated\n        :type commitment_form: ``osid.calendaring.CommitmentForm``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- ``commitment_form`` already used in an update transaction\n        :raise: ``InvalidArgument`` -- the form contains an invalid value\n        :raise: ``NullArgument`` -- ``commitment_form`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure\n        :raise: ``Unsupported`` -- ``commitment_form`` did not originate from ``get_commitment_form_for_update()``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.calendaring.CommitmentForm", 
                     "var_name": "commitment_form", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.calendaring.CommitmentForm"
               ], 
               "return_type": "", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract", 
                  "INVALID_ARGUMENT": "ConsumerContract", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }, 
            {
               "name": "can_delete_commitments", 
               "doc": {
                  "headline": "Tests if this user can delete ``Commitments``.", 
                  "body": "        A return of true does not guarantee successful authorization. A\n        return of false indicates that it is known deleting a\n        ``Commitment`` will result in a ``PermissionDenied``. This is\n        intended as a hint to an application that may opt not to offer\n        delete operations to an unauthorized user."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``false`` if ``Commitment`` deletion is not\n                authorized, ``true`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``false`` if ``Commitment`` deletion is not authorized, ``true`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "delete_commitment", 
               "doc": {
                  "headline": "Deletes the ``Commitment`` identified by the given ``Id``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    commitment_id (osid.id.Id): the ``Id`` of the\n                ``Commitment`` to delete\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NotFound - a ``Commitment`` was not found identified by\n                the given ``Id``\n        raise:  NullArgument - ``commitment_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param commitment_id: the ``Id`` of the ``Commitment`` to delete\n        :type commitment_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- a ``Commitment`` was not found identified by the given ``Id``\n        :raise: ``NullArgument`` -- ``commitment_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "commitment_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "can_manage_commitment_aliases", 
               "doc": {
                  "headline": "Tests if this user can manage ``Id`` aliases for ``Commitments``.", 
                  "body": "        A return of true does not guarantee successful authorization. A\n        return of false indicates that it is known changing an alias\n        will result in a ``PermissionDenied``. This is intended as a\n        hint to an application that may opt not to offer alias\n        operations to an unauthorized user."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``false`` if ``Commitment`` aliasing is not\n                authorized, ``true`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``false`` if ``Commitment`` aliasing is not authorized, ``true`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "alias_commitment", 
               "doc": {
                  "headline": "Adds an ``Id`` to a ``Commitment`` for the purpose of creating compatibility.", 
                  "body": "        The primary ``Id`` of the ``Commitment`` is determined by the\n        provider. The new ``Id`` performs as an alias to the primary\n        ``Id``. If the alias is a pointer to another commitment, it is\n        reassigned to the given commitment ``Id``."
               }, 
               "arg_doc": "        arg:    commitment_id (osid.id.Id): the ``Id`` of a\n                ``Commitment``\n        arg:    alias_id (osid.id.Id): the alias ``Id``\n", 
               "return_doc": "", 
               "error_doc": "        raise:  AlreadyExists - ``alias_id`` is already assigned\n        raise:  NotFound - ``commitment_id`` not found\n        raise:  NullArgument - ``commitment_id`` or ``alias_id`` is\n                ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param commitment_id: the ``Id`` of a ``Commitment``\n        :type commitment_id: ``osid.id.Id``\n        :param alias_id: the alias ``Id``\n        :type alias_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``AlreadyExists`` -- ``alias_id`` is already assigned\n        :raise: ``NotFound`` -- ``commitment_id`` not found\n        :raise: ``NullArgument`` -- ``commitment_id`` or ``alias_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "commitment_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "alias_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {
                  "ALREADY_EXISTS": "User", 
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.calendaring.CommitmentNotificationSession", 
         "shortname": "CommitmentNotificationSession", 
         "category": "sessions", 
         "doc": {
            "headline": "This session defines methods to receive asynchronous notifications on adds/changes to event commitments.", 
            "body": "    This session is intended for consumers needing to synchronize their\n    state with this service without the use of polling. Notifications\n    are cancelled when this session is closed.\n\n    The views defined in this session correspond to the views in the\n    ``CommitmentLookupSession``."
         }, 
         "inherit_fullnames": [
            "osid.OsidSession"
         ], 
         "inherit_shortnames": [
            "OsidSession"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidSession"
            }
         ], 
         "method_names": [
            "get_calendar_id", 
            "get_calendar", 
            "can_register_for_commitment_notifications", 
            "use_federated_calendar_view", 
            "use_isolated_calendar_view", 
            "register_for_new_commitments", 
            "register_for_new_commitments_by_genus_type", 
            "register_for_new_commitments_for_event", 
            "register_for_new_commitments_for_resource", 
            "register_for_changed_commitments", 
            "register_for_changed_commitments_by_genus_type", 
            "register_for_changed_commitments_for_event", 
            "register_for_changed_commitments_for_resource", 
            "register_for_changed_commitment", 
            "register_for_deleted_commitments", 
            "register_for_deleted_commitments_by_genus_type", 
            "register_for_deleted_commitments_for_event", 
            "register_for_deleted_commitments_for_resource", 
            "register_for_deleted_commitment"
         ], 
         "methods": [
            {
               "name": "get_calendar_id", 
               "doc": {
                  "headline": "Gets the ``Calendar``  ``Id`` associated with this session.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.id.Id) - the ``Calendar Id`` associated with this\n                session", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the ``Calendar Id`` associated with this session\n        :rtype: ``osid.id.Id``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.id.Id", 
               "errors": {}
            }, 
            {
               "name": "get_calendar", 
               "doc": {
                  "headline": "Gets the ``Calendar`` associated with this session.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.Calendar) - the ``Calendar``\n                associated with this session", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the ``Calendar`` associated with this session\n        :rtype: ``osid.calendaring.Calendar``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.Calendar", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "can_register_for_commitment_notifications", 
               "doc": {
                  "headline": "Tests if this user can register for ``Commitment`` notifications.", 
                  "body": "        A return of true does not guarantee successful authorization. A\n        return of false indicates that it is known all methods in this\n        session will result in a ``PermissionDenied``. This is intended\n        as a hint to an application that may opt not to offer\n        notification operations."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``false`` if notification methods are not\n                authorized, ``true`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``false`` if notification methods are not authorized, ``true`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "use_federated_calendar_view", 
               "doc": {
                  "headline": "Federates the view for methods in this session.", 
                  "body": "        A federated view will include notifications for commitments in\n        calendars which are children of this calendar in the calendar\n        hierarchy."
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "use_isolated_calendar_view", 
               "doc": {
                  "headline": "Isolates the view for methods in this session.", 
                  "body": "        An isolated view restricts notifications to this calendar only."
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "register_for_new_commitments", 
               "doc": {
                  "headline": "Register for notifications of new commitments.", 
                  "body": "        ``CommitmentReceiver.newCommitment()`` is invoked when a new\n        commitment is created."
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "register_for_new_commitments_by_genus_type", 
               "doc": {
                  "headline": "Register for notifications of new commitments by commitment genus type.", 
                  "body": "        ``CommitmentReceiver.newCommitment()`` is invoked when a new\n        commitment is created."
               }, 
               "arg_doc": "        arg:    commitment_genus_type (osid.id.Id): the commitment genus\n                type to monitor\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``commitment_genus_type is null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param commitment_genus_type: the commitment genus type to monitor\n        :type commitment_genus_type: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``commitment_genus_type is null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "commitment_genus_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "register_for_new_commitments_for_event", 
               "doc": {
                  "headline": "Register for notifications of new commitments for the given event.", 
                  "body": "        ``CommitmentReceiver.newCommitment()`` is invoked when a new\n        commitment is created."
               }, 
               "arg_doc": "        arg:    event_id (osid.id.Id): the ``Id`` of the ``Event`` to\n                monitor\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``event_id is null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param event_id: the ``Id`` of the ``Event`` to monitor\n        :type event_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``event_id is null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "event_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "register_for_new_commitments_for_resource", 
               "doc": {
                  "headline": "Register for notifications of new commitments for the given resource.", 
                  "body": "        ``CommitmentReceiver.newCommitment()`` is invoked when a new\n        commitment is created."
               }, 
               "arg_doc": "        arg:    resource_id (osid.id.Id): the ``Id`` of the ``Resource``\n                to monitor\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``resource_id is null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param resource_id: the ``Id`` of the ``Resource`` to monitor\n        :type resource_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``resource_id is null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "resource_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "register_for_changed_commitments", 
               "doc": {
                  "headline": "Registers for notification of updated commitments.", 
                  "body": "        ``CommitmentReceiver.changedCommitment()`` is invoked when a\n        commitment is changed."
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "register_for_changed_commitments_by_genus_type", 
               "doc": {
                  "headline": "Register for notifications of changed commitments by commitment genus type.", 
                  "body": "        ``CommitmentReceiver.changedCommitment()`` is invoked when a\n        commitment is changed."
               }, 
               "arg_doc": "        arg:    commitment_genus_type (osid.type.Type): the commitment\n                genus type to monitor\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``commitment_genus_type is null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param commitment_genus_type: the commitment genus type to monitor\n        :type commitment_genus_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``commitment_genus_type is null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "commitment_genus_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "register_for_changed_commitments_for_event", 
               "doc": {
                  "headline": "Register for notifications of changed commitments for the given event.", 
                  "body": "        ``CommitmentReceiver.changedCommitment()`` is invoked when a\n        commitment is changed."
               }, 
               "arg_doc": "        arg:    event_id (osid.id.Id): the ``Id`` of the ``Event`` to\n                monitor\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``event_id is null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param event_id: the ``Id`` of the ``Event`` to monitor\n        :type event_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``event_id is null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "event_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "register_for_changed_commitments_for_resource", 
               "doc": {
                  "headline": "Register for notifications of changed commitments for the given rsource.", 
                  "body": "        ``CommitmentReceiver.changedCommitment()`` is invoked when a\n        commitment is changed."
               }, 
               "arg_doc": "        arg:    resource_id (osid.id.Id): the ``Id`` of the ``Resource``\n                to monitor\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``resource_id is null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param resource_id: the ``Id`` of the ``Resource`` to monitor\n        :type resource_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``resource_id is null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "resource_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "register_for_changed_commitment", 
               "doc": {
                  "headline": "Registers for notification of an updated commitment.", 
                  "body": "        ``CommitmentReceiver.changedCommitment()`` is invoked when the\n        specified commitment is changed."
               }, 
               "arg_doc": "        arg:    commitment_id (osid.id.Id): the ``Id`` of the\n                ``Commitment`` to monitor\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``commitment_id is null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param commitment_id: the ``Id`` of the ``Commitment`` to monitor\n        :type commitment_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``commitment_id is null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "commitment_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "register_for_deleted_commitments", 
               "doc": {
                  "headline": "Registers for notification of deleted commitments.", 
                  "body": "        ``CommitmentReceiver.deletedCommitment()`` is invoked when a\n        commitment is deleted."
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "register_for_deleted_commitments_by_genus_type", 
               "doc": {
                  "headline": "Register for notifications of deleted commitments by commitment genus type.", 
                  "body": "        ``CommitmentReceiver.deletedCommitment()`` is invoked when a\n        commitment is deleted."
               }, 
               "arg_doc": "        arg:    commitment_genus_type (osid.id.Id): the commitment genus\n                type to monitor\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``commitment_genus_type is null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param commitment_genus_type: the commitment genus type to monitor\n        :type commitment_genus_type: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``commitment_genus_type is null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "commitment_genus_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "register_for_deleted_commitments_for_event", 
               "doc": {
                  "headline": "Register for notifications of deleted commitments for the given event.", 
                  "body": "        ``CommitmentReceiver.deletedCommitment()`` is invoked when a\n        commitment is deleted."
               }, 
               "arg_doc": "        arg:    event_id (osid.id.Id): the ``Id`` of the ``Event`` to\n                monitor\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``event_id is null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param event_id: the ``Id`` of the ``Event`` to monitor\n        :type event_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``event_id is null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "event_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "register_for_deleted_commitments_for_resource", 
               "doc": {
                  "headline": "Register for notifications of deleted commitments for the given rsource.", 
                  "body": "        ``CommitmentReceiver.deletedCommitment()`` is invoked when a\n        commitment is deleted."
               }, 
               "arg_doc": "        arg:    resource_id (osid.id.Id): the ``Id`` of the ``Resource``\n                to monitor\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``resource_id is null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param resource_id: the ``Id`` of the ``Resource`` to monitor\n        :type resource_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``resource_id is null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "resource_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "register_for_deleted_commitment", 
               "doc": {
                  "headline": "Registers for notification of a deleted commitment.", 
                  "body": "        ``CommitmentReceiver.changedCommitment()`` is invoked when the\n        specified commitment is deleted."
               }, 
               "arg_doc": "        arg:    commitment_id (osid.id.Id): the ``Id`` of the\n                ``Commitment`` to monitor\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``commitment_id is null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param commitment_id: the ``Id`` of the ``Commitment`` to monitor\n        :type commitment_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``commitment_id is null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "commitment_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.calendaring.CommitmentCalendarSession", 
         "shortname": "CommitmentCalendarSession", 
         "category": "sessions", 
         "doc": {
            "headline": "This session provides methods to retrieve ``Commitment`` to ``Calendar`` mappings.", 
            "body": "    A ``Commitment`` may appear in multiple ``Calendars``. Each\n    ``Calendar`` may have its own authorizations governing who is\n    allowed to look at it.\n\n    This lookup session defines two views:\n    \n      * comparative view: elements may be silently omitted or re-ordered\n      * plenary view: provides a complete result set or is an error\n        condition\n"
         }, 
         "inherit_fullnames": [
            "osid.OsidSession"
         ], 
         "inherit_shortnames": [
            "OsidSession"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidSession"
            }
         ], 
         "method_names": [
            "can_lookup_commitment_calendar_mappings", 
            "use_comparative_calendar_view", 
            "use_plenary_calendar_view", 
            "get_commitment_ids_by_calendar", 
            "get_commitments_by_calendar", 
            "get_commitment_ids_by_calendars", 
            "get_commitments_by_calendars", 
            "get_calendar_ids_by_commitment", 
            "get_calendars_by_commitment"
         ], 
         "methods": [
            {
               "name": "can_lookup_commitment_calendar_mappings", 
               "doc": {
                  "headline": "Tests if this user can perform lookups of commitment/calendar mappings.", 
                  "body": "        A return of true does not guarantee successful authorization. A\n        return of false indicates that it is known lookup methods in\n        this session will result in a ``PermissionDenied``. This is\n        intended as a hint to an application that may opt not to offer\n        lookup operations to unauthorized users."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``false`` if looking up mappings is not\n                authorized, ``true`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``false`` if looking up mappings is not authorized, ``true`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "use_comparative_calendar_view", 
               "doc": {
                  "headline": "The returns from the lookup methods may omit or translate elements based on this session, such as authorization, and not result in an error.", 
                  "body": "        This view is used when greater interoperability is desired at\n        the expense of precision."
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "use_plenary_calendar_view", 
               "doc": {
                  "headline": "A complete view of the ``Commitment`` and ``Calendar`` returns is desired.", 
                  "body": "        Methods will return what is requested or result in an error.\n        This view is used when greater precision is desired at the\n        expense of interoperability."
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "get_commitment_ids_by_calendar", 
               "doc": {
                  "headline": "Gets the list of ``Commitment``  ``Ids`` associated with an ``Calendar``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    calendar_id (osid.id.Id): ``Id`` of the ``Calendar``\n", 
               "return_doc": "        return: (osid.id.IdList) - list of related commitment ``Ids``", 
               "error_doc": "        raise:  NotFound - ``calendar_id`` is not found\n        raise:  NullArgument - ``calendar_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param calendar_id: ``Id`` of the ``Calendar``\n        :type calendar_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: list of related commitment ``Ids``\n        :rtype: ``osid.id.IdList``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``calendar_id`` is not found\n        :raise: ``NullArgument`` -- ``calendar_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "calendar_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "osid.id.IdList", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_commitments_by_calendar", 
               "doc": {
                  "headline": "Gets the list of ``Commitments`` associated with an ``Calendar``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    calendar_id (osid.id.Id): ``Id`` of the ``Calendar``\n", 
               "return_doc": "        return: (osid.calendaring.CommitmentList) - list of related\n                commitments", 
               "error_doc": "        raise:  NotFound - ``calendar_id`` is not found\n        raise:  NullArgument - ``calendar_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param calendar_id: ``Id`` of the ``Calendar``\n        :type calendar_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: list of related commitments\n        :rtype: ``osid.calendaring.CommitmentList``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``calendar_id`` is not found\n        :raise: ``NullArgument`` -- ``calendar_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "calendar_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "osid.calendaring.CommitmentList", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_commitment_ids_by_calendars", 
               "doc": {
                  "headline": "Gets the list of ``Commitment Ids`` corresponding to a list of ``Calendars``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    calendar_ids (osid.id.IdList): list of calendar ``Ids``\n", 
               "return_doc": "        return: (osid.id.IdList) - list of commitment ``Ids``", 
               "error_doc": "        raise:  NullArgument - ``calendar_ids`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param calendar_ids: list of calendar ``Ids``\n        :type calendar_ids: ``osid.id.IdList``\n", 
               "sphinx_return_doc": "        :return: list of commitment ``Ids``\n        :rtype: ``osid.id.IdList``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``calendar_ids`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.IdList", 
                     "var_name": "calendar_ids", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.IdList"
               ], 
               "return_type": "osid.id.IdList", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_commitments_by_calendars", 
               "doc": {
                  "headline": "Gets the list of ``Commitments`` corresponding to a list of ``Calendars``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    calendar_ids (osid.id.IdList): list of calendar ``Ids``\n", 
               "return_doc": "        return: (osid.calendaring.CommitmentList) - list of commitments", 
               "error_doc": "        raise:  NullArgument - ``calendar_ids`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param calendar_ids: list of calendar ``Ids``\n        :type calendar_ids: ``osid.id.IdList``\n", 
               "sphinx_return_doc": "        :return: list of commitments\n        :rtype: ``osid.calendaring.CommitmentList``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``calendar_ids`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.IdList", 
                     "var_name": "calendar_ids", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.IdList"
               ], 
               "return_type": "osid.calendaring.CommitmentList", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_calendar_ids_by_commitment", 
               "doc": {
                  "headline": "Gets the list of ``Calendar Ids`` mapped to a ``Commitment``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    commitment_id (osid.id.Id): ``Id`` of a ``Commitment``\n", 
               "return_doc": "        return: (osid.id.IdList) - list of calendar ``Ids``", 
               "error_doc": "        raise:  NotFound - ``commitment_id`` is not found\n        raise:  NullArgument - ``commitment_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param commitment_id: ``Id`` of a ``Commitment``\n        :type commitment_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: list of calendar ``Ids``\n        :rtype: ``osid.id.IdList``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``commitment_id`` is not found\n        :raise: ``NullArgument`` -- ``commitment_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "commitment_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "osid.id.IdList", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_calendars_by_commitment", 
               "doc": {
                  "headline": "Gets the list of ``Calendars`` mapped to a ``Commitment``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    commitment_id (osid.id.Id): ``Id`` of a ``Commitment``\n", 
               "return_doc": "        return: (osid.calendaring.CalendarList) - list of calendar\n                ``Ids``", 
               "error_doc": "        raise:  NotFound - ``commitment_id`` is not found\n        raise:  NullArgument - ``commitment_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param commitment_id: ``Id`` of a ``Commitment``\n        :type commitment_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: list of calendar ``Ids``\n        :rtype: ``osid.calendaring.CalendarList``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``commitment_id`` is not found\n        :raise: ``NullArgument`` -- ``commitment_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "commitment_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "osid.calendaring.CalendarList", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.calendaring.CommitmentCalendarAssignmentSession", 
         "shortname": "CommitmentCalendarAssignmentSession", 
         "category": "sessions", 
         "doc": {
            "headline": "This session provides methods to re-assign ``Commitments`` to ``Calendars``.", 
            "body": "    A ``Commitment`` may map to multiple ``Calendars`` and removing the\n    last reference to a ``Commitment`` is the equivalent of deleting it.\n    Each ``Calendar`` may have its own authorizations governing who is\n    allowed to operate on it.\n\n    Moving or adding a reference of a ``Commitment`` to another\n    ``Calendar`` is not a copy operation (eg: does not change its ``Id``\n    )."
         }, 
         "inherit_fullnames": [
            "osid.OsidSession"
         ], 
         "inherit_shortnames": [
            "OsidSession"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidSession"
            }
         ], 
         "method_names": [
            "can_assign_commitments", 
            "can_assign_commitments_to_calendar", 
            "get_assignable_calendar_ids", 
            "get_assignable_calendar_ids_for_commitment", 
            "assign_commitment_to_calendar", 
            "unassign_commitment_from_calendar"
         ], 
         "methods": [
            {
               "name": "can_assign_commitments", 
               "doc": {
                  "headline": "Tests if this user can alter commitment/calendar mappings.", 
                  "body": "        A return of true does not guarantee successful authorization. A\n        return of false indicates that it is known mapping methods in\n        this session will result in a ``PermissionDenied``. This is\n        intended as a hint to an application that may opt not to offer\n        lookup operations to unauthorized users."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``false`` if mapping is not authorized,\n                ``true`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``false`` if mapping is not authorized, ``true`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "can_assign_commitments_to_calendar", 
               "doc": {
                  "headline": "Tests if this user can alter commitment/calendar mappings.", 
                  "body": "        A return of true does not guarantee successful authorization. A\n        return of false indicates that it is known mapping methods in\n        this session will result in a ``PermissionDenied``. This is\n        intended as a hint to an application that may opt not to offer\n        lookup operations to unauthorized users."
               }, 
               "arg_doc": "        arg:    calendar_id (osid.id.Id): the ``Id`` of the ``Calendar``\n", 
               "return_doc": "        return: (boolean) - ``false`` if mapping is not authorized,\n                ``true`` otherwise", 
               "error_doc": "        raise:  NullArgument - ``calendar_id`` is ``null``", 
               "sphinx_param_doc": "        :param calendar_id: the ``Id`` of the ``Calendar``\n        :type calendar_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: ``false`` if mapping is not authorized, ``true`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``calendar_id`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "calendar_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "boolean", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "get_assignable_calendar_ids", 
               "doc": {
                  "headline": "Gets a list of calendars including and under the given calendar node in which any commitment can be assigned.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    calendar_id (osid.id.Id): the ``Id`` of the ``Calendar``\n", 
               "return_doc": "        return: (osid.id.IdList) - list of assignable calendar ``Ids``", 
               "error_doc": "        raise:  NullArgument - ``calendar_id`` is ``null``\n        raise:  OperationFailed - unable to complete request", 
               "sphinx_param_doc": "        :param calendar_id: the ``Id`` of the ``Calendar``\n        :type calendar_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: list of assignable calendar ``Ids``\n        :rtype: ``osid.id.IdList``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``calendar_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "calendar_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "osid.id.IdList", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational"
               }
            }, 
            {
               "name": "get_assignable_calendar_ids_for_commitment", 
               "doc": {
                  "headline": "Gets a list of calendars including and under the given calendar node in which a specific commitment can be assigned.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    calendar_id (osid.id.Id): the ``Id`` of the ``Calendar``\n        arg:    commitment_id (osid.id.Id): the ``Id`` of the\n                ``Commitment``\n", 
               "return_doc": "        return: (osid.id.IdList) - list of assignable calendar ``Ids``", 
               "error_doc": "        raise:  NullArgument - ``calendar_id`` or ``commitment_id`` is\n                ``null``\n        raise:  OperationFailed - unable to complete request", 
               "sphinx_param_doc": "        :param calendar_id: the ``Id`` of the ``Calendar``\n        :type calendar_id: ``osid.id.Id``\n        :param commitment_id: the ``Id`` of the ``Commitment``\n        :type commitment_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: list of assignable calendar ``Ids``\n        :rtype: ``osid.id.IdList``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``calendar_id`` or ``commitment_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "calendar_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "commitment_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "osid.id.Id"
               ], 
               "return_type": "osid.id.IdList", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational"
               }
            }, 
            {
               "name": "assign_commitment_to_calendar", 
               "doc": {
                  "headline": "Adds an existing ``Commitment`` to a ``Calendar``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    commitment_id (osid.id.Id): the ``Id`` of the\n                ``Commitment``\n        arg:    calendar_id (osid.id.Id): the ``Id`` of the ``Calendar``\n", 
               "return_doc": "", 
               "error_doc": "        raise:  AlreadyExists - ``commitment_id`` is already assigned to\n                ``calendar_id``\n        raise:  NotFound - ``commitment_id`` or ``calendar_id`` not\n                found\n        raise:  NullArgument - ``commitment_id`` or ``calendar_id`` is\n                ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param commitment_id: the ``Id`` of the ``Commitment``\n        :type commitment_id: ``osid.id.Id``\n        :param calendar_id: the ``Id`` of the ``Calendar``\n        :type calendar_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``AlreadyExists`` -- ``commitment_id`` is already assigned to ``calendar_id``\n        :raise: ``NotFound`` -- ``commitment_id`` or ``calendar_id`` not found\n        :raise: ``NullArgument`` -- ``commitment_id`` or ``calendar_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "commitment_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "calendar_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {
                  "ALREADY_EXISTS": "User", 
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "unassign_commitment_from_calendar", 
               "doc": {
                  "headline": "Removes a ``Commitment`` from a ``Calendar``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    commitment_id (osid.id.Id): the ``Id`` of the\n                ``Commitment``\n        arg:    calendar_id (osid.id.Id): the ``Id`` of the ``Calendar``\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NotFound - ``commitment_id`` or ``calendar_id`` not\n                found or ``commitment_id`` not assigned to\n                ``calendar_id``\n        raise:  NullArgument - ``commitment_id`` or ``calendar_id`` is\n                ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param commitment_id: the ``Id`` of the ``Commitment``\n        :type commitment_id: ``osid.id.Id``\n        :param calendar_id: the ``Id`` of the ``Calendar``\n        :type calendar_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``commitment_id`` or ``calendar_id`` not found or ``commitment_id`` not assigned to ``calendar_id``\n        :raise: ``NullArgument`` -- ``commitment_id`` or ``calendar_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "commitment_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "calendar_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.calendaring.CommitmentSmartCalendarSession", 
         "shortname": "CommitmentSmartCalendarSession", 
         "category": "sessions", 
         "doc": {
            "headline": "This session manages queries and sequencing to create \"smart\" dynamic catalogs.", 
            "body": "    A ``CommitmentQuery`` can be retrieved from this session and mapped\n    to this ``Calendar`` to create a virtual collection of\n    ``Commitments``. The entries may be sequenced using the\n    ``CommitmentSearchOrder`` from this session.\n\n    This ``Calendar`` has a default query that matches any commitment\n    and a default search order that specifies no sequencing. The queries\n    may be examined using a ``CommitmentQueryInspector``. The query may\n    be modified by converting the inspector back to a\n    ``CommitmentQuery``."
         }, 
         "inherit_fullnames": [
            "osid.OsidSession"
         ], 
         "inherit_shortnames": [
            "OsidSession"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidSession"
            }
         ], 
         "method_names": [
            "get_calendar_id", 
            "get_calendar", 
            "can_manage_smart_calendars", 
            "get_commitment_query", 
            "get_commitment_search_order", 
            "apply_commitment_query", 
            "inspect_commitment_query", 
            "apply_commitment_sequencing", 
            "get_commitment_query_from_inspector"
         ], 
         "methods": [
            {
               "name": "get_calendar_id", 
               "doc": {
                  "headline": "Gets the ``Calendar``  ``Id`` associated with this session.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.id.Id) - the ``Calendar Id`` associated with this\n                session", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the ``Calendar Id`` associated with this session\n        :rtype: ``osid.id.Id``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.id.Id", 
               "errors": {}
            }, 
            {
               "name": "get_calendar", 
               "doc": {
                  "headline": "Gets the ``Calendar`` associated with this session.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.Calendar) - the ``Calendar``\n                associated with this session", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the ``Calendar`` associated with this session\n        :rtype: ``osid.calendaring.Calendar``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.Calendar", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "can_manage_smart_calendars", 
               "doc": {
                  "headline": "Tests if this user can manage smart calendars.", 
                  "body": "        A return of true does not guarantee successful authorization. A\n        return of false indicates that it is known all methods in this\n        session will result in a ``PermissionDenied``. This is intended\n        as a hint to an application that may opt not to offer smart\n        operations."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``false`` if smart calendar methods are not\n                authorized, ``true`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``false`` if smart calendar methods are not authorized, ``true`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "get_commitment_query", 
               "doc": {
                  "headline": "Gets a commitment query.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.CommitmentQuery) - the commitment\n                query", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the commitment query\n        :rtype: ``osid.calendaring.CommitmentQuery``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.CommitmentQuery", 
               "errors": {}
            }, 
            {
               "name": "get_commitment_search_order", 
               "doc": {
                  "headline": "Gets a commitment search order.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.CommitmentSearchOrder) - the\n                commitment search order", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the commitment search order\n        :rtype: ``osid.calendaring.CommitmentSearchOrder``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.CommitmentSearchOrder", 
               "errors": {}
            }, 
            {
               "name": "apply_commitment_query", 
               "doc": {
                  "headline": "Applies a commitment query to this calendar.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    commitment_query (osid.calendaring.CommitmentQuery): the\n                commitment query\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``commitment_query`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure occurred\n        raise:  Unsupported - ``commitment_query`` not of this service", 
               "sphinx_param_doc": "        :param commitment_query: the commitment query\n        :type commitment_query: ``osid.calendaring.CommitmentQuery``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``commitment_query`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure occurred\n        :raise: ``Unsupported`` -- ``commitment_query`` not of this service", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.calendaring.CommitmentQuery", 
                     "var_name": "commitment_query", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.calendaring.CommitmentQuery"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }, 
            {
               "name": "inspect_commitment_query", 
               "doc": {
                  "headline": "Gets a commitment query inspector for this calendar.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.CommitmentQueryInspector) - the\n                commitment query inspector", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure occurred", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the commitment query inspector\n        :rtype: ``osid.calendaring.CommitmentQueryInspector``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure occurred", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.CommitmentQueryInspector", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "apply_commitment_sequencing", 
               "doc": {
                  "headline": "Applies a commitment search order to this calendar.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    commitment_search_order\n                (osid.calendaring.CommitmentSearchOrder): the commitment\n                search order\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``commitment_search_order`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure occurred\n        raise:  Unsupported - ``commitment_search_order`` not of this\n                service", 
               "sphinx_param_doc": "        :param commitment_search_order: the commitment search order\n        :type commitment_search_order: ``osid.calendaring.CommitmentSearchOrder``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``commitment_search_order`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure occurred\n        :raise: ``Unsupported`` -- ``commitment_search_order`` not of this service", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.calendaring.CommitmentSearchOrder", 
                     "var_name": "commitment_search_order", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.calendaring.CommitmentSearchOrder"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_commitment_query_from_inspector", 
               "doc": {
                  "headline": "Gets a commitment query from an inspector.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    commitment_query_inspector\n                (osid.calendaring.CommitmentQueryInspector): a\n                commitment query inspector\n", 
               "return_doc": "        return: (osid.calendaring.CommitmentQuery) - the commitment\n                query", 
               "error_doc": "        raise:  NullArgument - ``commitment_query_inspector`` is\n                ``null``\n        raise:  Unsupported - ``commitment_query_inspector`` is not of\n                this service", 
               "sphinx_param_doc": "        :param commitment_query_inspector: a commitment query inspector\n        :type commitment_query_inspector: ``osid.calendaring.CommitmentQueryInspector``\n", 
               "sphinx_return_doc": "        :return: the commitment query\n        :rtype: ``osid.calendaring.CommitmentQuery``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``commitment_query_inspector`` is ``null``\n        :raise: ``Unsupported`` -- ``commitment_query_inspector`` is not of this service", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.calendaring.CommitmentQueryInspector", 
                     "var_name": "commitment_query_inspector", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.calendaring.CommitmentQueryInspector"
               ], 
               "return_type": "osid.calendaring.CommitmentQuery", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.calendaring.TimePeriodLookupSession", 
         "shortname": "TimePeriodLookupSession", 
         "category": "sessions", 
         "doc": {
            "headline": "This session provides methods for retrieving ``TimePeriod`` objects.", 
            "body": "    The ``TimePeriod`` represents a period of time in which to manage\n    recurring events.\n\n    This session defines views that offer differing behaviors when\n    retrieving multiple objects.\n    \n      * comparative view: elements may be silently omitted or re-ordered\n      * plenary view: provides a complete set or is an error condition\n      * isolated calendar view: All time period methods in this session\n        operate, retrieve and pertain to time periods defined explicitly\n        in the current calendar. Using an isolated view is useful for\n        managing time periods with the ``TimePeriodAdminSession.``\n      * federated calendar view: All time period methods in this session\n        operate, retrieve and pertain to all time periods defined in\n        this calendar and any other calendars implicitly available in\n        this calendar through calendar inheritence.\n\n    \n    Time periods may have an additional records indicated by their\n    respective record types. The record may not be accessed through a\n    cast of the ``TimePeriod``."
         }, 
         "inherit_fullnames": [
            "osid.OsidSession"
         ], 
         "inherit_shortnames": [
            "OsidSession"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidSession"
            }
         ], 
         "method_names": [
            "get_calendar_id", 
            "get_calendar", 
            "can_lookup_time_periods", 
            "use_comparative_time_period_view", 
            "use_plenary_time_period_view", 
            "use_federated_calendar_view", 
            "use_isolated_calendar_view", 
            "get_time_period", 
            "get_time_periods_by_ids", 
            "get_time_periods_by_genus_type", 
            "get_time_periods_by_parent_genus_type", 
            "get_time_periods_by_record_type", 
            "get_time_periods_by_date", 
            "get_time_periods_in_date_range", 
            "get_time_periods"
         ], 
         "methods": [
            {
               "name": "get_calendar_id", 
               "doc": {
                  "headline": "Gets the ``Calendar``  ``Id`` associated with this session.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.id.Id) - the ``Calendar Id`` associated with this\n                session", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the ``Calendar Id`` associated with this session\n        :rtype: ``osid.id.Id``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.id.Id", 
               "errors": {}
            }, 
            {
               "name": "get_calendar", 
               "doc": {
                  "headline": "Gets the ``Calendar`` associated with this session.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.Calendar) - the ``Calendar``\n                associated with this session", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the ``Calendar`` associated with this session\n        :rtype: ``osid.calendaring.Calendar``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.Calendar", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "can_lookup_time_periods", 
               "doc": {
                  "headline": "Tests if this user can perform ``TimePeriod`` lookups.", 
                  "body": "        A return of true does not guarantee successful authorization. A\n        return of false indicates that it is known all methods in this\n        session will result in a ``PermissionDenied``. This is intended\n        as a hint to an application that may opt not to offer lookup\n        operations to unauthorized users."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``false`` if lookup methods are not\n                authorized, ``true`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``false`` if lookup methods are not authorized, ``true`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "use_comparative_time_period_view", 
               "doc": {
                  "headline": "The returns from the lookup methods may omit or translate elements based on this session, such as authorization, and not result in an error.", 
                  "body": "        This view is used when greater interoperability is desired at\n        the expense of precision."
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "use_plenary_time_period_view", 
               "doc": {
                  "headline": "A complete view of the ``TimePeriod`` returns is desired.", 
                  "body": "        Methods will return what is requested or result in an error.\n        This view is used when greater precision is desired at the\n        expense of interoperability."
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "use_federated_calendar_view", 
               "doc": {
                  "headline": "Federates the view for methods in this session.", 
                  "body": "        A federated view will include time periods in calendars which\n        are children of this calendar in the calendar hierarchy."
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "use_isolated_calendar_view", 
               "doc": {
                  "headline": "Isolates the view for methods in this session.", 
                  "body": "        An isolated view restricts lookups to this calendar only."
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "get_time_period", 
               "doc": {
                  "headline": "Gets the ``TimePeriod`` specified by its ``Id``.", 
                  "body": "        In plenary mode, the exact ``Id`` is found or a ``NotFound``\n        results. Otherwise, the returned ``TimePeriod`` may have a\n        different ``Id`` than requested, such as the case where a\n        duplicate ``Id`` was assigned to a ``TimePeriod`` and retained\n        for compatibility."
               }, 
               "arg_doc": "        arg:    time_period_id (osid.id.Id): ``Id`` of the\n                ``TimePeriod``\n", 
               "return_doc": "        return: (osid.calendaring.TimePeriod) - the time period", 
               "error_doc": "        raise:  NotFound - ``time_period_id`` not found\n        raise:  NullArgument - ``time_period_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param time_period_id: ``Id`` of the ``TimePeriod``\n        :type time_period_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: the time period\n        :rtype: ``osid.calendaring.TimePeriod``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``time_period_id`` not found\n        :raise: ``NullArgument`` -- ``time_period_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "time_period_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "osid.calendaring.TimePeriod", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_time_periods_by_ids", 
               "doc": {
                  "headline": "Gets a ``TimePeriodList`` corresponding to the given ``IdList``.", 
                  "body": "        In plenary mode, the returned list contains all of the time\n        periods specified in the ``Id`` list, in the order of the list,\n        including duplicates, or an error results if an ``Id`` in the\n        supplied list is not found or inaccessible. Otherwise,\n        inaccessible ``TimePeriods`` may be omitted from the list and\n        may present the elements in any order including returning a\n        unique set."
               }, 
               "arg_doc": "        arg:    time_period_ids (osid.id.IdList): the list of ``Ids`` to\n                retrieve\n", 
               "return_doc": "        return: (osid.calendaring.TimePeriodList) - the returned\n                ``TimePeriod`` list", 
               "error_doc": "        raise:  NotFound - an ``Id was`` not found\n        raise:  NullArgument - ``rime_period_ids`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param time_period_ids: the list of ``Ids`` to retrieve\n        :type time_period_ids: ``osid.id.IdList``\n", 
               "sphinx_return_doc": "        :return: the returned ``TimePeriod`` list\n        :rtype: ``osid.calendaring.TimePeriodList``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- an ``Id was`` not found\n        :raise: ``NullArgument`` -- ``rime_period_ids`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.IdList", 
                     "var_name": "time_period_ids", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.IdList"
               ], 
               "return_type": "osid.calendaring.TimePeriodList", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_time_periods_by_genus_type", 
               "doc": {
                  "headline": "Gets a ``TimePeriodList`` corresponding to the given time period genus ``Type`` which does not include time periods of genus types derived from the specified ``Type``.", 
                  "body": "        In plenary mode, the returned list contains all known time\n        periods or an error results. Otherwise, the returned list may\n        contain only those time periods that are accessible through this\n        session."
               }, 
               "arg_doc": "        arg:    time_period_genus_type (osid.type.Type): a time period\n                genus type\n", 
               "return_doc": "        return: (osid.calendaring.TimePeriodList) - the returned\n                ``TimePeriod`` list", 
               "error_doc": "        raise:  NullArgument - ``time_period_genus_type`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param time_period_genus_type: a time period genus type\n        :type time_period_genus_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "        :return: the returned ``TimePeriod`` list\n        :rtype: ``osid.calendaring.TimePeriodList``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``time_period_genus_type`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "time_period_genus_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "osid.calendaring.TimePeriodList", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_time_periods_by_parent_genus_type", 
               "doc": {
                  "headline": "Gets a ``TimePeriodList`` corresponding to the given time period genus ``Type`` and include any additional time periods with genus types derived from the specified ``Type``.", 
                  "body": "        In plenary mode, the returned list contains all known time\n        periods or an error results. Otherwise, the returned list may\n        contain only those time periods that are accessible through this\n        session."
               }, 
               "arg_doc": "        arg:    time_period_genus_type (osid.type.Type): a time period\n                genus type\n", 
               "return_doc": "        return: (osid.calendaring.TimePeriodList) - the returned\n                ``TimePeriod`` list", 
               "error_doc": "        raise:  NullArgument - ``time_period_genus_type`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param time_period_genus_type: a time period genus type\n        :type time_period_genus_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "        :return: the returned ``TimePeriod`` list\n        :rtype: ``osid.calendaring.TimePeriodList``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``time_period_genus_type`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "time_period_genus_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "osid.calendaring.TimePeriodList", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_time_periods_by_record_type", 
               "doc": {
                  "headline": "Gets a ``TimePeriodList`` containing the given time period record ``Type``.", 
                  "body": "        In plenary mode, the returned list contains all known time\n        periods or an error results. Otherwise, the returned list may\n        contain only those time periods that are accessible through this\n        session."
               }, 
               "arg_doc": "        arg:    time_period_record_type (osid.type.Type): a time period\n                record type\n", 
               "return_doc": "        return: (osid.calendaring.TimePeriodList) - the returned\n                ``TimePeriod`` list", 
               "error_doc": "        raise:  NullArgument - ``time_period_record_type`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param time_period_record_type: a time period record type\n        :type time_period_record_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "        :return: the returned ``TimePeriod`` list\n        :rtype: ``osid.calendaring.TimePeriodList``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``time_period_record_type`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "time_period_record_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "osid.calendaring.TimePeriodList", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_time_periods_by_date", 
               "doc": {
                  "headline": "Gets a ``TimePeriodList`` containing the given ``DateTime``.", 
                  "body": "        Time periods containing the given date are matched. In plenary\n        mode, the returned list contains all of the time periods\n        specified in the ``Id`` list, in the order of the list,\n        including duplicates, or an error results if an ``Id`` in the\n        supplied list is not found or inaccessible. Otherwise,\n        inaccessible ``TimePeriods`` may be omitted from the list and\n        may present the elements in any order including returning a\n        unique set."
               }, 
               "arg_doc": "        arg:    datetime (osid.calendaring.DateTime): a date\n", 
               "return_doc": "        return: (osid.calendaring.TimePeriodList) - the returned\n                ``TimePeriod`` list", 
               "error_doc": "        raise:  NullArgument - ``datetime`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param datetime: a date\n        :type datetime: ``osid.calendaring.DateTime``\n", 
               "sphinx_return_doc": "        :return: the returned ``TimePeriod`` list\n        :rtype: ``osid.calendaring.TimePeriodList``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``datetime`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.calendaring.DateTime", 
                     "var_name": "datetime", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.calendaring.DateTime"
               ], 
               "return_type": "osid.calendaring.TimePeriodList", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_time_periods_in_date_range", 
               "doc": {
                  "headline": "Gets a ``TimePeriodList`` corresponding to the given ``DateTime``.", 
                  "body": "        Time periods whose start end end times are included in the given\n        date range are matched.In plenary mode, the returned list\n        contains all of the time periods specified in the ``Id`` list,\n        in the order of the list, including duplicates, or an error\n        results if an ``Id`` in the supplied list is not found or\n        inaccessible. Otherwise, inaccessible ``TimePeriods`` may be\n        omitted from the list and may present the elements in any order\n        including returning a unique set."
               }, 
               "arg_doc": "        arg:    start (osid.calendaring.DateTime): start of daterange\n        arg:    end (osid.calendaring.DateTime): end of date range\n", 
               "return_doc": "        return: (osid.calendaring.TimePeriodList) - the returned\n                ``TimePeriod`` list", 
               "error_doc": "        raise:  InvalidArgument - ``end`` is less than ``start``\n        raise:  NullArgument - ``start`` or ``end`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param start: start of daterange\n        :type start: ``osid.calendaring.DateTime``\n        :param end: end of date range\n        :type end: ``osid.calendaring.DateTime``\n", 
               "sphinx_return_doc": "        :return: the returned ``TimePeriod`` list\n        :rtype: ``osid.calendaring.TimePeriodList``", 
               "sphinx_error_doc": "        :raise: ``InvalidArgument`` -- ``end`` is less than ``start``\n        :raise: ``NullArgument`` -- ``start`` or ``end`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.calendaring.DateTime", 
                     "var_name": "start", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.calendaring.DateTime", 
                     "var_name": "end", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.calendaring.DateTime", 
                  "osid.calendaring.DateTime"
               ], 
               "return_type": "osid.calendaring.TimePeriodList", 
               "errors": {
                  "INVALID_ARGUMENT": "ConsumerContract", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_time_periods", 
               "doc": {
                  "headline": "Gets all ``TimePeriods``.", 
                  "body": "        In plenary mode, the returned list contains all known time\n        periods or an error results. Otherwise, the returned list may\n        contain only those time periods that are accessible through this\n        session."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.TimePeriodList) - a ``TimePeriodList``", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: a ``TimePeriodList``\n        :rtype: ``osid.calendaring.TimePeriodList``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.TimePeriodList", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.calendaring.TimePeriodQuerySession", 
         "shortname": "TimePeriodQuerySession", 
         "category": "sessions", 
         "doc": {
            "headline": "This session provides methods for searching ``TimePeriod`` objects.", 
            "body": "    The search query is constructed using the ``TimePeriodQuery``. The\n    time period record ``Type`` also specifies the record for the time\n    period query.\n\n    Time periods may have a query record indicated by their respective\n    record types. The query record is accessed via the\n    ``TimePeriodQuery``."
         }, 
         "inherit_fullnames": [
            "osid.OsidSession"
         ], 
         "inherit_shortnames": [
            "OsidSession"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidSession"
            }
         ], 
         "method_names": [
            "get_calendar_id", 
            "get_calendar", 
            "can_search_time_periods", 
            "use_federated_calendar_view", 
            "use_isolated_calendar_view", 
            "get_time_period_query", 
            "get_time_periods_by_query"
         ], 
         "methods": [
            {
               "name": "get_calendar_id", 
               "doc": {
                  "headline": "Gets the ``Calendar``  ``Id`` associated with this session.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.id.Id) - the ``Calendar Id`` associated with this\n                session", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the ``Calendar Id`` associated with this session\n        :rtype: ``osid.id.Id``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.id.Id", 
               "errors": {}
            }, 
            {
               "name": "get_calendar", 
               "doc": {
                  "headline": "Gets the ``Calendar`` associated with this session.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.Calendar) - the ``Calendar``\n                associated with this session", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the ``Calendar`` associated with this session\n        :rtype: ``osid.calendaring.Calendar``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.Calendar", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "can_search_time_periods", 
               "doc": {
                  "headline": "Tests if this user can perform ``TimePeriod`` searches.", 
                  "body": "        A return of true does not guarantee successful authorization. A\n        return of false indicates that it is known all methods in this\n        session will result in a ``PermissionDenied``. This is intended\n        as a hint to an application that may opt not to offer search\n        operations to unauthorized users."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``false`` if search methods are not\n                authorized, ``true`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``false`` if search methods are not authorized, ``true`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "use_federated_calendar_view", 
               "doc": {
                  "headline": "Federates the view for methods in this session.", 
                  "body": "        A federated view will include time periods in calendars which\n        are children of this calendar in the calendar hierarchy."
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "use_isolated_calendar_view", 
               "doc": {
                  "headline": "Isolates the view for methods in this session.", 
                  "body": "        An isolated view restricts searches to this calendar only."
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "get_time_period_query", 
               "doc": {
                  "headline": "Gets a time period query.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.TimePeriodQuery) - the time period\n                query", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the time period query\n        :rtype: ``osid.calendaring.TimePeriodQuery``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.TimePeriodQuery", 
               "errors": {}
            }, 
            {
               "name": "get_time_periods_by_query", 
               "doc": {
                  "headline": "Gets a list of ``TimePeriods`` matching the given query.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    time_period_query (osid.calendaring.TimePeriodQuery):\n                the time period query\n", 
               "return_doc": "        return: (osid.calendaring.TimePeriodList) - the returned\n                ``TimePeriodList``", 
               "error_doc": "        raise:  NullArgument - ``time_period_query`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        raise:  Unsupported - ``time_period_query`` is not of this\n                service", 
               "sphinx_param_doc": "        :param time_period_query: the time period query\n        :type time_period_query: ``osid.calendaring.TimePeriodQuery``\n", 
               "sphinx_return_doc": "        :return: the returned ``TimePeriodList``\n        :rtype: ``osid.calendaring.TimePeriodList``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``time_period_query`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure\n        :raise: ``Unsupported`` -- ``time_period_query`` is not of this service", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.calendaring.TimePeriodQuery", 
                     "var_name": "time_period_query", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.calendaring.TimePeriodQuery"
               ], 
               "return_type": "osid.calendaring.TimePeriodList", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.calendaring.TimePeriodSearchSession", 
         "shortname": "TimePeriodSearchSession", 
         "category": "sessions", 
         "doc": {
            "headline": "This session provides methods for searching ``TimePeriod`` objects.", 
            "body": "    The search query is constructed using the ``TimePeriodQuery``. The\n    time period record ``Type`` also specifies the record for the time\n    period query.\n\n    ``get_time_periods_by_query()`` is the basic search method and\n    returns a list of ``TimePeriods``. A more advanced search may be\n    performed with ``getTimePeriodsBySearch()``. It accepts a\n    ``TimePeriodSearch`` in addition to the query for the purpose of\n    specifying additional options affecting the entire search, such as\n    ordering. ``get_time_periods_by_search()`` returns a\n    ``TimePeriodSearchResults`` that can be used to access the resulting\n    ``TimePeriodList`` or be used to perform a search within the result\n    set through ``TimePeriodSearch``.\n    \n    Time periods may have a query record indicated by their respective\n    record types. The query record is accessed via the\n    ``TimePeriodQuery``."
         }, 
         "inherit_fullnames": [
            "osid.calendaring.TimePeriodQuerySession"
         ], 
         "inherit_shortnames": [
            "TimePeriodQuerySession"
         ], 
         "inherit_pkg_names": [
            "calendaring"
         ], 
         "inheritance": [
            {
               "pkg_name": "calendaring", 
               "name": "TimePeriodQuerySession"
            }
         ], 
         "method_names": [
            "get_time_period_search", 
            "get_time_period_search_order", 
            "get_time_periods_by_search", 
            "get_time_period_query_from_inspector"
         ], 
         "methods": [
            {
               "name": "get_time_period_search", 
               "doc": {
                  "headline": "Gets a time period search.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.TimePeriodSearch) - the time period\n                search", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the time period search\n        :rtype: ``osid.calendaring.TimePeriodSearch``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.TimePeriodSearch", 
               "errors": {}
            }, 
            {
               "name": "get_time_period_search_order", 
               "doc": {
                  "headline": "Gets a time period search order.", 
                  "body": "        The ``TimePeriodSearchOrder`` is supplied to a\n        ``TimePeriodSearch`` to specify the ordering of results."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.TimePeriodSearchOrder) - the time\n                period search order", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the time period search order\n        :rtype: ``osid.calendaring.TimePeriodSearchOrder``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.TimePeriodSearchOrder", 
               "errors": {}
            }, 
            {
               "name": "get_time_periods_by_search", 
               "doc": {
                  "headline": "Gets the search results matching the given search query using the given search.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    time_period_query (osid.calendaring.TimePeriodQuery):\n                the time period query\n        arg:    time_period_search (osid.calendaring.TimePeriodSearch):\n                the time period search\n", 
               "return_doc": "        return: (osid.calendaring.TimePeriodSearchResults) - the time\n                period search results", 
               "error_doc": "        raise:  NullArgument - ``time_period_query`` or\n                ``time_period_search`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        raise:  Unsupported - ``time_period_search`` or t\n                ``ime_period_query`` is not of this service", 
               "sphinx_param_doc": "        :param time_period_query: the time period query\n        :type time_period_query: ``osid.calendaring.TimePeriodQuery``\n        :param time_period_search: the time period search\n        :type time_period_search: ``osid.calendaring.TimePeriodSearch``\n", 
               "sphinx_return_doc": "        :return: the time period search results\n        :rtype: ``osid.calendaring.TimePeriodSearchResults``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``time_period_query`` or ``time_period_search`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure\n        :raise: ``Unsupported`` -- ``time_period_search`` or t ``ime_period_query`` is not of this service", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.calendaring.TimePeriodQuery", 
                     "var_name": "time_period_query", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.calendaring.TimePeriodSearch", 
                     "var_name": "time_period_search", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.calendaring.TimePeriodQuery", 
                  "osid.calendaring.TimePeriodSearch"
               ], 
               "return_type": "osid.calendaring.TimePeriodSearchResults", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_time_period_query_from_inspector", 
               "doc": {
                  "headline": "Gets a time period query from an inspector.", 
                  "body": "        The inspector is available from a ``TimePeriodSearchResults``."
               }, 
               "arg_doc": "        arg:    time_period_query_inspector\n                (osid.calendaring.TimePeriodQueryInspector): a time\n                period query inspector\n", 
               "return_doc": "        return: (osid.calendaring.TimePeriodQuery) - the time period\n                query", 
               "error_doc": "        raise:  NullArgument - ``time_period_query_inspector`` is\n                ``null``\n        raise:  Unsupported - ``time_period_query_inspector`` is not of\n                this service", 
               "sphinx_param_doc": "        :param time_period_query_inspector: a time period query inspector\n        :type time_period_query_inspector: ``osid.calendaring.TimePeriodQueryInspector``\n", 
               "sphinx_return_doc": "        :return: the time period query\n        :rtype: ``osid.calendaring.TimePeriodQuery``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``time_period_query_inspector`` is ``null``\n        :raise: ``Unsupported`` -- ``time_period_query_inspector`` is not of this service", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.calendaring.TimePeriodQueryInspector", 
                     "var_name": "time_period_query_inspector", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.calendaring.TimePeriodQueryInspector"
               ], 
               "return_type": "osid.calendaring.TimePeriodQuery", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.calendaring.TimePeriodAdminSession", 
         "shortname": "TimePeriodAdminSession", 
         "category": "sessions", 
         "doc": {
            "headline": "This session creates, updates, and deletes ``Time Periods``.", 
            "body": "    The data for create and update is provided by the consumer via the\n    form object. ``OsidForms`` are requested for each create or update\n    and may not be reused.\n\n    Create and update operations differ in their usage. To create a\n    ``TimePeriod,`` a ``TimePeriodForm`` is requested using\n    ``get_time_period_form_for_create()`` specifying the desired record\n    ``Types`` or none if no record ``Types`` are needed. The returned\n    ``TimePeriodForm`` will indicate that it is to be used with a create\n    operation and can be used to examine metdata or validate data prior\n    to creation. Once the ``TimePeriodForm`` is submiited to a create\n    operation, it cannot be reused with another create operation unless\n    the first operation was unsuccessful. Each ``TimePeriodForm``\n    corresponds to an attempted transaction.\n    \n    For updates, ``TimePeriodForms`` are requested to the ``TimePeriod``\n    ``Id`` that is to be updated using ``getTimePeriodFormForUpdate()``.\n    Similarly, the ``TimePeriodForm`` has metadata about the data that\n    can be updated and it can perform validation before submitting the\n    update. The ``TimePeriodForm`` can only be used once for a\n    successful update and cannot be reused.\n    \n    The delete operations delete ``Time Periods``. To unmap a\n    ``TimePeriod`` from the current ``Calendar,`` the\n    ``TimePeriodCalendarAssignmentSession`` should be used. These delete\n    operations attempt to remove the ``TimePeriod`` itself thus removing\n    it from all known ``Calendar`` catalogs.\n    \n    This session includes an ``Id`` aliasing mechanism to assign an\n    external ``Id`` to an internally assigned Id."
         }, 
         "inherit_fullnames": [
            "osid.OsidSession"
         ], 
         "inherit_shortnames": [
            "OsidSession"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidSession"
            }
         ], 
         "method_names": [
            "get_calendar_id", 
            "get_calendar", 
            "can_create_time_periods", 
            "can_create_time_period_with_record_types", 
            "get_time_period_form_for_create", 
            "create_time_period", 
            "can_update_time_periods", 
            "get_time_period_form_for_update", 
            "update_time_period", 
            "can_delete_time_periods", 
            "delete_time_period", 
            "can_manage_time_period_aliases", 
            "alias_time_period", 
            "add_exception_event", 
            "remove_exception_event"
         ], 
         "methods": [
            {
               "name": "get_calendar_id", 
               "doc": {
                  "headline": "Gets the ``Calendar``  ``Id`` associated with this session.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.id.Id) - the ``Calendar Id`` associated with this\n                session", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the ``Calendar Id`` associated with this session\n        :rtype: ``osid.id.Id``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.id.Id", 
               "errors": {}
            }, 
            {
               "name": "get_calendar", 
               "doc": {
                  "headline": "Gets the ``Calendar`` associated with this session.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.Calendar) - the ``Calendar``\n                associated with this session", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the ``Calendar`` associated with this session\n        :rtype: ``osid.calendaring.Calendar``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.Calendar", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "can_create_time_periods", 
               "doc": {
                  "headline": "Tests if this user can create ``TimePeriods``.", 
                  "body": "        A return of true does not guarantee successful authorization. A\n        return of false indicates that it is known creating a TimePeriod\n        will result in a ``PermissionDenied``. This is intended as a\n        hint to an application that may opt not to offer create\n        operations to an unauthorized user."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``false`` if ``TimePeriod`` creation is not\n                authorized, ``true`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``false`` if ``TimePeriod`` creation is not authorized, ``true`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "can_create_time_period_with_record_types", 
               "doc": {
                  "headline": "Tests if this user can create a single ``TimePeriod`` using the desired record types.", 
                  "body": "        While ``CalendaringManager.getTimePeriodRecordTypes()`` can be\n        used to examine which records are supported, this method tests\n        which record(s) are required for creating a specific\n        ``TimePeriod``. Providing an empty array tests if a\n        ``TimePeriod`` can be created with no records."
               }, 
               "arg_doc": "        arg:    time_period_record_types (osid.type.Type[]): array of\n                time period record types\n", 
               "return_doc": "        return: (boolean) - ``true`` if ``TimePeriod`` creation using\n                the specified record ``Types`` is supported, ``false``\n                otherwise", 
               "error_doc": "        raise:  NullArgument - ``time_period_record_types`` is ``null``", 
               "sphinx_param_doc": "        :param time_period_record_types: array of time period record types\n        :type time_period_record_types: ``osid.type.Type[]``\n", 
               "sphinx_return_doc": "        :return: ``true`` if ``TimePeriod`` creation using the specified record ``Types`` is supported, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``time_period_record_types`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type[]", 
                     "var_name": "time_period_record_types", 
                     "array": true
                  }
               ], 
               "arg_types": [
                  "osid.type.Type[]"
               ], 
               "return_type": "boolean", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "get_time_period_form_for_create", 
               "doc": {
                  "headline": "Gets the time period form for creating new time periods.", 
                  "body": "        A new form should be requested for each create transaction."
               }, 
               "arg_doc": "        arg:    time_period_record_types (osid.type.Type[]): array of\n                time period record types\n", 
               "return_doc": "        return: (osid.calendaring.TimePeriodForm) - the time period form", 
               "error_doc": "        raise:  NullArgument - ``time_period_record_types`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        raise:  Unsupported - unable to get form for requested record\n                types", 
               "sphinx_param_doc": "        :param time_period_record_types: array of time period record types\n        :type time_period_record_types: ``osid.type.Type[]``\n", 
               "sphinx_return_doc": "        :return: the time period form\n        :rtype: ``osid.calendaring.TimePeriodForm``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``time_period_record_types`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure\n        :raise: ``Unsupported`` -- unable to get form for requested record types", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type[]", 
                     "var_name": "time_period_record_types", 
                     "array": true
                  }
               ], 
               "arg_types": [
                  "osid.type.Type[]"
               ], 
               "return_type": "osid.calendaring.TimePeriodForm", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }, 
            {
               "name": "create_time_period", 
               "doc": {
                  "headline": "Creates a new ``TimePeriod``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    time_period_form (osid.calendaring.TimePeriodForm): the\n                forms for this ``TimePeriod``\n", 
               "return_doc": "        return: (osid.calendaring.TimePeriod) - the new ``TimePeriod``", 
               "error_doc": "        raise:  IllegalState - ``time_period_form`` already used in a\n                create transaction\n        raise:  InvalidArgument - one or more of the form elements is\n                invalid\n        raise:  NullArgument - ``time_period_form`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        raise:  Unsupported - ``time_period_form`` did not originate\n                from ``get_time_period_for_create()``", 
               "sphinx_param_doc": "        :param time_period_form: the forms for this ``TimePeriod``\n        :type time_period_form: ``osid.calendaring.TimePeriodForm``\n", 
               "sphinx_return_doc": "        :return: the new ``TimePeriod``\n        :rtype: ``osid.calendaring.TimePeriod``", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- ``time_period_form`` already used in a create transaction\n        :raise: ``InvalidArgument`` -- one or more of the form elements is invalid\n        :raise: ``NullArgument`` -- ``time_period_form`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure\n        :raise: ``Unsupported`` -- ``time_period_form`` did not originate from ``get_time_period_for_create()``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.calendaring.TimePeriodForm", 
                     "var_name": "time_period_form", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.calendaring.TimePeriodForm"
               ], 
               "return_type": "osid.calendaring.TimePeriod", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract", 
                  "INVALID_ARGUMENT": "ConsumerContract", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }, 
            {
               "name": "can_update_time_periods", 
               "doc": {
                  "headline": "Tests if this user can update ``TimePeriods``.", 
                  "body": "        A return of true does not guarantee successful authorization. A\n        return of false indicates that it is known updating a\n        ``TimePeriod`` will result in a ``PermissionDenied``. This is\n        intended as a hint to an application that may opt not to offer\n        update operations to an unauthorized user."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``false`` if time period modification is not\n                authorized, ``true`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``false`` if time period modification is not authorized, ``true`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "get_time_period_form_for_update", 
               "doc": {
                  "headline": "Gets the time period form for updating an existing time period.", 
                  "body": "        A new time period form should be requested for each update\n        transaction."
               }, 
               "arg_doc": "        arg:    time_period_id (osid.id.Id): the ``Id`` of the\n                ``TimePeriod``\n", 
               "return_doc": "        return: (osid.calendaring.TimePeriodForm) - the time period form", 
               "error_doc": "        raise:  NotFound - ``time_period_id`` is not found\n        raise:  NullArgument - ``time_periodid`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param time_period_id: the ``Id`` of the ``TimePeriod``\n        :type time_period_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: the time period form\n        :rtype: ``osid.calendaring.TimePeriodForm``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``time_period_id`` is not found\n        :raise: ``NullArgument`` -- ``time_periodid`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "time_period_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "osid.calendaring.TimePeriodForm", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "update_time_period", 
               "doc": {
                  "headline": "Updates an existing tiem period.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    time_period_form (osid.calendaring.TimePeriodForm): the\n                form containing the elements to be updated\n", 
               "return_doc": "", 
               "error_doc": "        raise:  IllegalState - ``time_period_form`` already used in an\n                update transaction\n        raise:  InvalidArgument - the form contains an invalid value\n        raise:  NullArgument - ``time_period_form`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        raise:  Unsupported - ``time_period_form`` did not originate\n                from ``get_time_period_for_update()``", 
               "sphinx_param_doc": "        :param time_period_form: the form containing the elements to be updated\n        :type time_period_form: ``osid.calendaring.TimePeriodForm``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- ``time_period_form`` already used in an update transaction\n        :raise: ``InvalidArgument`` -- the form contains an invalid value\n        :raise: ``NullArgument`` -- ``time_period_form`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure\n        :raise: ``Unsupported`` -- ``time_period_form`` did not originate from ``get_time_period_for_update()``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.calendaring.TimePeriodForm", 
                     "var_name": "time_period_form", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.calendaring.TimePeriodForm"
               ], 
               "return_type": "", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract", 
                  "INVALID_ARGUMENT": "ConsumerContract", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }, 
            {
               "name": "can_delete_time_periods", 
               "doc": {
                  "headline": "Tests if this user can delete ``TimePeriods``.", 
                  "body": "        A return of true does not guarantee successful authorization. A\n        return of false indicates that it is known deleting a\n        ``TimePeriod`` will result in a ``PermissionDenied``. This is\n        intended as a hint to an application that may opt not to offer\n        delete operations to an unauthorized user."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``false`` if ``TimePeriod`` deletion is not\n                authorized, ``true`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``false`` if ``TimePeriod`` deletion is not authorized, ``true`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "delete_time_period", 
               "doc": {
                  "headline": "Deletes the ``TimePeriod`` identified by the given ``Id``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    time_period_id (osid.id.Id): the ``Id`` of the\n                ``TimePeriod`` to delete\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NotFound - a ``TimePeriod`` was not found identified by\n                the given ``Id``\n        raise:  NullArgument - ``time_period_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param time_period_id: the ``Id`` of the ``TimePeriod`` to delete\n        :type time_period_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- a ``TimePeriod`` was not found identified by the given ``Id``\n        :raise: ``NullArgument`` -- ``time_period_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "time_period_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "can_manage_time_period_aliases", 
               "doc": {
                  "headline": "Tests if this user can manage ``Id`` aliases for ``TimePeriods``.", 
                  "body": "        A return of true does not guarantee successful authorization. A\n        return of false indicates that it is known changing an alias\n        will result in a ``PermissionDenied``. This is intended as a\n        hint to an application that may opt not to offer alias\n        operations to an unauthorized user."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``false`` if ``TimePeriod`` aliasing is not\n                authorized, ``true`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``false`` if ``TimePeriod`` aliasing is not authorized, ``true`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "alias_time_period", 
               "doc": {
                  "headline": "Adds an ``Id`` to a ``TimePeriod`` for the purpose of creating compatibility.", 
                  "body": "        The primary ``Id`` of the ``TimePeriod`` is determined by the\n        provider. The new ``Id`` performs as an alias to the primary\n        ``Id``. If the alias is a pointer to another time period, it is\n        reassigned to the given time period ``Id``."
               }, 
               "arg_doc": "        arg:    time_period_id (osid.id.Id): the ``Id`` of a\n                ``TimePeriod``\n        arg:    alias_id (osid.id.Id): the alias ``Id``\n", 
               "return_doc": "", 
               "error_doc": "        raise:  AlreadyExists - ``alias_id`` is already assigned\n        raise:  NotFound - ``time_period_id`` not found\n        raise:  NullArgument - ``time_period_id`` or ``alias_id`` is\n                ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param time_period_id: the ``Id`` of a ``TimePeriod``\n        :type time_period_id: ``osid.id.Id``\n        :param alias_id: the alias ``Id``\n        :type alias_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``AlreadyExists`` -- ``alias_id`` is already assigned\n        :raise: ``NotFound`` -- ``time_period_id`` not found\n        :raise: ``NullArgument`` -- ``time_period_id`` or ``alias_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "time_period_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "alias_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {
                  "ALREADY_EXISTS": "User", 
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "add_exception_event", 
               "doc": {
                  "headline": "Adds an exception event to a time period.", 
                  "body": "        Time period exception events govern exceptions to recurring\n        events mapped to a time period."
               }, 
               "arg_doc": "        arg:    time_period_id (osid.id.Id): the ``Id`` of a\n                ``TimePeriod``\n        arg:    event_id (osid.id.Id): an exception event ``Id``\n", 
               "return_doc": "", 
               "error_doc": "        raise:  AlreadyExists - event is already part of the time period\n        raise:  NotFound - ``time_period_id`` or ``event_id`` is not\n                found\n        raise:  NullArgument - ``time_period_id`` or ``event_id`` is\n                ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param time_period_id: the ``Id`` of a ``TimePeriod``\n        :type time_period_id: ``osid.id.Id``\n        :param event_id: an exception event ``Id``\n        :type event_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``AlreadyExists`` -- event is already part of the time period\n        :raise: ``NotFound`` -- ``time_period_id`` or ``event_id`` is not found\n        :raise: ``NullArgument`` -- ``time_period_id`` or ``event_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "time_period_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "event_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {
                  "ALREADY_EXISTS": "User", 
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "remove_exception_event", 
               "doc": {
                  "headline": "Removes an exception event from a time period.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    time_period_id (osid.id.Id): the ``Id`` of a\n                ``TimePeriod``\n        arg:    event_id (osid.id.Id): an exception event ``Id``\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NotFound - ``event_id`` not an exception in\n                ``time_period_id``\n        raise:  NullArgument - ``time_period_id`` or ``event_id`` is\n                ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param time_period_id: the ``Id`` of a ``TimePeriod``\n        :type time_period_id: ``osid.id.Id``\n        :param event_id: an exception event ``Id``\n        :type event_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``event_id`` not an exception in ``time_period_id``\n        :raise: ``NullArgument`` -- ``time_period_id`` or ``event_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "time_period_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "event_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.calendaring.TimePeriodNotificationSession", 
         "shortname": "TimePeriodNotificationSession", 
         "category": "sessions", 
         "doc": {
            "headline": "This session defines methods to receive asynchronous notifications on adds/changes to ``TimePeriods``.", 
            "body": "    This session is intended for consumers needing to synchronize their\n    state with this service without the use of polling. Notifications\n    are cancelled when this session is closed.\n\n    The two views defined in this session correspond to the views in the\n    ``TimePeriodLookupSession``."
         }, 
         "inherit_fullnames": [
            "osid.OsidSession"
         ], 
         "inherit_shortnames": [
            "OsidSession"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidSession"
            }
         ], 
         "method_names": [
            "get_calendar_id", 
            "get_calendar", 
            "can_register_for_time_period_notifications", 
            "use_federated_calendar_view", 
            "use_isolated_calendar_view", 
            "register_for_new_time_periods", 
            "register_for_changed_time_periods", 
            "register_for_changed_time_period", 
            "register_for_deleted_time_periods", 
            "register_for_deleted_time_period"
         ], 
         "methods": [
            {
               "name": "get_calendar_id", 
               "doc": {
                  "headline": "Gets the ``Calendar``  ``Id`` associated with this session.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.id.Id) - the ``Calendar Id`` associated with this\n                session", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the ``Calendar Id`` associated with this session\n        :rtype: ``osid.id.Id``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.id.Id", 
               "errors": {}
            }, 
            {
               "name": "get_calendar", 
               "doc": {
                  "headline": "Gets the ``Calendar`` associated with this session.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.Calendar) - the ``Calendar``\n                associated with this session", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the ``Calendar`` associated with this session\n        :rtype: ``osid.calendaring.Calendar``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.Calendar", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "can_register_for_time_period_notifications", 
               "doc": {
                  "headline": "Tests if this user can register for ``TimePeriod`` notifications.", 
                  "body": "        A return of true does not guarantee successful authorization. A\n        return of false indicates that it is known all methods in this\n        session will result in a ``PermissionDenied``. This is intended\n        as a hint to an application that may opt not to offer\n        notification operations."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``false`` if notification methods are not\n                authorized, ``true`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``false`` if notification methods are not authorized, ``true`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "use_federated_calendar_view", 
               "doc": {
                  "headline": "Federates the view for methods in this session.", 
                  "body": "        A federated view will include notifications for time periods in\n        calendars which are children of this calendar in the calendar\n        hierarchy."
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "use_isolated_calendar_view", 
               "doc": {
                  "headline": "Isolates the view for methods in this session.", 
                  "body": "        An isolated view restricts notifications to this calendar only."
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "register_for_new_time_periods", 
               "doc": {
                  "headline": "Register for notifications of new time periods.", 
                  "body": "        ``TimePeriodReceiver.newTimePeriod()`` is invoked when a new\n        time period is created."
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "register_for_changed_time_periods", 
               "doc": {
                  "headline": "Registers for notification of updated time periods.", 
                  "body": "        ``TimePeriodReceiver.changedTimePeriod()`` is invoked when a\n        time period is changed."
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "register_for_changed_time_period", 
               "doc": {
                  "headline": "Registers for notification of an updated time period.", 
                  "body": "        ``TimePeriodReceiver.changedTimePeriod()`` is invoked when the\n        specified time period is changed."
               }, 
               "arg_doc": "        arg:    time_period_id (osid.id.Id): the ``Id`` of the\n                ``TimePeriod`` to monitor\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``time_period_id is null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param time_period_id: the ``Id`` of the ``TimePeriod`` to monitor\n        :type time_period_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``time_period_id is null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "time_period_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "register_for_deleted_time_periods", 
               "doc": {
                  "headline": "Registers for notification of deleted time periods.", 
                  "body": "        ``TimePeriodReceiver.deletedTimePeriod()`` is invoked when a\n        time period is removed from this calendar."
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "register_for_deleted_time_period", 
               "doc": {
                  "headline": "Registers for notification of a deleted time period.", 
                  "body": "        ``TimePeriodReceiver.changedTimePeriod()`` is invoked when the\n        specified time period is removed from this calendar."
               }, 
               "arg_doc": "        arg:    time_period_id (osid.id.Id): the ``Id`` of the\n                ``TimePeriod`` to monitor\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``time_period_id is null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param time_period_id: the ``Id`` of the ``TimePeriod`` to monitor\n        :type time_period_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``time_period_id is null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "time_period_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.calendaring.TimePeriodCalendarSession", 
         "shortname": "TimePeriodCalendarSession", 
         "category": "sessions", 
         "doc": {
            "headline": "This session provides methods to retrieve ``TimePeriod`` to ``Calendar`` mappings.", 
            "body": "    A ``TimePeriod`` may appear in multiple ``Calendars``. Each\n    ``Calendar`` may have its own authorizations governing who is\n    allowed to look at it.\n\n    This lookup session defines two views:\n    \n      * comparative view: elements may be silently omitted or re-ordered\n      * plenary view: provides a complete result set or is an error\n        condition\n"
         }, 
         "inherit_fullnames": [
            "osid.OsidSession"
         ], 
         "inherit_shortnames": [
            "OsidSession"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidSession"
            }
         ], 
         "method_names": [
            "can_lookup_time_period_calendar_mappings", 
            "use_comparative_calendar_view", 
            "use_plenary_calendar_view", 
            "get_time_period_ids_by_calendar", 
            "get_time_periods_by_calendar", 
            "get_time_period_ids_by_calendars", 
            "get_time_periods_by_calendars", 
            "get_calendar_ids_by_time_period", 
            "get_calendars_by_time_period"
         ], 
         "methods": [
            {
               "name": "can_lookup_time_period_calendar_mappings", 
               "doc": {
                  "headline": "Tests if this user can perform lookups of time period/calendar mappings.", 
                  "body": "        A return of true does not guarantee successful authorization. A\n        return of false indicates that it is known lookup methods in\n        this session will result in a ``PermissionDenied``. This is\n        intended as a hint to an application that may opt not to offer\n        lookup operations to unauthorized users."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``false`` if looking up mappings is not\n                authorized, ``true`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``false`` if looking up mappings is not authorized, ``true`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "use_comparative_calendar_view", 
               "doc": {
                  "headline": "The returns from the lookup methods may omit or translate elements based on this session, such as authorization, and not result in an error.", 
                  "body": "        This view is used when greater interoperability is desired at\n        the expense of precision."
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "use_plenary_calendar_view", 
               "doc": {
                  "headline": "A complete view of the ``TimePeriod`` and ``Calendar`` returns is desired.", 
                  "body": "        Methods will return what is requested or result in an error.\n        This view is used when greater precision is desired at the\n        expense of interoperability."
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "get_time_period_ids_by_calendar", 
               "doc": {
                  "headline": "Gets the list of ``TimePeriod``  ``Ids`` associated with an ``Calendar``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    calendar_id (osid.id.Id): ``Id`` of the ``Calendar``\n", 
               "return_doc": "        return: (osid.id.IdList) - list of related time period ``Ids``", 
               "error_doc": "        raise:  NotFound - ``calendar_id`` is not found\n        raise:  NullArgument - ``calendar_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param calendar_id: ``Id`` of the ``Calendar``\n        :type calendar_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: list of related time period ``Ids``\n        :rtype: ``osid.id.IdList``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``calendar_id`` is not found\n        :raise: ``NullArgument`` -- ``calendar_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "calendar_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "osid.id.IdList", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_time_periods_by_calendar", 
               "doc": {
                  "headline": "Gets the list of ``TimePeriods`` associated with an ``Calendar``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    calendar_id (osid.id.Id): ``Id`` of the ``Calendar``\n", 
               "return_doc": "        return: (osid.calendaring.TimePeriodList) - list of related time\n                periods", 
               "error_doc": "        raise:  NotFound - ``calendar_id`` is not found\n        raise:  NullArgument - ``calendar_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param calendar_id: ``Id`` of the ``Calendar``\n        :type calendar_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: list of related time periods\n        :rtype: ``osid.calendaring.TimePeriodList``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``calendar_id`` is not found\n        :raise: ``NullArgument`` -- ``calendar_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "calendar_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "osid.calendaring.TimePeriodList", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_time_period_ids_by_calendars", 
               "doc": {
                  "headline": "Gets the list of ``TimePeriod Ids`` corresponding to a list of ``Calendars``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    calendar_ids (osid.id.IdList): list of calendar ``Ids``\n", 
               "return_doc": "        return: (osid.id.IdList) - list of time period ``Ids``", 
               "error_doc": "        raise:  NullArgument - ``calendar_ids`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param calendar_ids: list of calendar ``Ids``\n        :type calendar_ids: ``osid.id.IdList``\n", 
               "sphinx_return_doc": "        :return: list of time period ``Ids``\n        :rtype: ``osid.id.IdList``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``calendar_ids`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.IdList", 
                     "var_name": "calendar_ids", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.IdList"
               ], 
               "return_type": "osid.id.IdList", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_time_periods_by_calendars", 
               "doc": {
                  "headline": "Gets the list of ``TimePeriods`` corresponding to a list of ``Calendars``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    calendar_ids (osid.id.IdList): list of calendar ``Ids``\n", 
               "return_doc": "        return: (osid.calendaring.TimePeriodList) - list of time periods", 
               "error_doc": "        raise:  NullArgument - ``calendar_ids`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param calendar_ids: list of calendar ``Ids``\n        :type calendar_ids: ``osid.id.IdList``\n", 
               "sphinx_return_doc": "        :return: list of time periods\n        :rtype: ``osid.calendaring.TimePeriodList``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``calendar_ids`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.IdList", 
                     "var_name": "calendar_ids", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.IdList"
               ], 
               "return_type": "osid.calendaring.TimePeriodList", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_calendar_ids_by_time_period", 
               "doc": {
                  "headline": "Gets the list of ``Calendar Ids`` mapped to a ``TimePeriod``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    time_period_id (osid.id.Id): ``Id`` of a ``TimePeriod``\n", 
               "return_doc": "        return: (osid.id.IdList) - list of calendar ``Ids``", 
               "error_doc": "        raise:  NotFound - ``time_period_id`` is not found\n        raise:  NullArgument - ``time_period_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param time_period_id: ``Id`` of a ``TimePeriod``\n        :type time_period_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: list of calendar ``Ids``\n        :rtype: ``osid.id.IdList``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``time_period_id`` is not found\n        :raise: ``NullArgument`` -- ``time_period_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "time_period_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "osid.id.IdList", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_calendars_by_time_period", 
               "doc": {
                  "headline": "Gets the list of ``Calendars`` mapped to a ``TimePeriod``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    time_period_id (osid.id.Id): ``Id`` of a ``TimePeriod``\n", 
               "return_doc": "        return: (osid.calendaring.CalendarList) - list of calendar\n                ``Ids``", 
               "error_doc": "        raise:  NotFound - ``time_period_id`` is not found\n        raise:  NullArgument - ``time_period_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param time_period_id: ``Id`` of a ``TimePeriod``\n        :type time_period_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: list of calendar ``Ids``\n        :rtype: ``osid.calendaring.CalendarList``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``time_period_id`` is not found\n        :raise: ``NullArgument`` -- ``time_period_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "time_period_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "osid.calendaring.CalendarList", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.calendaring.TimePeriodCalendarAssignmentSession", 
         "shortname": "TimePeriodCalendarAssignmentSession", 
         "category": "sessions", 
         "doc": {
            "headline": "This session provides methods to re-assign ``TimePeriods`` to ``Calendars``.", 
            "body": "    A ``TimePeriod`` may map to multiple ``Calendars`` and removing the\n    last reference to a ``TimePeriod`` is the equivalent of deleting it.\n    Each ``Calendar`` may have its own authorizations governing who is\n    allowed to operate on it.\n\n    Moving or adding a reference of a ``TimePeriod`` to another\n    ``Calendar`` is not a copy operation (eg: does not change its ``Id``\n    )."
         }, 
         "inherit_fullnames": [
            "osid.OsidSession"
         ], 
         "inherit_shortnames": [
            "OsidSession"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidSession"
            }
         ], 
         "method_names": [
            "can_assign_time_periods", 
            "can_assign_time_periods_to_calendar", 
            "get_assignable_calendar_ids", 
            "get_assignable_calendar_ids_for_time_period", 
            "assign_time_period_to_calendar", 
            "unassign_time_period_from_calendar"
         ], 
         "methods": [
            {
               "name": "can_assign_time_periods", 
               "doc": {
                  "headline": "Tests if this user can alter time period/calendar mappings.", 
                  "body": "        A return of true does not guarantee successful authorization. A\n        return of false indicates that it is known mapping methods in\n        this session will result in a ``PermissionDenied``. This is\n        intended as a hint to an application that may opt not to offer\n        lookup operations to unauthorized users."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``false`` if mapping is not authorized,\n                ``true`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``false`` if mapping is not authorized, ``true`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "can_assign_time_periods_to_calendar", 
               "doc": {
                  "headline": "Tests if this user can alter time period/calendar mappings.", 
                  "body": "        A return of true does not guarantee successful authorization. A\n        return of false indicates that it is known mapping methods in\n        this session will result in a ``PermissionDenied``. This is\n        intended as a hint to an application that may opt not to offer\n        lookup operations to unauthorized users."
               }, 
               "arg_doc": "        arg:    calendar_id (osid.id.Id): the ``Id`` of the ``Calendar``\n", 
               "return_doc": "        return: (boolean) - ``false`` if mapping is not authorized,\n                ``true`` otherwise", 
               "error_doc": "        raise:  NullArgument - ``calendar_id`` is ``null``", 
               "sphinx_param_doc": "        :param calendar_id: the ``Id`` of the ``Calendar``\n        :type calendar_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: ``false`` if mapping is not authorized, ``true`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``calendar_id`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "calendar_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "boolean", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "get_assignable_calendar_ids", 
               "doc": {
                  "headline": "Gets a list of calendars including and under the given calendar node in which any time period can be assigned.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    calendar_id (osid.id.Id): the ``Id`` of the ``Calendar``\n", 
               "return_doc": "        return: (osid.id.IdList) - list of assignable calendar ``Ids``", 
               "error_doc": "        raise:  NullArgument - ``calendar_id`` is ``null``\n        raise:  OperationFailed - unable to complete request", 
               "sphinx_param_doc": "        :param calendar_id: the ``Id`` of the ``Calendar``\n        :type calendar_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: list of assignable calendar ``Ids``\n        :rtype: ``osid.id.IdList``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``calendar_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "calendar_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "osid.id.IdList", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational"
               }
            }, 
            {
               "name": "get_assignable_calendar_ids_for_time_period", 
               "doc": {
                  "headline": "Gets a list of calendars including and under the given calendar node in which a specific time period can be assigned.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    calendar_id (osid.id.Id): the ``Id`` of the ``Calendar``\n        arg:    time_period_id (osid.id.Id): the ``Id`` of the\n                ``TimePeriod``\n", 
               "return_doc": "        return: (osid.id.IdList) - list of assignable calendar ``Ids``", 
               "error_doc": "        raise:  NullArgument - ``calendar_id`` or ``time_period_id`` is\n                ``null``\n        raise:  OperationFailed - unable to complete request", 
               "sphinx_param_doc": "        :param calendar_id: the ``Id`` of the ``Calendar``\n        :type calendar_id: ``osid.id.Id``\n        :param time_period_id: the ``Id`` of the ``TimePeriod``\n        :type time_period_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: list of assignable calendar ``Ids``\n        :rtype: ``osid.id.IdList``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``calendar_id`` or ``time_period_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "calendar_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "time_period_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "osid.id.Id"
               ], 
               "return_type": "osid.id.IdList", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational"
               }
            }, 
            {
               "name": "assign_time_period_to_calendar", 
               "doc": {
                  "headline": "Adds an existing ``TimePeriod`` to a ``Calendar``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    time_period_id (osid.id.Id): the ``Id`` of the\n                ``TimePeriod``\n        arg:    calendar_id (osid.id.Id): the ``Id`` of the ``Calendar``\n", 
               "return_doc": "", 
               "error_doc": "        raise:  AlreadyExists - ``time_period_id`` is already assigned\n                to ``calendar_id``\n        raise:  NotFound - ``time_period_id`` or ``calendar_id`` not\n                found\n        raise:  NullArgument - ``time_period_id`` or ``calendar_id`` is\n                ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param time_period_id: the ``Id`` of the ``TimePeriod``\n        :type time_period_id: ``osid.id.Id``\n        :param calendar_id: the ``Id`` of the ``Calendar``\n        :type calendar_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``AlreadyExists`` -- ``time_period_id`` is already assigned to ``calendar_id``\n        :raise: ``NotFound`` -- ``time_period_id`` or ``calendar_id`` not found\n        :raise: ``NullArgument`` -- ``time_period_id`` or ``calendar_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "time_period_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "calendar_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {
                  "ALREADY_EXISTS": "User", 
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "unassign_time_period_from_calendar", 
               "doc": {
                  "headline": "Removes a ``TimePeriod`` from a ``Calendar``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    time_period_id (osid.id.Id): the ``Id`` of the\n                ``TimePeriod``\n        arg:    calendar_id (osid.id.Id): the ``Id`` of the ``Calendar``\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NotFound - ``time_period_id`` or ``calendar_id`` not\n                found or ``time_period_id`` not assigned to\n                ``calendar_id``\n        raise:  NullArgument - ``time_period_id`` or ``calendar_id`` is\n                ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param time_period_id: the ``Id`` of the ``TimePeriod``\n        :type time_period_id: ``osid.id.Id``\n        :param calendar_id: the ``Id`` of the ``Calendar``\n        :type calendar_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``time_period_id`` or ``calendar_id`` not found or ``time_period_id`` not assigned to ``calendar_id``\n        :raise: ``NullArgument`` -- ``time_period_id`` or ``calendar_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "time_period_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "calendar_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.calendaring.TimePeriodSmartCalendarSession", 
         "shortname": "TimePeriodSmartCalendarSession", 
         "category": "sessions", 
         "doc": {
            "headline": "This session manages queries and sequencing to create \"smart\" dynamic catalogs.", 
            "body": "    A ``TimePeriodQuery`` can be retrieved from this session and mapped\n    to this ``Calendar`` to create a virtual collection of\n    ``TomePeriods``. The entries may be sequenced using the\n    ``TimePeriodSearchOrder`` from this session.\n\n    This ``Calendar`` has a default query that matches any time period\n    and a default search order that specifies no sequencing. The queries\n    may be examined using a ``TimePeriodQueryInspector``. The query may\n    be modified by converting the inspector back to a\n    ``TimePeriodQuery``."
         }, 
         "inherit_fullnames": [
            "osid.OsidSession"
         ], 
         "inherit_shortnames": [
            "OsidSession"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidSession"
            }
         ], 
         "method_names": [
            "get_calendar_id", 
            "get_calendar", 
            "can_manage_smart_calendars", 
            "get_time_period_query", 
            "get_time_period_search_order", 
            "apply_time_period_query", 
            "inspect_time_period_query", 
            "apply_time_period_sequencing", 
            "get_time_period_query_from_inspector"
         ], 
         "methods": [
            {
               "name": "get_calendar_id", 
               "doc": {
                  "headline": "Gets the ``Calendar``  ``Id`` associated with this session.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.id.Id) - the ``Calendar Id`` associated with this\n                session", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the ``Calendar Id`` associated with this session\n        :rtype: ``osid.id.Id``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.id.Id", 
               "errors": {}
            }, 
            {
               "name": "get_calendar", 
               "doc": {
                  "headline": "Gets the ``Calendar`` associated with this session.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.Calendar) - the ``Calendar``\n                associated with this session", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the ``Calendar`` associated with this session\n        :rtype: ``osid.calendaring.Calendar``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.Calendar", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "can_manage_smart_calendars", 
               "doc": {
                  "headline": "Tests if this user can manage smart calendars.", 
                  "body": "        A return of true does not guarantee successful authorization. A\n        return of false indicates that it is known all methods in this\n        session will result in a ``PermissionDenied``. This is intended\n        as a hint to an application that may opt not to offer smart\n        operations."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``false`` if smart calendar methods are not\n                authorized, ``true`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``false`` if smart calendar methods are not authorized, ``true`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "get_time_period_query", 
               "doc": {
                  "headline": "Gets a time period query.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.TimePeriodQuery) - the time period\n                query", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the time period query\n        :rtype: ``osid.calendaring.TimePeriodQuery``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.TimePeriodQuery", 
               "errors": {}
            }, 
            {
               "name": "get_time_period_search_order", 
               "doc": {
                  "headline": "Gets a time period search order.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.TimePeriodSearchOrder) - the time\n                period search order", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the time period search order\n        :rtype: ``osid.calendaring.TimePeriodSearchOrder``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.TimePeriodSearchOrder", 
               "errors": {}
            }, 
            {
               "name": "apply_time_period_query", 
               "doc": {
                  "headline": "Applies a time period query to this calendar.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    time_period_query (osid.calendaring.TimePeriodQuery):\n                the time period query\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``time_period_query`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure occurred\n        raise:  Unsupported - ``time_period_query`` not of this service", 
               "sphinx_param_doc": "        :param time_period_query: the time period query\n        :type time_period_query: ``osid.calendaring.TimePeriodQuery``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``time_period_query`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure occurred\n        :raise: ``Unsupported`` -- ``time_period_query`` not of this service", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.calendaring.TimePeriodQuery", 
                     "var_name": "time_period_query", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.calendaring.TimePeriodQuery"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }, 
            {
               "name": "inspect_time_period_query", 
               "doc": {
                  "headline": "Gets a time period query inspector for this calendar.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.TimePeriodQueryInspector) - the time\n                period query inspector", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure occurred", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the time period query inspector\n        :rtype: ``osid.calendaring.TimePeriodQueryInspector``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure occurred", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.TimePeriodQueryInspector", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "apply_time_period_sequencing", 
               "doc": {
                  "headline": "Applies a time period search order to this calendar.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    time_period_search_order\n                (osid.calendaring.TimePeriodSearchOrder): the time\n                period search order\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``time_period_search_order`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure occurred\n        raise:  Unsupported - ``time_period_search_order`` not of this\n                service", 
               "sphinx_param_doc": "        :param time_period_search_order: the time period search order\n        :type time_period_search_order: ``osid.calendaring.TimePeriodSearchOrder``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``time_period_search_order`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure occurred\n        :raise: ``Unsupported`` -- ``time_period_search_order`` not of this service", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.calendaring.TimePeriodSearchOrder", 
                     "var_name": "time_period_search_order", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.calendaring.TimePeriodSearchOrder"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_time_period_query_from_inspector", 
               "doc": {
                  "headline": "Gets a time period query from an inspector.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    time_period_query_inspector\n                (osid.calendaring.TimePeriodQueryInspector): a time\n                period query inspector\n", 
               "return_doc": "        return: (osid.calendaring.TimePeriodQuery) - the time period\n                query interface", 
               "error_doc": "        raise:  NullArgument - ``time_period_query_inspector`` is\n                ``null``\n        raise:  Unsupported - ``time_period_query_inspector`` is not of\n                this service", 
               "sphinx_param_doc": "        :param time_period_query_inspector: a time period query inspector\n        :type time_period_query_inspector: ``osid.calendaring.TimePeriodQueryInspector``\n", 
               "sphinx_return_doc": "        :return: the time period query interface\n        :rtype: ``osid.calendaring.TimePeriodQuery``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``time_period_query_inspector`` is ``null``\n        :raise: ``Unsupported`` -- ``time_period_query_inspector`` is not of this service", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.calendaring.TimePeriodQueryInspector", 
                     "var_name": "time_period_query_inspector", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.calendaring.TimePeriodQueryInspector"
               ], 
               "return_type": "osid.calendaring.TimePeriodQuery", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.calendaring.CalendarLookupSession", 
         "shortname": "CalendarLookupSession", 
         "category": "sessions", 
         "doc": {
            "headline": "This session provides methods for retrieving ``Calendar`` objects.", 
            "body": "    The ``Calendar`` represents a collection of ``Events, Schedules`` ,\n    and time periods.\n\n    This session defines views that offer differing behaviors when\n    retrieving multiple objects.\n    \n      * comparative view: elements may be silently omitted or re-ordered\n      * plenary view: provides a complete set or is an error condition\n\n    \n    Generally, the comparative view should be used for most applications\n    as it permits operation even if there is data that cannot be\n    accessed. For example, a browsing application may only need to\n    examine the ``Calendars`` it can access, without breaking execution.\n    However, an administrative application may require all ``Calendar``\n    elements to be available.\n    \n    Calendars may have an additional records indicated by their\n    respective record types. The record may not be accessed through a\n    cast of the ``Calendar``."
         }, 
         "inherit_fullnames": [
            "osid.OsidSession"
         ], 
         "inherit_shortnames": [
            "OsidSession"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidSession"
            }
         ], 
         "method_names": [
            "can_lookup_calendars", 
            "use_comparative_calendar_view", 
            "use_plenary_calendar_view", 
            "get_calendar", 
            "get_calendars_by_ids", 
            "get_calendars_by_genus_type", 
            "get_calendars_by_parent_genus_type", 
            "get_calendars_by_record_type", 
            "get_calendars_by_provider", 
            "get_calendars"
         ], 
         "methods": [
            {
               "name": "can_lookup_calendars", 
               "doc": {
                  "headline": "Tests if this user can perform ``Calendar`` lookups.", 
                  "body": "        A return of true does not guarantee successful authorization. A\n        return of false indicates that it is known all methods in this\n        session will result in a ``PermissionDenied``. This is intended\n        as a hint to an application that may opt not to offer lookup\n        operations to unauthorized users."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``false`` if lookup methods are not\n                authorized, ``true`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``false`` if lookup methods are not authorized, ``true`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "use_comparative_calendar_view", 
               "doc": {
                  "headline": "The returns from the lookup methods may omit or translate elements based on this session, such as authorization, and not result in an error.", 
                  "body": "        This view is used when greater interoperability is desired at\n        the expense of precision."
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "use_plenary_calendar_view", 
               "doc": {
                  "headline": "A complete view of the ``Calendar`` returns is desired.", 
                  "body": "        Methods will return what is requested or result in an error.\n        This view is used when greater precision is desired at the\n        expense of interoperability."
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "get_calendar", 
               "doc": {
                  "headline": "Gets the ``Calendar`` specified by its ``Id``.", 
                  "body": "        In plenary mode, the exact ``Id`` is found or a ``NotFound``\n        results. Otherwise, the returned ``Calendar`` may have a\n        different ``Id`` than requested, such as the case where a\n        duplicate ``Id`` was assigned to a ``Calendar`` and retained for\n        compatility."
               }, 
               "arg_doc": "        arg:    calendar_id (osid.id.Id): ``Id`` of the ``Calendar``\n", 
               "return_doc": "        return: (osid.calendaring.Calendar) - the calendar", 
               "error_doc": "        raise:  NotFound - ``calendar_id`` not found\n        raise:  NullArgument - ``calendar_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param calendar_id: ``Id`` of the ``Calendar``\n        :type calendar_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: the calendar\n        :rtype: ``osid.calendaring.Calendar``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``calendar_id`` not found\n        :raise: ``NullArgument`` -- ``calendar_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "calendar_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "osid.calendaring.Calendar", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_calendars_by_ids", 
               "doc": {
                  "headline": "Gets a ``CalendarList`` corresponding to the given ``IdList``.", 
                  "body": "        In plenary mode, the returned list contains all of the calendars\n        specified in the ``Id`` list, in the order of the list,\n        including duplicates, or an error results if an ``Id`` in the\n        supplied list is not found or inaccessible. Otherwise,\n        inaccessible ``Calendar`` objects may be omitted from the list\n        and may present the elements in any order including returning a\n        unique set."
               }, 
               "arg_doc": "        arg:    calendar_ids (osid.id.IdList): the list of ``Ids`` to\n                retrieve\n", 
               "return_doc": "        return: (osid.calendaring.CalendarList) - the returned\n                ``Calendar`` list", 
               "error_doc": "        raise:  NotFound - an ``Id was`` not found\n        raise:  NullArgument - ``calendar_ids`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param calendar_ids: the list of ``Ids`` to retrieve\n        :type calendar_ids: ``osid.id.IdList``\n", 
               "sphinx_return_doc": "        :return: the returned ``Calendar`` list\n        :rtype: ``osid.calendaring.CalendarList``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- an ``Id was`` not found\n        :raise: ``NullArgument`` -- ``calendar_ids`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.IdList", 
                     "var_name": "calendar_ids", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.IdList"
               ], 
               "return_type": "osid.calendaring.CalendarList", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_calendars_by_genus_type", 
               "doc": {
                  "headline": "Gets a ``CalendarList`` corresponding to the given calendar genus ``Type`` which does not include calendars of types derived from the specified ``Type``.", 
                  "body": "        In plenary mode, the returned list contains all known calendars\n        or an error results. Otherwise, the returned list may contain\n        only those calendars that are accessible through this session."
               }, 
               "arg_doc": "        arg:    calendar_genus_type (osid.type.Type): a calendar genus\n                type\n", 
               "return_doc": "        return: (osid.calendaring.CalendarList) - the returned\n                ``Calendar`` list", 
               "error_doc": "        raise:  NullArgument - ``calendar_genus_type`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param calendar_genus_type: a calendar genus type\n        :type calendar_genus_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "        :return: the returned ``Calendar`` list\n        :rtype: ``osid.calendaring.CalendarList``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``calendar_genus_type`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "calendar_genus_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "osid.calendaring.CalendarList", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_calendars_by_parent_genus_type", 
               "doc": {
                  "headline": "Gets a ``CalendarList`` corresponding to the given calendar genus ``Type`` and include any additional calendars with genus types derived from the specified ``Type``.", 
                  "body": "        In plenary mode, the returned list contains all known calendars\n        or an error results. Otherwise, the returned list may contain\n        only those calendars that are accessible through this session."
               }, 
               "arg_doc": "        arg:    calendar_genus_type (osid.type.Type): a calendar genus\n                type\n", 
               "return_doc": "        return: (osid.calendaring.CalendarList) - the returned\n                ``Calendar`` list", 
               "error_doc": "        raise:  NullArgument - ``calendar_genus_type`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param calendar_genus_type: a calendar genus type\n        :type calendar_genus_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "        :return: the returned ``Calendar`` list\n        :rtype: ``osid.calendaring.CalendarList``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``calendar_genus_type`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "calendar_genus_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "osid.calendaring.CalendarList", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_calendars_by_record_type", 
               "doc": {
                  "headline": "Gets a ``CalendarList`` containing the given calendar record ``Type``.", 
                  "body": "        In plenary mode, the returned list contains all known calendars\n        or an error results. Otherwise, the returned list may contain\n        only those calendars that are accessible through this session."
               }, 
               "arg_doc": "        arg:    calendar_record_type (osid.type.Type): a calendar record\n                type\n", 
               "return_doc": "        return: (osid.calendaring.CalendarList) - the returned\n                ``Calendar`` list", 
               "error_doc": "        raise:  NullArgument - ``calendar_record_type`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param calendar_record_type: a calendar record type\n        :type calendar_record_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "        :return: the returned ``Calendar`` list\n        :rtype: ``osid.calendaring.CalendarList``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``calendar_record_type`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "calendar_record_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "osid.calendaring.CalendarList", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_calendars_by_provider", 
               "doc": {
                  "headline": "Gets a ``CalendarList`` for the given provider.", 
                  "body": "        In plenary mode, the returned list contains all known calendars\n        or an error results. Otherwise, the returned list may contain\n        only those calendars that are accessible through this session."
               }, 
               "arg_doc": "        arg:    resource_id (osid.id.Id): a resource ``Id``\n", 
               "return_doc": "        return: (osid.calendaring.CalendarList) - the returned\n                ``Calendar`` list", 
               "error_doc": "        raise:  NullArgument - ``resource_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param resource_id: a resource ``Id``\n        :type resource_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: the returned ``Calendar`` list\n        :rtype: ``osid.calendaring.CalendarList``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``resource_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "resource_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "osid.calendaring.CalendarList", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_calendars", 
               "doc": {
                  "headline": "Gets all ``Calendars``.", 
                  "body": "        In plenary mode, the returned list contains all known calendars\n        or an error results. Otherwise, the returned list may contain\n        only those calendars that are accessible through this session."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.CalendarList) - a ``CalendarList``", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: a ``CalendarList``\n        :rtype: ``osid.calendaring.CalendarList``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.CalendarList", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.calendaring.CalendarQuerySession", 
         "shortname": "CalendarQuerySession", 
         "category": "sessions", 
         "doc": {
            "headline": "This session provides methods for searching among ``Calendar`` objects.", 
            "body": "    The search query is constructed using the ``CalendarQuery``.\n\n    Calendars may have a query record indicated by their respective\n    record types. The query record is accessed via the\n    ``CalendarQuery``."
         }, 
         "inherit_fullnames": [
            "osid.OsidSession"
         ], 
         "inherit_shortnames": [
            "OsidSession"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidSession"
            }
         ], 
         "method_names": [
            "can_search_calendars", 
            "get_calendar_query", 
            "get_calendars_by_query"
         ], 
         "methods": [
            {
               "name": "can_search_calendars", 
               "doc": {
                  "headline": "Tests if this user can perform ``Calendar`` searches.", 
                  "body": "        A return of true does not guarantee successful authorization. A\n        return of false indicates that it is known all methods in this\n        session will result in a ``PermissionDenied``. This is intended\n        as a hint to an application that may opt not to offer search\n        operations to unauthorized users."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``false`` if search methods are not\n                authorized, ``true`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``false`` if search methods are not authorized, ``true`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "get_calendar_query", 
               "doc": {
                  "headline": "Gets a calendar query.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.CalendarQuery) - a calendar query", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: a calendar query\n        :rtype: ``osid.calendaring.CalendarQuery``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.CalendarQuery", 
               "errors": {}
            }, 
            {
               "name": "get_calendars_by_query", 
               "doc": {
                  "headline": "Gets a list of ``Calendar`` objects matching the given calendar query.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    calendar_query (osid.calendaring.CalendarQuery): the\n                calendar query\n", 
               "return_doc": "        return: (osid.calendaring.CalendarList) - the returned\n                ``CalendarList``", 
               "error_doc": "        raise:  NullArgument - ``calendar_query`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        raise:  Unsupported - ``calendar_query`` is not of this service", 
               "sphinx_param_doc": "        :param calendar_query: the calendar query\n        :type calendar_query: ``osid.calendaring.CalendarQuery``\n", 
               "sphinx_return_doc": "        :return: the returned ``CalendarList``\n        :rtype: ``osid.calendaring.CalendarList``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``calendar_query`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure\n        :raise: ``Unsupported`` -- ``calendar_query`` is not of this service", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.calendaring.CalendarQuery", 
                     "var_name": "calendar_query", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.calendaring.CalendarQuery"
               ], 
               "return_type": "osid.calendaring.CalendarList", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.calendaring.CalendarSearchSession", 
         "shortname": "CalendarSearchSession", 
         "category": "sessions", 
         "doc": {
            "headline": "This session provides methods for searching among ``Calendar`` objects.", 
            "body": "    The search query is constructed using the ``CalendarQuery``.\n\n    ``get_calendars_by_query()`` is the basic search method and returns\n    a list of ``Calendar`` objects.A more advanced search may be\n    performed with ``getCalendarsBySearch()``. It accepts a\n    ``CalendarSearch`` in addition to the query for the purpose of\n    specifying additional options affecting the entire search, such as\n    ordering. ``get_calendars_by_search()`` returns a\n    ``CalendarSearchResults`` that can be used to access the resulting\n    ``CalendarList`` or be used to perform a search within the result\n    set through ``CalendarSearch``.\n    \n    Calendars may have a query record indicated by their respective\n    record types. The query record is accessed via the\n    ``CalendarQuery``."
         }, 
         "inherit_fullnames": [
            "osid.calendaring.CalendarQuerySession"
         ], 
         "inherit_shortnames": [
            "CalendarQuerySession"
         ], 
         "inherit_pkg_names": [
            "calendaring"
         ], 
         "inheritance": [
            {
               "pkg_name": "calendaring", 
               "name": "CalendarQuerySession"
            }
         ], 
         "method_names": [
            "can_search_calendars", 
            "get_calendar_search", 
            "get_calendar_search_order", 
            "get_calendars_by_search", 
            "get_calendar_query_from_inspector"
         ], 
         "methods": [
            {
               "name": "can_search_calendars", 
               "doc": {
                  "headline": "Tests if this user can perform ``Calendar`` searches.", 
                  "body": "        A return of true does not guarantee successful authorization. A\n        return of false indicates that it is known all methods in this\n        session will result in a ``PermissionDenied``. This is intended\n        as a hint to an application that may opt not to offer search\n        operations to unauthorized users."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``false`` if search methods are not\n                authorized, ``true`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``false`` if search methods are not authorized, ``true`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "get_calendar_search", 
               "doc": {
                  "headline": "Gets a calendar search.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.CalendarSearch) - a calendar search", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: a calendar search\n        :rtype: ``osid.calendaring.CalendarSearch``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.CalendarSearch", 
               "errors": {}
            }, 
            {
               "name": "get_calendar_search_order", 
               "doc": {
                  "headline": "Gets a calendar search order.", 
                  "body": "        The ``CalendarSearchOrder`` is supplied to a ``CalendarSearch``\n        to specify the ordering of results."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.CalendarSearchOrder) - the calendar\n                search order", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the calendar search order\n        :rtype: ``osid.calendaring.CalendarSearchOrder``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.CalendarSearchOrder", 
               "errors": {}
            }, 
            {
               "name": "get_calendars_by_search", 
               "doc": {
                  "headline": "Gets the search results matching the given search query using the given search.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    calendar_query (osid.calendaring.CalendarQuery): the\n                calendar query\n        arg:    calendar_search (osid.calendaring.CalendarSearch): the\n                calendar search\n", 
               "return_doc": "        return: (osid.calendaring.CalendarSearchResults) - the calendar\n                search results", 
               "error_doc": "        raise:  NullArgument - ``calendar_query`` or ``calendar_search``\n                is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        raise:  Unsupported - ``calendar_query`` or ``calendar_search``\n                is not of this service", 
               "sphinx_param_doc": "        :param calendar_query: the calendar query\n        :type calendar_query: ``osid.calendaring.CalendarQuery``\n        :param calendar_search: the calendar search\n        :type calendar_search: ``osid.calendaring.CalendarSearch``\n", 
               "sphinx_return_doc": "        :return: the calendar search results\n        :rtype: ``osid.calendaring.CalendarSearchResults``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``calendar_query`` or ``calendar_search`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure\n        :raise: ``Unsupported`` -- ``calendar_query`` or ``calendar_search`` is not of this service", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.calendaring.CalendarQuery", 
                     "var_name": "calendar_query", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.calendaring.CalendarSearch", 
                     "var_name": "calendar_search", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.calendaring.CalendarQuery", 
                  "osid.calendaring.CalendarSearch"
               ], 
               "return_type": "osid.calendaring.CalendarSearchResults", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_calendar_query_from_inspector", 
               "doc": {
                  "headline": "Gets a calendar query from an inspector.", 
                  "body": "        The inspector is available from an ``CalendarSearchResults``."
               }, 
               "arg_doc": "        arg:    calendar_query_inspector\n                (osid.calendaring.CalendarQueryInspector): a calendar\n                query inspector\n", 
               "return_doc": "        return: (osid.calendaring.CalendarQuery) - the calendar query", 
               "error_doc": "        raise:  NullArgument - ``calendar_query_inspector`` is ``null``\n        raise:  Unsupported - ``calendar_query_inspector`` is not of\n                this service", 
               "sphinx_param_doc": "        :param calendar_query_inspector: a calendar query inspector\n        :type calendar_query_inspector: ``osid.calendaring.CalendarQueryInspector``\n", 
               "sphinx_return_doc": "        :return: the calendar query\n        :rtype: ``osid.calendaring.CalendarQuery``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``calendar_query_inspector`` is ``null``\n        :raise: ``Unsupported`` -- ``calendar_query_inspector`` is not of this service", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.calendaring.CalendarQueryInspector", 
                     "var_name": "calendar_query_inspector", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.calendaring.CalendarQueryInspector"
               ], 
               "return_type": "osid.calendaring.CalendarQuery", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.calendaring.CalendarAdminSession", 
         "shortname": "CalendarAdminSession", 
         "category": "sessions", 
         "doc": {
            "headline": "This session creates, updates, and deletes ``Calendars``.", 
            "body": "    The data for create and update is provided by the consumer via the\n    form object. ``OsidForms`` are requested for each create or update\n    and may not be reused.\n\n    Create and update operations differ in their usage. To create a\n    ``Calendar,`` a ``CalendarForm`` is requested using\n    ``get_calendar_form_for_create()`` specifying the desired record\n    ``Types`` or none if no record ``Types`` are needed. The returned\n    ``CalendarForm`` will indicate that it is to be used with a create\n    operation and can be used to examine metdata or validate data prior\n    to creation. Once the ``CalendarForm`` is submiited to a create\n    operation, it cannot be reused with another create operation unless\n    the first operation was unsuccessful. Each ``CalendarForm``\n    corresponds to an attempted transaction.\n    \n    For updates, ``CalendarForms`` are requested to the ``Calendar``\n    ``Id`` that is to be updated using ``getCalendarFormForUpdate()``.\n    Similarly, the ``CalendarForm`` has metadata about the data that can\n    be updated and it can perform validation before submitting the\n    update. The ``Calendar`` can only be used once for a successful\n    update and cannot be reused.\n    \n    The delete operations delete ``Calendars``. This session also\n    includes an ``Id`` aliasing mechanism to assign an external ``Id``\n    to an internally assigned Id."
         }, 
         "inherit_fullnames": [
            "osid.OsidSession"
         ], 
         "inherit_shortnames": [
            "OsidSession"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidSession"
            }
         ], 
         "method_names": [
            "can_create_calendars", 
            "can_create_calendar_with_record_types", 
            "get_calendar_form_for_create", 
            "create_calendar", 
            "can_update_calendars", 
            "get_calendar_form_for_update", 
            "update_calendar", 
            "can_delete_calendars", 
            "delete_calendar", 
            "can_manage_calendar_aliases", 
            "alias_calendar"
         ], 
         "methods": [
            {
               "name": "can_create_calendars", 
               "doc": {
                  "headline": "Tests if this user can create ``Calendars``.", 
                  "body": "        A return of true does not guarantee successful authorization. A\n        return of false indicates that it is known creating a\n        ``Calendar`` will result in a ``PermissionDenied``. This is\n        intended as a hint to an application that may not wish to offer\n        create operations to unauthorized users."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``false`` if ``Calendar`` creation is not\n                authorized, ``true`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``false`` if ``Calendar`` creation is not authorized, ``true`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "can_create_calendar_with_record_types", 
               "doc": {
                  "headline": "Tests if this user can create a single ``Calendar`` using the desired record types.", 
                  "body": "        While ``CalendaringManager.getCalendarRecordTypes()`` can be\n        used to examine which records are supported, this method tests\n        which record(s) are required for creating a specific\n        ``Calendar``. Providing an empty array tests if a ``Calendar``\n        can be created with no records."
               }, 
               "arg_doc": "        arg:    calendar_record_types (osid.type.Type[]): array of\n                calendar record types\n", 
               "return_doc": "        return: (boolean) - ``true`` if ``Calendar`` creation using the\n                specified ``Types`` is supported, ``false`` otherwise", 
               "error_doc": "        raise:  NullArgument - ``calendar_record_types`` is ``null``", 
               "sphinx_param_doc": "        :param calendar_record_types: array of calendar record types\n        :type calendar_record_types: ``osid.type.Type[]``\n", 
               "sphinx_return_doc": "        :return: ``true`` if ``Calendar`` creation using the specified ``Types`` is supported, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``calendar_record_types`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type[]", 
                     "var_name": "calendar_record_types", 
                     "array": true
                  }
               ], 
               "arg_types": [
                  "osid.type.Type[]"
               ], 
               "return_type": "boolean", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "get_calendar_form_for_create", 
               "doc": {
                  "headline": "Gets the calendar form for creating new calendars.", 
                  "body": "        A new form should be requested for each create transaction."
               }, 
               "arg_doc": "        arg:    calendar_record_types (osid.type.Type[]): array of\n                calendar record types\n", 
               "return_doc": "        return: (osid.calendaring.CalendarForm) - the calendar form", 
               "error_doc": "        raise:  NullArgument - ``calendar_record_types`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        raise:  Unsupported - unable to get form for requested record\n                types", 
               "sphinx_param_doc": "        :param calendar_record_types: array of calendar record types\n        :type calendar_record_types: ``osid.type.Type[]``\n", 
               "sphinx_return_doc": "        :return: the calendar form\n        :rtype: ``osid.calendaring.CalendarForm``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``calendar_record_types`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure\n        :raise: ``Unsupported`` -- unable to get form for requested record types", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type[]", 
                     "var_name": "calendar_record_types", 
                     "array": true
                  }
               ], 
               "arg_types": [
                  "osid.type.Type[]"
               ], 
               "return_type": "osid.calendaring.CalendarForm", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }, 
            {
               "name": "create_calendar", 
               "doc": {
                  "headline": "Creates a new ``Calendar``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    calendar_form (osid.calendaring.CalendarForm): the form\n                for this ``Calendar``\n", 
               "return_doc": "        return: (osid.calendaring.CalendarForm) - the new ``Calendar``", 
               "error_doc": "        raise:  IllegalState - ``calendar_form`` already used for a\n                create transaction\n        raise:  InvalidArgument - one or more of the form elements is\n                invalid\n        raise:  NullArgument - ``calendar_form`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        raise:  Unsupported - ``calendar_form`` did not originate from\n                ``get_calendar_form_for_create()``", 
               "sphinx_param_doc": "        :param calendar_form: the form for this ``Calendar``\n        :type calendar_form: ``osid.calendaring.CalendarForm``\n", 
               "sphinx_return_doc": "        :return: the new ``Calendar``\n        :rtype: ``osid.calendaring.CalendarForm``", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- ``calendar_form`` already used for a create transaction\n        :raise: ``InvalidArgument`` -- one or more of the form elements is invalid\n        :raise: ``NullArgument`` -- ``calendar_form`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure\n        :raise: ``Unsupported`` -- ``calendar_form`` did not originate from ``get_calendar_form_for_create()``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.calendaring.CalendarForm", 
                     "var_name": "calendar_form", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.calendaring.CalendarForm"
               ], 
               "return_type": "osid.calendaring.CalendarForm", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract", 
                  "INVALID_ARGUMENT": "ConsumerContract", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }, 
            {
               "name": "can_update_calendars", 
               "doc": {
                  "headline": "Tests if this user can update ``Calendars``.", 
                  "body": "        A return of true does not guarantee successful authorization. A\n        return of false indicates that it is known updating a\n        ``Calendar`` will result in a ``PermissionDenied``. This is\n        intended as a hint to an application that may not wish to offer\n        update operations to unauthorized users."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``false`` if ``Calendar`` modification is\n                not authorized, ``true`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``false`` if ``Calendar`` modification is not authorized, ``true`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "get_calendar_form_for_update", 
               "doc": {
                  "headline": "Gets the calendar form for updating an existing calendar.", 
                  "body": "        A new calendar form should be requested for each update\n        transaction."
               }, 
               "arg_doc": "        arg:    calendar_id (osid.id.Id): the ``Id`` of the ``Calendar``\n", 
               "return_doc": "        return: (osid.calendaring.CalendarForm) - the calendar form", 
               "error_doc": "        raise:  NotFound - ``calendar_id`` is not found\n        raise:  NullArgument - ``calendar_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param calendar_id: the ``Id`` of the ``Calendar``\n        :type calendar_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: the calendar form\n        :rtype: ``osid.calendaring.CalendarForm``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``calendar_id`` is not found\n        :raise: ``NullArgument`` -- ``calendar_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "calendar_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "osid.calendaring.CalendarForm", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "update_calendar", 
               "doc": {
                  "headline": "Updates an existing calendar.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    calendar_form (osid.calendaring.CalendarForm): the form\n                containing the elements to be updated\n", 
               "return_doc": "", 
               "error_doc": "        raise:  IllegalState - ``calendar_form`` already used for an\n                update transaction\n        raise:  InvalidArgument - the form contains an invalid value\n        raise:  NullArgument - ``calendar_form`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure\n        raise:  Unsupported - ``calendar_form`` did not originate from\n                ``get_calendar_form_for_update()``", 
               "sphinx_param_doc": "        :param calendar_form: the form containing the elements to be updated\n        :type calendar_form: ``osid.calendaring.CalendarForm``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- ``calendar_form`` already used for an update transaction\n        :raise: ``InvalidArgument`` -- the form contains an invalid value\n        :raise: ``NullArgument`` -- ``calendar_form`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure\n        :raise: ``Unsupported`` -- ``calendar_form`` did not originate from ``get_calendar_form_for_update()``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.calendaring.CalendarForm", 
                     "var_name": "calendar_form", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.calendaring.CalendarForm"
               ], 
               "return_type": "", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract", 
                  "INVALID_ARGUMENT": "ConsumerContract", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }, 
            {
               "name": "can_delete_calendars", 
               "doc": {
                  "headline": "Tests if this user can delete calendars.", 
                  "body": "        A return of true does not guarantee successful authorization. A\n        return of false indicates that it is known deleting a\n        ``Calendar`` will result in a ``PermissionDenied``. This is\n        intended as a hint to an application that may not wish to offer\n        delete operations to unauthorized users."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``false`` if ``Calendar`` deletion is not\n                authorized, ``true`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``false`` if ``Calendar`` deletion is not authorized, ``true`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "delete_calendar", 
               "doc": {
                  "headline": "Deletes a ``Calendar``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    calendar_id (osid.id.Id): the ``Id`` of the ``Calendar``\n                to remove\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NotFound - ``calendar_id`` not found\n        raise:  NullArgument - ``calendar_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param calendar_id: the ``Id`` of the ``Calendar`` to remove\n        :type calendar_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``calendar_id`` not found\n        :raise: ``NullArgument`` -- ``calendar_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "calendar_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "can_manage_calendar_aliases", 
               "doc": {
                  "headline": "Tests if this user can manage ``Id`` aliases for ``Calendars``.", 
                  "body": "        A return of true does not guarantee successful authorization. A\n        return of false indicates that it is known changing an alias\n        will result in a ``PermissionDenied``. This is intended as a\n        hint to an application that may opt not to offer alias\n        operations to an unauthorized user."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``false`` if ``Calendar`` aliasing is not\n                authorized, ``true`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``false`` if ``Calendar`` aliasing is not authorized, ``true`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "alias_calendar", 
               "doc": {
                  "headline": "Adds an ``Id`` to a ``Calendar`` for the purpose of creating compatibility.", 
                  "body": "        The primary ``Id`` of the ``Calendar`` is determined by the\n        provider. The new ``Id`` performs as an alias to the primary\n        ``Id``. If the alias is a pointer to another calendar, it is\n        reassigned to the given calendar ``Id``."
               }, 
               "arg_doc": "        arg:    calendar_id (osid.id.Id): the ``Id`` of a ``Calendar``\n        arg:    alias_id (osid.id.Id): the alias ``Id``\n", 
               "return_doc": "", 
               "error_doc": "        raise:  AlreadyExists - ``alias_id`` is already assigned\n        raise:  NotFound - ``calendar_id`` not found\n        raise:  NullArgument - ``calendar_id`` or ``alias_id`` is\n                ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param calendar_id: the ``Id`` of a ``Calendar``\n        :type calendar_id: ``osid.id.Id``\n        :param alias_id: the alias ``Id``\n        :type alias_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``AlreadyExists`` -- ``alias_id`` is already assigned\n        :raise: ``NotFound`` -- ``calendar_id`` not found\n        :raise: ``NullArgument`` -- ``calendar_id`` or ``alias_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "calendar_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "alias_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {
                  "ALREADY_EXISTS": "User", 
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.calendaring.CalendarNotificationSession", 
         "shortname": "CalendarNotificationSession", 
         "category": "sessions", 
         "doc": {
            "headline": "This session defines methods to receive notifications on adds/changes to ``Calendar`` objects.", 
            "body": "    This session is intended for consumers needing to synchronize their\n    state with this service without the use of polling. Notifications\n    are cancelled when this session i"
         }, 
         "inherit_fullnames": [
            "osid.OsidSession"
         ], 
         "inherit_shortnames": [
            "OsidSession"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidSession"
            }
         ], 
         "method_names": [
            "can_register_for_calendar_notifications", 
            "register_for_new_calendars", 
            "register_for_new_calendar_ancestors", 
            "register_for_new_calendar_descendants", 
            "register_for_changed_calendars", 
            "register_for_changed_calendar", 
            "register_for_deleted_calendars", 
            "register_for_deleted_calendar", 
            "register_for_deleted_calendar_ancestors", 
            "register_for_deleted_calendar_descendants"
         ], 
         "methods": [
            {
               "name": "can_register_for_calendar_notifications", 
               "doc": {
                  "headline": "Tests if this user can register for ``Calendar`` notifications.", 
                  "body": "        A return of true does not guarantee successful authorization. A\n        return of false indicates that it is known all methods in this\n        session will result in a ``PermissionDenied``. This is intended\n        as a hint to an application that may opt not to offer\n        notification operations."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``false`` if notification methods are not\n                authorized, ``true`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``false`` if notification methods are not authorized, ``true`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "register_for_new_calendars", 
               "doc": {
                  "headline": "Register for notifications of new calendars.", 
                  "body": "        ``CalendarReceiver.newCalendar()`` is invoked when a new\n        ``Calendar`` is created."
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "register_for_new_calendar_ancestors", 
               "doc": {
                  "headline": "Registers for notification if an ancestor is added to the specified calendar in the calendar hierarchy.", 
                  "body": "        ``CalendarReceiver.newCalendarAncestor()`` is invoked when the\n        specified calendar experiences an addition in ancestry."
               }, 
               "arg_doc": "        arg:    calendar_id (osid.id.Id): the ``Id`` of the calendar to\n                monitor\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``calendar_id is null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param calendar_id: the ``Id`` of the calendar to monitor\n        :type calendar_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``calendar_id is null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "calendar_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "register_for_new_calendar_descendants", 
               "doc": {
                  "headline": "Registers for notification if a descendant is added to the specified calendar in the calendar hierarchy.", 
                  "body": "        ``CalendarReceiver.newCalendarDescendant()`` is invoked when the\n        specified calendar experiences an addition in descendants."
               }, 
               "arg_doc": "        arg:    calendar_id (osid.id.Id): the ``Id`` of the calendar to\n                monitor\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``calendar_id is null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param calendar_id: the ``Id`` of the calendar to monitor\n        :type calendar_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``calendar_id is null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "calendar_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "register_for_changed_calendars", 
               "doc": {
                  "headline": "Registers for notification of updated calendars.", 
                  "body": "        ``CalendarReceiver.changedCalendar()`` is invoked when a\n        calendar is changed."
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "register_for_changed_calendar", 
               "doc": {
                  "headline": "Registers for notification of an updated calendar.", 
                  "body": "        ``CalendarReceiver.changedCalendar()`` is invoked when the\n        specified calendar is changed."
               }, 
               "arg_doc": "        arg:    calendar_id (osid.id.Id): the ``Id`` of the calendar to\n                monitor\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``calendar_id is null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param calendar_id: the ``Id`` of the calendar to monitor\n        :type calendar_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``calendar_id is null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "calendar_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "register_for_deleted_calendars", 
               "doc": {
                  "headline": "Registers for notification of deleted calendars.", 
                  "body": "        ``CalendarReceiver.deletedCalendar()`` is invoked when a\n        calenedar is deleted."
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "register_for_deleted_calendar", 
               "doc": {
                  "headline": "Registers for notification of a deleted calendar.", 
                  "body": "        ``CalendarReceiver.deletedCalendar()`` is invoked when the\n        specified calendar is deleted."
               }, 
               "arg_doc": "        arg:    calendar_id (osid.id.Id): the ``Id`` of the calendar to\n                monitor\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``calendar_id is null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param calendar_id: the ``Id`` of the calendar to monitor\n        :type calendar_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``calendar_id is null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "calendar_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "register_for_deleted_calendar_ancestors", 
               "doc": {
                  "headline": "Registers for notification if an ancestor is removed from the specified calendar in the calendar hierarchy.", 
                  "body": "        ``CalendarReceiver.deletedCalendarAncestor()`` is invoked when\n        the specified calendar experiences a removal of an ancestor."
               }, 
               "arg_doc": "        arg:    calendar_id (osid.id.Id): the ``Id`` of the calendar to\n                monitor\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``calendar_id is null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param calendar_id: the ``Id`` of the calendar to monitor\n        :type calendar_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``calendar_id is null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "calendar_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "register_for_deleted_calendar_descendants", 
               "doc": {
                  "headline": "Registers for notification if a descendant is removed from fthe specified calendar in the calendar hierarchy.", 
                  "body": "        ``CalendarReceiver.deletedCalendarDescednant()`` is invoked when\n        the specified calendar experiences a removal of one of its\n        descendants."
               }, 
               "arg_doc": "        arg:    calendar_id (osid.id.Id): the ``Id`` of the calendar to\n                monitor\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``calendar_id is null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param calendar_id: the ``Id`` of the calendar to monitor\n        :type calendar_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``calendar_id is null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "calendar_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.calendaring.CalendarHierarchySession", 
         "shortname": "CalendarHierarchySession", 
         "category": "sessions", 
         "doc": {
            "headline": "This session defines methods for traversing a hierarchy of ``Calendar`` objects.", 
            "body": "    Each node in the hierarchy is a unique ``Calendar``. The hierarchy\n    may be traversed recursively to establish the tree structure through\n    ``get_parent_calendars()`` and ``getChildCalendars()``. To relate\n    these ``Ids`` to another OSID, ``get_calendar_nodes()`` can be used\n    for retrievals that can be used for bulk lookups in other OSIDs. Any\n    ``Calendar`` available in the Calendaring OSID is known to this\n    hierarchy but does not appear in the hierarchy traversal until added\n    as a root node or a child of another node.\n\n    A user may not be authorized to traverse the entire hierarchy. Parts\n    of the hierarchy may be made invisible through omission from the\n    returns of ``get_parent_calendars()`` or ``get_child_calendars()``\n    in lieu of a ``PermissionDenied`` error that may disrupt the\n    traversal through authorized pathways.\n    \n    This session defines views that offer differing behaviors when\n    retrieving multiple objects.\n    \n      * comparative view: calendar elements may be silently omitted or\n        re-ordered\n      * plenary view: provides a complete set or is an error condition\n"
         }, 
         "inherit_fullnames": [
            "osid.OsidSession"
         ], 
         "inherit_shortnames": [
            "OsidSession"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidSession"
            }
         ], 
         "method_names": [
            "get_calendar_hierarchy_id", 
            "get_calendar_hierarchy", 
            "can_access_calendar_hierarchy", 
            "use_comparative_calendar_view", 
            "use_plenary_calendar_view", 
            "get_root_calendar_ids", 
            "get_root_calendars", 
            "has_parent_calendars", 
            "is_parent_of_calendar", 
            "get_parent_calendar_ids", 
            "get_parent_calendars", 
            "is_ancestor_of_calendar", 
            "has_child_calendars", 
            "is_child_of_calendar", 
            "get_child_calendar_ids", 
            "get_child_calendars", 
            "is_descendant_of_calendar", 
            "get_calendar_node_ids", 
            "get_calendar_nodes"
         ], 
         "methods": [
            {
               "name": "get_calendar_hierarchy_id", 
               "doc": {
                  "headline": "Gets the hierarchy ``Id`` associated with this session.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.id.Id) - the hierarchy ``Id`` associated with this\n                session", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the hierarchy ``Id`` associated with this session\n        :rtype: ``osid.id.Id``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.id.Id", 
               "errors": {}
            }, 
            {
               "name": "get_calendar_hierarchy", 
               "doc": {
                  "headline": "Gets the hierarchy associated with this session.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.hierarchy.Hierarchy) - the hierarchy associated\n                with this session", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the hierarchy associated with this session\n        :rtype: ``osid.hierarchy.Hierarchy``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.hierarchy.Hierarchy", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "can_access_calendar_hierarchy", 
               "doc": {
                  "headline": "Tests if this user can perform hierarchy queries.", 
                  "body": "        A return of true does not guarantee successful authorization. A\n        return of false indicates that it is known all methods in this\n        session will result in a ``PermissionDenied``. This is intended\n        as a hint to an an application that may not offer traversal\n        functions to unauthorized users."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``false`` if hierarchy traversal methods are\n                not authorized, ``true`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``false`` if hierarchy traversal methods are not authorized, ``true`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "use_comparative_calendar_view", 
               "doc": {
                  "headline": "The returns from the calendar methods may omit or translate elements based on this session, such as authorization, and not result in an error.", 
                  "body": "        This view is used when greater interoperability is desired at\n        the expense of precision."
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "use_plenary_calendar_view", 
               "doc": {
                  "headline": "A complete view of the ``Hierarchy`` returns is desired.", 
                  "body": "        Methods will return what is requested or result in an error.\n        This view is used when greater precision is desired at the\n        expense of interoperability."
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "get_root_calendar_ids", 
               "doc": {
                  "headline": "Gets the root calendar ``Ids`` in this hierarchy.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.id.IdList) - the root calendar ``Ids``", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the root calendar ``Ids``\n        :rtype: ``osid.id.IdList``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.id.IdList", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_root_calendars", 
               "doc": {
                  "headline": "Gets the root calendars in this calendar hierarchy.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.CalendarList) - the root calendars", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the root calendars\n        :rtype: ``osid.calendaring.CalendarList``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method is must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.CalendarList", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "has_parent_calendars", 
               "doc": {
                  "headline": "Tests if the ``Calendar`` has any parents.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    calendar_id (osid.id.Id): the ``Id`` of a calendar\n", 
               "return_doc": "        return: (boolean) - ``true`` if the calendar has parents,\n                ``false`` otherwise", 
               "error_doc": "        raise:  NotFound - ``calendar_id`` is not found\n        raise:  NullArgument - ``calendar_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param calendar_id: the ``Id`` of a calendar\n        :type calendar_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: ``true`` if the calendar has parents, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``calendar_id`` is not found\n        :raise: ``NullArgument`` -- ``calendar_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "calendar_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "boolean", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "is_parent_of_calendar", 
               "doc": {
                  "headline": "Tests if an ``Id`` is a direct parent of a calendar.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    id (osid.id.Id): an ``Id``\n        arg:    calendar_id (osid.id.Id): the ``Id`` of a calendar\n", 
               "return_doc": "        return: (boolean) - ``true`` if this ``id`` is a parent of\n                ``calendar_id,``  ``false`` otherwise", 
               "error_doc": "        raise:  NotFound - ``calendar_id`` is not found\n        raise:  NullArgument - ``id`` or ``calendar_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param id: an ``Id``\n        :type id: ``osid.id.Id``\n        :param calendar_id: the ``Id`` of a calendar\n        :type calendar_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: ``true`` if this ``id`` is a parent of ``calendar_id,``  ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``calendar_id`` is not found\n        :raise: ``NullArgument`` -- ``id`` or ``calendar_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "        *implementation notes*: If ``id`` not found return ``false``.\n", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "id_", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "calendar_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "osid.id.Id"
               ], 
               "return_type": "boolean", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_parent_calendar_ids", 
               "doc": {
                  "headline": "Gets the parent ``Ids`` of the given calendar.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    calendar_id (osid.id.Id): the ``Id`` of a calendar\n", 
               "return_doc": "        return: (osid.id.IdList) - the parent ``Ids`` of the calendar", 
               "error_doc": "        raise:  NotFound - ``calendar_id`` is not found\n        raise:  NullArgument - ``calendar_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param calendar_id: the ``Id`` of a calendar\n        :type calendar_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: the parent ``Ids`` of the calendar\n        :rtype: ``osid.id.IdList``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``calendar_id`` is not found\n        :raise: ``NullArgument`` -- ``calendar_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "calendar_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "osid.id.IdList", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_parent_calendars", 
               "doc": {
                  "headline": "Gets the parents of the given calendar.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    calendar_id (osid.id.Id): the ``Id`` of a calendar\n", 
               "return_doc": "        return: (osid.calendaring.CalendarList) - the parents of the\n                calendar", 
               "error_doc": "        raise:  NotFound - ``calendar_id`` is not found\n        raise:  NullArgument - ``calendar_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param calendar_id: the ``Id`` of a calendar\n        :type calendar_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: the parents of the calendar\n        :rtype: ``osid.calendaring.CalendarList``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``calendar_id`` is not found\n        :raise: ``NullArgument`` -- ``calendar_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "calendar_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "osid.calendaring.CalendarList", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "is_ancestor_of_calendar", 
               "doc": {
                  "headline": "Tests if an ``Id`` is an ancestor of a calendar.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    id (osid.id.Id): an ``Id``\n        arg:    calendar_id (osid.id.Id): the ``Id`` of a calendar\n", 
               "return_doc": "        return: (boolean) - ``true`` if this ``id`` is an ancestor of\n                ``calendar_id,``  ``false`` otherwise", 
               "error_doc": "        raise:  NotFound - ``calendar_id`` is not found\n        raise:  NullArgument - ``id`` or ``calendar_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param id: an ``Id``\n        :type id: ``osid.id.Id``\n        :param calendar_id: the ``Id`` of a calendar\n        :type calendar_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: ``true`` if this ``id`` is an ancestor of ``calendar_id,``  ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``calendar_id`` is not found\n        :raise: ``NullArgument`` -- ``id`` or ``calendar_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "        *implementation notes*: If ``id`` not found return ``false``.\n", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "id_", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "calendar_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "osid.id.Id"
               ], 
               "return_type": "boolean", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "has_child_calendars", 
               "doc": {
                  "headline": "Tests if a calendar has any children.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    calendar_id (osid.id.Id): the ``Id`` of a calendar\n", 
               "return_doc": "        return: (boolean) - ``true`` if the ``calendar_id`` has\n                children, ``false`` otherwise", 
               "error_doc": "        raise:  NotFound - ``calendar_id`` is not found\n        raise:  NullArgument - ``calendar_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param calendar_id: the ``Id`` of a calendar\n        :type calendar_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: ``true`` if the ``calendar_id`` has children, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``calendar_id`` is not found\n        :raise: ``NullArgument`` -- ``calendar_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "calendar_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "boolean", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "is_child_of_calendar", 
               "doc": {
                  "headline": "Tests if a calendar is a direct child of another.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    id (osid.id.Id): an ``Id``\n        arg:    calendar_id (osid.id.Id): the ``Id`` of a calendar\n", 
               "return_doc": "        return: (boolean) - ``true`` if the ``id`` is a child of\n                ``calendar_id,``  ``false`` otherwise", 
               "error_doc": "        raise:  NotFound - ``calendar_id`` is not found\n        raise:  NullArgument - ``id`` or ``calendar_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param id: an ``Id``\n        :type id: ``osid.id.Id``\n        :param calendar_id: the ``Id`` of a calendar\n        :type calendar_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: ``true`` if the ``id`` is a child of ``calendar_id,``  ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``calendar_id`` is not found\n        :raise: ``NullArgument`` -- ``id`` or ``calendar_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "        *implementation notes*: If ``id`` not found return ``false``.\n", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "id_", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "calendar_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "osid.id.Id"
               ], 
               "return_type": "boolean", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_child_calendar_ids", 
               "doc": {
                  "headline": "Gets the child ``Ids`` of the given calendar.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    calendar_id (osid.id.Id): the ``Id`` to query\n", 
               "return_doc": "        return: (osid.id.IdList) - the children of the calendar", 
               "error_doc": "        raise:  NotFound - ``calendar_id`` is not found\n        raise:  NullArgument - ``calendar_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param calendar_id: the ``Id`` to query\n        :type calendar_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: the children of the calendar\n        :rtype: ``osid.id.IdList``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``calendar_id`` is not found\n        :raise: ``NullArgument`` -- ``calendar_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "calendar_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "osid.id.IdList", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_child_calendars", 
               "doc": {
                  "headline": "Gets the children of the given calendar.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    calendar_id (osid.id.Id): the ``Id`` to query\n", 
               "return_doc": "        return: (osid.calendaring.CalendarList) - the children of the\n                calendar", 
               "error_doc": "        raise:  NotFound - ``calendar_id`` is not found\n        raise:  NullArgument - ``calendar_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param calendar_id: the ``Id`` to query\n        :type calendar_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: the children of the calendar\n        :rtype: ``osid.calendaring.CalendarList``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``calendar_id`` is not found\n        :raise: ``NullArgument`` -- ``calendar_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "calendar_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "osid.calendaring.CalendarList", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "is_descendant_of_calendar", 
               "doc": {
                  "headline": "Tests if an ``Id`` is a descendant of a calendar.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    id (osid.id.Id): an ``Id``\n        arg:    calendar_id (osid.id.Id): the ``Id`` of a calendar\n", 
               "return_doc": "        return: (boolean) - ``true`` if the ``id`` is a descendant of\n                the ``calendar_id,`` ``false`` otherwise", 
               "error_doc": "        raise:  NotFound - ``calendar_id`` is not found\n        raise:  NullArgument - ``id`` or ``calendar_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param id: an ``Id``\n        :type id: ``osid.id.Id``\n        :param calendar_id: the ``Id`` of a calendar\n        :type calendar_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "        :return: ``true`` if the ``id`` is a descendant of the ``calendar_id,``  ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``calendar_id`` is not found\n        :raise: ``NullArgument`` -- ``id`` or ``calendar_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "        *implementation notes*: If ``id`` is not found return ``false``.\n", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "id_", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "calendar_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "osid.id.Id"
               ], 
               "return_type": "boolean", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_calendar_node_ids", 
               "doc": {
                  "headline": "Gets a portion of the hierarchy for the given calendar.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    calendar_id (osid.id.Id): the ``Id`` to query\n        arg:    ancestor_levels (cardinal): the maximum number of\n                ancestor levels to include. A value of 0 returns no\n                parents in the node.\n        arg:    descendant_levels (cardinal): the maximum number of\n                descendant levels to include. A value of 0 returns no\n                children in the node.\n        arg:    include_siblings (boolean): ``true`` to include the\n                siblings of the given node, ``false`` to omit the\n                siblings\n", 
               "return_doc": "        return: (osid.hierarchy.Node) - a catalog node", 
               "error_doc": "        raise:  NotFound - ``calendar_id`` not found\n        raise:  NullArgument - ``calendar_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param calendar_id: the ``Id`` to query\n        :type calendar_id: ``osid.id.Id``\n        :param ancestor_levels: the maximum number of ancestor levels to include. A value of 0 returns no parents in the node.\n        :type ancestor_levels: ``cardinal``\n        :param descendant_levels: the maximum number of descendant levels to include. A value of 0 returns no children in the node.\n        :type descendant_levels: ``cardinal``\n        :param include_siblings: ``true`` to include the siblings of the given node, ``false`` to omit the siblings\n        :type include_siblings: ``boolean``\n", 
               "sphinx_return_doc": "        :return: a catalog node\n        :rtype: ``osid.hierarchy.Node``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``calendar_id`` not found\n        :raise: ``NullArgument`` -- ``calendar_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "calendar_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "cardinal", 
                     "var_name": "ancestor_levels", 
                     "array": false
                  }, 
                  {
                     "arg_type": "cardinal", 
                     "var_name": "descendant_levels", 
                     "array": false
                  }, 
                  {
                     "arg_type": "boolean", 
                     "var_name": "include_siblings", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "cardinal", 
                  "cardinal", 
                  "boolean"
               ], 
               "return_type": "osid.hierarchy.Node", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "get_calendar_nodes", 
               "doc": {
                  "headline": "Gets a portion of the hierarchy for the given calendar.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    calendar_id (osid.id.Id): the ``Id`` to query\n        arg:    ancestor_levels (cardinal): the maximum number of\n                ancestor levels to include. A value of 0 returns no\n                parents in the node.\n        arg:    descendant_levels (cardinal): the maximum number of\n                descendant levels to include. A value of 0 returns no\n                children in the node.\n        arg:    include_siblings (boolean): ``true`` to include the\n                siblings of the given node, ``false`` to omit the\n                siblings\n", 
               "return_doc": "        return: (osid.calendaring.CalendarNode) - a calendar node", 
               "error_doc": "        raise:  NotFound - ``calendar_id`` not found\n        raise:  NullArgument - ``calendar_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param calendar_id: the ``Id`` to query\n        :type calendar_id: ``osid.id.Id``\n        :param ancestor_levels: the maximum number of ancestor levels to include. A value of 0 returns no parents in the node.\n        :type ancestor_levels: ``cardinal``\n        :param descendant_levels: the maximum number of descendant levels to include. A value of 0 returns no children in the node.\n        :type descendant_levels: ``cardinal``\n        :param include_siblings: ``true`` to include the siblings of the given node, ``false`` to omit the siblings\n        :type include_siblings: ``boolean``\n", 
               "sphinx_return_doc": "        :return: a calendar node\n        :rtype: ``osid.calendaring.CalendarNode``", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``calendar_id`` not found\n        :raise: ``NullArgument`` -- ``calendar_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "calendar_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "cardinal", 
                     "var_name": "ancestor_levels", 
                     "array": false
                  }, 
                  {
                     "arg_type": "cardinal", 
                     "var_name": "descendant_levels", 
                     "array": false
                  }, 
                  {
                     "arg_type": "boolean", 
                     "var_name": "include_siblings", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "cardinal", 
                  "cardinal", 
                  "boolean"
               ], 
               "return_type": "osid.calendaring.CalendarNode", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.calendaring.CalendarHierarchyDesignSession", 
         "shortname": "CalendarHierarchyDesignSession", 
         "category": "sessions", 
         "doc": {
            "headline": "This session defines methods for managing a hierarchy of ``Calendar`` objects.", 
            "body": "    Each node in the hierarchy is a unique ``Calendar``."
         }, 
         "inherit_fullnames": [
            "osid.OsidSession"
         ], 
         "inherit_shortnames": [
            "OsidSession"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidSession"
            }
         ], 
         "method_names": [
            "get_calendar_hierarchy_id", 
            "get_calendar_hierarchy", 
            "can_modify_calendar_hierarchy", 
            "add_root_calendar", 
            "remove_root_calendar", 
            "add_child_calendar", 
            "remove_child_calendar", 
            "remove_child_calendars"
         ], 
         "methods": [
            {
               "name": "get_calendar_hierarchy_id", 
               "doc": {
                  "headline": "Gets the hierarchy ``Id`` associated with this session.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.id.Id) - the hierarchy ``Id`` associated with this\n                session", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the hierarchy ``Id`` associated with this session\n        :rtype: ``osid.id.Id``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.id.Id", 
               "errors": {}
            }, 
            {
               "name": "get_calendar_hierarchy", 
               "doc": {
                  "headline": "Gets the hierarchy associated with this session.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.hierarchy.Hierarchy) - the hierarchy associated\n                with this session", 
               "error_doc": "        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the hierarchy associated with this session\n        :rtype: ``osid.hierarchy.Hierarchy``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.hierarchy.Hierarchy", 
               "errors": {
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "can_modify_calendar_hierarchy", 
               "doc": {
                  "headline": "Tests if this user can change the hierarchy.", 
                  "body": "        A return of true does not guarantee successful authorization. A\n        return of false indicates that it is known performing any update\n        will result in a ``PermissionDenied``. This is intended as a\n        hint to an application that may opt not to offer these\n        operations to an unauthorized user."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``false`` if changing this hierarchy is not\n                authorized, ``true`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``false`` if changing this hierarchy is not authorized, ``true`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "add_root_calendar", 
               "doc": {
                  "headline": "Adds a root calendar.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    calendar_id (osid.id.Id): the ``Id`` of a calendar\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NotFound - ``calendar_id`` not a root\n        raise:  NullArgument - ``calendar_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param calendar_id: the ``Id`` of a calendar\n        :type calendar_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``calendar_id`` not a root\n        :raise: ``NullArgument`` -- ``calendar_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "calendar_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "remove_root_calendar", 
               "doc": {
                  "headline": "Removes a root calendar from this hierarchy.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    calendar_id (osid.id.Id): the ``Id`` of a calendar\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NotFound - ``calendar_id`` not a parent of ``child_id``\n        raise:  NullArgument - ``calendar_id`` or ``child_id`` is\n                ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param calendar_id: the ``Id`` of a calendar\n        :type calendar_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``calendar_id`` not a parent of ``child_id``\n        :raise: ``NullArgument`` -- ``calendar_id`` or ``child_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "calendar_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "add_child_calendar", 
               "doc": {
                  "headline": "Adds a child to a calendar.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    calendar_id (osid.id.Id): the ``Id`` of a calendar\n        arg:    child_id (osid.id.Id): the ``Id`` of the new child\n", 
               "return_doc": "", 
               "error_doc": "        raise:  AlreadyExists - ``calendar_id`` is already a parent of\n                ``child_id``\n        raise:  NotFound - ``calendar_id`` or ``child_id`` not found\n        raise:  NullArgument - ``calendar_id`` or ``child_id`` is\n                ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param calendar_id: the ``Id`` of a calendar\n        :type calendar_id: ``osid.id.Id``\n        :param child_id: the ``Id`` of the new child\n        :type child_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``AlreadyExists`` -- ``calendar_id`` is already a parent of ``child_id``\n        :raise: ``NotFound`` -- ``calendar_id`` or ``child_id`` not found\n        :raise: ``NullArgument`` -- ``calendar_id`` or ``child_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "calendar_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "child_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {
                  "ALREADY_EXISTS": "User", 
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "remove_child_calendar", 
               "doc": {
                  "headline": "Removes a child from a calendar.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    calendar_id (osid.id.Id): the ``Id`` of a calendar\n        arg:    child_id (osid.id.Id): the ``Id`` of the new child\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NotFound - ``calendar_id`` not a parent of ``child_id``\n        raise:  NullArgument - ``calendar_id`` or ``child_id`` is\n                ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param calendar_id: the ``Id`` of a calendar\n        :type calendar_id: ``osid.id.Id``\n        :param child_id: the ``Id`` of the new child\n        :type child_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``calendar_id`` not a parent of ``child_id``\n        :raise: ``NullArgument`` -- ``calendar_id`` or ``child_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "calendar_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "child_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }, 
            {
               "name": "remove_child_calendars", 
               "doc": {
                  "headline": "Removes all children from a calendar.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    calendar_id (osid.id.Id): the ``Id`` of a calendar\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NotFound - ``calendar_id`` is in hierarchy\n        raise:  NullArgument - ``calendar_id`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  PermissionDenied - authorization failure", 
               "sphinx_param_doc": "        :param calendar_id: the ``Id`` of a calendar\n        :type calendar_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NotFound`` -- ``calendar_id`` is in hierarchy\n        :raise: ``NullArgument`` -- ``calendar_id`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``PermissionDenied`` -- authorization failure", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "calendar_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {
                  "NOT_FOUND": "User", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "PERMISSION_DENIED": "User"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.calendaring.Event", 
         "shortname": "Event", 
         "category": "objects", 
         "doc": {
            "headline": "An ``Event`` represents a span of time and an optional location.", 
            "body": ""
         }, 
         "inherit_fullnames": [
            "osid.OsidObject", 
            "osid.Temporal", 
            "osid.Containable"
         ], 
         "inherit_shortnames": [
            "OsidObject", 
            "Temporal", 
            "Containable"
         ], 
         "inherit_pkg_names": [
            "osid", 
            "osid", 
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidObject"
            }, 
            {
               "pkg_name": "osid", 
               "name": "Temporal"
            }, 
            {
               "pkg_name": "osid", 
               "name": "Containable"
            }
         ], 
         "method_names": [
            "is_implicit", 
            "is_in_recurring_series", 
            "is_superseding_event", 
            "is_offset_event", 
            "get_duration", 
            "get_location_description", 
            "has_location", 
            "get_location_id", 
            "get_location", 
            "has_sponsors", 
            "get_sponsor_ids", 
            "get_sponsors", 
            "get_event_record"
         ], 
         "methods": [
            {
               "name": "is_implicit", 
               "doc": {
                  "headline": "Tests if this event is implicit.", 
                  "body": "        An implicit event is one that is generated from an offset or\n        recurring series."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if this event is implicit,\n                ``false`` if explicitly defined", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if this event is implicit, ``false`` if explicitly defined\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "is_in_recurring_series", 
               "doc": {
                  "headline": "Tests if this event is an implclit event part of a recurring event.", 
                  "body": "        If true, ``is_implicit()`` must also be true."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if this event is part of a\n                recurring series, ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if this event is part of a recurring series, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "is_superseding_event", 
               "doc": {
                  "headline": "Tests if this event is a superseding event.", 
                  "body": "        If true, ``is_implicit()`` must also be true."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if this event is superseding event,\n                ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if this event is superseding event, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "is_offset_event", 
               "doc": {
                  "headline": "Tests if this event is an event calculated from an offset.", 
                  "body": "        If true, ``is_implicit()`` must also be true."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if this event is an offset event,\n                ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if this event is an offset event, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "get_duration", 
               "doc": {
                  "headline": "Gets the duration of the event.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    units (osid.calendaring.DateTimeResolution): the units\n                of the duration\n", 
               "return_doc": "        return: (osid.calendaring.Duration) - the duration", 
               "error_doc": "        raise:  NullArgument - ``units`` is ``null``", 
               "sphinx_param_doc": "        :param units: the units of the duration\n        :type units: ``osid.calendaring.DateTimeResolution``\n", 
               "sphinx_return_doc": "        :return: the duration\n        :rtype: ``osid.calendaring.Duration``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``units`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.calendaring.DateTimeResolution", 
                     "var_name": "units", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.calendaring.DateTimeResolution"
               ], 
               "return_type": "osid.calendaring.Duration", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "get_location_description", 
               "doc": {
                  "headline": "Gets a descriptive location.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.locale.DisplayText) - the location", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the location\n        :rtype: ``osid.locale.DisplayText``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.locale.DisplayText", 
               "errors": {}
            }, 
            {
               "name": "has_location", 
               "doc": {
                  "headline": "Tests if a location is associated with this event.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if there is an associated location,\n                ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if there is an associated location, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "get_location_id", 
               "doc": {
                  "headline": "Gets the location ``Id``.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.id.Id) - a location ``Id``", 
               "error_doc": "        raise:  IllegalState - ``has_location()`` is ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: a location ``Id``\n        :rtype: ``osid.id.Id``", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- ``has_location()`` is ``false``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.id.Id", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract"
               }
            }, 
            {
               "name": "get_location", 
               "doc": {
                  "headline": "Gets the ``Location``.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.mapping.Location) - a location", 
               "error_doc": "        raise:  IllegalState - ``has_location()`` is ``false``\n        raise:  OperationFailed - unable to complete request", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: a location\n        :rtype: ``osid.mapping.Location``", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- ``has_location()`` is ``false``\n        :raise: ``OperationFailed`` -- unable to complete request", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.mapping.Location", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational"
               }
            }, 
            {
               "name": "has_sponsors", 
               "doc": {
                  "headline": "Tests if a sponsor is associated with this event.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if there is an associated sponsor.\n                ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if there is an associated sponsor. ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "get_sponsor_ids", 
               "doc": {
                  "headline": "Gets the ``Id`` of the event sponsors.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.id.IdList) - the sponsor ``Ids``", 
               "error_doc": "        raise:  IllegalState - ``has_sponsors()`` is ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the sponsor ``Ids``\n        :rtype: ``osid.id.IdList``", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- ``has_sponsors()`` is ``false``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.id.IdList", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract"
               }
            }, 
            {
               "name": "get_sponsors", 
               "doc": {
                  "headline": "Gets the ``Sponsors``.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.resource.ResourceList) - the sponsors", 
               "error_doc": "        raise:  IllegalState - ``has_sponsors()`` is ``false``\n        raise:  OperationFailed - unable to complete request", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the sponsors\n        :rtype: ``osid.resource.ResourceList``", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- ``has_sponsors()`` is ``false``\n        :raise: ``OperationFailed`` -- unable to complete request", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.resource.ResourceList", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational"
               }
            }, 
            {
               "name": "get_event_record", 
               "doc": {
                  "headline": "Gets the event record corresponding to the given ``Event`` record ``Type``.", 
                  "body": "        This method is used to retrieve an object implementing the\n        requested record. The ``event_record_type`` may be the ``Type``\n        returned in ``get_record_types()`` or any of its parents in a\n        ``Type`` hierarchy where ``has_record_type(event_record_type)``\n        is ``true`` ."
               }, 
               "arg_doc": "        arg:    event_record_type (osid.type.Type): the type of the\n                record to retrieve\n", 
               "return_doc": "        return: (osid.calendaring.records.EventRecord) - the event\n                record", 
               "error_doc": "        raise:  NullArgument - ``event_record_type`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unsupported - ``has_record_type(event_record_type)`` is\n                ``false``", 
               "sphinx_param_doc": "        :param event_record_type: the type of the record to retrieve\n        :type event_record_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "        :return: the event record\n        :rtype: ``osid.calendaring.records.EventRecord``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``event_record_type`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unsupported`` -- ``has_record_type(event_record_type)`` is ``false``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "event_record_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "osid.calendaring.records.EventRecord", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.calendaring.records.EventRecord", 
         "shortname": "EventRecord", 
         "category": "records", 
         "doc": {
            "headline": "A record for an ``Event``.", 
            "body": "    The methods specified by the record type are available through the\n    underlying object."
         }, 
         "inherit_fullnames": [
            "osid.OsidRecord"
         ], 
         "inherit_shortnames": [
            "OsidRecord"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidRecord"
            }
         ], 
         "method_names": [], 
         "methods": []
      }, 
      {
         "fullname": "osid.calendaring.EventQuery", 
         "shortname": "EventQuery", 
         "category": "queries", 
         "doc": {
            "headline": "This is the query for searching events.", 
            "body": "    Each method match request produces an ``AND`` term while multiple\n    invocations of a method produces a nested ``OR``."
         }, 
         "inherit_fullnames": [
            "osid.OsidObjectQuery", 
            "osid.OsidTemporalQuery", 
            "osid.OsidContainableQuery"
         ], 
         "inherit_shortnames": [
            "OsidObjectQuery", 
            "OsidTemporalQuery", 
            "OsidContainableQuery"
         ], 
         "inherit_pkg_names": [
            "osid", 
            "osid", 
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidObjectQuery"
            }, 
            {
               "pkg_name": "osid", 
               "name": "OsidTemporalQuery"
            }, 
            {
               "pkg_name": "osid", 
               "name": "OsidContainableQuery"
            }
         ], 
         "method_names": [
            "match_implicit", 
            "clear_implicit_terms", 
            "match_duration", 
            "match_any_duration", 
            "clear_duration_terms", 
            "match_recurring_event_id", 
            "clear_recurring_event_id_terms", 
            "supports_recurring_event_query", 
            "get_recurring_event_query", 
            "match_any_recurring_event", 
            "clear_recurring_event_terms", 
            "match_superseding_event_id", 
            "clear_superseding_event_id_terms", 
            "supports_superseding_event_query", 
            "get_superseding_event_query", 
            "match_any_superseding_event", 
            "clear_superseding_event_terms", 
            "match_offset_event_id", 
            "clear_offset_event_id_terms", 
            "supports_offset_event_query", 
            "get_offset_event_query", 
            "match_any_offset_event", 
            "clear_offset_event_terms", 
            "match_location_description", 
            "match_any_location_description", 
            "clear_location_description_terms", 
            "match_location_id", 
            "clear_location_id_terms", 
            "supports_location_query", 
            "get_location_query", 
            "match_any_location", 
            "clear_location_terms", 
            "match_sponsor_id", 
            "clear_sponsor_id_terms", 
            "supports_sponsor_query", 
            "get_sponsor_query", 
            "clear_sponsor_terms", 
            "match_coordinate", 
            "clear_coordinate_terms", 
            "match_spatial_unit", 
            "clear_spatial_unit_terms", 
            "match_commitment_id", 
            "clear_commitment_id_terms", 
            "supports_commitment_query", 
            "get_commitment_query", 
            "match_any_commitment", 
            "clear_commitment_terms", 
            "match_containing_event_id", 
            "clear_containing_event_id_terms", 
            "supports_containing_event_query", 
            "get_containing_event_query", 
            "match_any_containing_event", 
            "clear_containing_event_terms", 
            "match_calendar_id", 
            "clear_calendar_id_terms", 
            "supports_calendar_query", 
            "get_calendar_query", 
            "clear_calendar_terms", 
            "get_event_query_record"
         ], 
         "methods": [
            {
               "name": "match_implicit", 
               "doc": {
                  "headline": "Matches an event that is implicitly generated.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    match (boolean): ``true`` to match events implicitly\n                generated, ``false`` to match events explicitly defined\n", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "        :param match: ``true`` to match events implicitly generated, ``false`` to match events explicitly defined\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "clear_implicit_terms", 
               "doc": {
                  "headline": "Clears the implcit terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "match_duration", 
               "doc": {
                  "headline": "Matches the event duration between the given range inclusive.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    low (osid.calendaring.Duration): low duration range\n        arg:    high (osid.calendaring.Duration): high duration range\n        arg:    match (boolean): ``true`` for a positive match,\n                ``false`` for a negative match\n", 
               "return_doc": "", 
               "error_doc": "        raise:  InvalidArgument - ``high`` is less than ``low``\n        raise:  NullArgument - ``high`` or ``low`` is ``null``", 
               "sphinx_param_doc": "        :param low: low duration range\n        :type low: ``osid.calendaring.Duration``\n        :param high: high duration range\n        :type high: ``osid.calendaring.Duration``\n        :param match: ``true`` for a positive match, ``false`` for a negative match\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``InvalidArgument`` -- ``high`` is less than ``low``\n        :raise: ``NullArgument`` -- ``high`` or ``low`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.calendaring.Duration", 
                     "var_name": "low", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.calendaring.Duration", 
                     "var_name": "high", 
                     "array": false
                  }, 
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.calendaring.Duration", 
                  "osid.calendaring.Duration", 
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {
                  "INVALID_ARGUMENT": "ConsumerContract", 
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "match_any_duration", 
               "doc": {
                  "headline": "Matches an event that has any duration.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    match (boolean): ``true`` to match events with any\n                duration, ``false`` to match events with no start time\n", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "        :param match: ``true`` to match events with any duration, ``false`` to match events with no start time\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "clear_duration_terms", 
               "doc": {
                  "headline": "Clears the duration terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "match_recurring_event_id", 
               "doc": {
                  "headline": "Matches events that related to the recurring event.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    recurring_event_id (osid.id.Id): an ``Id`` for a\n                recurring event\n        arg:    match (boolean): ``true`` for a positive match,\n                ``false`` for a negative match\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``recurring_event_id`` is ``null``", 
               "sphinx_param_doc": "        :param recurring_event_id: an ``Id`` for a recurring event\n        :type recurring_event_id: ``osid.id.Id``\n        :param match: ``true`` for a positive match, ``false`` for a negative match\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``recurring_event_id`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "recurring_event_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "clear_recurring_event_id_terms", 
               "doc": {
                  "headline": "Clears the recurring event terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "supports_recurring_event_query", 
               "doc": {
                  "headline": "Tests if a ``RecurringEventQuery`` is available for querying recurring events.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if a recurring event query is\n                available, ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if a recurring event query is available, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "get_recurring_event_query", 
               "doc": {
                  "headline": "Gets the query for a recurring event.", 
                  "body": "        Multiple retrievals produce a nested ``OR`` term."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.RecurringEventQuery) - the recurring\n                event query", 
               "error_doc": "        raise:  Unimplemented - ``supports_recurring_event_query()`` is\n                ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the recurring event query\n        :rtype: ``osid.calendaring.RecurringEventQuery``", 
               "sphinx_error_doc": "        :raise: ``Unimplemented`` -- ``supports_recurring_event_query()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_recurring_event_query()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.RecurringEventQuery", 
               "errors": {
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "match_any_recurring_event", 
               "doc": {
                  "headline": "Matches an event that is part of any recurring event.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    match (boolean): ``true`` to match events part of any\n                recurring event, ``false`` to match only standalone\n                events\n", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "        :param match: ``true`` to match events part of any recurring event, ``false`` to match only standalone events\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "clear_recurring_event_terms", 
               "doc": {
                  "headline": "Clears the recurring event terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "match_superseding_event_id", 
               "doc": {
                  "headline": "Matches events that relate to the superseding event.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    superseding_event_id (osid.id.Id): an ``Id`` for a\n                superseding event\n        arg:    match (boolean): ``true`` for a positive match,\n                ``false`` for a negative match\n", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "        :param superseding_event_id: an ``Id`` for a superseding event\n        :type superseding_event_id: ``osid.id.Id``\n        :param match: ``true`` for a positive match, ``false`` for a negative match\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "superseding_event_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "clear_superseding_event_id_terms", 
               "doc": {
                  "headline": "Clears the superseding events type terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "supports_superseding_event_query", 
               "doc": {
                  "headline": "Tests if a ``SupersedingEventQuery`` is available for querying offset events.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if a superseding event query is\n                available, ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if a superseding event query is available, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "get_superseding_event_query", 
               "doc": {
                  "headline": "Gets the query for a superseding event.", 
                  "body": "        Multiple retrievals produce a nested ``OR`` term."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.SupersedingEventQuery) - the\n                superseding event query", 
               "error_doc": "        raise:  Unimplemented - ``supports_superseding_event_query()``\n                is ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the superseding event query\n        :rtype: ``osid.calendaring.SupersedingEventQuery``", 
               "sphinx_error_doc": "        :raise: ``Unimplemented`` -- ``supports_superseding_event_query()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_superseding_event_query()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.SupersedingEventQuery", 
               "errors": {
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "match_any_superseding_event", 
               "doc": {
                  "headline": "Matches any superseding event.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    match (boolean): ``true`` to match any superseding\n                events, ``false`` otherwise\n", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "        :param match: ``true`` to match any superseding events, ``false`` otherwise\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "clear_superseding_event_terms", 
               "doc": {
                  "headline": "Clears the superseding event terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "match_offset_event_id", 
               "doc": {
                  "headline": "Matches events that relates to the offset event.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    offset_event_id (osid.id.Id): an ``Id`` for an offset\n                event\n        arg:    match (boolean): ``true`` for a positive match,\n                ``false`` for a negative match\n", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "        :param offset_event_id: an ``Id`` for an offset event\n        :type offset_event_id: ``osid.id.Id``\n        :param match: ``true`` for a positive match, ``false`` for a negative match\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "offset_event_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "clear_offset_event_id_terms", 
               "doc": {
                  "headline": "Clears the recurring events type terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "supports_offset_event_query", 
               "doc": {
                  "headline": "Tests if an ``OffsetEventQuery`` is available for querying offset events.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if an offset event query is\n                available, ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if an offset event query is available, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "get_offset_event_query", 
               "doc": {
                  "headline": "Gets the query for an offset event.", 
                  "body": "        Multiple retrievals produce a nested ``OR`` term."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.OffsetEventQuery) - the offset event\n                query", 
               "error_doc": "        raise:  Unimplemented - ``supports_offset_event_query()`` is\n                ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the offset event query\n        :rtype: ``osid.calendaring.OffsetEventQuery``", 
               "sphinx_error_doc": "        :raise: ``Unimplemented`` -- ``supports_offset_event_query()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_offset_event_query()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.OffsetEventQuery", 
               "errors": {
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "match_any_offset_event", 
               "doc": {
                  "headline": "Matches any offset event.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    match (boolean): ``true`` to match any offset events,\n                ``false`` otherwise\n", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "        :param match: ``true`` to match any offset events, ``false`` otherwise\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "clear_offset_event_terms", 
               "doc": {
                  "headline": "Clears the offset event terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "match_location_description", 
               "doc": {
                  "headline": "Matches the location description string.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    location (string): location string\n        arg:    string_match_type (osid.type.Type): string match type\n        arg:    match (boolean): ``true`` for a positive match,\n                ``false`` for a negative match\n", 
               "return_doc": "", 
               "error_doc": "        raise:  InvalidArgument - ``location`` is not of\n                ``string_match_type``\n        raise:  NullArgument - ``location`` or ``string_match_type`` is\n                ``null``\n        raise:  Unsupported -\n                ``supports_string_match_type(string_match_type)`` is\n                ``false``", 
               "sphinx_param_doc": "        :param location: location string\n        :type location: ``string``\n        :param string_match_type: string match type\n        :type string_match_type: ``osid.type.Type``\n        :param match: ``true`` for a positive match, ``false`` for a negative match\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``InvalidArgument`` -- ``location`` is not of ``string_match_type``\n        :raise: ``NullArgument`` -- ``location`` or ``string_match_type`` is ``null``\n        :raise: ``Unsupported`` -- ``supports_string_match_type(string_match_type)`` is ``false``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "string", 
                     "var_name": "location", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "string_match_type", 
                     "array": false
                  }, 
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "string", 
                  "osid.type.Type", 
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {
                  "INVALID_ARGUMENT": "ConsumerContract", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }, 
            {
               "name": "match_any_location_description", 
               "doc": {
                  "headline": "Matches an event that has any location description assigned.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    match (boolean): ``true`` to match events with any\n                location description, ``false`` to match events with no\n                location description\n", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "        :param match: ``true`` to match events with any location description, ``false`` to match events with no location description\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "clear_location_description_terms", 
               "doc": {
                  "headline": "Clears the location description terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "match_location_id", 
               "doc": {
                  "headline": "Sets the location ``Id`` for this query.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    location_id (osid.id.Id): a location ``Id``\n        arg:    match (boolean): ``true`` for a positive match,\n                ``false`` for a negative match\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``location_id`` is ``null``", 
               "sphinx_param_doc": "        :param location_id: a location ``Id``\n        :type location_id: ``osid.id.Id``\n        :param match: ``true`` for a positive match, ``false`` for a negative match\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``location_id`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "location_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "clear_location_id_terms", 
               "doc": {
                  "headline": "Clears the location ``Id`` terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "supports_location_query", 
               "doc": {
                  "headline": "Tests if a ``LocationQuery`` is available for querying locations.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if a location query is available,\n                ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if a location query is available, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "get_location_query", 
               "doc": {
                  "headline": "Gets the query for a location.", 
                  "body": "        Multiple retrievals produce a nested ``OR`` term."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.mapping.LocationQuery) - the location query", 
               "error_doc": "        raise:  Unimplemented - ``supports_location_query()`` is\n                ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the location query\n        :rtype: ``osid.mapping.LocationQuery``", 
               "sphinx_error_doc": "        :raise: ``Unimplemented`` -- ``supports_location_query()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_location_query()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.mapping.LocationQuery", 
               "errors": {
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "match_any_location", 
               "doc": {
                  "headline": "Matches an event that has any location assigned.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    match (boolean): ``true`` to match events with any\n                location, ``false`` to match events with no location\n", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "        :param match: ``true`` to match events with any location, ``false`` to match events with no location\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "clear_location_terms", 
               "doc": {
                  "headline": "Clears the location terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "match_sponsor_id", 
               "doc": {
                  "headline": "Sets the sponsor ``Id`` for this query.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    sponsor_id (osid.id.Id): a sponsor ``Id``\n        arg:    match (boolean): ``true`` for a positive match,\n                ``false`` for a negative match\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``sponsor_id`` is ``null``", 
               "sphinx_param_doc": "        :param sponsor_id: a sponsor ``Id``\n        :type sponsor_id: ``osid.id.Id``\n        :param match: ``true`` for a positive match, ``false`` for a negative match\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``sponsor_id`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "sponsor_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "clear_sponsor_id_terms", 
               "doc": {
                  "headline": "Clears the sponsor ``Id`` terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "supports_sponsor_query", 
               "doc": {
                  "headline": "Tests if a ``LocationQuery`` is available for querying sponsors.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if a sponsor query is available,\n                ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if a sponsor query is available, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "get_sponsor_query", 
               "doc": {
                  "headline": "Gets the query for a sponsor.", 
                  "body": "        Multiple retrievals produce a nested ``OR`` term."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.resource.ResourceQuery) - the sponsor query", 
               "error_doc": "        raise:  Unimplemented - ``supports_sponsor_query()`` is\n                ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the sponsor query\n        :rtype: ``osid.resource.ResourceQuery``", 
               "sphinx_error_doc": "        :raise: ``Unimplemented`` -- ``supports_sponsor_query()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_sponsor_query()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.resource.ResourceQuery", 
               "errors": {
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "clear_sponsor_terms", 
               "doc": {
                  "headline": "Clears the sponsor terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "match_coordinate", 
               "doc": {
                  "headline": "Matches events whose locations contain the given coordinate.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    coordinate (osid.mapping.Coordinate): a coordinate\n        arg:    match (boolean): ``true`` for a positive match,\n                ``false`` for a negative match\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``coordinate`` is ``null``", 
               "sphinx_param_doc": "        :param coordinate: a coordinate\n        :type coordinate: ``osid.mapping.Coordinate``\n        :param match: ``true`` for a positive match, ``false`` for a negative match\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``coordinate`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.mapping.Coordinate", 
                     "var_name": "coordinate", 
                     "array": false
                  }, 
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.mapping.Coordinate", 
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "clear_coordinate_terms", 
               "doc": {
                  "headline": "Clears the cooordinate terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "match_spatial_unit", 
               "doc": {
                  "headline": "Matches events whose locations fall within the given spatial unit.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    spatial_unit (osid.mapping.SpatialUnit): a spatial unit\n        arg:    match (boolean): ``true`` for a positive match,\n                ``false`` for a negative match\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``spatial_unit`` is ``null``", 
               "sphinx_param_doc": "        :param spatial_unit: a spatial unit\n        :type spatial_unit: ``osid.mapping.SpatialUnit``\n        :param match: ``true`` for a positive match, ``false`` for a negative match\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``spatial_unit`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.mapping.SpatialUnit", 
                     "var_name": "spatial_unit", 
                     "array": false
                  }, 
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.mapping.SpatialUnit", 
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "clear_spatial_unit_terms", 
               "doc": {
                  "headline": "Clears the spatial unit terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "match_commitment_id", 
               "doc": {
                  "headline": "Sets the commitment ``Id`` for this query.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    commitment_id (osid.id.Id): a commitment ``Id``\n        arg:    match (boolean): ``true`` for a positive match,\n                ``false`` for a negative match\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``commitment_id`` is ``null``", 
               "sphinx_param_doc": "        :param commitment_id: a commitment ``Id``\n        :type commitment_id: ``osid.id.Id``\n        :param match: ``true`` for a positive match, ``false`` for a negative match\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``commitment_id`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "commitment_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "clear_commitment_id_terms", 
               "doc": {
                  "headline": "Clears the commitment ``Id`` terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "supports_commitment_query", 
               "doc": {
                  "headline": "Tests if a ``CommitmentQuery`` is available for querying recurring event terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if a commitment query is available,\n                ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if a commitment query is available, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "get_commitment_query", 
               "doc": {
                  "headline": "Gets the query for a commitment.", 
                  "body": "        Multiple retrievals produce a nested ``OR`` term."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.CommitmentQuery) - the commitment\n                query", 
               "error_doc": "        raise:  Unimplemented - ``supports_commitment_query()`` is\n                ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the commitment query\n        :rtype: ``osid.calendaring.CommitmentQuery``", 
               "sphinx_error_doc": "        :raise: ``Unimplemented`` -- ``supports_commitment_query()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_commitment_query()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.CommitmentQuery", 
               "errors": {
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "match_any_commitment", 
               "doc": {
                  "headline": "Matches an event that has any commitment.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    match (boolean): ``true`` to match events with any\n                commitment, ``false`` to match events with no\n                commitments\n", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "        :param match: ``true`` to match events with any commitment, ``false`` to match events with no commitments\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "clear_commitment_terms", 
               "doc": {
                  "headline": "Clears the commitment terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "match_containing_event_id", 
               "doc": {
                  "headline": "Sets the event ``Id`` for this query to match events that have the specified event as an ancestor.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    event_id (osid.id.Id): an event ``Id``\n        arg:    match (boolean): ``true`` for a positive match,\n                ``false`` for a negative match\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``event_id`` is ``null``", 
               "sphinx_param_doc": "        :param event_id: an event ``Id``\n        :type event_id: ``osid.id.Id``\n        :param match: ``true`` for a positive match, ``false`` for a negative match\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``event_id`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "event_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "clear_containing_event_id_terms", 
               "doc": {
                  "headline": "Clears the containing event ``Id`` terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "supports_containing_event_query", 
               "doc": {
                  "headline": "Tests if a containing event query is available.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if a containing event query is\n                available, ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if a containing event query is available, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "get_containing_event_query", 
               "doc": {
                  "headline": "Gets the query for a containing event.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.EventQuery) - the containing event\n                query", 
               "error_doc": "        raise:  Unimplemented - ``supports_containing_event_query()`` is\n                ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the containing event query\n        :rtype: ``osid.calendaring.EventQuery``", 
               "sphinx_error_doc": "        :raise: ``Unimplemented`` -- ``supports_containing_event_query()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_containing_event_query()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.EventQuery", 
               "errors": {
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "match_any_containing_event", 
               "doc": {
                  "headline": "Matches events with any ancestor event.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    match (boolean): ``true`` to match events with any\n                ancestor event, ``false`` to match events with no\n                ancestor events\n", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "        :param match: ``true`` to match events with any ancestor event, ``false`` to match events with no ancestor events\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "clear_containing_event_terms", 
               "doc": {
                  "headline": "Clears the containing event terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "match_calendar_id", 
               "doc": {
                  "headline": "Sets the calendar ``Id`` for this query.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    calendar_id (osid.id.Id): a calendar ``Id``\n        arg:    match (boolean): ``true`` for a positive match,\n                ``false`` for a negative match\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``calendar_id`` is ``null``", 
               "sphinx_param_doc": "        :param calendar_id: a calendar ``Id``\n        :type calendar_id: ``osid.id.Id``\n        :param match: ``true`` for a positive match, ``false`` for a negative match\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``calendar_id`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "calendar_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "clear_calendar_id_terms", 
               "doc": {
                  "headline": "Clears the calendar ``Id`` terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "supports_calendar_query", 
               "doc": {
                  "headline": "Tests if a ``CalendarQuery`` is available for querying calendars.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if a calendar query is available,\n                ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if a calendar query is available, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "get_calendar_query", 
               "doc": {
                  "headline": "Gets the query for a calendar.", 
                  "body": "        Multiple retrievals produce a nested ``OR`` term."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.CalendarQuery) - the calendar query", 
               "error_doc": "        raise:  Unimplemented - ``supports_calendar_query()`` is\n                ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the calendar query\n        :rtype: ``osid.calendaring.CalendarQuery``", 
               "sphinx_error_doc": "        :raise: ``Unimplemented`` -- ``supports_calendar_query()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_calendar_query()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.CalendarQuery", 
               "errors": {
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "clear_calendar_terms", 
               "doc": {
                  "headline": "Clears the calendar terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "get_event_query_record", 
               "doc": {
                  "headline": "Gets the event query record corresponding to the given ``Event`` record ``Type``.", 
                  "body": "        Multiple retrievals produce a nested ``OR`` term."
               }, 
               "arg_doc": "        arg:    event_record_type (osid.type.Type): an event query\n                record type\n", 
               "return_doc": "        return: (osid.calendaring.records.EventQueryRecord) - the event\n                query record", 
               "error_doc": "        raise:  NullArgument - ``event_record_type`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unsupported - ``has_record_type(event_record_type)`` is\n                ``false``", 
               "sphinx_param_doc": "        :param event_record_type: an event query record type\n        :type event_record_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "        :return: the event query record\n        :rtype: ``osid.calendaring.records.EventQueryRecord``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``event_record_type`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unsupported`` -- ``has_record_type(event_record_type)`` is ``false``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "event_record_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "osid.calendaring.records.EventQueryRecord", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.calendaring.records.EventQueryRecord", 
         "shortname": "EventQueryRecord", 
         "category": "records", 
         "doc": {
            "headline": "A record for an ``EventQuery``.", 
            "body": "    The methods specified by the record type are available through the\n    underlying object."
         }, 
         "inherit_fullnames": [
            "osid.OsidRecord"
         ], 
         "inherit_shortnames": [
            "OsidRecord"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidRecord"
            }
         ], 
         "method_names": [], 
         "methods": []
      }, 
      {
         "fullname": "osid.calendaring.EventQueryInspector", 
         "shortname": "EventQueryInspector", 
         "category": "query_inspectors", 
         "doc": {
            "headline": "This is the query inspector for examining event queries.", 
            "body": ""
         }, 
         "inherit_fullnames": [
            "osid.OsidObjectQueryInspector", 
            "osid.OsidTemporalQueryInspector", 
            "osid.OsidContainableQueryInspector"
         ], 
         "inherit_shortnames": [
            "OsidObjectQueryInspector", 
            "OsidTemporalQueryInspector", 
            "OsidContainableQueryInspector"
         ], 
         "inherit_pkg_names": [
            "osid", 
            "osid", 
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidObjectQueryInspector"
            }, 
            {
               "pkg_name": "osid", 
               "name": "OsidTemporalQueryInspector"
            }, 
            {
               "pkg_name": "osid", 
               "name": "OsidContainableQueryInspector"
            }
         ], 
         "method_names": [
            "get_implicit_terms", 
            "get_duration_terms", 
            "get_recurring_event_id_terms", 
            "get_recurring_event_terms", 
            "get_superseding_event_id_terms", 
            "get_superseding_event_terms", 
            "get_offset_event_id_terms", 
            "get_offset_event_terms", 
            "get_location_description_terms", 
            "get_location_id_terms", 
            "get_location_terms", 
            "get_sponsor_id_terms", 
            "get_sponsor_terms", 
            "get_coordinate_terms", 
            "get_spatial_unit_terms", 
            "get_commitment_id_terms", 
            "get_commitment_terms", 
            "get_containing_event_id_terms", 
            "get_containing_event_terms", 
            "get_calendar_id_terms", 
            "get_calendar_terms", 
            "get_event_query_inspector_record"
         ], 
         "methods": [
            {
               "name": "get_implicit_terms", 
               "doc": {
                  "headline": "Gets the implicit terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.search.terms.BooleanTerm) - the implicit terms", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the implicit terms\n        :rtype: ``osid.search.terms.BooleanTerm``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.search.terms.BooleanTerm", 
               "errors": {}
            }, 
            {
               "name": "get_duration_terms", 
               "doc": {
                  "headline": "Gets the duration terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.search.terms.DurationTerm) - the duration terms", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the duration terms\n        :rtype: ``osid.search.terms.DurationTerm``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.search.terms.DurationTerm", 
               "errors": {}
            }, 
            {
               "name": "get_recurring_event_id_terms", 
               "doc": {
                  "headline": "Gets the recurring event ``Id`` terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.search.terms.IdTerm) - the recurring event ``Id``\n                terms", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the recurring event ``Id`` terms\n        :rtype: ``osid.search.terms.IdTerm``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.search.terms.IdTerm", 
               "errors": {}
            }, 
            {
               "name": "get_recurring_event_terms", 
               "doc": {
                  "headline": "Gets the recurring event terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.RecurringEventQueryInspector) - the\n                recurring event terms", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the recurring event terms\n        :rtype: ``osid.calendaring.RecurringEventQueryInspector``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.RecurringEventQueryInspector", 
               "errors": {}
            }, 
            {
               "name": "get_superseding_event_id_terms", 
               "doc": {
                  "headline": "Gets the superseding event ``Id`` terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.search.terms.IdTerm) - the superseding event\n                ``Id`` terms", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the superseding event ``Id`` terms\n        :rtype: ``osid.search.terms.IdTerm``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.search.terms.IdTerm", 
               "errors": {}
            }, 
            {
               "name": "get_superseding_event_terms", 
               "doc": {
                  "headline": "Gets the superseding event terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.SupersedingEventQueryInspector) - the\n                superseding event terms", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the superseding event terms\n        :rtype: ``osid.calendaring.SupersedingEventQueryInspector``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.SupersedingEventQueryInspector", 
               "errors": {}
            }, 
            {
               "name": "get_offset_event_id_terms", 
               "doc": {
                  "headline": "Gets the offset event ``Id`` terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.search.terms.IdTerm) - the offset event ``Id``\n                terms", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the offset event ``Id`` terms\n        :rtype: ``osid.search.terms.IdTerm``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.search.terms.IdTerm", 
               "errors": {}
            }, 
            {
               "name": "get_offset_event_terms", 
               "doc": {
                  "headline": "Gets the offset event terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.OffsetEventQueryInspector) - the\n                offset event terms", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the offset event terms\n        :rtype: ``osid.calendaring.OffsetEventQueryInspector``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.OffsetEventQueryInspector", 
               "errors": {}
            }, 
            {
               "name": "get_location_description_terms", 
               "doc": {
                  "headline": "Gets the location description terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.search.terms.StringTerm) - the location\n                description terms", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the location description terms\n        :rtype: ``osid.search.terms.StringTerm``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.search.terms.StringTerm", 
               "errors": {}
            }, 
            {
               "name": "get_location_id_terms", 
               "doc": {
                  "headline": "Gets the location ``Id`` terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.search.terms.IdTerm) - the location ``Id`` terms", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the location ``Id`` terms\n        :rtype: ``osid.search.terms.IdTerm``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.search.terms.IdTerm", 
               "errors": {}
            }, 
            {
               "name": "get_location_terms", 
               "doc": {
                  "headline": "Gets the location terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.mapping.LocationQueryInspector) - the location\n                terms", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the location terms\n        :rtype: ``osid.mapping.LocationQueryInspector``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.mapping.LocationQueryInspector", 
               "errors": {}
            }, 
            {
               "name": "get_sponsor_id_terms", 
               "doc": {
                  "headline": "Gets the sponsor ``Id`` terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.search.terms.IdTerm) - the sponsor ``Id`` terms", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the sponsor ``Id`` terms\n        :rtype: ``osid.search.terms.IdTerm``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.search.terms.IdTerm", 
               "errors": {}
            }, 
            {
               "name": "get_sponsor_terms", 
               "doc": {
                  "headline": "Gets the sponsor terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.resource.ResourceQueryInspector) - the sponsor\n                terms", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the sponsor terms\n        :rtype: ``osid.resource.ResourceQueryInspector``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.resource.ResourceQueryInspector", 
               "errors": {}
            }, 
            {
               "name": "get_coordinate_terms", 
               "doc": {
                  "headline": "Gets the coordinate terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.search.terms.CoordinateTerm) - the coordinate\n                terms", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the coordinate terms\n        :rtype: ``osid.search.terms.CoordinateTerm``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.search.terms.CoordinateTerm", 
               "errors": {}
            }, 
            {
               "name": "get_spatial_unit_terms", 
               "doc": {
                  "headline": "Gets the spatial unit terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.search.terms.SpatialUnitTerm) - the spatial unit\n                terms", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the spatial unit terms\n        :rtype: ``osid.search.terms.SpatialUnitTerm``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.search.terms.SpatialUnitTerm", 
               "errors": {}
            }, 
            {
               "name": "get_commitment_id_terms", 
               "doc": {
                  "headline": "Gets the commitment ``Id`` terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.search.terms.IdTerm) - the commitment ``Id`` terms", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the commitment ``Id`` terms\n        :rtype: ``osid.search.terms.IdTerm``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.search.terms.IdTerm", 
               "errors": {}
            }, 
            {
               "name": "get_commitment_terms", 
               "doc": {
                  "headline": "Gets the commitment terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.CommitmentQueryInspector) - the\n                commitment terms", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the commitment terms\n        :rtype: ``osid.calendaring.CommitmentQueryInspector``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.CommitmentQueryInspector", 
               "errors": {}
            }, 
            {
               "name": "get_containing_event_id_terms", 
               "doc": {
                  "headline": "Gets the containing event ``Id`` terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.search.terms.IdTerm) - the event ``Id`` terms", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the event ``Id`` terms\n        :rtype: ``osid.search.terms.IdTerm``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.search.terms.IdTerm", 
               "errors": {}
            }, 
            {
               "name": "get_containing_event_terms", 
               "doc": {
                  "headline": "Gets the containing event terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.EventQueryInspector) - the event terms", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the event terms\n        :rtype: ``osid.calendaring.EventQueryInspector``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.EventQueryInspector", 
               "errors": {}
            }, 
            {
               "name": "get_calendar_id_terms", 
               "doc": {
                  "headline": "Gets the calendar ``Id`` terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.search.terms.IdTerm) - the calendar ``Id`` terms", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the calendar ``Id`` terms\n        :rtype: ``osid.search.terms.IdTerm``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.search.terms.IdTerm", 
               "errors": {}
            }, 
            {
               "name": "get_calendar_terms", 
               "doc": {
                  "headline": "Gets the calendar terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.CalendarQueryInspector) - the calendar\n                terms", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the calendar terms\n        :rtype: ``osid.calendaring.CalendarQueryInspector``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.CalendarQueryInspector", 
               "errors": {}
            }, 
            {
               "name": "get_event_query_inspector_record", 
               "doc": {
                  "headline": "Gets the event query inspector record corresponding to the given ``Event`` record ``Type``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    event_record_type (osid.type.Type): an event query\n                record type\n", 
               "return_doc": "        return: (osid.calendaring.records.EventQueryInspectorRecord) -\n                the event query inspector record", 
               "error_doc": "        raise:  NullArgument - ``event_record_type`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unsupported - ``has_record_type(event_record_type)`` is\n                ``false``", 
               "sphinx_param_doc": "        :param event_record_type: an event query record type\n        :type event_record_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "        :return: the event query inspector record\n        :rtype: ``osid.calendaring.records.EventQueryInspectorRecord``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``event_record_type`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unsupported`` -- ``has_record_type(event_record_type)`` is ``false``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "event_record_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "osid.calendaring.records.EventQueryInspectorRecord", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.calendaring.records.EventQueryInspectorRecord", 
         "shortname": "EventQueryInspectorRecord", 
         "category": "records", 
         "doc": {
            "headline": "A record for an ``EventQueryInspector``.", 
            "body": "    The methods specified by the record type are available through the\n    underlying object."
         }, 
         "inherit_fullnames": [
            "osid.OsidRecord"
         ], 
         "inherit_shortnames": [
            "OsidRecord"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidRecord"
            }
         ], 
         "method_names": [], 
         "methods": []
      }, 
      {
         "fullname": "osid.calendaring.EventForm", 
         "shortname": "EventForm", 
         "category": "objects", 
         "doc": {
            "headline": "This is the form for creating and updating ``Events``.", 
            "body": "    Like all ``OsidForm`` objects, various data elements may be set here\n    for use in the create and update methods in the\n    ``EventAdminSession``. For each data element that may be set,\n    metadata may be examined to provide display hints or data\n    constraints."
         }, 
         "inherit_fullnames": [
            "osid.OsidObjectForm", 
            "osid.OsidTemporalForm", 
            "osid.OsidContainableForm"
         ], 
         "inherit_shortnames": [
            "OsidObjectForm", 
            "OsidTemporalForm", 
            "OsidContainableForm"
         ], 
         "inherit_pkg_names": [
            "osid", 
            "osid", 
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidObjectForm"
            }, 
            {
               "pkg_name": "osid", 
               "name": "OsidTemporalForm"
            }, 
            {
               "pkg_name": "osid", 
               "name": "OsidContainableForm"
            }
         ], 
         "method_names": [
            "get_location_description_metadata", 
            "set_location_description", 
            "clear_location_description", 
            "get_location_metadata", 
            "set_location", 
            "clear_location", 
            "get_sponsor_metadata", 
            "set_sponsors", 
            "clear_sponsors", 
            "get_event_form_record"
         ], 
         "methods": [
            {
               "name": "get_location_description_metadata", 
               "doc": {
                  "headline": "Gets the metadata for a location description.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.Metadata) - metadata for the location description", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: metadata for the location description\n        :rtype: ``osid.Metadata``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.Metadata", 
               "errors": {}
            }, 
            {
               "name": "set_location_description", 
               "doc": {
                  "headline": "Sets the location description.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    location (string): the new location description\n", 
               "return_doc": "", 
               "error_doc": "        raise:  InvalidArgument - ``location`` is invalid\n        raise:  NoAccess - ``location`` cannot be modified\n        raise:  NullArgument - ``location`` is ``null``", 
               "sphinx_param_doc": "        :param location: the new location description\n        :type location: ``string``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``InvalidArgument`` -- ``location`` is invalid\n        :raise: ``NoAccess`` -- ``location`` cannot be modified\n        :raise: ``NullArgument`` -- ``location`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "string", 
                     "var_name": "location", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "string"
               ], 
               "return_type": "", 
               "errors": {
                  "INVALID_ARGUMENT": "ConsumerContract", 
                  "NO_ACCESS": "ConsumerContract", 
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "clear_location_description", 
               "doc": {
                  "headline": "Clears the location description.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "        raise:  NoAccess - ``Metadata.isRequired()`` or\n                ``Metadata.isReadOnly()`` is ``true``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NoAccess`` -- ``Metadata.isRequired()`` or ``Metadata.isReadOnly()`` is ``true``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {
                  "NO_ACCESS": "ConsumerContract"
               }
            }, 
            {
               "name": "get_location_metadata", 
               "doc": {
                  "headline": "Gets the metadata for a location.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.Metadata) - metadata for the location", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: metadata for the location\n        :rtype: ``osid.Metadata``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.Metadata", 
               "errors": {}
            }, 
            {
               "name": "set_location", 
               "doc": {
                  "headline": "Sets the location.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    location_id (osid.id.Id): the new location\n", 
               "return_doc": "", 
               "error_doc": "        raise:  InvalidArgument - ``location_id`` is invalid\n        raise:  NoAccess - ``location_id`` cannot be modified\n        raise:  NullArgument - ``location_id`` is ``null``", 
               "sphinx_param_doc": "        :param location_id: the new location\n        :type location_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``InvalidArgument`` -- ``location_id`` is invalid\n        :raise: ``NoAccess`` -- ``location_id`` cannot be modified\n        :raise: ``NullArgument`` -- ``location_id`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "location_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {
                  "INVALID_ARGUMENT": "ConsumerContract", 
                  "NO_ACCESS": "ConsumerContract", 
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "clear_location", 
               "doc": {
                  "headline": "Clears the location.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "        raise:  NoAccess - ``Metadata.isRequired()`` or\n                ``Metadata.isReadOnly()`` is ``true``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NoAccess`` -- ``Metadata.isRequired()`` or ``Metadata.isReadOnly()`` is ``true``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {
                  "NO_ACCESS": "ConsumerContract"
               }
            }, 
            {
               "name": "get_sponsor_metadata", 
               "doc": {
                  "headline": "Gets the metadata for a sponsor.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.Metadata) - metadata for the sponsor", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: metadata for the sponsor\n        :rtype: ``osid.Metadata``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.Metadata", 
               "errors": {}
            }, 
            {
               "name": "set_sponsors", 
               "doc": {
                  "headline": "Sets the sponsors.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    sponsor_ids (osid.id.Id[]): the new sponsor\n", 
               "return_doc": "", 
               "error_doc": "        raise:  InvalidArgument - ``sponsor_ids`` is invalid\n        raise:  NoAccess - ``sponsor_ids`` cannot be modified\n        raise:  NullArgument - ``sponsor_ids`` is ``null``", 
               "sphinx_param_doc": "        :param sponsor_ids: the new sponsor\n        :type sponsor_ids: ``osid.id.Id[]``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``InvalidArgument`` -- ``sponsor_ids`` is invalid\n        :raise: ``NoAccess`` -- ``sponsor_ids`` cannot be modified\n        :raise: ``NullArgument`` -- ``sponsor_ids`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id[]", 
                     "var_name": "sponsor_ids", 
                     "array": true
                  }
               ], 
               "arg_types": [
                  "osid.id.Id[]"
               ], 
               "return_type": "", 
               "errors": {
                  "INVALID_ARGUMENT": "ConsumerContract", 
                  "NO_ACCESS": "ConsumerContract", 
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "clear_sponsors", 
               "doc": {
                  "headline": "Clears the sponsors.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "        raise:  NoAccess - ``Metadata.isRequired()`` or\n                ``Metadata.isReadOnly()`` is ``true``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NoAccess`` -- ``Metadata.isRequired()`` or ``Metadata.isReadOnly()`` is ``true``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {
                  "NO_ACCESS": "ConsumerContract"
               }
            }, 
            {
               "name": "get_event_form_record", 
               "doc": {
                  "headline": "Gets the ``EventFormRecord`` corresponding to the given event record ``Type``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    event_record_type (osid.type.Type): the event record\n                type\n", 
               "return_doc": "        return: (osid.calendaring.records.EventFormRecord) - the event\n                form record", 
               "error_doc": "        raise:  NullArgument - ``event_record_type`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unsupported - ``has_record_type(event_record_type)`` is\n                ``false``", 
               "sphinx_param_doc": "        :param event_record_type: the event record type\n        :type event_record_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "        :return: the event form record\n        :rtype: ``osid.calendaring.records.EventFormRecord``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``event_record_type`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unsupported`` -- ``has_record_type(event_record_type)`` is ``false``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "event_record_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "osid.calendaring.records.EventFormRecord", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.calendaring.records.EventFormRecord", 
         "shortname": "EventFormRecord", 
         "category": "records", 
         "doc": {
            "headline": "A record for an ``EventForm``.", 
            "body": "    The methods specified by the record type are available through the\n    underlying object."
         }, 
         "inherit_fullnames": [
            "osid.OsidRecord"
         ], 
         "inherit_shortnames": [
            "OsidRecord"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidRecord"
            }
         ], 
         "method_names": [], 
         "methods": []
      }, 
      {
         "fullname": "osid.calendaring.EventSearchOrder", 
         "shortname": "EventSearchOrder", 
         "category": "search_orders", 
         "doc": {
            "headline": "An interface for specifying the ordering of search results.", 
            "body": ""
         }, 
         "inherit_fullnames": [
            "osid.OsidObjectSearchOrder", 
            "osid.OsidTemporalSearchOrder", 
            "osid.OsidContainableSearchOrder"
         ], 
         "inherit_shortnames": [
            "OsidObjectSearchOrder", 
            "OsidTemporalSearchOrder", 
            "OsidContainableSearchOrder"
         ], 
         "inherit_pkg_names": [
            "osid", 
            "osid", 
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidObjectSearchOrder"
            }, 
            {
               "pkg_name": "osid", 
               "name": "OsidTemporalSearchOrder"
            }, 
            {
               "pkg_name": "osid", 
               "name": "OsidContainableSearchOrder"
            }
         ], 
         "method_names": [
            "order_by_duration", 
            "order_by_recurring_event", 
            "supports_recurring_event_search_order", 
            "get_recurring_event_search_order", 
            "order_by_superseding_event", 
            "supports_superseding_event_search_order", 
            "get_superseding_event_search_order", 
            "order_by_offset_event", 
            "supports_offset_event_search_order", 
            "get_offset_event_search_order", 
            "order_by_location_description", 
            "order_by_location", 
            "supports_location_search_order", 
            "get_location_search_order", 
            "get_event_search_order_record"
         ], 
         "methods": [
            {
               "name": "order_by_duration", 
               "doc": {
                  "headline": "Specified a preference for ordering results by the duration.", 
                  "body": "        For recurring events, the duration is the duration of a single\n        event."
               }, 
               "arg_doc": "        arg:    style (osid.SearchOrderStyle): a search order style\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``style`` is ``null``", 
               "sphinx_param_doc": "        :param style: a search order style\n        :type style: ``osid.SearchOrderStyle``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``style`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.SearchOrderStyle", 
                     "var_name": "style", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.SearchOrderStyle"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "order_by_recurring_event", 
               "doc": {
                  "headline": "Specified a preference for ordering results by the recurring event.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    style (osid.SearchOrderStyle): a search order style\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``style`` is ``null``", 
               "sphinx_param_doc": "        :param style: a search order style\n        :type style: ``osid.SearchOrderStyle``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``style`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.SearchOrderStyle", 
                     "var_name": "style", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.SearchOrderStyle"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "supports_recurring_event_search_order", 
               "doc": {
                  "headline": "Tests if a ``RecurringEventSearchOrder`` is available for recurring events.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if a recurring event search order\n                is available, ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if a recurring event search order is available, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "get_recurring_event_search_order", 
               "doc": {
                  "headline": "Gets the search order for a recurring event.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.RecurringEventSearchOrder) - the\n                recurring event search order", 
               "error_doc": "        raise:  Unimplemented -\n                ``supports_recurring_event_search_order()`` is ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the recurring event search order\n        :rtype: ``osid.calendaring.RecurringEventSearchOrder``", 
               "sphinx_error_doc": "        :raise: ``Unimplemented`` -- ``supports_recurring_event_search_order()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_recurring_event_search_order()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.RecurringEventSearchOrder", 
               "errors": {
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "order_by_superseding_event", 
               "doc": {
                  "headline": "Specified a preference for ordering results by the superseding event.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    style (osid.SearchOrderStyle): a search order style\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``style`` is ``null``", 
               "sphinx_param_doc": "        :param style: a search order style\n        :type style: ``osid.SearchOrderStyle``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``style`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.SearchOrderStyle", 
                     "var_name": "style", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.SearchOrderStyle"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "supports_superseding_event_search_order", 
               "doc": {
                  "headline": "Tests if a ``SupersedingEventSearchOrder`` is available for offset events.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if a superseding event search order\n                is available, ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if a superseding event search order is available, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "get_superseding_event_search_order", 
               "doc": {
                  "headline": "Gets the search order for a superseding event.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.SupersedingEventSearchOrder) - the\n                superseding event search order", 
               "error_doc": "        raise:  Unimplemented -\n                ``supports_superseding_event_search_order()`` is\n                ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the superseding event search order\n        :rtype: ``osid.calendaring.SupersedingEventSearchOrder``", 
               "sphinx_error_doc": "        :raise: ``Unimplemented`` -- ``supports_superseding_event_search_order()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_superseding_event_search_order()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.SupersedingEventSearchOrder", 
               "errors": {
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "order_by_offset_event", 
               "doc": {
                  "headline": "Specified a preference for ordering results by the offset event.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    style (osid.SearchOrderStyle): a search order style\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``style`` is ``null``", 
               "sphinx_param_doc": "        :param style: a search order style\n        :type style: ``osid.SearchOrderStyle``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``style`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.SearchOrderStyle", 
                     "var_name": "style", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.SearchOrderStyle"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "supports_offset_event_search_order", 
               "doc": {
                  "headline": "Tests if an ``OffsetEventSearchOrder`` is available for offset events.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if an offset event search order is\n                available, ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if an offset event search order is available, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "get_offset_event_search_order", 
               "doc": {
                  "headline": "Gets the search order for an offset event.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.OffsetEventSearchOrder) - the offset\n                event search order", 
               "error_doc": "        raise:  Unimplemented - ``supports_offset_event_search_order()``\n                is ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the offset event search order\n        :rtype: ``osid.calendaring.OffsetEventSearchOrder``", 
               "sphinx_error_doc": "        :raise: ``Unimplemented`` -- ``supports_offset_event_search_order()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_offset_event_search_order()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.OffsetEventSearchOrder", 
               "errors": {
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "order_by_location_description", 
               "doc": {
                  "headline": "Specified a preference for ordering results by the location description.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    style (osid.SearchOrderStyle): a search order style\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``style`` is ``null``", 
               "sphinx_param_doc": "        :param style: a search order style\n        :type style: ``osid.SearchOrderStyle``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``style`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.SearchOrderStyle", 
                     "var_name": "style", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.SearchOrderStyle"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "order_by_location", 
               "doc": {
                  "headline": "Specified a preference for ordering results by the location.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    style (osid.SearchOrderStyle): a search order style\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``style`` is ``null``", 
               "sphinx_param_doc": "        :param style: a search order style\n        :type style: ``osid.SearchOrderStyle``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``style`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.SearchOrderStyle", 
                     "var_name": "style", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.SearchOrderStyle"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "supports_location_search_order", 
               "doc": {
                  "headline": "Tests if a ``LocationSearchOrder`` is available.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if a location search order is\n                available, ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if a location search order is available, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "get_location_search_order", 
               "doc": {
                  "headline": "Gets the search order for a location.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.mapping.LocationSearchOrder) - the location search\n                order", 
               "error_doc": "        raise:  Unimplemented - ``supports_location_search_order()`` is\n                ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the location search order\n        :rtype: ``osid.mapping.LocationSearchOrder``", 
               "sphinx_error_doc": "        :raise: ``Unimplemented`` -- ``supports_location_search_order()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_location_search_order()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.mapping.LocationSearchOrder", 
               "errors": {
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_event_search_order_record", 
               "doc": {
                  "headline": "Gets the event search order record corresponding to the given event record ``Type``.", 
                  "body": "        Multiple retrievals return the same underlying object."
               }, 
               "arg_doc": "        arg:    event_record_type (osid.type.Type): an event record type\n", 
               "return_doc": "        return: (osid.calendaring.records.EventSearchOrderRecord) - the\n                event search order record", 
               "error_doc": "        raise:  NullArgument - ``event_record_type`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unsupported - ``has_record_type(event_record_type)`` is\n                ``false``", 
               "sphinx_param_doc": "        :param event_record_type: an event record type\n        :type event_record_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "        :return: the event search order record\n        :rtype: ``osid.calendaring.records.EventSearchOrderRecord``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``event_record_type`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unsupported`` -- ``has_record_type(event_record_type)`` is ``false``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "event_record_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "osid.calendaring.records.EventSearchOrderRecord", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.calendaring.records.EventSearchOrderRecord", 
         "shortname": "EventSearchOrderRecord", 
         "category": "records", 
         "doc": {
            "headline": "A record for an ``EventSearchOrder``.", 
            "body": "    The methods specified by the record type are available through the\n    underlying object."
         }, 
         "inherit_fullnames": [
            "osid.OsidRecord"
         ], 
         "inherit_shortnames": [
            "OsidRecord"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidRecord"
            }
         ], 
         "method_names": [], 
         "methods": []
      }, 
      {
         "fullname": "osid.calendaring.EventSearch", 
         "shortname": "EventSearch", 
         "category": "searches", 
         "doc": {
            "headline": "``EventSearch`` defines the interface for specifying event search options.", 
            "body": ""
         }, 
         "inherit_fullnames": [
            "osid.OsidSearch"
         ], 
         "inherit_shortnames": [
            "OsidSearch"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidSearch"
            }
         ], 
         "method_names": [
            "search_among_events", 
            "order_event_results", 
            "get_event_search_record"
         ], 
         "methods": [
            {
               "name": "search_among_events", 
               "doc": {
                  "headline": "Execute this search among the given list of events.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    event_ids (osid.id.IdList): list of events\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``event_ids`` is ``null``", 
               "sphinx_param_doc": "        :param event_ids: list of events\n        :type event_ids: ``osid.id.IdList``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``event_ids`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.IdList", 
                     "var_name": "event_ids", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.IdList"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "order_event_results", 
               "doc": {
                  "headline": "Specify an ordering to the search results.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    event_search_order (osid.calendaring.EventSearchOrder):\n                event search order\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``event_search_order`` is ``null``\n        raise:  Unsupported - ``event_search_order`` is not of this\n                service", 
               "sphinx_param_doc": "        :param event_search_order: event search order\n        :type event_search_order: ``osid.calendaring.EventSearchOrder``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``event_search_order`` is ``null``\n        :raise: ``Unsupported`` -- ``event_search_order`` is not of this service", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.calendaring.EventSearchOrder", 
                     "var_name": "event_search_order", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.calendaring.EventSearchOrder"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_event_search_record", 
               "doc": {
                  "headline": "Gets the event search record corresponding to the given event search record ``Type``.", 
                  "body": "        This method is used to retrieve an object implementing the\n        requested record."
               }, 
               "arg_doc": "        arg:    event_search_record_type (osid.type.Type): an event\n                search record type\n", 
               "return_doc": "        return: (osid.calendaring.records.EventSearchRecord) - the event\n                search record", 
               "error_doc": "        raise:  NullArgument - ``event_search_record_type`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unsupported -\n                ``has_record_type(event_search_record_type)`` is\n                ``false``", 
               "sphinx_param_doc": "        :param event_search_record_type: an event search record type\n        :type event_search_record_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "        :return: the event search record\n        :rtype: ``osid.calendaring.records.EventSearchRecord``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``event_search_record_type`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unsupported`` -- ``has_record_type(event_search_record_type)`` is ``false``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "event_search_record_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "osid.calendaring.records.EventSearchRecord", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.calendaring.records.EventSearchRecord", 
         "shortname": "EventSearchRecord", 
         "category": "records", 
         "doc": {
            "headline": "A record for an ``EventSearch``.", 
            "body": "    The methods specified by the record type are available through the\n    underlying object."
         }, 
         "inherit_fullnames": [
            "osid.OsidRecord"
         ], 
         "inherit_shortnames": [
            "OsidRecord"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidRecord"
            }
         ], 
         "method_names": [], 
         "methods": []
      }, 
      {
         "fullname": "osid.calendaring.EventSearchResults", 
         "shortname": "EventSearchResults", 
         "category": "searches", 
         "doc": {
            "headline": "This interface provides a means to capture results of a search.", 
            "body": ""
         }, 
         "inherit_fullnames": [
            "osid.OsidSearchResults"
         ], 
         "inherit_shortnames": [
            "OsidSearchResults"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidSearchResults"
            }
         ], 
         "method_names": [
            "get_events", 
            "get_event_query_inspector", 
            "get_event_search_results_record"
         ], 
         "methods": [
            {
               "name": "get_events", 
               "doc": {
                  "headline": "Gets the event list resulting from the search.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.EventList) - the event list", 
               "error_doc": "        raise:  IllegalState - list already retrieved", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the event list\n        :rtype: ``osid.calendaring.EventList``", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- list already retrieved", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.EventList", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract"
               }
            }, 
            {
               "name": "get_event_query_inspector", 
               "doc": {
                  "headline": "Gets the inspector for the query to examine the terms used in the search.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.EventQueryInspector) - the query\n                inspector", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the query inspector\n        :rtype: ``osid.calendaring.EventQueryInspector``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.EventQueryInspector", 
               "errors": {}
            }, 
            {
               "name": "get_event_search_results_record", 
               "doc": {
                  "headline": "Gets the event search results record corresponding to the given event search record ``Type``.", 
                  "body": "        This method is used to retrieve an object implementing the\n        requested record."
               }, 
               "arg_doc": "        arg:    event_search_record_type (osid.type.Type): an event\n                search record type\n", 
               "return_doc": "        return: (osid.calendaring.records.EventSearchResultsRecord) -\n                the event search results record", 
               "error_doc": "        raise:  NullArgument - ``event_search_record_type`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unsupported -\n                ``has_record_type(event_search_record_type)`` is\n                ``false``", 
               "sphinx_param_doc": "        :param event_search_record_type: an event search record type\n        :type event_search_record_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "        :return: the event search results record\n        :rtype: ``osid.calendaring.records.EventSearchResultsRecord``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``event_search_record_type`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unsupported`` -- ``has_record_type(event_search_record_type)`` is ``false``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "event_search_record_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "osid.calendaring.records.EventSearchResultsRecord", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.calendaring.records.EventSearchResultsRecord", 
         "shortname": "EventSearchResultsRecord", 
         "category": "records", 
         "doc": {
            "headline": "A record for an ``EventSearchResults``.", 
            "body": "    The methods specified by the record type are available through the\n    underlying object."
         }, 
         "inherit_fullnames": [
            "osid.OsidRecord"
         ], 
         "inherit_shortnames": [
            "OsidRecord"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidRecord"
            }
         ], 
         "method_names": [], 
         "methods": []
      }, 
      {
         "fullname": "osid.calendaring.EventReceiver", 
         "shortname": "EventReceiver", 
         "category": "receivers", 
         "doc": {
            "headline": "The event receiver is the consumer supplied interface for receiving notifications pertaining to new, updated or deleted ``Events``.", 
            "body": ""
         }, 
         "inherit_fullnames": [
            "osid.OsidReceiver"
         ], 
         "inherit_shortnames": [
            "OsidReceiver"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidReceiver"
            }
         ], 
         "method_names": [
            "new_event", 
            "changed_event", 
            "deleted_event"
         ], 
         "methods": [
            {
               "name": "new_event", 
               "doc": {
                  "headline": "The callback for notifications of new events.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    event_id (osid.id.Id): the ``Id`` of the new ``Event``\n", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "        :param event_id: the ``Id`` of the new ``Event``\n        :type event_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "event_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "changed_event", 
               "doc": {
                  "headline": "The callback for notification of updated events.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    event_id (osid.id.Id): the ``Id`` of the updated\n                ``Event``\n", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "        :param event_id: the ``Id`` of the updated ``Event``\n        :type event_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "event_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "deleted_event", 
               "doc": {
                  "headline": "The callback for notification of deleted events.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    event_id (osid.id.Id): the ``Id`` of the deleted\n                ``Event``\n", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "        :param event_id: the ``Id`` of the deleted ``Event``\n        :type event_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "event_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {}
            }
         ]
      }, 
      {
         "fullname": "osid.calendaring.EventList", 
         "shortname": "EventList", 
         "category": "objects", 
         "doc": {
            "headline": "Like all ``OsidLists,``  ``EventList`` provides a means for accessing ``Event`` elements sequentially either one at a time or many at a time.", 
            "body": "    Examples: while (el.hasNext()) { Event event = el.getNextEvent(); }\n\n    or\n      while (el.hasNext()) {\n           Event[] events = el.getNextEvents(el.available());\n      }\n    \n"
         }, 
         "inherit_fullnames": [
            "osid.OsidList"
         ], 
         "inherit_shortnames": [
            "OsidList"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidList"
            }
         ], 
         "method_names": [
            "get_next_event", 
            "get_next_events"
         ], 
         "methods": [
            {
               "name": "get_next_event", 
               "doc": {
                  "headline": "Gets the next ``Event`` in this list.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.Event) - the next ``Event`` in this\n                list. The ``has_next()`` method should be used to test\n                that a next ``Event`` is available before calling this\n                method.", 
               "error_doc": "        raise:  IllegalState - no more elements available in this list\n        raise:  OperationFailed - unable to complete request", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the next ``Event`` in this list. The ``has_next()`` method should be used to test that a next ``Event`` is available before calling this method.\n        :rtype: ``osid.calendaring.Event``", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- no more elements available in this list\n        :raise: ``OperationFailed`` -- unable to complete request", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.Event", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational"
               }
            }, 
            {
               "name": "get_next_events", 
               "doc": {
                  "headline": "Gets the next set of ``Event`` elements in this list which must be less than or equal to the number returned from ``available()``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    n (cardinal): the number of ``Event`` elements requested\n                which should be less than or equal to ``available()``\n", 
               "return_doc": "        return: (osid.calendaring.Event) - an array of ``Event``\n                elements.The length of the array is less than or equal\n                to the number specified.", 
               "error_doc": "        raise:  IllegalState - no more elements available in this list\n        raise:  OperationFailed - unable to complete request", 
               "sphinx_param_doc": "        :param n: the number of ``Event`` elements requested which should be less than or equal to ``available()``\n        :type n: ``cardinal``\n", 
               "sphinx_return_doc": "        :return: an array of ``Event`` elements.The length of the array is less than or equal to the number specified.\n        :rtype: ``osid.calendaring.Event``", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- no more elements available in this list\n        :raise: ``OperationFailed`` -- unable to complete request", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "cardinal", 
                     "var_name": "n", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "cardinal"
               ], 
               "return_type": "osid.calendaring.Event", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.calendaring.RecurringEvent", 
         "shortname": "RecurringEvent", 
         "category": "objects", 
         "doc": {
            "headline": "A ``RecurringEvent`` an event that repeats over a set of ``Schedules,`` other events, or custom rule.", 
            "body": "    The active status of the rule informs the appearance of recurring\n    events as events."
         }, 
         "inherit_fullnames": [
            "osid.OsidRule", 
            "osid.Containable"
         ], 
         "inherit_shortnames": [
            "OsidRule", 
            "Containable"
         ], 
         "inherit_pkg_names": [
            "osid", 
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidRule"
            }, 
            {
               "pkg_name": "osid", 
               "name": "Containable"
            }
         ], 
         "method_names": [
            "get_schedule_ids", 
            "get_schedules", 
            "get_superseding_event_ids", 
            "get_superseding_events", 
            "get_specific_meeting_times", 
            "get_event_ids", 
            "get_events", 
            "get_blackouts", 
            "has_sponsors", 
            "get_sponsor_ids", 
            "get_sponsors", 
            "get_recurring_event_record"
         ], 
         "methods": [
            {
               "name": "get_schedule_ids", 
               "doc": {
                  "headline": "Gets the ``Schedule Id`` of this composite event.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.id.IdList) - the recurring schedule ``Ids``", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the recurring schedule ``Ids``\n        :rtype: ``osid.id.IdList``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.id.IdList", 
               "errors": {}
            }, 
            {
               "name": "get_schedules", 
               "doc": {
                  "headline": "Gets the recurring schedule in this composite event.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.ScheduleList) - the recurring\n                schedules", 
               "error_doc": "        raise:  OperationFailed - unable to complete request", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the recurring schedules\n        :rtype: ``osid.calendaring.ScheduleList``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.ScheduleList", 
               "errors": {
                  "OPERATION_FAILED": "Operational"
               }
            }, 
            {
               "name": "get_superseding_event_ids", 
               "doc": {
                  "headline": "Gets the superseding event ``Ids``.", 
                  "body": "        A superseding event is one that replaces another in a series."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.id.IdList) - list of superseding event ``Ids``", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: list of superseding event ``Ids``\n        :rtype: ``osid.id.IdList``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.id.IdList", 
               "errors": {}
            }, 
            {
               "name": "get_superseding_events", 
               "doc": {
                  "headline": "Gets the superseding events.", 
                  "body": "        A superseding event is one that replaces another in a series."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.SupersedingEventList) - list of\n                superseding events", 
               "error_doc": "        raise:  OperationFailed - unable to complete request", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: list of superseding events\n        :rtype: ``osid.calendaring.SupersedingEventList``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.SupersedingEventList", 
               "errors": {
                  "OPERATION_FAILED": "Operational"
               }
            }, 
            {
               "name": "get_specific_meeting_times", 
               "doc": {
                  "headline": "Gets specific dates for this event outside of the schedules.", 
                  "body": "        Specific dates are excluded from blackouts."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.MeetingTimeList) - speciifc list of\n                dates", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: speciifc list of dates\n        :rtype: ``osid.calendaring.MeetingTimeList``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.MeetingTimeList", 
               "errors": {}
            }, 
            {
               "name": "get_event_ids", 
               "doc": {
                  "headline": "Gets the composed event ``Ids``.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.id.IdList) - list of event ``Ids``", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: list of event ``Ids``\n        :rtype: ``osid.id.IdList``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.id.IdList", 
               "errors": {}
            }, 
            {
               "name": "get_events", 
               "doc": {
                  "headline": "Gets the composed events.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.EventList) - list of events", 
               "error_doc": "        raise:  OperationFailed - unable to complete request", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: list of events\n        :rtype: ``osid.calendaring.EventList``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.EventList", 
               "errors": {
                  "OPERATION_FAILED": "Operational"
               }
            }, 
            {
               "name": "get_blackouts", 
               "doc": {
                  "headline": "Gets the blackout dates for this recurring event.", 
                  "body": "        Recurring events overlapping with the time intervals do not\n        appear in their series."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.DateTimeIntervalList) - recurring\n                event exceptions", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: recurring event exceptions\n        :rtype: ``osid.calendaring.DateTimeIntervalList``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.DateTimeIntervalList", 
               "errors": {}
            }, 
            {
               "name": "has_sponsors", 
               "doc": {
                  "headline": "Tests if a sponsor is associated with the overall recurring event.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if there is an associated sponsor.\n                ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if there is an associated sponsor. ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "get_sponsor_ids", 
               "doc": {
                  "headline": "Gets the ``Id`` of the recurring event sponsors.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.id.IdList) - the sponsor ``Ids``", 
               "error_doc": "        raise:  IllegalState - ``has_sponsors()`` is ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the sponsor ``Ids``\n        :rtype: ``osid.id.IdList``", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- ``has_sponsors()`` is ``false``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.id.IdList", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract"
               }
            }, 
            {
               "name": "get_sponsors", 
               "doc": {
                  "headline": "Gets the ``Sponsors``.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.resource.ResourceList) - the sponsors", 
               "error_doc": "        raise:  IllegalState - ``has_sponsors()`` is ``false``\n        raise:  OperationFailed - unable to complete request", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the sponsors\n        :rtype: ``osid.resource.ResourceList``", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- ``has_sponsors()`` is ``false``\n        :raise: ``OperationFailed`` -- unable to complete request", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.resource.ResourceList", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational"
               }
            }, 
            {
               "name": "get_recurring_event_record", 
               "doc": {
                  "headline": "Gets the recurring event record corresponding to the given ``RecurringEvent`` record ``Type``.", 
                  "body": "        This method is used to retrieve an object implementing the\n        requested record. The ``recurring_event_record_type`` may be the\n        ``Type`` returned in ``get_record_types()`` or any of its\n        parents in a ``Type`` hierarchy where\n        ``has_record_type(recurring_event_record_type)`` is ``true`` ."
               }, 
               "arg_doc": "        arg:    recurring_event_record_type (osid.type.Type): the type\n                of the record to retrieve\n", 
               "return_doc": "        return: (osid.calendaring.records.RecurringEventRecord) - the\n                recurring event record", 
               "error_doc": "        raise:  NullArgument - ``recurring_event_record_type`` is\n                ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unsupported -\n                ``has_record_type(recurring_event_record_type)`` is\n                ``false``", 
               "sphinx_param_doc": "        :param recurring_event_record_type: the type of the record to retrieve\n        :type recurring_event_record_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "        :return: the recurring event record\n        :rtype: ``osid.calendaring.records.RecurringEventRecord``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``recurring_event_record_type`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unsupported`` -- ``has_record_type(recurring_event_record_type)`` is ``false``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "recurring_event_record_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "osid.calendaring.records.RecurringEventRecord", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.calendaring.records.RecurringEventRecord", 
         "shortname": "RecurringEventRecord", 
         "category": "records", 
         "doc": {
            "headline": "A record for a ``RecurringEvent``.", 
            "body": "    The methods specified by the record type are available through the\n    underlying object."
         }, 
         "inherit_fullnames": [
            "osid.OsidRecord"
         ], 
         "inherit_shortnames": [
            "OsidRecord"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidRecord"
            }
         ], 
         "method_names": [], 
         "methods": []
      }, 
      {
         "fullname": "osid.calendaring.RecurringEventQuery", 
         "shortname": "RecurringEventQuery", 
         "category": "queries", 
         "doc": {
            "headline": "This is the query for searching recurring events.", 
            "body": "    Each method match request produces an ``AND`` term while multiple\n    invocations of a method produces a nested ``OR``."
         }, 
         "inherit_fullnames": [
            "osid.OsidRuleQuery", 
            "osid.OsidContainableQuery"
         ], 
         "inherit_shortnames": [
            "OsidRuleQuery", 
            "OsidContainableQuery"
         ], 
         "inherit_pkg_names": [
            "osid", 
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidRuleQuery"
            }, 
            {
               "pkg_name": "osid", 
               "name": "OsidContainableQuery"
            }
         ], 
         "method_names": [
            "match_schedule_id", 
            "clear_schedule_id_terms", 
            "supports_schedule_query", 
            "get_schedule_query", 
            "match_any_schedule", 
            "clear_schedule_terms", 
            "match_superseding_event_id", 
            "clear_superseding_event_id_terms", 
            "supports_superseding_event_query", 
            "get_superseding_event_query", 
            "match_any_superseding_event", 
            "clear_superseding_event_terms", 
            "match_specific_meeting_time", 
            "match_any_specific_meeting_time", 
            "clear_specific_meeting_time_terms", 
            "match_event_id", 
            "clear_event_id_terms", 
            "supports_event_query", 
            "get_event_query", 
            "match_any_event", 
            "clear_event_terms", 
            "match_blackout", 
            "match_any_blackout", 
            "clear_blackout_terms", 
            "match_blackout_inclusive", 
            "clear_blackout_inclusive_terms", 
            "match_sponsor_id", 
            "clear_sponsor_id_terms", 
            "supports_sponsor_query", 
            "get_sponsor_query", 
            "clear_sponsor_terms", 
            "match_calendar_id", 
            "clear_calendar_id_terms", 
            "supports_calendar_query", 
            "get_calendar_query", 
            "clear_calendar_terms", 
            "get_recurring_event_query_record"
         ], 
         "methods": [
            {
               "name": "match_schedule_id", 
               "doc": {
                  "headline": "Sets the schedule ``Id`` for this query for matching schedules.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    schedule_id (osid.id.Id): a schedule ``Id``\n        arg:    match (boolean): ``true`` for a positive match,\n                ``false`` for a negative match\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``schedule_id`` is ``null``", 
               "sphinx_param_doc": "        :param schedule_id: a schedule ``Id``\n        :type schedule_id: ``osid.id.Id``\n        :param match: ``true`` for a positive match, ``false`` for a negative match\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``schedule_id`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "schedule_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "clear_schedule_id_terms", 
               "doc": {
                  "headline": "Clears the schedule ``Id`` terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "supports_schedule_query", 
               "doc": {
                  "headline": "Tests if a ``ScheduleQuery`` is available for querying schedules.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if a schedule query is available,\n                ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if a schedule query is available, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "get_schedule_query", 
               "doc": {
                  "headline": "Gets the query for a schedule.", 
                  "body": "        Multiple retrievals produce a nested ``OR`` term."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.ScheduleQuery) - the schedule query", 
               "error_doc": "        raise:  Unimplemented - ``supports_schedule_query()`` is\n                ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the schedule query\n        :rtype: ``osid.calendaring.ScheduleQuery``", 
               "sphinx_error_doc": "        :raise: ``Unimplemented`` -- ``supports_schedule_query()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_schedule_query()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.ScheduleQuery", 
               "errors": {
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "match_any_schedule", 
               "doc": {
                  "headline": "Matches a recurring event that has any schedule assigned.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    match (boolean): ``true`` to match recurring events with\n                any schedules, ``false`` to match recurring events with\n                no schedules\n", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "        :param match: ``true`` to match recurring events with any schedules, ``false`` to match recurring events with no schedules\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "clear_schedule_terms", 
               "doc": {
                  "headline": "Clears the schedule terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "match_superseding_event_id", 
               "doc": {
                  "headline": "Sets the superseding event ``Id`` for this query.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    superseding_event_id (osid.id.Id): a superseding event\n                ``Id``\n        arg:    match (boolean): ``true`` for a positive match,\n                ``false`` for a negative match\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``superseding_event_id`` is ``null``", 
               "sphinx_param_doc": "        :param superseding_event_id: a superseding event ``Id``\n        :type superseding_event_id: ``osid.id.Id``\n        :param match: ``true`` for a positive match, ``false`` for a negative match\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``superseding_event_id`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "superseding_event_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "clear_superseding_event_id_terms", 
               "doc": {
                  "headline": "Clears the superseding event ``Id`` terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "supports_superseding_event_query", 
               "doc": {
                  "headline": "Tests if a ``SupersedingEventQuery`` is available for querying superseding events.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if a superseding event query is\n                available, ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if a superseding event query is available, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "get_superseding_event_query", 
               "doc": {
                  "headline": "Gets the query for a superseding event.", 
                  "body": "        Multiple retrievals produce a nested ``OR`` term."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.SupersedingEventQuery) - the\n                superseding event query", 
               "error_doc": "        raise:  Unimplemented - ``supports_superseding_event_query()``\n                is ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the superseding event query\n        :rtype: ``osid.calendaring.SupersedingEventQuery``", 
               "sphinx_error_doc": "        :raise: ``Unimplemented`` -- ``supports_superseding_event_query()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_superseding_event_query()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.SupersedingEventQuery", 
               "errors": {
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "match_any_superseding_event", 
               "doc": {
                  "headline": "Matches a recurring event that has any superseding event assigned.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    match (boolean): ``true`` to match recurring events with\n                any superseding events, ``false`` to match events with\n                no superseding events\n", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "        :param match: ``true`` to match recurring events with any superseding events, ``false`` to match events with no superseding events\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "clear_superseding_event_terms", 
               "doc": {
                  "headline": "Clears the superseding event terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "match_specific_meeting_time", 
               "doc": {
                  "headline": "Matches recurring events with specific dates between the given range inclusive.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    start (osid.calendaring.DateTime): start date\n        arg:    end (osid.calendaring.DateTime): end date\n        arg:    match (boolean): ``true`` for a positive match,\n                ``false`` for a negative match\n", 
               "return_doc": "", 
               "error_doc": "        raise:  InvalidArgument - ``end`` is less than ``start``\n        raise:  NullArgument - ``start`` or ``end`` is ``zero``", 
               "sphinx_param_doc": "        :param start: start date\n        :type start: ``osid.calendaring.DateTime``\n        :param end: end date\n        :type end: ``osid.calendaring.DateTime``\n        :param match: ``true`` for a positive match, ``false`` for a negative match\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``InvalidArgument`` -- ``end`` is less than ``start``\n        :raise: ``NullArgument`` -- ``start`` or ``end`` is ``zero``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.calendaring.DateTime", 
                     "var_name": "start", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.calendaring.DateTime", 
                     "var_name": "end", 
                     "array": false
                  }, 
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.calendaring.DateTime", 
                  "osid.calendaring.DateTime", 
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {
                  "INVALID_ARGUMENT": "ConsumerContract", 
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "match_any_specific_meeting_time", 
               "doc": {
                  "headline": "Matches a recurring event that has any specific date assigned.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    match (boolean): ``true`` to match recurring events with\n                any specific date, ``false`` to match recurring events\n                with no specific date\n", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "        :param match: ``true`` to match recurring events with any specific date, ``false`` to match recurring events with no specific date\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "clear_specific_meeting_time_terms", 
               "doc": {
                  "headline": "Clears the blackout terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "match_event_id", 
               "doc": {
                  "headline": "Sets the composed event ``Id`` for this query.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    event_id (osid.id.Id): an event ``Id``\n        arg:    match (boolean): ``true`` for a positive match,\n                ``false`` for a negative match\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``event_id`` is ``null``", 
               "sphinx_param_doc": "        :param event_id: an event ``Id``\n        :type event_id: ``osid.id.Id``\n        :param match: ``true`` for a positive match, ``false`` for a negative match\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``event_id`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "event_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "clear_event_id_terms", 
               "doc": {
                  "headline": "Clears the event ``Id`` terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "supports_event_query", 
               "doc": {
                  "headline": "Tests if an ``EventQuery`` is available for querying composed events.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if an event query is available,\n                ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if an event query is available, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "get_event_query", 
               "doc": {
                  "headline": "Gets the query for an event.", 
                  "body": "        Multiple retrievals produce a nested ``OR`` term."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.EventQuery) - the event query", 
               "error_doc": "        raise:  Unimplemented - ``supports_event_query()`` is ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the event query\n        :rtype: ``osid.calendaring.EventQuery``", 
               "sphinx_error_doc": "        :raise: ``Unimplemented`` -- ``supports_event_query()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_event_query()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.EventQuery", 
               "errors": {
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "match_any_event", 
               "doc": {
                  "headline": "Matches a recurring event that has any composed event assigned.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    match (boolean): ``true`` to match recurring events with\n                any composed events, ``false`` to match events with no\n                composed events\n", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "        :param match: ``true`` to match recurring events with any composed events, ``false`` to match events with no composed events\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "clear_event_terms", 
               "doc": {
                  "headline": "Clears the event terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "match_blackout", 
               "doc": {
                  "headline": "Matches a blackout that contains the given date time.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    datetime (osid.calendaring.DateTime): a datetime\n        arg:    match (boolean): ``true`` for a positive match,\n                ``false`` for a negative match\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``datetime`` is ``null``", 
               "sphinx_param_doc": "        :param datetime: a datetime\n        :type datetime: ``osid.calendaring.DateTime``\n        :param match: ``true`` for a positive match, ``false`` for a negative match\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``datetime`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.calendaring.DateTime", 
                     "var_name": "datetime", 
                     "array": false
                  }, 
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.calendaring.DateTime", 
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "match_any_blackout", 
               "doc": {
                  "headline": "Matches a recurring event that has any blackout assigned.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    match (boolean): ``true`` to match recurring events with\n                any blackout, ``false`` to match recurring events with\n                no blackout\n", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "        :param match: ``true`` to match recurring events with any blackout, ``false`` to match recurring events with no blackout\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "clear_blackout_terms", 
               "doc": {
                  "headline": "Clears the blackout terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "match_blackout_inclusive", 
               "doc": {
                  "headline": "Matches recurring events with blackouts between the given range inclusive.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    start (osid.calendaring.DateTime): start date\n        arg:    end (osid.calendaring.DateTime): end date\n        arg:    match (boolean): ``true`` for a positive match,\n                ``false`` for a negative match\n", 
               "return_doc": "", 
               "error_doc": "        raise:  InvalidArgument - ``end`` is less than ``start``\n        raise:  NullArgument - ``start`` or ``end`` is ``zero``", 
               "sphinx_param_doc": "        :param start: start date\n        :type start: ``osid.calendaring.DateTime``\n        :param end: end date\n        :type end: ``osid.calendaring.DateTime``\n        :param match: ``true`` for a positive match, ``false`` for a negative match\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``InvalidArgument`` -- ``end`` is less than ``start``\n        :raise: ``NullArgument`` -- ``start`` or ``end`` is ``zero``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.calendaring.DateTime", 
                     "var_name": "start", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.calendaring.DateTime", 
                     "var_name": "end", 
                     "array": false
                  }, 
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.calendaring.DateTime", 
                  "osid.calendaring.DateTime", 
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {
                  "INVALID_ARGUMENT": "ConsumerContract", 
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "clear_blackout_inclusive_terms", 
               "doc": {
                  "headline": "Clears the blackout terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "match_sponsor_id", 
               "doc": {
                  "headline": "Sets the sponsor ``Id`` for this query.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    sponsor_id (osid.id.Id): a sponsor ``Id``\n        arg:    match (boolean): ``true`` for a positive match,\n                ``false`` for a negative match\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``sponsor_id`` is ``null``", 
               "sphinx_param_doc": "        :param sponsor_id: a sponsor ``Id``\n        :type sponsor_id: ``osid.id.Id``\n        :param match: ``true`` for a positive match, ``false`` for a negative match\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``sponsor_id`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "sponsor_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "clear_sponsor_id_terms", 
               "doc": {
                  "headline": "Clears the sponsor ``Id`` terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "supports_sponsor_query", 
               "doc": {
                  "headline": "Tests if a ``LocationQuery`` is available for querying sponsors.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if a sponsor query is available,\n                ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if a sponsor query is available, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "get_sponsor_query", 
               "doc": {
                  "headline": "Gets the query for a sponsor.", 
                  "body": "        Multiple retrievals produce a nested ``OR`` term."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.resource.ResourceQuery) - the sponsor query", 
               "error_doc": "        raise:  Unimplemented - ``supports_sponsor_query()`` is\n                ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the sponsor query\n        :rtype: ``osid.resource.ResourceQuery``", 
               "sphinx_error_doc": "        :raise: ``Unimplemented`` -- ``supports_sponsor_query()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_sponsor_query()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.resource.ResourceQuery", 
               "errors": {
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "clear_sponsor_terms", 
               "doc": {
                  "headline": "Clears the sponsor terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "match_calendar_id", 
               "doc": {
                  "headline": "Sets the calendar ``Id`` for this query.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    calendar_id (osid.id.Id): a calendar ``Id``\n        arg:    match (boolean): ``true`` for a positive match,\n                ``false`` for a negative match\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``calendar_id`` is ``null``", 
               "sphinx_param_doc": "        :param calendar_id: a calendar ``Id``\n        :type calendar_id: ``osid.id.Id``\n        :param match: ``true`` for a positive match, ``false`` for a negative match\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``calendar_id`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "calendar_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "clear_calendar_id_terms", 
               "doc": {
                  "headline": "Clears the calendar ``Id`` terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "supports_calendar_query", 
               "doc": {
                  "headline": "Tests if a ``CalendarQuery`` is available for querying calendars.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if a calendar query is available,\n                ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if a calendar query is available, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "get_calendar_query", 
               "doc": {
                  "headline": "Gets the query for a calendar.", 
                  "body": "        Multiple retrievals produce a nested ``OR`` term."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.CalendarQuery) - the calendar query", 
               "error_doc": "        raise:  Unimplemented - ``supports_calendar_query()`` is\n                ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the calendar query\n        :rtype: ``osid.calendaring.CalendarQuery``", 
               "sphinx_error_doc": "        :raise: ``Unimplemented`` -- ``supports_calendar_query()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_calendar_query()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.CalendarQuery", 
               "errors": {
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "clear_calendar_terms", 
               "doc": {
                  "headline": "Clears the calendar terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "get_recurring_event_query_record", 
               "doc": {
                  "headline": "Gets the recurring event query recod corresponding to the given ``RecurringEvent`` record ``Type``.", 
                  "body": "        Multiple retrievals produce a nested ``OR`` term."
               }, 
               "arg_doc": "        arg:    recurring_event_record_type (osid.type.Type): a\n                recurring event query record type\n", 
               "return_doc": "        return: (osid.calendaring.records.RecurringEventQueryRecord) -\n                the recurring event query record", 
               "error_doc": "        raise:  NullArgument - ``recurring_event_record_type`` is\n                ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unsupported -\n                ``has_record_type(recurring_event_record_type)`` is\n                ``false``", 
               "sphinx_param_doc": "        :param recurring_event_record_type: a recurring event query record type\n        :type recurring_event_record_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "        :return: the recurring event query record\n        :rtype: ``osid.calendaring.records.RecurringEventQueryRecord``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``recurring_event_record_type`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unsupported`` -- ``has_record_type(recurring_event_record_type)`` is ``false``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "recurring_event_record_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "osid.calendaring.records.RecurringEventQueryRecord", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.calendaring.records.RecurringEventQueryRecord", 
         "shortname": "RecurringEventQueryRecord", 
         "category": "records", 
         "doc": {
            "headline": "A record for a ``RecurringEventQuery``.", 
            "body": "    The methods specified by the record type are available through the\n    underlying object."
         }, 
         "inherit_fullnames": [
            "osid.OsidRecord"
         ], 
         "inherit_shortnames": [
            "OsidRecord"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidRecord"
            }
         ], 
         "method_names": [], 
         "methods": []
      }, 
      {
         "fullname": "osid.calendaring.RecurringEventQueryInspector", 
         "shortname": "RecurringEventQueryInspector", 
         "category": "query_inspectors", 
         "doc": {
            "headline": "This is the query inspector for examining recurring event queries.", 
            "body": ""
         }, 
         "inherit_fullnames": [
            "osid.OsidRuleQueryInspector", 
            "osid.OsidContainableQueryInspector"
         ], 
         "inherit_shortnames": [
            "OsidRuleQueryInspector", 
            "OsidContainableQueryInspector"
         ], 
         "inherit_pkg_names": [
            "osid", 
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidRuleQueryInspector"
            }, 
            {
               "pkg_name": "osid", 
               "name": "OsidContainableQueryInspector"
            }
         ], 
         "method_names": [
            "get_schedule_id_terms", 
            "get_schedule_terms", 
            "get_superseding_event_id_terms", 
            "get_superseding_event_terms", 
            "get_event_id_terms", 
            "get_event_terms", 
            "get_blackout_terms", 
            "get_blackout_inclusive_terms", 
            "get_sponsor_id_terms", 
            "get_sponsor_terms", 
            "get_specific_meeting_time_terms", 
            "get_calendar_id_terms", 
            "get_calendar_terms", 
            "get_recurring_event_query_inspector_record"
         ], 
         "methods": [
            {
               "name": "get_schedule_id_terms", 
               "doc": {
                  "headline": "Gets the schedule ``Id`` terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.search.terms.IdTerm) - the schedule ``Id`` terms", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the schedule ``Id`` terms\n        :rtype: ``osid.search.terms.IdTerm``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.search.terms.IdTerm", 
               "errors": {}
            }, 
            {
               "name": "get_schedule_terms", 
               "doc": {
                  "headline": "Gets the schedule terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.ScheduleQueryInspector) - the schedule\n                terms", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the schedule terms\n        :rtype: ``osid.calendaring.ScheduleQueryInspector``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.ScheduleQueryInspector", 
               "errors": {}
            }, 
            {
               "name": "get_superseding_event_id_terms", 
               "doc": {
                  "headline": "Gets the superseding event ``Id`` terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.search.terms.IdTerm) - the superseding event\n                ``Id`` terms", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the superseding event ``Id`` terms\n        :rtype: ``osid.search.terms.IdTerm``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.search.terms.IdTerm", 
               "errors": {}
            }, 
            {
               "name": "get_superseding_event_terms", 
               "doc": {
                  "headline": "Gets the superseding event terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.SupersedingEventQueryInspector) - the\n                superseding event terms", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the superseding event terms\n        :rtype: ``osid.calendaring.SupersedingEventQueryInspector``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.SupersedingEventQueryInspector", 
               "errors": {}
            }, 
            {
               "name": "get_event_id_terms", 
               "doc": {
                  "headline": "Gets the event ``Id`` terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.search.terms.IdTerm) - the event ``Id`` terms", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the event ``Id`` terms\n        :rtype: ``osid.search.terms.IdTerm``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.search.terms.IdTerm", 
               "errors": {}
            }, 
            {
               "name": "get_event_terms", 
               "doc": {
                  "headline": "Gets the event terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.EventQueryInspector) - the event terms", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the event terms\n        :rtype: ``osid.calendaring.EventQueryInspector``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.EventQueryInspector", 
               "errors": {}
            }, 
            {
               "name": "get_blackout_terms", 
               "doc": {
                  "headline": "Gets the blackout terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.search.terms.DateTimeTerm) - the time terms", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the time terms\n        :rtype: ``osid.search.terms.DateTimeTerm``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.search.terms.DateTimeTerm", 
               "errors": {}
            }, 
            {
               "name": "get_blackout_inclusive_terms", 
               "doc": {
                  "headline": "Gets the inclusive blackout terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.search.terms.DateTimeRangeTerm) - the time range\n                terms", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the time range terms\n        :rtype: ``osid.search.terms.DateTimeRangeTerm``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.search.terms.DateTimeRangeTerm", 
               "errors": {}
            }, 
            {
               "name": "get_sponsor_id_terms", 
               "doc": {
                  "headline": "Gets the sponsor ``Id`` terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.search.terms.IdTerm) - the sponsor ``Id`` terms", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the sponsor ``Id`` terms\n        :rtype: ``osid.search.terms.IdTerm``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.search.terms.IdTerm", 
               "errors": {}
            }, 
            {
               "name": "get_sponsor_terms", 
               "doc": {
                  "headline": "Gets the sponsor terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.resource.ResourceQueryInspector) - the sponsor\n                terms", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the sponsor terms\n        :rtype: ``osid.resource.ResourceQueryInspector``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.resource.ResourceQueryInspector", 
               "errors": {}
            }, 
            {
               "name": "get_specific_meeting_time_terms", 
               "doc": {
                  "headline": "Gets the date terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.search.terms.DateTimeTerm) - the time terms", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the time terms\n        :rtype: ``osid.search.terms.DateTimeTerm``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.search.terms.DateTimeTerm", 
               "errors": {}
            }, 
            {
               "name": "get_calendar_id_terms", 
               "doc": {
                  "headline": "Gets the calendar ``Id`` terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.search.terms.IdTerm) - the calendar ``Id`` terms", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the calendar ``Id`` terms\n        :rtype: ``osid.search.terms.IdTerm``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.search.terms.IdTerm", 
               "errors": {}
            }, 
            {
               "name": "get_calendar_terms", 
               "doc": {
                  "headline": "Gets the calendar terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.CalendarQueryInspector) - the calendar\n                terms", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the calendar terms\n        :rtype: ``osid.calendaring.CalendarQueryInspector``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.CalendarQueryInspector", 
               "errors": {}
            }, 
            {
               "name": "get_recurring_event_query_inspector_record", 
               "doc": {
                  "headline": "Gets the recurring event query inspector record corresponding to the given ``RecurringEvent`` record ``Type``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    recurring_event_record_type (osid.type.Type): a\n                recurring event query record type\n", 
               "return_doc": "        return:\n                (osid.calendaring.records.RecurringEventQueryInspectorRe\n                cord) - the recurring event query inspector record", 
               "error_doc": "        raise:  NullArgument - ``recurring_event_record_type`` is\n                ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unsupported -\n                ``has_record_type(recurring_event_record_type)`` is\n                ``false``", 
               "sphinx_param_doc": "        :param recurring_event_record_type: a recurring event query record type\n        :type recurring_event_record_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "        :return: the recurring event query inspector record\n        :rtype: ``osid.calendaring.records.RecurringEventQueryInspectorRecord``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``recurring_event_record_type`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unsupported`` -- ``has_record_type(recurring_event_record_type)`` is ``false``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "recurring_event_record_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "osid.calendaring.records.RecurringEventQueryInspectorRecord", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.calendaring.records.RecurringEventQueryInspectorRecord", 
         "shortname": "RecurringEventQueryInspectorRecord", 
         "category": "records", 
         "doc": {
            "headline": "A record for a ``RecurringEventQueryInspector``.", 
            "body": "    The methods specified by the record type are available through the\n    underlying object."
         }, 
         "inherit_fullnames": [
            "osid.OsidRecord"
         ], 
         "inherit_shortnames": [
            "OsidRecord"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidRecord"
            }
         ], 
         "method_names": [], 
         "methods": []
      }, 
      {
         "fullname": "osid.calendaring.RecurringEventForm", 
         "shortname": "RecurringEventForm", 
         "category": "objects", 
         "doc": {
            "headline": "This is the form for creating and updating ``RecurringEvents``.", 
            "body": "    Like all ``OsidForm`` objects, various data elements may be set here\n    for use in the create and update methods in the\n    ``RecurringEventAdminSession``. For each data element that may be\n    set, metadata may be examined to provide display hints or data\n    constraints."
         }, 
         "inherit_fullnames": [
            "osid.OsidRuleForm", 
            "osid.OsidContainableForm"
         ], 
         "inherit_shortnames": [
            "OsidRuleForm", 
            "OsidContainableForm"
         ], 
         "inherit_pkg_names": [
            "osid", 
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidRuleForm"
            }, 
            {
               "pkg_name": "osid", 
               "name": "OsidContainableForm"
            }
         ], 
         "method_names": [
            "get_sponsor_metadata", 
            "set_sponsors", 
            "clear_sponsors", 
            "get_recurring_event_form_record"
         ], 
         "methods": [
            {
               "name": "get_sponsor_metadata", 
               "doc": {
                  "headline": "Gets the metadata for a sponsor.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.Metadata) - metadata for the sponsor", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: metadata for the sponsor\n        :rtype: ``osid.Metadata``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.Metadata", 
               "errors": {}
            }, 
            {
               "name": "set_sponsors", 
               "doc": {
                  "headline": "Sets the sponsors.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    sponsor_ids (osid.id.Id[]): the new sponsor\n", 
               "return_doc": "", 
               "error_doc": "        raise:  InvalidArgument - ``sponsor_ids`` is invalid\n        raise:  NoAccess - ``sponsor_ids`` cannot be modified\n        raise:  NullArgument - ``sponsor_ids`` is ``null``", 
               "sphinx_param_doc": "        :param sponsor_ids: the new sponsor\n        :type sponsor_ids: ``osid.id.Id[]``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``InvalidArgument`` -- ``sponsor_ids`` is invalid\n        :raise: ``NoAccess`` -- ``sponsor_ids`` cannot be modified\n        :raise: ``NullArgument`` -- ``sponsor_ids`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id[]", 
                     "var_name": "sponsor_ids", 
                     "array": true
                  }
               ], 
               "arg_types": [
                  "osid.id.Id[]"
               ], 
               "return_type": "", 
               "errors": {
                  "INVALID_ARGUMENT": "ConsumerContract", 
                  "NO_ACCESS": "ConsumerContract", 
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "clear_sponsors", 
               "doc": {
                  "headline": "Clears the sponsors.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "        raise:  NoAccess - ``Metadata.isRequired()`` or\n                ``Metadata.isReadOnly()`` is ``true``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NoAccess`` -- ``Metadata.isRequired()`` or ``Metadata.isReadOnly()`` is ``true``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {
                  "NO_ACCESS": "ConsumerContract"
               }
            }, 
            {
               "name": "get_recurring_event_form_record", 
               "doc": {
                  "headline": "Gets the ``RecurringEventFormRecord`` corresponding to the given recurring event record ``Type``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    recurring_event_record_type (osid.type.Type): the\n                recurring event record type\n", 
               "return_doc": "        return: (osid.calendaring.records.RecurringEventFormRecord) -\n                the recurring event form record", 
               "error_doc": "        raise:  NullArgument - ``recurring_event_record_type`` is\n                ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unsupported -\n                ``has_record_type(recurring_event_record_type)`` is\n                ``false``", 
               "sphinx_param_doc": "        :param recurring_event_record_type: the recurring event record type\n        :type recurring_event_record_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "        :return: the recurring event form record\n        :rtype: ``osid.calendaring.records.RecurringEventFormRecord``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``recurring_event_record_type`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unsupported`` -- ``has_record_type(recurring_event_record_type)`` is ``false``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "recurring_event_record_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "osid.calendaring.records.RecurringEventFormRecord", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.calendaring.records.RecurringEventFormRecord", 
         "shortname": "RecurringEventFormRecord", 
         "category": "records", 
         "doc": {
            "headline": "A record for a ``RecurringEventForm``.", 
            "body": "    The methods specified by the record type are available through the\n    underlying object."
         }, 
         "inherit_fullnames": [
            "osid.OsidRecord"
         ], 
         "inherit_shortnames": [
            "OsidRecord"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidRecord"
            }
         ], 
         "method_names": [], 
         "methods": []
      }, 
      {
         "fullname": "osid.calendaring.RecurringEventSearchOrder", 
         "shortname": "RecurringEventSearchOrder", 
         "category": "search_orders", 
         "doc": {
            "headline": "An interface for specifying the ordering of search results.", 
            "body": ""
         }, 
         "inherit_fullnames": [
            "osid.OsidRuleSearchOrder", 
            "osid.OsidContainableSearchOrder"
         ], 
         "inherit_shortnames": [
            "OsidRuleSearchOrder", 
            "OsidContainableSearchOrder"
         ], 
         "inherit_pkg_names": [
            "osid", 
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidRuleSearchOrder"
            }, 
            {
               "pkg_name": "osid", 
               "name": "OsidContainableSearchOrder"
            }
         ], 
         "method_names": [
            "get_recurring_event_search_order_record"
         ], 
         "methods": [
            {
               "name": "get_recurring_event_search_order_record", 
               "doc": {
                  "headline": "Gets the recurring event search order record corresponding to the given event record ``Type``.", 
                  "body": "        Multiple retrievals return the same underlying object."
               }, 
               "arg_doc": "        arg:    recurring_event_record_type (osid.type.Type): a\n                recurring event record type\n", 
               "return_doc": "        return:\n                (osid.calendaring.records.RecurringEventSearchOrderRecor\n                d) - the recurring event search order record", 
               "error_doc": "        raise:  NullArgument - ``recurring_event_record_type`` is\n                ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unsupported -\n                ``has_record_type(recurring_event_record_type)`` is\n                ``false``", 
               "sphinx_param_doc": "        :param recurring_event_record_type: a recurring event record type\n        :type recurring_event_record_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "        :return: the recurring event search order record\n        :rtype: ``osid.calendaring.records.RecurringEventSearchOrderRecord``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``recurring_event_record_type`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unsupported`` -- ``has_record_type(recurring_event_record_type)`` is ``false``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "recurring_event_record_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "osid.calendaring.records.RecurringEventSearchOrderRecord", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.calendaring.records.RecurringEventSearchOrderRecord", 
         "shortname": "RecurringEventSearchOrderRecord", 
         "category": "records", 
         "doc": {
            "headline": "A record for a ``RecurringEventSearchOrder``.", 
            "body": "    The methods specified by the record type are available through the\n    underlying object."
         }, 
         "inherit_fullnames": [
            "osid.OsidRecord"
         ], 
         "inherit_shortnames": [
            "OsidRecord"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidRecord"
            }
         ], 
         "method_names": [], 
         "methods": []
      }, 
      {
         "fullname": "osid.calendaring.RecurringEventSearch", 
         "shortname": "RecurringEventSearch", 
         "category": "searches", 
         "doc": {
            "headline": "``RecurringEventSearch`` defines the interface for specifying recurring event search options.", 
            "body": ""
         }, 
         "inherit_fullnames": [
            "osid.OsidSearch"
         ], 
         "inherit_shortnames": [
            "OsidSearch"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidSearch"
            }
         ], 
         "method_names": [
            "search_among_recurring_events", 
            "order_recurring_event_results", 
            "get_recurring_event_search_record"
         ], 
         "methods": [
            {
               "name": "search_among_recurring_events", 
               "doc": {
                  "headline": "Execute this search among the given list of recurring events.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    recurring_event_ids (osid.id.IdList): list of recurring\n                events\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``recurring_event_ids`` is ``null``", 
               "sphinx_param_doc": "        :param recurring_event_ids: list of recurring events\n        :type recurring_event_ids: ``osid.id.IdList``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``recurring_event_ids`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.IdList", 
                     "var_name": "recurring_event_ids", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.IdList"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "order_recurring_event_results", 
               "doc": {
                  "headline": "Specify an ordering to the search results.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    recurring_event_search_order\n                (osid.calendaring.RecurringEventSearchOrder): recurring\n                event search order\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``recurring_event_search_order`` is\n                ``null``\n        raise:  Unsupported - ``recurring_event_search_order`` is not of\n                this service", 
               "sphinx_param_doc": "        :param recurring_event_search_order: recurring event search order\n        :type recurring_event_search_order: ``osid.calendaring.RecurringEventSearchOrder``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``recurring_event_search_order`` is ``null``\n        :raise: ``Unsupported`` -- ``recurring_event_search_order`` is not of this service", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.calendaring.RecurringEventSearchOrder", 
                     "var_name": "recurring_event_search_order", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.calendaring.RecurringEventSearchOrder"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_recurring_event_search_record", 
               "doc": {
                  "headline": "Gets the recurring event record corresponding to the given recurring event search record ``Type``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    recurring_event_search_record_type (osid.type.Type): a\n                recurring event search record type\n", 
               "return_doc": "        return: (osid.calendaring.records.RecurringEventSearchRecord) -\n                the recurring event search record", 
               "error_doc": "        raise:  NullArgument - ``recurring_event_search_record_type`` is\n                ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unsupported -\n                ``has_record_type(recurring_event_search_record_type)``\n                is ``false``", 
               "sphinx_param_doc": "        :param recurring_event_search_record_type: a recurring event search record type\n        :type recurring_event_search_record_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "        :return: the recurring event search record\n        :rtype: ``osid.calendaring.records.RecurringEventSearchRecord``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``recurring_event_search_record_type`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unsupported`` -- ``has_record_type(recurring_event_search_record_type)`` is ``false``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "recurring_event_search_record_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "osid.calendaring.records.RecurringEventSearchRecord", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.calendaring.records.RecurringEventSearchRecord", 
         "shortname": "RecurringEventSearchRecord", 
         "category": "records", 
         "doc": {
            "headline": "A record for a ``RecurringEventSearch``.", 
            "body": "    The methods specified by the record type are available through the\n    underlying object."
         }, 
         "inherit_fullnames": [
            "osid.OsidRecord"
         ], 
         "inherit_shortnames": [
            "OsidRecord"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidRecord"
            }
         ], 
         "method_names": [], 
         "methods": []
      }, 
      {
         "fullname": "osid.calendaring.RecurringEventSearchResults", 
         "shortname": "RecurringEventSearchResults", 
         "category": "searches", 
         "doc": {
            "headline": "This interface provides a means to capture results of a search.", 
            "body": ""
         }, 
         "inherit_fullnames": [
            "osid.OsidSearchResults"
         ], 
         "inherit_shortnames": [
            "OsidSearchResults"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidSearchResults"
            }
         ], 
         "method_names": [
            "get_recurring_events", 
            "get_recurring_event_query_inspector", 
            "get_recurring_event_search_results_record"
         ], 
         "methods": [
            {
               "name": "get_recurring_events", 
               "doc": {
                  "headline": "Gets the recurring event list resulting from the search.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.RecurringEventList) - the recurring\n                event list", 
               "error_doc": "        raise:  IllegalState - list already retrieved", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the recurring event list\n        :rtype: ``osid.calendaring.RecurringEventList``", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- list already retrieved", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.RecurringEventList", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract"
               }
            }, 
            {
               "name": "get_recurring_event_query_inspector", 
               "doc": {
                  "headline": "Gets the inspector for the query to examine the terms used in the search.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.RecurringEventQueryInspector) - the\n                query inspector", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the query inspector\n        :rtype: ``osid.calendaring.RecurringEventQueryInspector``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.RecurringEventQueryInspector", 
               "errors": {}
            }, 
            {
               "name": "get_recurring_event_search_results_record", 
               "doc": {
                  "headline": "Gets the recurring event search results record corresponding to the given recurring event search record ``Type``.", 
                  "body": "        This method is used to retrieve an object implementing the\n        requested record."
               }, 
               "arg_doc": "        arg:    recurring_event_search_record_type (osid.type.Type): a\n                recurring event search record type\n", 
               "return_doc": "        return:\n                (osid.calendaring.records.RecurringEventSearchResultsRec\n                ord) - the recurring event search results record", 
               "error_doc": "        raise:  NullArgument - ``recurring_event_search_record_type`` is\n                ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unsupported -\n                ``has_record_type(recurring_event_search_record_type)``\n                is ``false``", 
               "sphinx_param_doc": "        :param recurring_event_search_record_type: a recurring event search record type\n        :type recurring_event_search_record_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "        :return: the recurring event search results record\n        :rtype: ``osid.calendaring.records.RecurringEventSearchResultsRecord``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``recurring_event_search_record_type`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unsupported`` -- ``has_record_type(recurring_event_search_record_type)`` is ``false``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "recurring_event_search_record_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "osid.calendaring.records.RecurringEventSearchResultsRecord", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.calendaring.records.RecurringEventSearchResultsRecord", 
         "shortname": "RecurringEventSearchResultsRecord", 
         "category": "records", 
         "doc": {
            "headline": "A record for a ``RecurringEventSearchResults``.", 
            "body": "    The methods specified by the record type are available through the\n    underlying object."
         }, 
         "inherit_fullnames": [
            "osid.OsidRecord"
         ], 
         "inherit_shortnames": [
            "OsidRecord"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidRecord"
            }
         ], 
         "method_names": [], 
         "methods": []
      }, 
      {
         "fullname": "osid.calendaring.RecurringEventReceiver", 
         "shortname": "RecurringEventReceiver", 
         "category": "receivers", 
         "doc": {
            "headline": "The recurring event receiver is the consumer supplied interface for receiving notifications pertaining to new, updated or deleted ``RecurringEvents``.", 
            "body": ""
         }, 
         "inherit_fullnames": [
            "osid.OsidReceiver"
         ], 
         "inherit_shortnames": [
            "OsidReceiver"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidReceiver"
            }
         ], 
         "method_names": [
            "new_recurring_event", 
            "changed_recurring_event", 
            "deleted_recurring_event"
         ], 
         "methods": [
            {
               "name": "new_recurring_event", 
               "doc": {
                  "headline": "The callback for notifications of new recurring events.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    recurring_event_id (osid.id.Id): the ``Id`` of the new\n                ``RecurringEvent``\n", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "        :param recurring_event_id: the ``Id`` of the new ``RecurringEvent``\n        :type recurring_event_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "recurring_event_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "changed_recurring_event", 
               "doc": {
                  "headline": "The callback for notification of updated recurring events.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    recurring_event_id (osid.id.Id): the ``Id`` of the\n                updated ``RecurringEvent``\n", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "        :param recurring_event_id: the ``Id`` of the updated ``RecurringEvent``\n        :type recurring_event_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "recurring_event_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "deleted_recurring_event", 
               "doc": {
                  "headline": "The callback for notification of deleted recurring events.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    recurring_event_id (osid.id.Id): the ``Id`` of the\n                deleted ``RecurringEvent``\n", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "        :param recurring_event_id: the ``Id`` of the deleted ``RecurringEvent``\n        :type recurring_event_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "recurring_event_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {}
            }
         ]
      }, 
      {
         "fullname": "osid.calendaring.RecurringEventList", 
         "shortname": "RecurringEventList", 
         "category": "objects", 
         "doc": {
            "headline": "Like all ``OsidLists,``  ``RecurringEventList`` provides a means for accessing ``RecurringEvent`` elements sequentially either one at a time or many at a time.", 
            "body": "    Examples: while (rel.hasNext()) { RecurringEvent event =\n    rel.getNextRecurringEvent(); }\n\n    or\n      while (rel.hasNext()) {\n           RecurringEvent[] events = rel.getNextRecurringEvents(rel.available());\n      }\n    \n"
         }, 
         "inherit_fullnames": [
            "osid.OsidList"
         ], 
         "inherit_shortnames": [
            "OsidList"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidList"
            }
         ], 
         "method_names": [
            "get_next_recurring_event", 
            "get_next_recurring_events"
         ], 
         "methods": [
            {
               "name": "get_next_recurring_event", 
               "doc": {
                  "headline": "Gets the next ``RecurringEvent`` in this list.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.RecurringEvent) - the next\n                ``RecurringEvent`` in this list. The ``has_next()``\n                method should be used to test that a next\n                ``RecurringEvent`` is available before calling this\n                method.", 
               "error_doc": "        raise:  IllegalState - no more elements available in this list\n        raise:  OperationFailed - unable to complete request", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the next ``RecurringEvent`` in this list. The ``has_next()`` method should be used to test that a next ``RecurringEvent`` is available before calling this method.\n        :rtype: ``osid.calendaring.RecurringEvent``", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- no more elements available in this list\n        :raise: ``OperationFailed`` -- unable to complete request", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.RecurringEvent", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational"
               }
            }, 
            {
               "name": "get_next_recurring_events", 
               "doc": {
                  "headline": "Gets the next set of ``RecurringEvent`` elements in this list which must be less than or equal to the number returned from ``available()``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    n (cardinal): the number of ``RecurringEvent`` elements\n                requested which should be less than or equal to\n                ``available()``\n", 
               "return_doc": "        return: (osid.calendaring.RecurringEvent) - an array of\n                ``RecurringEvent`` elements.The length of the array is\n                less than or equal to the number specified.", 
               "error_doc": "        raise:  IllegalState - no more elements available in this list\n        raise:  OperationFailed - unable to complete request", 
               "sphinx_param_doc": "        :param n: the number of ``RecurringEvent`` elements requested which should be less than or equal to ``available()``\n        :type n: ``cardinal``\n", 
               "sphinx_return_doc": "        :return: an array of ``RecurringEvent`` elements.The length of the array is less than or equal to the number specified.\n        :rtype: ``osid.calendaring.RecurringEvent``", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- no more elements available in this list\n        :raise: ``OperationFailed`` -- unable to complete request", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "cardinal", 
                     "var_name": "n", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "cardinal"
               ], 
               "return_type": "osid.calendaring.RecurringEvent", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.calendaring.SupersedingEvent", 
         "shortname": "SupersedingEvent", 
         "category": "objects", 
         "doc": {
            "headline": "A ``SupersedingEvent`` represents an override of an event such as an individual item in a recurring series.", 
            "body": "    The event which is to supersede another must already be created. The\n    ``SupersedingEvent`` rule causes the superseded ``Event`` to be\n    overidden with the superseding ``Event`` at the superseding\n    ``Event`` 's date and time."
         }, 
         "inherit_fullnames": [
            "osid.OsidRule"
         ], 
         "inherit_shortnames": [
            "OsidRule"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidRule"
            }
         ], 
         "method_names": [
            "get_superseded_event_id", 
            "get_superseded_event", 
            "get_superseding_event_id", 
            "get_superseding_event", 
            "supersedes_by_date", 
            "get_superseded_date", 
            "supersedes_by_position", 
            "get_superseded_event_position", 
            "get_superseding_event_record"
         ], 
         "methods": [
            {
               "name": "get_superseded_event_id", 
               "doc": {
                  "headline": "Gets the event ``Id`` that is to be superseded.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.id.Id) - the superseding event ``Id``", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the superseding event ``Id``\n        :rtype: ``osid.id.Id``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.id.Id", 
               "errors": {}
            }, 
            {
               "name": "get_superseded_event", 
               "doc": {
                  "headline": "Gets the event that is to be superseded.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.Event) - the superseding event", 
               "error_doc": "        raise:  OperationFailed - unable to complete request", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the superseding event\n        :rtype: ``osid.calendaring.Event``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.Event", 
               "errors": {
                  "OPERATION_FAILED": "Operational"
               }
            }, 
            {
               "name": "get_superseding_event_id", 
               "doc": {
                  "headline": "Gets the event ``Id`` that is superseding another.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.id.Id) - the superseding event ``Id``", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the superseding event ``Id``\n        :rtype: ``osid.id.Id``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.id.Id", 
               "errors": {}
            }, 
            {
               "name": "get_superseding_event", 
               "doc": {
                  "headline": "Gets the event that is superseding another.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.Event) - the superseding event", 
               "error_doc": "        raise:  OperationFailed - unable to complete request", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the superseding event\n        :rtype: ``osid.calendaring.Event``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.Event", 
               "errors": {
                  "OPERATION_FAILED": "Operational"
               }
            }, 
            {
               "name": "supersedes_by_date", 
               "doc": {
                  "headline": "Tests if the superseding event replaces an event within a recurring series offered at a specific date/time.", 
                  "body": "        If ``supersedes_by_date()`` is true, then\n        ``supersedes_by_position()`` must be false."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if an event is superseded by date,\n                ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if an event is superseded by date, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "get_superseded_date", 
               "doc": {
                  "headline": "Gets the date of an event to replace if a recurring event is offered on that date.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.DateTime) - the date of the event to\n                replace", 
               "error_doc": "        raise:  IllegalState - ``supersedes_by_date()`` is ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the date of the event to replace\n        :rtype: ``osid.calendaring.DateTime``", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- ``supersedes_by_date()`` is ``false``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.DateTime", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract"
               }
            }, 
            {
               "name": "supersedes_by_position", 
               "doc": {
                  "headline": "Tests if the superseding event replaces an event within a recurring series identified by its denormalized position in the series.", 
                  "body": "        A negative number counts from the end of the series. If\n        ``supersedes_by_position()`` is ``true,`` then\n        ``supersedes_by_date()`` must be ``false``."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if an event is superseded by\n                position, ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if an event is superseded by position, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "get_superseded_event_position", 
               "doc": {
                  "headline": "Gets the position in the denormalized recurring series of the event to replace.", 
                  "body": "        Positive numbers count from the start and negative numbers count\n        from the end. Zero is invalid."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (integer) - the position of the event to replace", 
               "error_doc": "        raise:  IllegalState - ``supersedes_by_position()`` is ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the position of the event to replace\n        :rtype: ``integer``", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- ``supersedes_by_position()`` is ``false``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "integer", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract"
               }
            }, 
            {
               "name": "get_superseding_event_record", 
               "doc": {
                  "headline": "Gets the superseding event record corresponding to the given ``SupersedingEvent`` record ``Type``.", 
                  "body": "        This method is used to retrieve an object implementing the\n        requested record. The ``superseding_event_record_type`` may be\n        the ``Type`` returned in ``get_record_types()`` or any of its\n        parents in a ``Type`` hierarchy where\n        ``has_record_type(superseding_event_record_type)`` is ``true`` ."
               }, 
               "arg_doc": "        arg:    superseding_event_record_type (osid.type.Type): the type\n                of the record to retrieve\n", 
               "return_doc": "        return: (osid.calendaring.records.SupersedingEventRecord) - the\n                superseding event record", 
               "error_doc": "        raise:  NullArgument - ``superseding_event_record_type`` is\n                ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unsupported -\n                ``has_record_type(superseding_event_record_type)`` is\n                ``false``", 
               "sphinx_param_doc": "        :param superseding_event_record_type: the type of the record to retrieve\n        :type superseding_event_record_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "        :return: the superseding event record\n        :rtype: ``osid.calendaring.records.SupersedingEventRecord``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``superseding_event_record_type`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unsupported`` -- ``has_record_type(superseding_event_record_type)`` is ``false``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "superseding_event_record_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "osid.calendaring.records.SupersedingEventRecord", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.calendaring.records.SupersedingEventRecord", 
         "shortname": "SupersedingEventRecord", 
         "category": "records", 
         "doc": {
            "headline": "A record for a ``SupersedingEvent``.", 
            "body": "    The methods specified by the record type are available through the\n    underlying object."
         }, 
         "inherit_fullnames": [
            "osid.OsidRecord"
         ], 
         "inherit_shortnames": [
            "OsidRecord"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidRecord"
            }
         ], 
         "method_names": [], 
         "methods": []
      }, 
      {
         "fullname": "osid.calendaring.SupersedingEventQuery", 
         "shortname": "SupersedingEventQuery", 
         "category": "queries", 
         "doc": {
            "headline": "This is the query for searching superseding events.", 
            "body": "    Each method match request produces an ``AND`` term while multiple\n    invocations of a method produces a nested ``OR``."
         }, 
         "inherit_fullnames": [
            "osid.OsidRuleQuery"
         ], 
         "inherit_shortnames": [
            "OsidRuleQuery"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidRuleQuery"
            }
         ], 
         "method_names": [
            "match_superseded_event_id", 
            "clear_superseded_event_id_terms", 
            "supports_superseded_event_query", 
            "get_superseded_event_query", 
            "clear_superseded_event_terms", 
            "match_superseding_event_id", 
            "clear_superseding_event_id_terms", 
            "supports_superseding_event_query", 
            "get_superseding_event_query", 
            "clear_superseding_event_terms", 
            "match_superseded_date", 
            "match_any_superseded_date", 
            "clear_superseded_date_terms", 
            "match_superseded_event_position", 
            "match_any_superseded_event_position", 
            "clear_superseded_event_position_terms", 
            "match_calendar_id", 
            "clear_calendar_id_terms", 
            "supports_calendar_query", 
            "get_calendar_query", 
            "clear_calendar_terms", 
            "get_superseding_event_query_record"
         ], 
         "methods": [
            {
               "name": "match_superseded_event_id", 
               "doc": {
                  "headline": "Sets the event ``Id`` for this query for matching attached events.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    event_id (osid.id.Id): an event ``Id``\n        arg:    match (boolean): ``true`` for a positive match,\n                ``false`` for a negative match\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``event_id`` is ``null``", 
               "sphinx_param_doc": "        :param event_id: an event ``Id``\n        :type event_id: ``osid.id.Id``\n        :param match: ``true`` for a positive match, ``false`` for a negative match\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``event_id`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "event_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "clear_superseded_event_id_terms", 
               "doc": {
                  "headline": "Clears the event ``Id`` terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "supports_superseded_event_query", 
               "doc": {
                  "headline": "Tests if an ``EventQuery`` is available for querying attached events.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if an event query is available,\n                ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if an event query is available, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "get_superseded_event_query", 
               "doc": {
                  "headline": "Gets the query for an attached event.", 
                  "body": "        Multiple retrievals produce a nested ``OR`` term."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.EventQuery) - the event query", 
               "error_doc": "        raise:  Unimplemented - ``supports_superseded_event_query()`` is\n                ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the event query\n        :rtype: ``osid.calendaring.EventQuery``", 
               "sphinx_error_doc": "        :raise: ``Unimplemented`` -- ``supports_superseded_event_query()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_superseded_event_query()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.EventQuery", 
               "errors": {
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "clear_superseded_event_terms", 
               "doc": {
                  "headline": "Clears the event terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "match_superseding_event_id", 
               "doc": {
                  "headline": "Sets the superseding event ``Id`` for this query.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    superseding_event_id (osid.id.Id): a superseding event\n                ``Id``\n        arg:    match (boolean): ``true`` for a positive match,\n                ``false`` for a negative match\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``superseding_event_id`` is ``null``", 
               "sphinx_param_doc": "        :param superseding_event_id: a superseding event ``Id``\n        :type superseding_event_id: ``osid.id.Id``\n        :param match: ``true`` for a positive match, ``false`` for a negative match\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``superseding_event_id`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "superseding_event_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "clear_superseding_event_id_terms", 
               "doc": {
                  "headline": "Clears the superseding event ``Id`` terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "supports_superseding_event_query", 
               "doc": {
                  "headline": "Tests if a ``SupersedingEventQuery`` is available.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if a superseding event query is\n                available, ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if a superseding event query is available, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "get_superseding_event_query", 
               "doc": {
                  "headline": "Gets the query for a superseding event.", 
                  "body": "        Multiple retrievals produce a nested ``OR`` term."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.EventQuery) - the superseding event\n                query", 
               "error_doc": "        raise:  Unimplemented - ``supports_superseding_event_query()``\n                is ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the superseding event query\n        :rtype: ``osid.calendaring.EventQuery``", 
               "sphinx_error_doc": "        :raise: ``Unimplemented`` -- ``supports_superseding_event_query()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_superseding_event_query()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.EventQuery", 
               "errors": {
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "clear_superseding_event_terms", 
               "doc": {
                  "headline": "Clears the superseding event terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "match_superseded_date", 
               "doc": {
                  "headline": "Matches superseding events that supersede within the given dates inclusive.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    from (osid.calendaring.DateTime): start date\n        arg:    to (osid.calendaring.DateTime): end date\n        arg:    match (boolean): ``true`` for a positive match,\n                ``false`` for a negative match\n", 
               "return_doc": "", 
               "error_doc": "        raise:  InvalidArgument - ``from`` is greater than ``to``\n        raise:  NullArgument - ``from`` or ``to`` is ``null``", 
               "sphinx_param_doc": "        :param from: start date\n        :type from: ``osid.calendaring.DateTime``\n        :param to: end date\n        :type to: ``osid.calendaring.DateTime``\n        :param match: ``true`` for a positive match, ``false`` for a negative match\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``InvalidArgument`` -- ``from`` is greater than ``to``\n        :raise: ``NullArgument`` -- ``from`` or ``to`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.calendaring.DateTime", 
                     "var_name": "from_", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.calendaring.DateTime", 
                     "var_name": "to", 
                     "array": false
                  }, 
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.calendaring.DateTime", 
                  "osid.calendaring.DateTime", 
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {
                  "INVALID_ARGUMENT": "ConsumerContract", 
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "match_any_superseded_date", 
               "doc": {
                  "headline": "Matches a superseding event that has any superseded date.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    match (boolean): ``true`` to match superseding events\n                with any superseded date, false to match superseding\n                events with no superseded date\n", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "        :param match: ``true`` to match superseding events with any superseded date, false to match superseding events with no superseded date\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "clear_superseded_date_terms", 
               "doc": {
                  "headline": "Clears the superseded date terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "match_superseded_event_position", 
               "doc": {
                  "headline": "Matches superseding events that supersede within the denormalized event positions inclusive.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    from (integer): start position\n        arg:    to (integer): end position\n        arg:    match (boolean): ``true`` for a positive match,\n                ``false`` for a negative match\n", 
               "return_doc": "", 
               "error_doc": "        raise:  InvalidArgument - the absolute value of ``from`` is\n                greater than ``to``", 
               "sphinx_param_doc": "        :param from: start position\n        :type from: ``integer``\n        :param to: end position\n        :type to: ``integer``\n        :param match: ``true`` for a positive match, ``false`` for a negative match\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``InvalidArgument`` -- the absolute value of ``from`` is greater than ``to``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "integer", 
                     "var_name": "from_", 
                     "array": false
                  }, 
                  {
                     "arg_type": "integer", 
                     "var_name": "to", 
                     "array": false
                  }, 
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "integer", 
                  "integer", 
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {
                  "INVALID_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "match_any_superseded_event_position", 
               "doc": {
                  "headline": "Matches a superseding event that has any superseded position.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    match (boolean): ``true`` to match superseding events\n                with any superseded event position, false to match\n                superseding events with no superseded event position\n", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "        :param match: ``true`` to match superseding events with any superseded event position, false to match superseding events with no superseded event position\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "clear_superseded_event_position_terms", 
               "doc": {
                  "headline": "Clears the superseded position terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "match_calendar_id", 
               "doc": {
                  "headline": "Sets the calendar ``Id`` for this query.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    calendar_id (osid.id.Id): a calendar ``Id``\n        arg:    match (boolean): ``true`` for a positive match,\n                ``false`` for a negative match\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``calendar_id`` is ``null``", 
               "sphinx_param_doc": "        :param calendar_id: a calendar ``Id``\n        :type calendar_id: ``osid.id.Id``\n        :param match: ``true`` for a positive match, ``false`` for a negative match\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``calendar_id`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "calendar_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "clear_calendar_id_terms", 
               "doc": {
                  "headline": "Clears the calendar ``Id`` terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "supports_calendar_query", 
               "doc": {
                  "headline": "Tests if a ``CalendarQuery`` is available for querying calendars.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if a calendar query is available,\n                ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if a calendar query is available, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "get_calendar_query", 
               "doc": {
                  "headline": "Gets the query for a calendar.", 
                  "body": "        Multiple retrievals produce a nested ``OR`` term."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.CalendarQuery) - the calendar query", 
               "error_doc": "        raise:  Unimplemented - ``supports_calendar_query()`` is\n                ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the calendar query\n        :rtype: ``osid.calendaring.CalendarQuery``", 
               "sphinx_error_doc": "        :raise: ``Unimplemented`` -- ``supports_calendar_query()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_calendar_query()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.CalendarQuery", 
               "errors": {
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "clear_calendar_terms", 
               "doc": {
                  "headline": "Clears the calendar terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "get_superseding_event_query_record", 
               "doc": {
                  "headline": "Gets the superseding event query record corresponding to the given ``SupersedingEvent`` record ``Type``.", 
                  "body": "        Multiple retrievals produce a nested ``OR`` term."
               }, 
               "arg_doc": "        arg:    superseding_event_record_type (osid.type.Type): a\n                superseding event query record type\n", 
               "return_doc": "        return: (osid.calendaring.records.SupersedingEventQueryRecord) -\n                the superseding event query record", 
               "error_doc": "        raise:  NullArgument - ``superseding_event_record_type`` is\n                ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unsupported -\n                ``has_record_type(superseding_event_record_type)`` is\n                ``false``", 
               "sphinx_param_doc": "        :param superseding_event_record_type: a superseding event query record type\n        :type superseding_event_record_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "        :return: the superseding event query record\n        :rtype: ``osid.calendaring.records.SupersedingEventQueryRecord``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``superseding_event_record_type`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unsupported`` -- ``has_record_type(superseding_event_record_type)`` is ``false``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "superseding_event_record_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "osid.calendaring.records.SupersedingEventQueryRecord", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.calendaring.records.SupersedingEventQueryRecord", 
         "shortname": "SupersedingEventQueryRecord", 
         "category": "records", 
         "doc": {
            "headline": "A record for a ``SupersedingEventQuery``.", 
            "body": "    The methods specified by the record type are available through the\n    underlying object."
         }, 
         "inherit_fullnames": [
            "osid.OsidRecord"
         ], 
         "inherit_shortnames": [
            "OsidRecord"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidRecord"
            }
         ], 
         "method_names": [], 
         "methods": []
      }, 
      {
         "fullname": "osid.calendaring.SupersedingEventQueryInspector", 
         "shortname": "SupersedingEventQueryInspector", 
         "category": "query_inspectors", 
         "doc": {
            "headline": "This is the query inspector for examining superseding event queries.", 
            "body": ""
         }, 
         "inherit_fullnames": [
            "osid.OsidRuleQueryInspector"
         ], 
         "inherit_shortnames": [
            "OsidRuleQueryInspector"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidRuleQueryInspector"
            }
         ], 
         "method_names": [
            "get_superseded_event_id_terms", 
            "get_superseded_event_terms", 
            "get_superseding_event_id_terms", 
            "get_superseding_event_terms", 
            "get_superseded_date_terms", 
            "get_superseded_event_position_terms", 
            "get_calendar_id_terms", 
            "get_calendar_terms", 
            "get_superseding_event_query_inspector_record"
         ], 
         "methods": [
            {
               "name": "get_superseded_event_id_terms", 
               "doc": {
                  "headline": "Gets the superseded event ``Id`` terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.search.terms.IdTerm) - the superseded event ``Id``\n                terms", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the superseded event ``Id`` terms\n        :rtype: ``osid.search.terms.IdTerm``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.search.terms.IdTerm", 
               "errors": {}
            }, 
            {
               "name": "get_superseded_event_terms", 
               "doc": {
                  "headline": "Gets the superseded event terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.EventQueryInspector) - the superseded\n                event terms", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the superseded event terms\n        :rtype: ``osid.calendaring.EventQueryInspector``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.EventQueryInspector", 
               "errors": {}
            }, 
            {
               "name": "get_superseding_event_id_terms", 
               "doc": {
                  "headline": "Gets the superseding event ``Id`` terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.search.terms.IdTerm) - the superseding event\n                ``Id`` terms", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the superseding event ``Id`` terms\n        :rtype: ``osid.search.terms.IdTerm``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.search.terms.IdTerm", 
               "errors": {}
            }, 
            {
               "name": "get_superseding_event_terms", 
               "doc": {
                  "headline": "Gets the superseding event terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.EventQueryInspector) - the superseding\n                event terms", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the superseding event terms\n        :rtype: ``osid.calendaring.EventQueryInspector``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.EventQueryInspector", 
               "errors": {}
            }, 
            {
               "name": "get_superseded_date_terms", 
               "doc": {
                  "headline": "Gets the superseded date range terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.search.terms.DateTimeRangeTerm) - the superseded\n                date range terms", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the superseded date range terms\n        :rtype: ``osid.search.terms.DateTimeRangeTerm``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.search.terms.DateTimeRangeTerm", 
               "errors": {}
            }, 
            {
               "name": "get_superseded_event_position_terms", 
               "doc": {
                  "headline": "Gets the superseded event position terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.search.terms.IntegerRangeTerm) - the superseded\n                event position terms", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the superseded event position terms\n        :rtype: ``osid.search.terms.IntegerRangeTerm``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.search.terms.IntegerRangeTerm", 
               "errors": {}
            }, 
            {
               "name": "get_calendar_id_terms", 
               "doc": {
                  "headline": "Gets the calendar ``Id`` terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.search.terms.IdTerm) - the calendar ``Id`` terms", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the calendar ``Id`` terms\n        :rtype: ``osid.search.terms.IdTerm``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.search.terms.IdTerm", 
               "errors": {}
            }, 
            {
               "name": "get_calendar_terms", 
               "doc": {
                  "headline": "Gets the calendar terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.CalendarQueryInspector) - the calendar\n                terms", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the calendar terms\n        :rtype: ``osid.calendaring.CalendarQueryInspector``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.CalendarQueryInspector", 
               "errors": {}
            }, 
            {
               "name": "get_superseding_event_query_inspector_record", 
               "doc": {
                  "headline": "Gets the superseding event query inspector record corresponding to the given ``SupersedingEvent`` record ``Type``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    superseding_event_record_type (osid.type.Type): a\n                superseding event query record type\n", 
               "return_doc": "        return:\n                (osid.calendaring.records.SupersedingEventQueryInspector\n                Record) - the superseding event query inspector record", 
               "error_doc": "        raise:  NullArgument - ``superseding_event_record_type`` is\n                ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unsupported -\n                ``has_record_type(superseding_event_record_type)`` is\n                ``false``", 
               "sphinx_param_doc": "        :param superseding_event_record_type: a superseding event query record type\n        :type superseding_event_record_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "        :return: the superseding event query inspector record\n        :rtype: ``osid.calendaring.records.SupersedingEventQueryInspectorRecord``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``superseding_event_record_type`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unsupported`` -- ``has_record_type(superseding_event_record_type)`` is ``false``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "superseding_event_record_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "osid.calendaring.records.SupersedingEventQueryInspectorRecord", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.calendaring.records.SupersedingEventQueryInspectorRecord", 
         "shortname": "SupersedingEventQueryInspectorRecord", 
         "category": "records", 
         "doc": {
            "headline": "A record for a ``SupersedingEventQueryInspector``.", 
            "body": "    The methods specified by the record type are available through the\n    underlying object."
         }, 
         "inherit_fullnames": [
            "osid.OsidRecord"
         ], 
         "inherit_shortnames": [
            "OsidRecord"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidRecord"
            }
         ], 
         "method_names": [], 
         "methods": []
      }, 
      {
         "fullname": "osid.calendaring.SupersedingEventForm", 
         "shortname": "SupersedingEventForm", 
         "category": "objects", 
         "doc": {
            "headline": "This is the form for creating and updating ``SupersedingEvents``.", 
            "body": "    Like all ``OsidForm`` objects, various data elements may be set here\n    for use in the create and update methods in the\n    ``SupersedingEventAdminSession``. For each data element that may be\n    set, metadata may be examined to provide display hints or data\n    constraints."
         }, 
         "inherit_fullnames": [
            "osid.OsidRuleForm"
         ], 
         "inherit_shortnames": [
            "OsidRuleForm"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidRuleForm"
            }
         ], 
         "method_names": [
            "get_superseded_date_metadata", 
            "set_superseded_date", 
            "clear_superseded_date", 
            "get_superseded_event_position_metadata", 
            "set_superseded_event_position", 
            "clear_superseded_event_position", 
            "get_superseding_event_form_record"
         ], 
         "methods": [
            {
               "name": "get_superseded_date_metadata", 
               "doc": {
                  "headline": "Gets the metadata to superseding an event within a recurring series by date.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.Metadata) - metadata for a superseded date", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: metadata for a superseded date\n        :rtype: ``osid.Metadata``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.Metadata", 
               "errors": {}
            }, 
            {
               "name": "set_superseded_date", 
               "doc": {
                  "headline": "Sets the superseded date.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    date (osid.calendaring.DateTime): the new superseded\n                date\n", 
               "return_doc": "", 
               "error_doc": "        raise:  InvalidArgument - ``date`` is invalid\n        raise:  NoAccess - ``date`` cannot be modified\n        raise:  NullArgument - ``date`` is ``null``", 
               "sphinx_param_doc": "        :param date: the new superseded date\n        :type date: ``osid.calendaring.DateTime``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``InvalidArgument`` -- ``date`` is invalid\n        :raise: ``NoAccess`` -- ``date`` cannot be modified\n        :raise: ``NullArgument`` -- ``date`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.calendaring.DateTime", 
                     "var_name": "date", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.calendaring.DateTime"
               ], 
               "return_type": "", 
               "errors": {
                  "INVALID_ARGUMENT": "ConsumerContract", 
                  "NO_ACCESS": "ConsumerContract", 
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "clear_superseded_date", 
               "doc": {
                  "headline": "Clears the superseded date.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "        raise:  NoAccess - ``Metadata.isRequired()`` or\n                ``Metadata.isReadOnly()`` is ``true``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NoAccess`` -- ``Metadata.isRequired()`` or ``Metadata.isReadOnly()`` is ``true``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {
                  "NO_ACCESS": "ConsumerContract"
               }
            }, 
            {
               "name": "get_superseded_event_position_metadata", 
               "doc": {
                  "headline": "Gets the metadata to superseding an event within a recurring series by date.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.Metadata) - metadata for a superseded date", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: metadata for a superseded date\n        :rtype: ``osid.Metadata``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.Metadata", 
               "errors": {}
            }, 
            {
               "name": "set_superseded_event_position", 
               "doc": {
                  "headline": "Sets the superseded position.", 
                  "body": "        A negative number counts from the end of the series."
               }, 
               "arg_doc": "        arg:    position (integer): the new superseded position\n", 
               "return_doc": "", 
               "error_doc": "        raise:  InvalidArgument - ``position`` is invalid\n        raise:  NoAccess - ``position`` cannot be modified", 
               "sphinx_param_doc": "        :param position: the new superseded position\n        :type position: ``integer``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``InvalidArgument`` -- ``position`` is invalid\n        :raise: ``NoAccess`` -- ``position`` cannot be modified", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "integer", 
                     "var_name": "position", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "integer"
               ], 
               "return_type": "", 
               "errors": {
                  "INVALID_ARGUMENT": "ConsumerContract", 
                  "NO_ACCESS": "ConsumerContract"
               }
            }, 
            {
               "name": "clear_superseded_event_position", 
               "doc": {
                  "headline": "Clears the superseded position.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "        raise:  NoAccess - ``Metadata.isRequired()`` or\n                ``Metadata.isReadOnly()`` is ``true``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NoAccess`` -- ``Metadata.isRequired()`` or ``Metadata.isReadOnly()`` is ``true``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {
                  "NO_ACCESS": "ConsumerContract"
               }
            }, 
            {
               "name": "get_superseding_event_form_record", 
               "doc": {
                  "headline": "Gets the ``SupersedingEventFormRecord`` corresponding to the given superseding event record ``Type``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    superseding_event_record_type (osid.type.Type): the\n                superseding event record type\n", 
               "return_doc": "        return: (osid.calendaring.records.SupersedingEventFormRecord) -\n                the superseding event form record", 
               "error_doc": "        raise:  NullArgument - ``superseding_event_record_type`` is\n                ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unsupported -\n                ``has_record_type(superseding_event_record_type)`` is\n                ``false``", 
               "sphinx_param_doc": "        :param superseding_event_record_type: the superseding event record type\n        :type superseding_event_record_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "        :return: the superseding event form record\n        :rtype: ``osid.calendaring.records.SupersedingEventFormRecord``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``superseding_event_record_type`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unsupported`` -- ``has_record_type(superseding_event_record_type)`` is ``false``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "superseding_event_record_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "osid.calendaring.records.SupersedingEventFormRecord", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.calendaring.records.SupersedingEventFormRecord", 
         "shortname": "SupersedingEventFormRecord", 
         "category": "records", 
         "doc": {
            "headline": "A record for a ``SupersedingEventForm``.", 
            "body": "    The methods specified by the record type are available through the\n    underlying object."
         }, 
         "inherit_fullnames": [
            "osid.OsidRecord"
         ], 
         "inherit_shortnames": [
            "OsidRecord"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidRecord"
            }
         ], 
         "method_names": [], 
         "methods": []
      }, 
      {
         "fullname": "osid.calendaring.SupersedingEventSearchOrder", 
         "shortname": "SupersedingEventSearchOrder", 
         "category": "search_orders", 
         "doc": {
            "headline": "An interface for specifying the ordering of search results.", 
            "body": ""
         }, 
         "inherit_fullnames": [
            "osid.OsidRuleSearchOrder"
         ], 
         "inherit_shortnames": [
            "OsidRuleSearchOrder"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidRuleSearchOrder"
            }
         ], 
         "method_names": [
            "order_by_superseded_event", 
            "supports_superseded_event_search_order", 
            "get_superseded_event_search_order", 
            "order_by_superseding_event", 
            "supports_superseding_event_search_order", 
            "get_superseding_event_search_order", 
            "order_by_superseded_date", 
            "order_by_superseded_event_position", 
            "get_superseding_event_search_order_record"
         ], 
         "methods": [
            {
               "name": "order_by_superseded_event", 
               "doc": {
                  "headline": "Specified a preference for ordering results by the superseded event.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    style (osid.SearchOrderStyle): a search order style\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``style`` is ``null``", 
               "sphinx_param_doc": "        :param style: a search order style\n        :type style: ``osid.SearchOrderStyle``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``style`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.SearchOrderStyle", 
                     "var_name": "style", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.SearchOrderStyle"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "supports_superseded_event_search_order", 
               "doc": {
                  "headline": "Tests if an ``EventSearchOrder`` is available.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if an event search order is\n                available, ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if an event search order is available, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "get_superseded_event_search_order", 
               "doc": {
                  "headline": "Gets the search order for the superseded event.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.EventSearchOrder) - the event search\n                order", 
               "error_doc": "        raise:  Unimplemented -\n                ``supports_superseded_event_search_order()`` is\n                ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the event search order\n        :rtype: ``osid.calendaring.EventSearchOrder``", 
               "sphinx_error_doc": "        :raise: ``Unimplemented`` -- ``supports_superseded_event_search_order()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_superseded_event_search_order()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.EventSearchOrder", 
               "errors": {
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "order_by_superseding_event", 
               "doc": {
                  "headline": "Specified a preference for ordering results by the superseding event.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    style (osid.SearchOrderStyle): a search order style\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``style`` is ``null``", 
               "sphinx_param_doc": "        :param style: a search order style\n        :type style: ``osid.SearchOrderStyle``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``style`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.SearchOrderStyle", 
                     "var_name": "style", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.SearchOrderStyle"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "supports_superseding_event_search_order", 
               "doc": {
                  "headline": "Tests if an ``EventSearchOrder`` is available.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if an event search order is\n                available, ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if an event search order is available, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "get_superseding_event_search_order", 
               "doc": {
                  "headline": "Gets the search order for the superseding event.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.EventSearchOrder) - the event search\n                order", 
               "error_doc": "        raise:  Unimplemented -\n                ``supports_superseding_event_search_order()`` is\n                ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the event search order\n        :rtype: ``osid.calendaring.EventSearchOrder``", 
               "sphinx_error_doc": "        :raise: ``Unimplemented`` -- ``supports_superseding_event_search_order()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_superseding_event_search_order()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.EventSearchOrder", 
               "errors": {
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "order_by_superseded_date", 
               "doc": {
                  "headline": "Specified a preference for ordering results by the superseded date.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    style (osid.SearchOrderStyle): a search order style\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``style`` is ``null``", 
               "sphinx_param_doc": "        :param style: a search order style\n        :type style: ``osid.SearchOrderStyle``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``style`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.SearchOrderStyle", 
                     "var_name": "style", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.SearchOrderStyle"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "order_by_superseded_event_position", 
               "doc": {
                  "headline": "Specified a preference for ordering results by the superseded event position.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    style (osid.SearchOrderStyle): a search order style\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``style`` is ``null``", 
               "sphinx_param_doc": "        :param style: a search order style\n        :type style: ``osid.SearchOrderStyle``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``style`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.SearchOrderStyle", 
                     "var_name": "style", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.SearchOrderStyle"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "get_superseding_event_search_order_record", 
               "doc": {
                  "headline": "Gets the superseding event search order record corresponding to the given superseding event record ``Type``.", 
                  "body": "        Multiple retrievals return the same underlying object."
               }, 
               "arg_doc": "        arg:    superseding_event_record_type (osid.type.Type): a\n                superseding event record type\n", 
               "return_doc": "        return:\n                (osid.calendaring.records.SupersedingEventSearchOrderRec\n                ord) - the superseding event search order record", 
               "error_doc": "        raise:  NullArgument - ``superseding_event_record_type`` is\n                ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unsupported -\n                ``has_record_type(superseding_event_record_type)`` is\n                ``false``", 
               "sphinx_param_doc": "        :param superseding_event_record_type: a superseding event record type\n        :type superseding_event_record_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "        :return: the superseding event search order record\n        :rtype: ``osid.calendaring.records.SupersedingEventSearchOrderRecord``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``superseding_event_record_type`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unsupported`` -- ``has_record_type(superseding_event_record_type)`` is ``false``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "superseding_event_record_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "osid.calendaring.records.SupersedingEventSearchOrderRecord", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.calendaring.records.SupersedingEventSearchOrderRecord", 
         "shortname": "SupersedingEventSearchOrderRecord", 
         "category": "records", 
         "doc": {
            "headline": "A record for a ``SupersedingEventSearchOrder``.", 
            "body": "    The methods specified by the record type are available through the\n    underlying object."
         }, 
         "inherit_fullnames": [
            "osid.OsidRecord"
         ], 
         "inherit_shortnames": [
            "OsidRecord"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidRecord"
            }
         ], 
         "method_names": [], 
         "methods": []
      }, 
      {
         "fullname": "osid.calendaring.SupersedingEventSearch", 
         "shortname": "SupersedingEventSearch", 
         "category": "searches", 
         "doc": {
            "headline": "``SupersedingEventSearch`` defines the interface for specifying superseding event search options.", 
            "body": ""
         }, 
         "inherit_fullnames": [
            "osid.OsidSearch"
         ], 
         "inherit_shortnames": [
            "OsidSearch"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidSearch"
            }
         ], 
         "method_names": [
            "search_among_superseding_events", 
            "order_superseding_event_results", 
            "get_superseding_event_search_record"
         ], 
         "methods": [
            {
               "name": "search_among_superseding_events", 
               "doc": {
                  "headline": "Execute this search among the given list of superseding events.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    superseding_event_ids (osid.id.IdList): list of\n                superseding events\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``superseding_event_ids`` is ``null``", 
               "sphinx_param_doc": "        :param superseding_event_ids: list of superseding events\n        :type superseding_event_ids: ``osid.id.IdList``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``superseding_event_ids`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.IdList", 
                     "var_name": "superseding_event_ids", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.IdList"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "order_superseding_event_results", 
               "doc": {
                  "headline": "Specify an ordering to the search results.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    superseding_event_search_order\n                (osid.calendaring.SupersedingEventSearchOrder):\n                superseding event search order\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``superseding_event_search_order`` is\n                ``null``\n        raise:  Unsupported - ``supereding_event_search_order`` is not\n                of this service", 
               "sphinx_param_doc": "        :param superseding_event_search_order: superseding event search order\n        :type superseding_event_search_order: ``osid.calendaring.SupersedingEventSearchOrder``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``superseding_event_search_order`` is ``null``\n        :raise: ``Unsupported`` -- ``supereding_event_search_order`` is not of this service", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.calendaring.SupersedingEventSearchOrder", 
                     "var_name": "superseding_event_search_order", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.calendaring.SupersedingEventSearchOrder"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_superseding_event_search_record", 
               "doc": {
                  "headline": "Gets the superseding event search record corresponding to the given superseding event search record ``Type``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    superseding_event_search_record_type (osid.type.Type): a\n                superseding event search record type\n", 
               "return_doc": "        return: (osid.calendaring.records.SupersedingEventSearchRecord)\n                - the superseding event search record", 
               "error_doc": "        raise:  NullArgument - ``superseding_event_search_record_type``\n                is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unsupported -\n                ``has_record_type(superseding_event_search_record_type)`\n                ` is ``false``", 
               "sphinx_param_doc": "        :param superseding_event_search_record_type: a superseding event search record type\n        :type superseding_event_search_record_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "        :return: the superseding event search record\n        :rtype: ``osid.calendaring.records.SupersedingEventSearchRecord``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``superseding_event_search_record_type`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unsupported`` -- ``has_record_type(superseding_event_search_record_type)`` is ``false``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "superseding_event_search_record_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "osid.calendaring.records.SupersedingEventSearchRecord", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.calendaring.records.SupersedingEventSearchRecord", 
         "shortname": "SupersedingEventSearchRecord", 
         "category": "records", 
         "doc": {
            "headline": "A record for a ``SupersedingEventSearch``.", 
            "body": "    The methods specified by the record type are available through the\n    underlying object."
         }, 
         "inherit_fullnames": [
            "osid.OsidRecord"
         ], 
         "inherit_shortnames": [
            "OsidRecord"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidRecord"
            }
         ], 
         "method_names": [], 
         "methods": []
      }, 
      {
         "fullname": "osid.calendaring.SupersedingEventSearchResults", 
         "shortname": "SupersedingEventSearchResults", 
         "category": "searches", 
         "doc": {
            "headline": "This interface provides a means to capture results of a search.", 
            "body": ""
         }, 
         "inherit_fullnames": [
            "osid.OsidSearchResults"
         ], 
         "inherit_shortnames": [
            "OsidSearchResults"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidSearchResults"
            }
         ], 
         "method_names": [
            "get_superseding_events", 
            "get_superseding_event_query_inspector", 
            "get_superseding_event_search_results_record"
         ], 
         "methods": [
            {
               "name": "get_superseding_events", 
               "doc": {
                  "headline": "Gets the superseding event list resulting from the search.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.SupersedingEventList) - the\n                superseding event list", 
               "error_doc": "        raise:  IllegalState - list already retrieved", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the superseding event list\n        :rtype: ``osid.calendaring.SupersedingEventList``", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- list already retrieved", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.SupersedingEventList", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract"
               }
            }, 
            {
               "name": "get_superseding_event_query_inspector", 
               "doc": {
                  "headline": "Gets the inspector for the query to examine the terms used in the search.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.SupersedingEventQueryInspector) - the\n                query inspector", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the query inspector\n        :rtype: ``osid.calendaring.SupersedingEventQueryInspector``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.SupersedingEventQueryInspector", 
               "errors": {}
            }, 
            {
               "name": "get_superseding_event_search_results_record", 
               "doc": {
                  "headline": "Gets the superseding event search results record corresponding to the given superseding event search record ``Type``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    superseding_event_search_record_type (osid.type.Type): a\n                superseding event search record type\n", 
               "return_doc": "        return:\n                (osid.calendaring.records.SupersedingEventSearchResultsR\n                ecord) - the superseding event search results record", 
               "error_doc": "        raise:  NullArgument - ``superseding_event_search_record_type``\n                is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unsupported -\n                ``has_record_type(superseding_event_search_record_type)`\n                ` is ``false``", 
               "sphinx_param_doc": "        :param superseding_event_search_record_type: a superseding event search record type\n        :type superseding_event_search_record_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "        :return: the superseding event search results record\n        :rtype: ``osid.calendaring.records.SupersedingEventSearchResultsRecord``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``superseding_event_search_record_type`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unsupported`` -- ``has_record_type(superseding_event_search_record_type)`` is ``false``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "superseding_event_search_record_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "osid.calendaring.records.SupersedingEventSearchResultsRecord", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.calendaring.records.SupersedingEventSearchResultsRecord", 
         "shortname": "SupersedingEventSearchResultsRecord", 
         "category": "records", 
         "doc": {
            "headline": "A record for a ``SupersedingEventSearchResults``.", 
            "body": "    The methods specified by the record type are available through the\n    underlying object."
         }, 
         "inherit_fullnames": [
            "osid.OsidRecord"
         ], 
         "inherit_shortnames": [
            "OsidRecord"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidRecord"
            }
         ], 
         "method_names": [], 
         "methods": []
      }, 
      {
         "fullname": "osid.calendaring.SupersedingEventReceiver", 
         "shortname": "SupersedingEventReceiver", 
         "category": "receivers", 
         "doc": {
            "headline": "The superseding event receiver is the consumer supplied interface for receiving notifications pertaining to new, updated or deleted ``SupersedingEvents``.", 
            "body": ""
         }, 
         "inherit_fullnames": [
            "osid.OsidReceiver"
         ], 
         "inherit_shortnames": [
            "OsidReceiver"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidReceiver"
            }
         ], 
         "method_names": [
            "new_superseding_event", 
            "changed_superseding_event", 
            "deleted_superseding_event"
         ], 
         "methods": [
            {
               "name": "new_superseding_event", 
               "doc": {
                  "headline": "The callback for notifications of new superseding events.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    superseding_event_id (osid.id.Id): the ``Id`` of the new\n                ``SupersedingEvent``\n", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "        :param superseding_event_id: the ``Id`` of the new ``SupersedingEvent``\n        :type superseding_event_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "superseding_event_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "changed_superseding_event", 
               "doc": {
                  "headline": "The callback for notification of updated superseding events.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    superseding_event_id (osid.id.Id): the ``Id`` of the\n                updated ``SupersedingEvent``\n", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "        :param superseding_event_id: the ``Id`` of the updated ``SupersedingEvent``\n        :type superseding_event_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "superseding_event_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "deleted_superseding_event", 
               "doc": {
                  "headline": "The callback for notification of deleted superseding events.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    superseding_event_id (osid.id.Id): the ``Id`` of the\n                deleted ``SupersedingEvent``\n", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "        :param superseding_event_id: the ``Id`` of the deleted ``SupersedingEvent``\n        :type superseding_event_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "superseding_event_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {}
            }
         ]
      }, 
      {
         "fullname": "osid.calendaring.SupersedingEventList", 
         "shortname": "SupersedingEventList", 
         "category": "objects", 
         "doc": {
            "headline": "Like all ``OsidLists,``  ``SupersedingEventList`` provides a means for accessing ``SupersedingEvent`` elements sequentially either one at a time or many at a time.", 
            "body": "    Examples: while (sel.hasNext()) { SupersedingEvent event =\n    sel.getNextSupersedingEvent(); }\n\n    or\n      while (sel.hasNext()) {\n           SupersedingEvent[] events = sel.getNextSupersedingEvents(sel.available());\n      }\n    \n"
         }, 
         "inherit_fullnames": [
            "osid.OsidList"
         ], 
         "inherit_shortnames": [
            "OsidList"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidList"
            }
         ], 
         "method_names": [
            "get_next_superseding_event", 
            "get_next_superseding_events"
         ], 
         "methods": [
            {
               "name": "get_next_superseding_event", 
               "doc": {
                  "headline": "Gets the next ``SupersedingEvent`` in this list.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.SupersedingEvent) - the next\n                ``SupersedingEvent`` in this list. The ``has_next()``\n                method should be used to test that a next\n                ``SupersedingEvent`` is available before calling this\n                method.", 
               "error_doc": "        raise:  IllegalState - no more elements available in this list\n        raise:  OperationFailed - unable to complete request", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the next ``SupersedingEvent`` in this list. The ``has_next()`` method should be used to test that a next ``SupersedingEvent`` is available before calling this method.\n        :rtype: ``osid.calendaring.SupersedingEvent``", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- no more elements available in this list\n        :raise: ``OperationFailed`` -- unable to complete request", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.SupersedingEvent", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational"
               }
            }, 
            {
               "name": "get_next_superseding_events", 
               "doc": {
                  "headline": "Gets the next set of ``SupersedingEvent`` elements in this list which must be less than or equal to the number returned from ``available()``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    n (cardinal): the number of ``SupersedingEvent``\n                elements requested which should be less than or equal to\n                ``available()``\n", 
               "return_doc": "        return: (osid.calendaring.SupersedingEvent) - an array of\n                ``SupersedingEvent`` elements.The length of the array is\n                less than or equal to the number specified.", 
               "error_doc": "        raise:  IllegalState - no more elements available in this list\n        raise:  OperationFailed - unable to complete request", 
               "sphinx_param_doc": "        :param n: the number of ``SupersedingEvent`` elements requested which should be less than or equal to ``available()``\n        :type n: ``cardinal``\n", 
               "sphinx_return_doc": "        :return: an array of ``SupersedingEvent`` elements.The length of the array is less than or equal to the number specified.\n        :rtype: ``osid.calendaring.SupersedingEvent``", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- no more elements available in this list\n        :raise: ``OperationFailed`` -- unable to complete request", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "cardinal", 
                     "var_name": "n", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "cardinal"
               ], 
               "return_type": "osid.calendaring.SupersedingEvent", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.calendaring.OffsetEvent", 
         "shortname": "OffsetEvent", 
         "category": "objects", 
         "doc": {
            "headline": "An ``OffsetEvent`` describes events that are relative to other events.", 
            "body": "    ``OffsetEvents`` may have a fixed or rubber start date as well as a\n    fixed or rubber end date. A rubber start and end date has a variable\n    duration based on the starting and ending milestones. An\n    ``OffsetEvent`` with a fixed start date and a fixed duration behaves\n    like a normal fixed ``Event``.\n\n    Creating an ``OffsetEvent`` produces an ``Event`` that is based on\n    these offset rules."
         }, 
         "inherit_fullnames": [
            "osid.OsidRule"
         ], 
         "inherit_shortnames": [
            "OsidRule"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidRule"
            }
         ], 
         "method_names": [
            "has_fixed_start_time", 
            "get_fixed_start_time", 
            "get_start_reference_event_id", 
            "get_start_reference_event", 
            "has_fixed_start_offset", 
            "get_fixed_start_offset", 
            "has_relative_weekday_start_offset", 
            "get_relative_weekday_start_offset", 
            "get_relative_start_weekday", 
            "has_fixed_duration", 
            "get_fixed_duration", 
            "get_end_reference_event_id", 
            "get_end_reference_event", 
            "has_fixed_end_offset", 
            "get_fixed_end_offset", 
            "has_relative_weekday_end_offset", 
            "get_relative_weekday_end_offset", 
            "get_relative_end_weekday", 
            "get_location_description", 
            "has_location", 
            "get_location_id", 
            "get_location", 
            "has_sponsors", 
            "get_sponsor_ids", 
            "get_sponsors", 
            "get_offset_event_record"
         ], 
         "methods": [
            {
               "name": "has_fixed_start_time", 
               "doc": {
                  "headline": "Tests if this offset event is based on a fixed start time.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if this offset is based on a fixed\n                start time, ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if this offset is based on a fixed start time, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "get_fixed_start_time", 
               "doc": {
                  "headline": "Gets the fixed start time for this event.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.DateTime) - the fixed start time", 
               "error_doc": "        raise:  IllegalState - ``has_fixed_start_ime()`` is ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the fixed start time\n        :rtype: ``osid.calendaring.DateTime``", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- ``has_fixed_start_ime()`` is ``false``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.DateTime", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract"
               }
            }, 
            {
               "name": "get_start_reference_event_id", 
               "doc": {
                  "headline": "Gets the ``Event Id`` to which the start of this event is offset.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.id.Id) - the relative event ``Id``", 
               "error_doc": "        raise:  IllegalState - ``has_fixed_start_time()`` is ``true``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the relative event ``Id``\n        :rtype: ``osid.id.Id``", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- ``has_fixed_start_time()`` is ``true``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.id.Id", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract"
               }
            }, 
            {
               "name": "get_start_reference_event", 
               "doc": {
                  "headline": "Gets the ``Event`` to which the start of this event is offset.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.Event) - the relative event", 
               "error_doc": "        raise:  IllegalState - ``has_fixed_start_time()`` is ``true``\n        raise:  OperationFailed - unable to complete request", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the relative event\n        :rtype: ``osid.calendaring.Event``", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- ``has_fixed_start_time()`` is ``true``\n        :raise: ``OperationFailed`` -- unable to complete request", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.Event", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational"
               }
            }, 
            {
               "name": "has_fixed_start_offset", 
               "doc": {
                  "headline": "Tests if this offset start time based on a fixed period of time.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if this offset is based on a fixed\n                period of time, ``false`` otherwise", 
               "error_doc": "        raise:  IllegalState - ``has_fixed_start_time()`` is ``true``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if this offset is based on a fixed period of time, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- ``has_fixed_start_time()`` is ``true``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract"
               }
            }, 
            {
               "name": "get_fixed_start_offset", 
               "doc": {
                  "headline": "Gets the fixed starting time offset.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.Duration) - the offset", 
               "error_doc": "        raise:  IllegalState - ``has_fixed_start_offset()`` is ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the offset\n        :rtype: ``osid.calendaring.Duration``", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- ``has_fixed_start_offset()`` is ``false``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.Duration", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract"
               }
            }, 
            {
               "name": "has_relative_weekday_start_offset", 
               "doc": {
                  "headline": "Tests if this starting time offset is a based on a relative weekday.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if this offset is based on a\n                relative weekday, ``false`` otherwise", 
               "error_doc": "        raise:  IllegalState - ``has_fixed_start_offset()`` is ``true``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if this offset is based on a relative weekday, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- ``has_fixed_start_offset()`` is ``true``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract"
               }
            }, 
            {
               "name": "get_relative_weekday_start_offset", 
               "doc": {
                  "headline": "Gets the starting offset as the nth weekday from the relative event.", 
                  "body": "        Zero is no offset."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (integer) - the offset", 
               "error_doc": "        raise:  IllegalState - ``has_relative_weekday_start_offset()``\n                is ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the offset\n        :rtype: ``integer``", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- ``has_relative_weekday_start_offset()`` is ``false``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "integer", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract"
               }
            }, 
            {
               "name": "get_relative_start_weekday", 
               "doc": {
                  "headline": "Gets the starting weekday number.", 
                  "body": "        The weekday is based on the calendar type. On the Gregorian\n        calendar, 0 is Sunday."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (cardinal) - the weekday number", 
               "error_doc": "        raise:  IllegalState - ``has_relative_weekday_start_offset()``\n                is ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the weekday number\n        :rtype: ``cardinal``", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- ``has_relative_weekday_start_offset()`` is ``false``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "cardinal", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract"
               }
            }, 
            {
               "name": "has_fixed_duration", 
               "doc": {
                  "headline": "Tests if this offset event is based on a fixed duration.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if this offset is based on a fixed\n                duration, ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if this offset is based on a fixed duration, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "get_fixed_duration", 
               "doc": {
                  "headline": "Gets the duration of the offset event.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    units (osid.calendaring.DateTimeResolution): the units\n                of the duration\n", 
               "return_doc": "        return: (osid.calendaring.Duration) - the duration", 
               "error_doc": "        raise:  IllegalState - ``has_fixed_duration()`` is ``false``\n        raise:  NullArgument - ``units`` is ``null``", 
               "sphinx_param_doc": "        :param units: the units of the duration\n        :type units: ``osid.calendaring.DateTimeResolution``\n", 
               "sphinx_return_doc": "        :return: the duration\n        :rtype: ``osid.calendaring.Duration``", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- ``has_fixed_duration()`` is ``false``\n        :raise: ``NullArgument`` -- ``units`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.calendaring.DateTimeResolution", 
                     "var_name": "units", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.calendaring.DateTimeResolution"
               ], 
               "return_type": "osid.calendaring.Duration", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract", 
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "get_end_reference_event_id", 
               "doc": {
                  "headline": "Gets the ``Event Id`` to which the end of this event is offset.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.id.Id) - the relative event ``Id``", 
               "error_doc": "        raise:  IllegalState - ``has_fixed_duration()`` is ``true``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the relative event ``Id``\n        :rtype: ``osid.id.Id``", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- ``has_fixed_duration()`` is ``true``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.id.Id", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract"
               }
            }, 
            {
               "name": "get_end_reference_event", 
               "doc": {
                  "headline": "Gets the ``Event`` to which the end of this event is offset.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.Event) - the relative event", 
               "error_doc": "        raise:  IllegalState - ``has_fixed_duration()`` is ``true``\n        raise:  OperationFailed - unable to complete request", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the relative event\n        :rtype: ``osid.calendaring.Event``", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- ``has_fixed_duration()`` is ``true``\n        :raise: ``OperationFailed`` -- unable to complete request", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.Event", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational"
               }
            }, 
            {
               "name": "has_fixed_end_offset", 
               "doc": {
                  "headline": "Tests if this offset end time based on a fixed period of time.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if this offset is based on a fixed\n                period of time, ``false`` otherwise", 
               "error_doc": "        raise:  IllegalState - ``has_fixed_duration()`` is ``true``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if this offset is based on a fixed period of time, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- ``has_fixed_duration()`` is ``true``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract"
               }
            }, 
            {
               "name": "get_fixed_end_offset", 
               "doc": {
                  "headline": "Gets the fixed ending time offset.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.Duration) - the offset", 
               "error_doc": "        raise:  IllegalState - ``has_fixed_end_offset()`` is ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the offset\n        :rtype: ``osid.calendaring.Duration``", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- ``has_fixed_end_offset()`` is ``false``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.Duration", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract"
               }
            }, 
            {
               "name": "has_relative_weekday_end_offset", 
               "doc": {
                  "headline": "Tests if this ending time offset is a based on a relative weekday.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if this offset is based on a\n                relative weekday, ``false`` otherwise", 
               "error_doc": "        raise:  IllegalState - ``has_fixed_end_offset()`` is ``true``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if this offset is based on a relative weekday, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- ``has_fixed_end_offset()`` is ``true``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract"
               }
            }, 
            {
               "name": "get_relative_weekday_end_offset", 
               "doc": {
                  "headline": "Gets the ending offset as the nth weekday from the relative event.", 
                  "body": "        Zero is no offset."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (integer) - the offset", 
               "error_doc": "        raise:  IllegalState - ``has_relative_weekday_end_offset()`` is\n                ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the offset\n        :rtype: ``integer``", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- ``has_relative_weekday_end_offset()`` is ``false``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "integer", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract"
               }
            }, 
            {
               "name": "get_relative_end_weekday", 
               "doc": {
                  "headline": "Gets the ending weekday number.", 
                  "body": "        The weekday is based on the calendar type. On the Gregorian\n        calendar, 0 is Sunday."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (cardinal) - the weekday number", 
               "error_doc": "        raise:  IllegalState - ``has_relative_weekday_end_offset()`` is\n                ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the weekday number\n        :rtype: ``cardinal``", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- ``has_relative_weekday_end_offset()`` is ``false``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "cardinal", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract"
               }
            }, 
            {
               "name": "get_location_description", 
               "doc": {
                  "headline": "Gets a descriptive location.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.locale.DisplayText) - the location", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the location\n        :rtype: ``osid.locale.DisplayText``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.locale.DisplayText", 
               "errors": {}
            }, 
            {
               "name": "has_location", 
               "doc": {
                  "headline": "Tests if a location is associated with this event.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if there is an associated location,\n                ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if there is an associated location, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "get_location_id", 
               "doc": {
                  "headline": "Gets the location ``Id``.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.id.Id) - a location ``Id``", 
               "error_doc": "        raise:  IllegalState - ``has_location()`` is ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: a location ``Id``\n        :rtype: ``osid.id.Id``", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- ``has_location()`` is ``false``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.id.Id", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract"
               }
            }, 
            {
               "name": "get_location", 
               "doc": {
                  "headline": "Gets the ``Location``.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.mapping.Location) - a location", 
               "error_doc": "        raise:  IllegalState - ``has_location()`` is ``false``\n        raise:  OperationFailed - unable to complete request", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: a location\n        :rtype: ``osid.mapping.Location``", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- ``has_location()`` is ``false``\n        :raise: ``OperationFailed`` -- unable to complete request", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.mapping.Location", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational"
               }
            }, 
            {
               "name": "has_sponsors", 
               "doc": {
                  "headline": "Tests if a sponsor is associated with this event.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if there is an associated sponsor.\n                ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if there is an associated sponsor. ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "get_sponsor_ids", 
               "doc": {
                  "headline": "Gets the ``Id`` of the event sponsors.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.id.IdList) - the sponsor ``Ids``", 
               "error_doc": "        raise:  IllegalState - ``has_sponsors()`` is ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the sponsor ``Ids``\n        :rtype: ``osid.id.IdList``", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- ``has_sponsors()`` is ``false``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.id.IdList", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract"
               }
            }, 
            {
               "name": "get_sponsors", 
               "doc": {
                  "headline": "Gets the ``Sponsors``.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.resource.ResourceList) - the sponsors", 
               "error_doc": "        raise:  IllegalState - ``has_sponsors()`` is ``false``\n        raise:  OperationFailed - unable to complete request", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the sponsors\n        :rtype: ``osid.resource.ResourceList``", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- ``has_sponsors()`` is ``false``\n        :raise: ``OperationFailed`` -- unable to complete request", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.resource.ResourceList", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational"
               }
            }, 
            {
               "name": "get_offset_event_record", 
               "doc": {
                  "headline": "Gets the offset event record corresponding to the given ``OffsetEvent`` record ``Type``.", 
                  "body": "        This method is used to retrieve an object implementing the\n        requested record. The ``offset_event_record_type`` may be the\n        ``Type`` returned in ``get_record_types()`` or any of its\n        parents in a ``Type`` hierarchy where\n        ``has_record_type(offset_event_record_type)`` is ``true`` ."
               }, 
               "arg_doc": "        arg:    offset_event_record_type (osid.type.Type): the type of\n                the record to retrieve\n", 
               "return_doc": "        return: (osid.calendaring.records.OffsetEventRecord) - the\n                offset event record", 
               "error_doc": "        raise:  NullArgument - ``offset_event_record_type`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unsupported -\n                ``has_record_type(offset_event_record_type)`` is\n                ``false``", 
               "sphinx_param_doc": "        :param offset_event_record_type: the type of the record to retrieve\n        :type offset_event_record_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "        :return: the offset event record\n        :rtype: ``osid.calendaring.records.OffsetEventRecord``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``offset_event_record_type`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unsupported`` -- ``has_record_type(offset_event_record_type)`` is ``false``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "offset_event_record_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "osid.calendaring.records.OffsetEventRecord", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.calendaring.records.OffsetEventRecord", 
         "shortname": "OffsetEventRecord", 
         "category": "records", 
         "doc": {
            "headline": "A record for an ``OffsetEvent``.", 
            "body": "    The methods specified by the record type are available through the\n    underlying object."
         }, 
         "inherit_fullnames": [
            "osid.OsidRecord"
         ], 
         "inherit_shortnames": [
            "OsidRecord"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidRecord"
            }
         ], 
         "method_names": [], 
         "methods": []
      }, 
      {
         "fullname": "osid.calendaring.OffsetEventQuery", 
         "shortname": "OffsetEventQuery", 
         "category": "queries", 
         "doc": {
            "headline": "This is the query for searching events.", 
            "body": "    Each method match request produces an ``AND`` term while multiple\n    invocations of a method produces a nested ``OR``."
         }, 
         "inherit_fullnames": [
            "osid.OsidRuleQuery"
         ], 
         "inherit_shortnames": [
            "OsidRuleQuery"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidRuleQuery"
            }
         ], 
         "method_names": [
            "match_fixed_start_time", 
            "match_any_fixed_start_time", 
            "clear_fixed_start_time_terms", 
            "match_start_reference_event_id", 
            "clear_start_reference_event_id_terms", 
            "supports_start_reference_event_query", 
            "get_start_reference_event_query", 
            "match_any_start_reference_event", 
            "clear_start_reference_event_terms", 
            "match_fixed_start_offset", 
            "match_any_fixed_start_offset", 
            "clear_fixed_start_offset_terms", 
            "match_relative_weekday_start_offset", 
            "clear_relative_weekday_start_offset_terms", 
            "match_relative_start_weekday", 
            "match_any_relative_start_weekday", 
            "clear_relative_start_weekday_terms", 
            "match_fixed_duration", 
            "clear_fixed_duration_terms", 
            "match_end_reference_event_id", 
            "clear_end_reference_event_id_terms", 
            "supports_end_reference_event_query", 
            "get_end_reference_event_query", 
            "match_any_end_reference_event", 
            "clear_end_reference_event_terms", 
            "match_fixed_end_offset", 
            "match_any_fixed_end_offset", 
            "clear_fixed_end_offset_terms", 
            "match_relative_weekday_end_offset", 
            "clear_relative_weekday_end_offset_terms", 
            "match_relative_end_weekday", 
            "match_any_relative_end_weekday", 
            "clear_relative_end_weekday_terms", 
            "match_location_description", 
            "match_any_location_description", 
            "clear_location_description_terms", 
            "match_location_id", 
            "clear_location_id_terms", 
            "supports_location_query", 
            "get_location_query", 
            "match_any_location", 
            "clear_location_terms", 
            "match_sponsor_id", 
            "clear_sponsor_id_terms", 
            "supports_sponsor_query", 
            "get_sponsor_query", 
            "clear_sponsor_terms", 
            "match_calendar_id", 
            "clear_calendar_id_terms", 
            "supports_calendar_query", 
            "get_calendar_query", 
            "clear_calendar_terms", 
            "get_offset_event_query_record"
         ], 
         "methods": [
            {
               "name": "match_fixed_start_time", 
               "doc": {
                  "headline": "Matches a fixed start time between the given range inclusive.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    from (osid.calendaring.DateTime): the start of the range\n        arg:    to (osid.calendaring.DateTime): the end of the range\n        arg:    match (boolean): ``true`` for a positive match,\n                ``false`` for a negative match\n", 
               "return_doc": "", 
               "error_doc": "        raise:  InvalidArgument - ``to`` is less than ``from``\n        raise:  NullArgument - ``from`` or ``to``  ``null``", 
               "sphinx_param_doc": "        :param from: the start of the range\n        :type from: ``osid.calendaring.DateTime``\n        :param to: the end of the range\n        :type to: ``osid.calendaring.DateTime``\n        :param match: ``true`` for a positive match, ``false`` for a negative match\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``InvalidArgument`` -- ``to`` is less than ``from``\n        :raise: ``NullArgument`` -- ``from`` or ``to``  ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.calendaring.DateTime", 
                     "var_name": "from_", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.calendaring.DateTime", 
                     "var_name": "to", 
                     "array": false
                  }, 
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.calendaring.DateTime", 
                  "osid.calendaring.DateTime", 
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {
                  "INVALID_ARGUMENT": "ConsumerContract", 
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "match_any_fixed_start_time", 
               "doc": {
                  "headline": "Matches events with fixed start times.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    match (boolean): ``true`` for a positive match,\n                ``false`` for a negative match\n", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "        :param match: ``true`` for a positive match, ``false`` for a negative match\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "clear_fixed_start_time_terms", 
               "doc": {
                  "headline": "Clears the fixed start time terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "match_start_reference_event_id", 
               "doc": {
                  "headline": "Sets the start reference event ``Id`` for this query.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    event_id (osid.id.Id): an event ``Id``\n        arg:    match (boolean): ``true`` for a positive match,\n                ``false`` for a negative match\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``event_id`` is ``null``", 
               "sphinx_param_doc": "        :param event_id: an event ``Id``\n        :type event_id: ``osid.id.Id``\n        :param match: ``true`` for a positive match, ``false`` for a negative match\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``event_id`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "event_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "clear_start_reference_event_id_terms", 
               "doc": {
                  "headline": "Clears the start reference event ``Id`` terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "supports_start_reference_event_query", 
               "doc": {
                  "headline": "Tests if an ``EventQuery`` is available for querying start reference event terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if an event query is available,\n                ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if an event query is available, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "get_start_reference_event_query", 
               "doc": {
                  "headline": "Gets the query for the start reference event.", 
                  "body": "        Multiple retrievals produce a nested ``OR`` term."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.EventQuery) - the event query", 
               "error_doc": "        raise:  Unimplemented -\n                ``supports_start_reference_event_query()`` is ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the event query\n        :rtype: ``osid.calendaring.EventQuery``", 
               "sphinx_error_doc": "        :raise: ``Unimplemented`` -- ``supports_start_reference_event_query()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_start_reference_event_query()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.EventQuery", 
               "errors": {
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "match_any_start_reference_event", 
               "doc": {
                  "headline": "Matches offset events with any starting reference event.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    match (boolean): ``true`` for a positive match,\n                ``false`` for a negative match\n", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "        :param match: ``true`` for a positive match, ``false`` for a negative match\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "clear_start_reference_event_terms", 
               "doc": {
                  "headline": "Clears the start reference event terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "match_fixed_start_offset", 
               "doc": {
                  "headline": "Matches a fixed offset amount between the given range inclusive.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    from (osid.calendaring.Duration): the start of the range\n        arg:    to (osid.calendaring.Duration): the end of the range\n        arg:    match (boolean): ``true`` for a positive match,\n                ``false`` for a negative match\n", 
               "return_doc": "", 
               "error_doc": "        raise:  InvalidArgument - ``to`` is less than ``from``\n        raise:  NullArgument - ``from`` or ``to``  ``null``", 
               "sphinx_param_doc": "        :param from: the start of the range\n        :type from: ``osid.calendaring.Duration``\n        :param to: the end of the range\n        :type to: ``osid.calendaring.Duration``\n        :param match: ``true`` for a positive match, ``false`` for a negative match\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``InvalidArgument`` -- ``to`` is less than ``from``\n        :raise: ``NullArgument`` -- ``from`` or ``to``  ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.calendaring.Duration", 
                     "var_name": "from_", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.calendaring.Duration", 
                     "var_name": "to", 
                     "array": false
                  }, 
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.calendaring.Duration", 
                  "osid.calendaring.Duration", 
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {
                  "INVALID_ARGUMENT": "ConsumerContract", 
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "match_any_fixed_start_offset", 
               "doc": {
                  "headline": "Matches fixed offset events.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    match (boolean): ``true`` for a positive match,\n                ``false`` for a negative match\n", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "        :param match: ``true`` for a positive match, ``false`` for a negative match\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "clear_fixed_start_offset_terms", 
               "doc": {
                  "headline": "Clears the fixed offset terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "match_relative_weekday_start_offset", 
               "doc": {
                  "headline": "Matches a relative weekday offset amount between the given range inclusive.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    low (integer): the start of the range\n        arg:    high (integer): the end of the range\n        arg:    match (boolean): ``true`` for a positive match,\n                ``false`` for a negative match\n", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "        :param low: the start of the range\n        :type low: ``integer``\n        :param high: the end of the range\n        :type high: ``integer``\n        :param match: ``true`` for a positive match, ``false`` for a negative match\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "integer", 
                     "var_name": "low", 
                     "array": false
                  }, 
                  {
                     "arg_type": "integer", 
                     "var_name": "high", 
                     "array": false
                  }, 
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "integer", 
                  "integer", 
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "clear_relative_weekday_start_offset_terms", 
               "doc": {
                  "headline": "Clears the relative weekday offset terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "match_relative_start_weekday", 
               "doc": {
                  "headline": "Matches a relative weekday.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    weekday (cardinal): the weekday\n        arg:    match (boolean): ``true`` for a positive match,\n                ``false`` for a negative match\n", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "        :param weekday: the weekday\n        :type weekday: ``cardinal``\n        :param match: ``true`` for a positive match, ``false`` for a negative match\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "cardinal", 
                     "var_name": "weekday", 
                     "array": false
                  }, 
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "cardinal", 
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "match_any_relative_start_weekday", 
               "doc": {
                  "headline": "Matches relative weekday offset events.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    match (boolean): ``true`` for a positive match,\n                ``false`` for a negative match\n", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "        :param match: ``true`` for a positive match, ``false`` for a negative match\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "clear_relative_start_weekday_terms", 
               "doc": {
                  "headline": "Clears the relative weekday terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "match_fixed_duration", 
               "doc": {
                  "headline": "Matches a fixed duration between the given range inclusive.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    low (osid.calendaring.Duration): the start of the range\n        arg:    high (osid.calendaring.Duration): the end of the range\n        arg:    match (boolean): ``true`` for a positive match,\n                ``false`` for a negative match\n", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "        :param low: the start of the range\n        :type low: ``osid.calendaring.Duration``\n        :param high: the end of the range\n        :type high: ``osid.calendaring.Duration``\n        :param match: ``true`` for a positive match, ``false`` for a negative match\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.calendaring.Duration", 
                     "var_name": "low", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.calendaring.Duration", 
                     "var_name": "high", 
                     "array": false
                  }, 
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.calendaring.Duration", 
                  "osid.calendaring.Duration", 
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "clear_fixed_duration_terms", 
               "doc": {
                  "headline": "Clears the fixed duration offset terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "match_end_reference_event_id", 
               "doc": {
                  "headline": "Sets the end reference event ``Id`` for this query.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    event_id (osid.id.Id): an event ``Id``\n        arg:    match (boolean): ``true`` for a positive match,\n                ``false`` for a negative match\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``event_id`` is ``null``", 
               "sphinx_param_doc": "        :param event_id: an event ``Id``\n        :type event_id: ``osid.id.Id``\n        :param match: ``true`` for a positive match, ``false`` for a negative match\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``event_id`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "event_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "clear_end_reference_event_id_terms", 
               "doc": {
                  "headline": "Clears the end reference event ``Id`` terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "supports_end_reference_event_query", 
               "doc": {
                  "headline": "Tests if an ``EventQuery`` is available for querying end reference event terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if an event query is available,\n                ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if an event query is available, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "get_end_reference_event_query", 
               "doc": {
                  "headline": "Gets the query for the end reference event.", 
                  "body": "        Multiple retrievals produce a nested ``OR`` term."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.EventQuery) - the event query", 
               "error_doc": "        raise:  Unimplemented -\n                ``supports_event_reference_event_query()`` is ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the event query\n        :rtype: ``osid.calendaring.EventQuery``", 
               "sphinx_error_doc": "        :raise: ``Unimplemented`` -- ``supports_event_reference_event_query()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_end_reference_event_query()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.EventQuery", 
               "errors": {
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "match_any_end_reference_event", 
               "doc": {
                  "headline": "Matches any end reference event events.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    match (boolean): ``true`` for a positive match,\n                ``false`` for a negative match\n", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "        :param match: ``true`` for a positive match, ``false`` for a negative match\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "clear_end_reference_event_terms", 
               "doc": {
                  "headline": "Clears the end reference event terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "match_fixed_end_offset", 
               "doc": {
                  "headline": "Matches a fixed offset amount between the given range inclusive.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    from (osid.calendaring.Duration): the start of the range\n        arg:    to (osid.calendaring.Duration): the end of the range\n        arg:    match (boolean): ``true`` for a positive match,\n                ``false`` for a negative match\n", 
               "return_doc": "", 
               "error_doc": "        raise:  InvalidArgument - ``to`` is less than ``from``\n        raise:  NullArgument - ``from`` or ``to``  ``null``", 
               "sphinx_param_doc": "        :param from: the start of the range\n        :type from: ``osid.calendaring.Duration``\n        :param to: the end of the range\n        :type to: ``osid.calendaring.Duration``\n        :param match: ``true`` for a positive match, ``false`` for a negative match\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``InvalidArgument`` -- ``to`` is less than ``from``\n        :raise: ``NullArgument`` -- ``from`` or ``to``  ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.calendaring.Duration", 
                     "var_name": "from_", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.calendaring.Duration", 
                     "var_name": "to", 
                     "array": false
                  }, 
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.calendaring.Duration", 
                  "osid.calendaring.Duration", 
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {
                  "INVALID_ARGUMENT": "ConsumerContract", 
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "match_any_fixed_end_offset", 
               "doc": {
                  "headline": "Matches fixed offset events.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    match (boolean): ``true`` for a positive match,\n                ``false`` for a negative match\n", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "        :param match: ``true`` for a positive match, ``false`` for a negative match\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "clear_fixed_end_offset_terms", 
               "doc": {
                  "headline": "Clears the fixed offset terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "match_relative_weekday_end_offset", 
               "doc": {
                  "headline": "Matches a relative weekday offset amount between the given range inclusive.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    low (integer): the start of the range\n        arg:    high (integer): the end of the range\n        arg:    match (boolean): ``true`` for a positive match,\n                ``false`` for a negative match\n", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "        :param low: the start of the range\n        :type low: ``integer``\n        :param high: the end of the range\n        :type high: ``integer``\n        :param match: ``true`` for a positive match, ``false`` for a negative match\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "integer", 
                     "var_name": "low", 
                     "array": false
                  }, 
                  {
                     "arg_type": "integer", 
                     "var_name": "high", 
                     "array": false
                  }, 
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "integer", 
                  "integer", 
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "clear_relative_weekday_end_offset_terms", 
               "doc": {
                  "headline": "Clears the relative weekday offset terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "match_relative_end_weekday", 
               "doc": {
                  "headline": "Matches a relative weekday.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    weekday (cardinal): the weekday\n        arg:    match (boolean): ``true`` for a positive match,\n                ``false`` for a negative match\n", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "        :param weekday: the weekday\n        :type weekday: ``cardinal``\n        :param match: ``true`` for a positive match, ``false`` for a negative match\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "cardinal", 
                     "var_name": "weekday", 
                     "array": false
                  }, 
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "cardinal", 
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "match_any_relative_end_weekday", 
               "doc": {
                  "headline": "Matches relative weekday offset events.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    match (boolean): ``true`` for a positive match,\n                ``false`` for a negative match\n", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "        :param match: ``true`` for a positive match, ``false`` for a negative match\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "clear_relative_end_weekday_terms", 
               "doc": {
                  "headline": "Clears the relative weekday terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "match_location_description", 
               "doc": {
                  "headline": "Matches the location description string.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    location (string): location string\n        arg:    string_match_type (osid.type.Type): string match type\n        arg:    match (boolean): ``true`` for a positive match,\n                ``false`` for a negative match\n", 
               "return_doc": "", 
               "error_doc": "        raise:  InvalidArgument - ``location`` is not of\n                ``string_match_type``\n        raise:  NullArgument - ``location`` or ``string_match_type`` is\n                ``null``\n        raise:  Unsupported -\n                ``supports_string_match_type(string_match_type)`` is\n                ``false``", 
               "sphinx_param_doc": "        :param location: location string\n        :type location: ``string``\n        :param string_match_type: string match type\n        :type string_match_type: ``osid.type.Type``\n        :param match: ``true`` for a positive match, ``false`` for a negative match\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``InvalidArgument`` -- ``location`` is not of ``string_match_type``\n        :raise: ``NullArgument`` -- ``location`` or ``string_match_type`` is ``null``\n        :raise: ``Unsupported`` -- ``supports_string_match_type(string_match_type)`` is ``false``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "string", 
                     "var_name": "location", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "string_match_type", 
                     "array": false
                  }, 
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "string", 
                  "osid.type.Type", 
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {
                  "INVALID_ARGUMENT": "ConsumerContract", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }, 
            {
               "name": "match_any_location_description", 
               "doc": {
                  "headline": "Matches an event that has any location description assigned.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    match (boolean): ``true`` to match events with any\n                location description, ``false`` to match events with no\n                location description\n", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "        :param match: ``true`` to match events with any location description, ``false`` to match events with no location description\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "clear_location_description_terms", 
               "doc": {
                  "headline": "Clears the location description terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "match_location_id", 
               "doc": {
                  "headline": "Sets the location ``Id`` for this query.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    location_id (osid.id.Id): a location ``Id``\n        arg:    match (boolean): ``true`` for a positive match,\n                ``false`` for a negative match\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``location_id`` is ``null``", 
               "sphinx_param_doc": "        :param location_id: a location ``Id``\n        :type location_id: ``osid.id.Id``\n        :param match: ``true`` for a positive match, ``false`` for a negative match\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``location_id`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "location_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "clear_location_id_terms", 
               "doc": {
                  "headline": "Clears the location ``Id`` terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "supports_location_query", 
               "doc": {
                  "headline": "Tests if a ``LocationQuery`` is available for querying locations.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if a location query is available,\n                ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if a location query is available, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "get_location_query", 
               "doc": {
                  "headline": "Gets the query for a location.", 
                  "body": "        Multiple retrievals produce a nested ``OR`` term."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.mapping.LocationQuery) - the location query", 
               "error_doc": "        raise:  Unimplemented - ``supports_location_query()`` is\n                ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the location query\n        :rtype: ``osid.mapping.LocationQuery``", 
               "sphinx_error_doc": "        :raise: ``Unimplemented`` -- ``supports_location_query()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_location_query()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.mapping.LocationQuery", 
               "errors": {
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "match_any_location", 
               "doc": {
                  "headline": "Matches an event that has any location assigned.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    match (boolean): ``true`` to match events with any\n                location, ``false`` to match events with no location\n", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "        :param match: ``true`` to match events with any location, ``false`` to match events with no location\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "clear_location_terms", 
               "doc": {
                  "headline": "Clears the location terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "match_sponsor_id", 
               "doc": {
                  "headline": "Sets the sponsor ``Id`` for this query.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    sponsor_id (osid.id.Id): a sponsor ``Id``\n        arg:    match (boolean): ``true`` for a positive match,\n                ``false`` for a negative match\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``sponsor_id`` is ``null``", 
               "sphinx_param_doc": "        :param sponsor_id: a sponsor ``Id``\n        :type sponsor_id: ``osid.id.Id``\n        :param match: ``true`` for a positive match, ``false`` for a negative match\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``sponsor_id`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "sponsor_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "clear_sponsor_id_terms", 
               "doc": {
                  "headline": "Clears the sponsor ``Id`` terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "supports_sponsor_query", 
               "doc": {
                  "headline": "Tests if a ``LocationQuery`` is available for querying sponsors.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if a sponsor query is available,\n                ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if a sponsor query is available, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "get_sponsor_query", 
               "doc": {
                  "headline": "Gets the query for a sponsor.", 
                  "body": "        Multiple retrievals produce a nested ``OR`` term."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.resource.ResourceQuery) - the sponsor query", 
               "error_doc": "        raise:  Unimplemented - ``supports_sponsor_query()`` is\n                ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the sponsor query\n        :rtype: ``osid.resource.ResourceQuery``", 
               "sphinx_error_doc": "        :raise: ``Unimplemented`` -- ``supports_sponsor_query()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_sponsor_query()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.resource.ResourceQuery", 
               "errors": {
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "clear_sponsor_terms", 
               "doc": {
                  "headline": "Clears the sponsor terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "match_calendar_id", 
               "doc": {
                  "headline": "Sets the calendar ``Id`` for this query.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    calendar_id (osid.id.Id): a calendar ``Id``\n        arg:    match (boolean): ``true`` for a positive match,\n                ``false`` for a negative match\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``calendar_id`` is ``null``", 
               "sphinx_param_doc": "        :param calendar_id: a calendar ``Id``\n        :type calendar_id: ``osid.id.Id``\n        :param match: ``true`` for a positive match, ``false`` for a negative match\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``calendar_id`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "calendar_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "clear_calendar_id_terms", 
               "doc": {
                  "headline": "Clears the calendar ``Id`` terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "supports_calendar_query", 
               "doc": {
                  "headline": "Tests if a ``CalendarQuery`` is available for querying calendars.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if a calendar query is available,\n                ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if a calendar query is available, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "get_calendar_query", 
               "doc": {
                  "headline": "Gets the query for a calendar.", 
                  "body": "        Multiple retrievals produce a nested ``OR`` term."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.CalendarQuery) - the calendar query", 
               "error_doc": "        raise:  Unimplemented - ``supports_calendar_query()`` is\n                ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the calendar query\n        :rtype: ``osid.calendaring.CalendarQuery``", 
               "sphinx_error_doc": "        :raise: ``Unimplemented`` -- ``supports_calendar_query()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_calendar_query()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.CalendarQuery", 
               "errors": {
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "clear_calendar_terms", 
               "doc": {
                  "headline": "Clears the calendar terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "get_offset_event_query_record", 
               "doc": {
                  "headline": "Gets the offset event query record corresponding to the given ``OffsetEvent`` record ``Type``.", 
                  "body": "        Multiple retrievals produce a nested ``OR`` term."
               }, 
               "arg_doc": "        arg:    offset_event_record_type (osid.type.Type): an offset\n                event query record type\n", 
               "return_doc": "        return: (osid.calendaring.records.OffsetEventQueryRecord) - the\n                offset event query record", 
               "error_doc": "        raise:  NullArgument - ``offset_event_record_type`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unsupported -\n                ``has_record_type(offset_event_record_type)`` is\n                ``false``", 
               "sphinx_param_doc": "        :param offset_event_record_type: an offset event query record type\n        :type offset_event_record_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "        :return: the offset event query record\n        :rtype: ``osid.calendaring.records.OffsetEventQueryRecord``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``offset_event_record_type`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unsupported`` -- ``has_record_type(offset_event_record_type)`` is ``false``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "offset_event_record_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "osid.calendaring.records.OffsetEventQueryRecord", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.calendaring.records.OffsetEventQueryRecord", 
         "shortname": "OffsetEventQueryRecord", 
         "category": "records", 
         "doc": {
            "headline": "A record for an ``OffsetEventQuery``.", 
            "body": "    The methods specified by the record type are available through the\n    underlying object."
         }, 
         "inherit_fullnames": [
            "osid.OsidRecord"
         ], 
         "inherit_shortnames": [
            "OsidRecord"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidRecord"
            }
         ], 
         "method_names": [], 
         "methods": []
      }, 
      {
         "fullname": "osid.calendaring.OffsetEventQueryInspector", 
         "shortname": "OffsetEventQueryInspector", 
         "category": "query_inspectors", 
         "doc": {
            "headline": "This is the query inspector for examining offset event queries.", 
            "body": ""
         }, 
         "inherit_fullnames": [
            "osid.OsidRuleQueryInspector"
         ], 
         "inherit_shortnames": [
            "OsidRuleQueryInspector"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidRuleQueryInspector"
            }
         ], 
         "method_names": [
            "get_fixed_start_time_terms", 
            "get_start_reference_event_id_terms", 
            "get_start_reference_event_terms", 
            "get_fixed_start_offset_terms", 
            "get_relative_weekday_start_offset_terms", 
            "get_relative_start_weekday_terms", 
            "get_fixed_duration_terms", 
            "get_end_reference_event_id_terms", 
            "get_end_reference_event_terms", 
            "get_fixed_end_offset_terms", 
            "get_relative_weekday_end_offset_terms", 
            "get_relative_end_weekday_terms", 
            "get_location_description_terms", 
            "get_location_id_terms", 
            "get_location_terms", 
            "get_sponsor_id_terms", 
            "get_sponsor_terms", 
            "get_calendar_id_terms", 
            "get_calendar_terms", 
            "get_offset_event_query_inspector_record"
         ], 
         "methods": [
            {
               "name": "get_fixed_start_time_terms", 
               "doc": {
                  "headline": "Gets the fixed start time terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.search.terms.DateTimeRangeTerm) - the fixed start\n                time terms", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the fixed start time terms\n        :rtype: ``osid.search.terms.DateTimeRangeTerm``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.search.terms.DateTimeRangeTerm", 
               "errors": {}
            }, 
            {
               "name": "get_start_reference_event_id_terms", 
               "doc": {
                  "headline": "Gets the event ``Id`` terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.search.terms.IdTerm) - the event ``Id`` terms", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the event ``Id`` terms\n        :rtype: ``osid.search.terms.IdTerm``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.search.terms.IdTerm", 
               "errors": {}
            }, 
            {
               "name": "get_start_reference_event_terms", 
               "doc": {
                  "headline": "Gets the event terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.EventQueryInspector) - the event terms", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the event terms\n        :rtype: ``osid.calendaring.EventQueryInspector``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.EventQueryInspector", 
               "errors": {}
            }, 
            {
               "name": "get_fixed_start_offset_terms", 
               "doc": {
                  "headline": "Gets the fixed offset terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.search.terms.IntegerRangeTerm) - the fixed offset\n                terms", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the fixed offset terms\n        :rtype: ``osid.search.terms.IntegerRangeTerm``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.search.terms.IntegerRangeTerm", 
               "errors": {}
            }, 
            {
               "name": "get_relative_weekday_start_offset_terms", 
               "doc": {
                  "headline": "Gets the relative weekday offset terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.search.terms.IntegerRangeTerm) - the relative\n                weekday offset terms", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the relative weekday offset terms\n        :rtype: ``osid.search.terms.IntegerRangeTerm``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.search.terms.IntegerRangeTerm", 
               "errors": {}
            }, 
            {
               "name": "get_relative_start_weekday_terms", 
               "doc": {
                  "headline": "Gets the relative weekday terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.search.terms.CardinalTerm) - the relative weekday\n                terms", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the relative weekday terms\n        :rtype: ``osid.search.terms.CardinalTerm``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.search.terms.CardinalTerm", 
               "errors": {}
            }, 
            {
               "name": "get_fixed_duration_terms", 
               "doc": {
                  "headline": "Gets the fixed duration terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.search.terms.DurationRangeTerm) - the fixed\n                duration terms", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the fixed duration terms\n        :rtype: ``osid.search.terms.DurationRangeTerm``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.search.terms.DurationRangeTerm", 
               "errors": {}
            }, 
            {
               "name": "get_end_reference_event_id_terms", 
               "doc": {
                  "headline": "Gets the event ``Id`` terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.search.terms.IdTerm) - the event ``Id`` terms", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the event ``Id`` terms\n        :rtype: ``osid.search.terms.IdTerm``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.search.terms.IdTerm", 
               "errors": {}
            }, 
            {
               "name": "get_end_reference_event_terms", 
               "doc": {
                  "headline": "Gets the event terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.EventQueryInspector) - the event terms", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the event terms\n        :rtype: ``osid.calendaring.EventQueryInspector``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.EventQueryInspector", 
               "errors": {}
            }, 
            {
               "name": "get_fixed_end_offset_terms", 
               "doc": {
                  "headline": "Gets the fixed offset terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.search.terms.IntegerRangeTerm) - the fixed offset\n                terms", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the fixed offset terms\n        :rtype: ``osid.search.terms.IntegerRangeTerm``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.search.terms.IntegerRangeTerm", 
               "errors": {}
            }, 
            {
               "name": "get_relative_weekday_end_offset_terms", 
               "doc": {
                  "headline": "Gets the relative weekday offset terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.search.terms.IntegerRangeTerm) - the relative\n                weekday offset terms", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the relative weekday offset terms\n        :rtype: ``osid.search.terms.IntegerRangeTerm``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.search.terms.IntegerRangeTerm", 
               "errors": {}
            }, 
            {
               "name": "get_relative_end_weekday_terms", 
               "doc": {
                  "headline": "Gets the relative weekday terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.search.terms.CardinalTerm) - the relative weekday\n                terms", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the relative weekday terms\n        :rtype: ``osid.search.terms.CardinalTerm``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.search.terms.CardinalTerm", 
               "errors": {}
            }, 
            {
               "name": "get_location_description_terms", 
               "doc": {
                  "headline": "Gets the location description terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.search.terms.StringTerm) - the location\n                description terms", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the location description terms\n        :rtype: ``osid.search.terms.StringTerm``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.search.terms.StringTerm", 
               "errors": {}
            }, 
            {
               "name": "get_location_id_terms", 
               "doc": {
                  "headline": "Gets the location ``Id`` terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.search.terms.IdTerm) - the location ``Id`` terms", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the location ``Id`` terms\n        :rtype: ``osid.search.terms.IdTerm``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.search.terms.IdTerm", 
               "errors": {}
            }, 
            {
               "name": "get_location_terms", 
               "doc": {
                  "headline": "Gets the location terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.mapping.LocationQueryInspector) - the location\n                terms", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the location terms\n        :rtype: ``osid.mapping.LocationQueryInspector``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.mapping.LocationQueryInspector", 
               "errors": {}
            }, 
            {
               "name": "get_sponsor_id_terms", 
               "doc": {
                  "headline": "Gets the sponsor ``Id`` terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.search.terms.IdTerm) - the sponsor ``Id`` terms", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the sponsor ``Id`` terms\n        :rtype: ``osid.search.terms.IdTerm``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.search.terms.IdTerm", 
               "errors": {}
            }, 
            {
               "name": "get_sponsor_terms", 
               "doc": {
                  "headline": "Gets the sponsor terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.resource.ResourceQueryInspector) - the sponsor\n                terms", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the sponsor terms\n        :rtype: ``osid.resource.ResourceQueryInspector``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.resource.ResourceQueryInspector", 
               "errors": {}
            }, 
            {
               "name": "get_calendar_id_terms", 
               "doc": {
                  "headline": "Gets the calendar ``Id`` terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.search.terms.IdTerm) - the calendar ``Id`` terms", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the calendar ``Id`` terms\n        :rtype: ``osid.search.terms.IdTerm``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.search.terms.IdTerm", 
               "errors": {}
            }, 
            {
               "name": "get_calendar_terms", 
               "doc": {
                  "headline": "Gets the calendar terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.CalendarQueryInspector) - the calendar\n                terms", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the calendar terms\n        :rtype: ``osid.calendaring.CalendarQueryInspector``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.CalendarQueryInspector", 
               "errors": {}
            }, 
            {
               "name": "get_offset_event_query_inspector_record", 
               "doc": {
                  "headline": "Gets the offset event query inspector record corresponding to the given ``OffsetEvent`` record ``Type``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    offset_event_record_type (osid.type.Type): an offset\n                event query record type\n", 
               "return_doc": "        return:\n                (osid.calendaring.records.OffsetEventQueryInspectorRecor\n                d) - the offset event query inspector record", 
               "error_doc": "        raise:  NullArgument - ``offset_event_record_type`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unsupported -\n                ``has_record_type(offset_event_record_type)`` is\n                ``false``", 
               "sphinx_param_doc": "        :param offset_event_record_type: an offset event query record type\n        :type offset_event_record_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "        :return: the offset event query inspector record\n        :rtype: ``osid.calendaring.records.OffsetEventQueryInspectorRecord``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``offset_event_record_type`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unsupported`` -- ``has_record_type(offset_event_record_type)`` is ``false``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "offset_event_record_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "osid.calendaring.records.OffsetEventQueryInspectorRecord", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.calendaring.records.OffsetEventQueryInspectorRecord", 
         "shortname": "OffsetEventQueryInspectorRecord", 
         "category": "records", 
         "doc": {
            "headline": "A record for an ``OffsetEventQueryInspector``.", 
            "body": "    The methods specified by the record type are available through the\n    underlying object."
         }, 
         "inherit_fullnames": [
            "osid.OsidRecord"
         ], 
         "inherit_shortnames": [
            "OsidRecord"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidRecord"
            }
         ], 
         "method_names": [], 
         "methods": []
      }, 
      {
         "fullname": "osid.calendaring.OffsetEventForm", 
         "shortname": "OffsetEventForm", 
         "category": "objects", 
         "doc": {
            "headline": "This is the form for creating and updating ``OffsetEvents``.", 
            "body": "    Like all ``OsidForm`` objects, various data elements may be set here\n    for use in the create and update methods in the\n    ``OffsetEventAdminSession``. For each data element that may be set,\n    metadata may be examined to provide display hints or data\n    constraints."
         }, 
         "inherit_fullnames": [
            "osid.OsidRuleForm"
         ], 
         "inherit_shortnames": [
            "OsidRuleForm"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidRuleForm"
            }
         ], 
         "method_names": [
            "get_fixed_start_time_metadata", 
            "set_fixed_start_time", 
            "clear_fixed_start_time", 
            "get_start_reference_event_metadata", 
            "set_start_reference_event", 
            "clear_start_reference_event", 
            "get_fixed_start_offset_metadata", 
            "set_fixed_start_offset", 
            "clear_fixed_start_offset", 
            "get_relative_weekday_start_offset_metadata", 
            "set_relative_weekday_start_offset", 
            "clear_relative_weekday_start_offset", 
            "get_relative_start_weekday_metadata", 
            "set_relative_start_weekday", 
            "clear_relative_start_weekday", 
            "get_fixed_duration_metadata", 
            "set_fixed_duration", 
            "clear_fixed_duration", 
            "get_end_reference_event_metadata", 
            "set_end_reference_event", 
            "clear_end_reference_event", 
            "get_fixed_end_offset_metadata", 
            "set_fixed_end_offset", 
            "clear_fixed_end_offset", 
            "get_relative_weekday_end_offset_metadata", 
            "set_relative_weekday_end_offset", 
            "clear_relative_weekday_end_offset", 
            "get_relative_end_weekday_metadata", 
            "set_relative_end_weekday", 
            "clear_relative_end_weekday", 
            "get_location_description_metadata", 
            "set_location_description", 
            "clear_location_description", 
            "get_location_metadata", 
            "set_location", 
            "clear_location", 
            "get_sponsor_metadata", 
            "set_sponsors", 
            "clear_sponsors", 
            "get_offset_event_form_record"
         ], 
         "methods": [
            {
               "name": "get_fixed_start_time_metadata", 
               "doc": {
                  "headline": "Gets the metadata for the fixed start time.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.Metadata) - metadata for the fixed start time", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: metadata for the fixed start time\n        :rtype: ``osid.Metadata``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.Metadata", 
               "errors": {}
            }, 
            {
               "name": "set_fixed_start_time", 
               "doc": {
                  "headline": "Sets the fixed start time.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    date (osid.calendaring.DateTime): the fixed start time\n", 
               "return_doc": "", 
               "error_doc": "        raise:  InvalidArgument - ``date`` is invalid\n        raise:  NoAccess - ``date`` cannot be modified\n        raise:  NullArgument - ``date`` is ``null``", 
               "sphinx_param_doc": "        :param date: the fixed start time\n        :type date: ``osid.calendaring.DateTime``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``InvalidArgument`` -- ``date`` is invalid\n        :raise: ``NoAccess`` -- ``date`` cannot be modified\n        :raise: ``NullArgument`` -- ``date`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.calendaring.DateTime", 
                     "var_name": "date", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.calendaring.DateTime"
               ], 
               "return_type": "", 
               "errors": {
                  "INVALID_ARGUMENT": "ConsumerContract", 
                  "NO_ACCESS": "ConsumerContract", 
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "clear_fixed_start_time", 
               "doc": {
                  "headline": "Clears the fixed start time.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "        raise:  NoAccess - ``Metadata.isRequired()`` or\n                ``Metadata.isReadOnly()`` is ``true``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NoAccess`` -- ``Metadata.isRequired()`` or ``Metadata.isReadOnly()`` is ``true``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {
                  "NO_ACCESS": "ConsumerContract"
               }
            }, 
            {
               "name": "get_start_reference_event_metadata", 
               "doc": {
                  "headline": "Gets the metadata for the starting reference event.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.Metadata) - metadata for the starting reference\n                event", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: metadata for the starting reference event\n        :rtype: ``osid.Metadata``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.Metadata", 
               "errors": {}
            }, 
            {
               "name": "set_start_reference_event", 
               "doc": {
                  "headline": "Sets the fixed start time.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    event_id (osid.id.Id): the start reference event ``Id``\n", 
               "return_doc": "", 
               "error_doc": "        raise:  InvalidArgument - ``event_id`` is invalid\n        raise:  NoAccess - ``event_id`` cannot be modified\n        raise:  NullArgument - ``event_id`` is ``null``", 
               "sphinx_param_doc": "        :param event_id: the start reference event ``Id``\n        :type event_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``InvalidArgument`` -- ``event_id`` is invalid\n        :raise: ``NoAccess`` -- ``event_id`` cannot be modified\n        :raise: ``NullArgument`` -- ``event_id`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "event_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {
                  "INVALID_ARGUMENT": "ConsumerContract", 
                  "NO_ACCESS": "ConsumerContract", 
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "clear_start_reference_event", 
               "doc": {
                  "headline": "Clears the start reference event.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "        raise:  NoAccess - ``Metadata.isRequired()`` or\n                ``Metadata.isReadOnly()`` is ``true``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NoAccess`` -- ``Metadata.isRequired()`` or ``Metadata.isReadOnly()`` is ``true``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {
                  "NO_ACCESS": "ConsumerContract"
               }
            }, 
            {
               "name": "get_fixed_start_offset_metadata", 
               "doc": {
                  "headline": "Gets the metadata for the fixed start offset.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.Metadata) - metadata for the fixed start offset", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: metadata for the fixed start offset\n        :rtype: ``osid.Metadata``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.Metadata", 
               "errors": {}
            }, 
            {
               "name": "set_fixed_start_offset", 
               "doc": {
                  "headline": "Sets the fixed start offset.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    offset (osid.calendaring.Duration): the fixed offset\n", 
               "return_doc": "", 
               "error_doc": "        raise:  InvalidArgument - ``offset`` is invalid\n        raise:  NoAccess - ``offset`` cannot be modified\n        raise:  NullArgument - ``offset`` is ``null``", 
               "sphinx_param_doc": "        :param offset: the fixed offset\n        :type offset: ``osid.calendaring.Duration``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``InvalidArgument`` -- ``offset`` is invalid\n        :raise: ``NoAccess`` -- ``offset`` cannot be modified\n        :raise: ``NullArgument`` -- ``offset`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.calendaring.Duration", 
                     "var_name": "offset", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.calendaring.Duration"
               ], 
               "return_type": "", 
               "errors": {
                  "INVALID_ARGUMENT": "ConsumerContract", 
                  "NO_ACCESS": "ConsumerContract", 
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "clear_fixed_start_offset", 
               "doc": {
                  "headline": "Clears the fixed start offset.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "        raise:  NoAccess - ``Metadata.isRequired()`` or\n                ``Metadata.isReadOnly()`` is ``true``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NoAccess`` -- ``Metadata.isRequired()`` or ``Metadata.isReadOnly()`` is ``true``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {
                  "NO_ACCESS": "ConsumerContract"
               }
            }, 
            {
               "name": "get_relative_weekday_start_offset_metadata", 
               "doc": {
                  "headline": "Gets the metadata for the relative weekday offset.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.Metadata) - metadata for the relative weekday\n                offset", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: metadata for the relative weekday offset\n        :rtype: ``osid.Metadata``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.Metadata", 
               "errors": {}
            }, 
            {
               "name": "set_relative_weekday_start_offset", 
               "doc": {
                  "headline": "Sets the relative weekday offset as the nth weekday from the relative event.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    offset (integer): the week offset\n", 
               "return_doc": "", 
               "error_doc": "        raise:  InvalidArgument - ``offset`` is invalid\n        raise:  NoAccess - ``offset`` cannot be modified", 
               "sphinx_param_doc": "        :param offset: the week offset\n        :type offset: ``integer``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``InvalidArgument`` -- ``offset`` is invalid\n        :raise: ``NoAccess`` -- ``offset`` cannot be modified", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "integer", 
                     "var_name": "offset", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "integer"
               ], 
               "return_type": "", 
               "errors": {
                  "INVALID_ARGUMENT": "ConsumerContract", 
                  "NO_ACCESS": "ConsumerContract"
               }
            }, 
            {
               "name": "clear_relative_weekday_start_offset", 
               "doc": {
                  "headline": "Clears the relative weekday offset.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "        raise:  NoAccess - ``Metadata.isRequired()`` or\n                ``Metadata.isReadOnly()`` is ``true``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NoAccess`` -- ``Metadata.isRequired()`` or ``Metadata.isReadOnly()`` is ``true``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {
                  "NO_ACCESS": "ConsumerContract"
               }
            }, 
            {
               "name": "get_relative_start_weekday_metadata", 
               "doc": {
                  "headline": "Gets the metadata for the relative weekday.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.Metadata) - metadata for the relative weekday", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: metadata for the relative weekday\n        :rtype: ``osid.Metadata``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.Metadata", 
               "errors": {}
            }, 
            {
               "name": "set_relative_start_weekday", 
               "doc": {
                  "headline": "Sets the relative weekday.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    weekday (cardinal): the weekday\n", 
               "return_doc": "", 
               "error_doc": "        raise:  InvalidArgument - ``weekday`` is invalid\n        raise:  NoAccess - ``weekday`` cannot be modified", 
               "sphinx_param_doc": "        :param weekday: the weekday\n        :type weekday: ``cardinal``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``InvalidArgument`` -- ``weekday`` is invalid\n        :raise: ``NoAccess`` -- ``weekday`` cannot be modified", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "cardinal", 
                     "var_name": "weekday", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "cardinal"
               ], 
               "return_type": "", 
               "errors": {
                  "INVALID_ARGUMENT": "ConsumerContract", 
                  "NO_ACCESS": "ConsumerContract"
               }
            }, 
            {
               "name": "clear_relative_start_weekday", 
               "doc": {
                  "headline": "Clears the relative start weekday.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "        raise:  NoAccess - ``Metadata.isRequired()`` or\n                ``Metadata.isReadOnly()`` is ``true``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NoAccess`` -- ``Metadata.isRequired()`` or ``Metadata.isReadOnly()`` is ``true``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {
                  "NO_ACCESS": "ConsumerContract"
               }
            }, 
            {
               "name": "get_fixed_duration_metadata", 
               "doc": {
                  "headline": "Gets the metadata for the fixed duration.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.Metadata) - metadata for the fixed duration", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: metadata for the fixed duration\n        :rtype: ``osid.Metadata``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.Metadata", 
               "errors": {}
            }, 
            {
               "name": "set_fixed_duration", 
               "doc": {
                  "headline": "Sets the fixed duration.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    duration (osid.calendaring.Duration): the fixed duration\n", 
               "return_doc": "", 
               "error_doc": "        raise:  InvalidArgument - ``duration`` is invalid\n        raise:  NoAccess - ``duration`` cannot be modified\n        raise:  NullArgument - ``duration`` is ``null``", 
               "sphinx_param_doc": "        :param duration: the fixed duration\n        :type duration: ``osid.calendaring.Duration``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``InvalidArgument`` -- ``duration`` is invalid\n        :raise: ``NoAccess`` -- ``duration`` cannot be modified\n        :raise: ``NullArgument`` -- ``duration`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.calendaring.Duration", 
                     "var_name": "duration", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.calendaring.Duration"
               ], 
               "return_type": "", 
               "errors": {
                  "INVALID_ARGUMENT": "ConsumerContract", 
                  "NO_ACCESS": "ConsumerContract", 
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "clear_fixed_duration", 
               "doc": {
                  "headline": "Clears the fixed duration.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "        raise:  NoAccess - ``Metadata.isRequired()`` or\n                ``Metadata.isReadOnly()`` is ``true``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NoAccess`` -- ``Metadata.isRequired()`` or ``Metadata.isReadOnly()`` is ``true``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {
                  "NO_ACCESS": "ConsumerContract"
               }
            }, 
            {
               "name": "get_end_reference_event_metadata", 
               "doc": {
                  "headline": "Gets the metadata for the ending reference event.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.Metadata) - metadata for the ending reference\n                event", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: metadata for the ending reference event\n        :rtype: ``osid.Metadata``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.Metadata", 
               "errors": {}
            }, 
            {
               "name": "set_end_reference_event", 
               "doc": {
                  "headline": "Sets the fixed end time.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    event_id (osid.id.Id): the end reference event ``Id``\n", 
               "return_doc": "", 
               "error_doc": "        raise:  InvalidArgument - ``event_id`` is invalid\n        raise:  NoAccess - ``event_id`` cannot be modified\n        raise:  NullArgument - ``event_id`` is ``null``", 
               "sphinx_param_doc": "        :param event_id: the end reference event ``Id``\n        :type event_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``InvalidArgument`` -- ``event_id`` is invalid\n        :raise: ``NoAccess`` -- ``event_id`` cannot be modified\n        :raise: ``NullArgument`` -- ``event_id`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "event_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {
                  "INVALID_ARGUMENT": "ConsumerContract", 
                  "NO_ACCESS": "ConsumerContract", 
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "clear_end_reference_event", 
               "doc": {
                  "headline": "Clears the ending reference event.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "        raise:  NoAccess - ``Metadata.isRequired()`` or\n                ``Metadata.isReadOnly()`` is ``true``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NoAccess`` -- ``Metadata.isRequired()`` or ``Metadata.isReadOnly()`` is ``true``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {
                  "NO_ACCESS": "ConsumerContract"
               }
            }, 
            {
               "name": "get_fixed_end_offset_metadata", 
               "doc": {
                  "headline": "Gets the metadata for the fixed end offset.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.Metadata) - metadata for the fixed end offset", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: metadata for the fixed end offset\n        :rtype: ``osid.Metadata``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.Metadata", 
               "errors": {}
            }, 
            {
               "name": "set_fixed_end_offset", 
               "doc": {
                  "headline": "Sets the fixed end offset.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    offset (osid.calendaring.Duration): the fixed offset\n", 
               "return_doc": "", 
               "error_doc": "        raise:  InvalidArgument - ``offset`` is invalid\n        raise:  NoAccess - ``offset`` cannot be modified\n        raise:  NullArgument - ``offset`` is ``null``", 
               "sphinx_param_doc": "        :param offset: the fixed offset\n        :type offset: ``osid.calendaring.Duration``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``InvalidArgument`` -- ``offset`` is invalid\n        :raise: ``NoAccess`` -- ``offset`` cannot be modified\n        :raise: ``NullArgument`` -- ``offset`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.calendaring.Duration", 
                     "var_name": "offset", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.calendaring.Duration"
               ], 
               "return_type": "", 
               "errors": {
                  "INVALID_ARGUMENT": "ConsumerContract", 
                  "NO_ACCESS": "ConsumerContract", 
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "clear_fixed_end_offset", 
               "doc": {
                  "headline": "Clears the fixed end offset.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "        raise:  NoAccess - ``Metadata.isRequired()`` or\n                ``Metadata.isReadOnly()`` is ``true``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NoAccess`` -- ``Metadata.isRequired()`` or ``Metadata.isReadOnly()`` is ``true``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {
                  "NO_ACCESS": "ConsumerContract"
               }
            }, 
            {
               "name": "get_relative_weekday_end_offset_metadata", 
               "doc": {
                  "headline": "Gets the metadata for the relative weekday offset.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.Metadata) - metadata for the relative weekday\n                offset", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: metadata for the relative weekday offset\n        :rtype: ``osid.Metadata``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.Metadata", 
               "errors": {}
            }, 
            {
               "name": "set_relative_weekday_end_offset", 
               "doc": {
                  "headline": "Sets the relative weekday offset as the nth weekday from the relative event.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    offset (integer): the week offset\n", 
               "return_doc": "", 
               "error_doc": "        raise:  InvalidArgument - ``offset`` is invalid\n        raise:  NoAccess - ``offset`` cannot be modified", 
               "sphinx_param_doc": "        :param offset: the week offset\n        :type offset: ``integer``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``InvalidArgument`` -- ``offset`` is invalid\n        :raise: ``NoAccess`` -- ``offset`` cannot be modified", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "integer", 
                     "var_name": "offset", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "integer"
               ], 
               "return_type": "", 
               "errors": {
                  "INVALID_ARGUMENT": "ConsumerContract", 
                  "NO_ACCESS": "ConsumerContract"
               }
            }, 
            {
               "name": "clear_relative_weekday_end_offset", 
               "doc": {
                  "headline": "Clears the relative weekday offset.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "        raise:  NoAccess - ``Metadata.isRequired()`` or\n                ``Metadata.isReadOnly()`` is ``true``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NoAccess`` -- ``Metadata.isRequired()`` or ``Metadata.isReadOnly()`` is ``true``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {
                  "NO_ACCESS": "ConsumerContract"
               }
            }, 
            {
               "name": "get_relative_end_weekday_metadata", 
               "doc": {
                  "headline": "Gets the metadata for the relative weekday.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.Metadata) - metadata for the relative weekday", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: metadata for the relative weekday\n        :rtype: ``osid.Metadata``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.Metadata", 
               "errors": {}
            }, 
            {
               "name": "set_relative_end_weekday", 
               "doc": {
                  "headline": "Sets the relative weekday.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    weekday (cardinal): the weekday\n", 
               "return_doc": "", 
               "error_doc": "        raise:  InvalidArgument - ``weekday`` is invalid\n        raise:  NoAccess - ``weekday`` cannot be modified", 
               "sphinx_param_doc": "        :param weekday: the weekday\n        :type weekday: ``cardinal``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``InvalidArgument`` -- ``weekday`` is invalid\n        :raise: ``NoAccess`` -- ``weekday`` cannot be modified", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "cardinal", 
                     "var_name": "weekday", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "cardinal"
               ], 
               "return_type": "", 
               "errors": {
                  "INVALID_ARGUMENT": "ConsumerContract", 
                  "NO_ACCESS": "ConsumerContract"
               }
            }, 
            {
               "name": "clear_relative_end_weekday", 
               "doc": {
                  "headline": "Clears the relative end weekday.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "        raise:  NoAccess - ``Metadata.isRequired()`` or\n                ``Metadata.isReadOnly()`` is ``true``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NoAccess`` -- ``Metadata.isRequired()`` or ``Metadata.isReadOnly()`` is ``true``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {
                  "NO_ACCESS": "ConsumerContract"
               }
            }, 
            {
               "name": "get_location_description_metadata", 
               "doc": {
                  "headline": "Gets the metadata for a location description.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.Metadata) - metadata for the location description", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: metadata for the location description\n        :rtype: ``osid.Metadata``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.Metadata", 
               "errors": {}
            }, 
            {
               "name": "set_location_description", 
               "doc": {
                  "headline": "Sets the location description.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    location (string): the new location description\n", 
               "return_doc": "", 
               "error_doc": "        raise:  InvalidArgument - ``location`` is invalid\n        raise:  NoAccess - ``location`` cannot be modified\n        raise:  NullArgument - ``location`` is ``null``", 
               "sphinx_param_doc": "        :param location: the new location description\n        :type location: ``string``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``InvalidArgument`` -- ``location`` is invalid\n        :raise: ``NoAccess`` -- ``location`` cannot be modified\n        :raise: ``NullArgument`` -- ``location`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "string", 
                     "var_name": "location", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "string"
               ], 
               "return_type": "", 
               "errors": {
                  "INVALID_ARGUMENT": "ConsumerContract", 
                  "NO_ACCESS": "ConsumerContract", 
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "clear_location_description", 
               "doc": {
                  "headline": "Clears the location description.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "        raise:  NoAccess - ``Metadata.isRequired()`` or\n                ``Metadata.isReadOnly()`` is ``true``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NoAccess`` -- ``Metadata.isRequired()`` or ``Metadata.isReadOnly()`` is ``true``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {
                  "NO_ACCESS": "ConsumerContract"
               }
            }, 
            {
               "name": "get_location_metadata", 
               "doc": {
                  "headline": "Gets the metadata for a location.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.Metadata) - metadata for the location", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: metadata for the location\n        :rtype: ``osid.Metadata``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.Metadata", 
               "errors": {}
            }, 
            {
               "name": "set_location", 
               "doc": {
                  "headline": "Sets the location.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    location_id (osid.id.Id): the new location\n", 
               "return_doc": "", 
               "error_doc": "        raise:  InvalidArgument - ``location_id`` is invalid\n        raise:  NoAccess - ``location_id`` cannot be modified\n        raise:  NullArgument - ``location_id`` is ``null``", 
               "sphinx_param_doc": "        :param location_id: the new location\n        :type location_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``InvalidArgument`` -- ``location_id`` is invalid\n        :raise: ``NoAccess`` -- ``location_id`` cannot be modified\n        :raise: ``NullArgument`` -- ``location_id`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "location_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {
                  "INVALID_ARGUMENT": "ConsumerContract", 
                  "NO_ACCESS": "ConsumerContract", 
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "clear_location", 
               "doc": {
                  "headline": "Clears the location.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "        raise:  NoAccess - ``Metadata.isRequired()`` or\n                ``Metadata.isReadOnly()`` is ``true``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NoAccess`` -- ``Metadata.isRequired()`` or ``Metadata.isReadOnly()`` is ``true``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {
                  "NO_ACCESS": "ConsumerContract"
               }
            }, 
            {
               "name": "get_sponsor_metadata", 
               "doc": {
                  "headline": "Gets the metadata for a sponsor.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.Metadata) - metadata for the sponsor", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: metadata for the sponsor\n        :rtype: ``osid.Metadata``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.Metadata", 
               "errors": {}
            }, 
            {
               "name": "set_sponsors", 
               "doc": {
                  "headline": "Sets the sponsors.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    sponsor_ids (osid.id.Id[]): the new sponsor\n", 
               "return_doc": "", 
               "error_doc": "        raise:  InvalidArgument - ``sponsor_ids`` is invalid\n        raise:  NoAccess - ``sponsor_ids`` cannot be modified\n        raise:  NullArgument - ``sponsor_ids`` is ``null``", 
               "sphinx_param_doc": "        :param sponsor_ids: the new sponsor\n        :type sponsor_ids: ``osid.id.Id[]``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``InvalidArgument`` -- ``sponsor_ids`` is invalid\n        :raise: ``NoAccess`` -- ``sponsor_ids`` cannot be modified\n        :raise: ``NullArgument`` -- ``sponsor_ids`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id[]", 
                     "var_name": "sponsor_ids", 
                     "array": true
                  }
               ], 
               "arg_types": [
                  "osid.id.Id[]"
               ], 
               "return_type": "", 
               "errors": {
                  "INVALID_ARGUMENT": "ConsumerContract", 
                  "NO_ACCESS": "ConsumerContract", 
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "clear_sponsors", 
               "doc": {
                  "headline": "Clears the sponsors.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "        raise:  NoAccess - ``Metadata.isRequired()`` or\n                ``Metadata.isReadOnly()`` is ``true``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NoAccess`` -- ``Metadata.isRequired()`` or ``Metadata.isReadOnly()`` is ``true``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {
                  "NO_ACCESS": "ConsumerContract"
               }
            }, 
            {
               "name": "get_offset_event_form_record", 
               "doc": {
                  "headline": "Gets the ``OffsetEventFormRecord`` corresponding to the given schedule record ``Type``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    offset_event_record_type (osid.type.Type): the offset\n                event record type\n", 
               "return_doc": "        return: (osid.calendaring.records.OffsetEventFormRecord) - the\n                offset event form record", 
               "error_doc": "        raise:  NullArgument - ``offset_event_record_type`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unsupported -\n                ``has_record_type(offset_event_record_type)`` is\n                ``false``", 
               "sphinx_param_doc": "        :param offset_event_record_type: the offset event record type\n        :type offset_event_record_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "        :return: the offset event form record\n        :rtype: ``osid.calendaring.records.OffsetEventFormRecord``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``offset_event_record_type`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unsupported`` -- ``has_record_type(offset_event_record_type)`` is ``false``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "offset_event_record_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "osid.calendaring.records.OffsetEventFormRecord", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.calendaring.records.OffsetEventFormRecord", 
         "shortname": "OffsetEventFormRecord", 
         "category": "records", 
         "doc": {
            "headline": "A record for an ``OffsetEventForm``.", 
            "body": "    The methods specified by the record type are available through the\n    underlying object."
         }, 
         "inherit_fullnames": [
            "osid.OsidRecord"
         ], 
         "inherit_shortnames": [
            "OsidRecord"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidRecord"
            }
         ], 
         "method_names": [], 
         "methods": []
      }, 
      {
         "fullname": "osid.calendaring.OffsetEventSearchOrder", 
         "shortname": "OffsetEventSearchOrder", 
         "category": "search_orders", 
         "doc": {
            "headline": "An interface for specifying the ordering of search results.", 
            "body": ""
         }, 
         "inherit_fullnames": [
            "osid.OsidRuleSearchOrder"
         ], 
         "inherit_shortnames": [
            "OsidRuleSearchOrder"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidRuleSearchOrder"
            }
         ], 
         "method_names": [
            "order_by_fixed_start_time", 
            "order_by_start_reference_event", 
            "supports_start_reference_event_search_order", 
            "get_start_reference_event_search_order", 
            "order_by_fixed_start_offset", 
            "order_by_relative_weekday_start_offset", 
            "order_by_relative_start_weekday", 
            "order_by_fixed_duration", 
            "order_by_end_reference_event", 
            "supports_end_reference_event_search_order", 
            "get_end_reference_event_search_order", 
            "order_by_fixed_end_offset", 
            "order_by_relative_weekday_end_offset", 
            "order_by_relative_end_weekday", 
            "order_by_location_description", 
            "order_by_location", 
            "supports_location_search_order", 
            "get_location_search_order", 
            "get_offset_event_search_order_record"
         ], 
         "methods": [
            {
               "name": "order_by_fixed_start_time", 
               "doc": {
                  "headline": "Specified a preference for ordering results by the fixed start time.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    style (osid.SearchOrderStyle): a search order style\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``style`` is ``null``", 
               "sphinx_param_doc": "        :param style: a search order style\n        :type style: ``osid.SearchOrderStyle``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``style`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.SearchOrderStyle", 
                     "var_name": "style", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.SearchOrderStyle"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "order_by_start_reference_event", 
               "doc": {
                  "headline": "Specified a preference for ordering results by the starting reference event.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    style (osid.SearchOrderStyle): a search order style\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``style`` is ``null``", 
               "sphinx_param_doc": "        :param style: a search order style\n        :type style: ``osid.SearchOrderStyle``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``style`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.SearchOrderStyle", 
                     "var_name": "style", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.SearchOrderStyle"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "supports_start_reference_event_search_order", 
               "doc": {
                  "headline": "Tests if an ``EventSearchOrder`` is available.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if an event search order is\n                available, ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if an event search order is available, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "get_start_reference_event_search_order", 
               "doc": {
                  "headline": "Gets the search order for an event.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.EventSearchOrder) - the event search\n                order", 
               "error_doc": "        raise:  Unimplemented -\n                ``supports_start_reference_event_search_order()`` is\n                ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the event search order\n        :rtype: ``osid.calendaring.EventSearchOrder``", 
               "sphinx_error_doc": "        :raise: ``Unimplemented`` -- ``supports_start_reference_event_search_order()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_start_reference_event_search_order()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.EventSearchOrder", 
               "errors": {
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "order_by_fixed_start_offset", 
               "doc": {
                  "headline": "Specified a preference for ordering results by the fixed offset.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    style (osid.SearchOrderStyle): a search order style\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``style`` is ``null``", 
               "sphinx_param_doc": "        :param style: a search order style\n        :type style: ``osid.SearchOrderStyle``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``style`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.SearchOrderStyle", 
                     "var_name": "style", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.SearchOrderStyle"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "order_by_relative_weekday_start_offset", 
               "doc": {
                  "headline": "Specified a preference for ordering results by the relative weekday offset.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    style (osid.SearchOrderStyle): a search order style\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``style`` is ``null``", 
               "sphinx_param_doc": "        :param style: a search order style\n        :type style: ``osid.SearchOrderStyle``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``style`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.SearchOrderStyle", 
                     "var_name": "style", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.SearchOrderStyle"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "order_by_relative_start_weekday", 
               "doc": {
                  "headline": "Specified a preference for ordering results by the relative weekday.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    style (osid.SearchOrderStyle): a search order style\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``style`` is ``null``", 
               "sphinx_param_doc": "        :param style: a search order style\n        :type style: ``osid.SearchOrderStyle``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``style`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.SearchOrderStyle", 
                     "var_name": "style", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.SearchOrderStyle"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "order_by_fixed_duration", 
               "doc": {
                  "headline": "Specified a preference for ordering results by the fixed duration.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    style (osid.SearchOrderStyle): a search order style\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``style`` is ``null``", 
               "sphinx_param_doc": "        :param style: a search order style\n        :type style: ``osid.SearchOrderStyle``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``style`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.SearchOrderStyle", 
                     "var_name": "style", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.SearchOrderStyle"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "order_by_end_reference_event", 
               "doc": {
                  "headline": "Specified a preference for ordering results by the ending reference event.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    style (osid.SearchOrderStyle): a search order style\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``style`` is ``null``", 
               "sphinx_param_doc": "        :param style: a search order style\n        :type style: ``osid.SearchOrderStyle``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``style`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.SearchOrderStyle", 
                     "var_name": "style", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.SearchOrderStyle"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "supports_end_reference_event_search_order", 
               "doc": {
                  "headline": "Tests if an ``EventSearchOrder`` is available.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if an event search order is\n                available, ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if an event search order is available, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "get_end_reference_event_search_order", 
               "doc": {
                  "headline": "Gets the search order for an event.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.EventSearchOrder) - the event search\n                order", 
               "error_doc": "        raise:  Unimplemented -\n                ``supports_end_reference_event_search_order()`` is\n                ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the event search order\n        :rtype: ``osid.calendaring.EventSearchOrder``", 
               "sphinx_error_doc": "        :raise: ``Unimplemented`` -- ``supports_end_reference_event_search_order()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_end_reference_event_search_order()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.EventSearchOrder", 
               "errors": {
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "order_by_fixed_end_offset", 
               "doc": {
                  "headline": "Specified a preference for ordering results by the fixed offset.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    style (osid.SearchOrderStyle): a search order style\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``style`` is ``null``", 
               "sphinx_param_doc": "        :param style: a search order style\n        :type style: ``osid.SearchOrderStyle``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``style`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.SearchOrderStyle", 
                     "var_name": "style", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.SearchOrderStyle"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "order_by_relative_weekday_end_offset", 
               "doc": {
                  "headline": "Specified a preference for ordering results by the relative weekday offset.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    style (osid.SearchOrderStyle): a search order style\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``style`` is ``null``", 
               "sphinx_param_doc": "        :param style: a search order style\n        :type style: ``osid.SearchOrderStyle``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``style`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.SearchOrderStyle", 
                     "var_name": "style", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.SearchOrderStyle"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "order_by_relative_end_weekday", 
               "doc": {
                  "headline": "Specified a preference for ordering results by the relative weekday.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    style (osid.SearchOrderStyle): a search order style\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``style`` is ``null``", 
               "sphinx_param_doc": "        :param style: a search order style\n        :type style: ``osid.SearchOrderStyle``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``style`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.SearchOrderStyle", 
                     "var_name": "style", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.SearchOrderStyle"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "order_by_location_description", 
               "doc": {
                  "headline": "Specified a preference for ordering results by the location description.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    style (osid.SearchOrderStyle): a search order style\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``style`` is ``null``", 
               "sphinx_param_doc": "        :param style: a search order style\n        :type style: ``osid.SearchOrderStyle``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``style`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.SearchOrderStyle", 
                     "var_name": "style", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.SearchOrderStyle"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "order_by_location", 
               "doc": {
                  "headline": "Specified a preference for ordering results by the location.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    style (osid.SearchOrderStyle): a search order style\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``style`` is ``null``", 
               "sphinx_param_doc": "        :param style: a search order style\n        :type style: ``osid.SearchOrderStyle``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``style`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.SearchOrderStyle", 
                     "var_name": "style", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.SearchOrderStyle"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "supports_location_search_order", 
               "doc": {
                  "headline": "Tests if a ``LocationSearchOrder`` is available.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if a location search order is\n                available, ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if a location search order is available, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "get_location_search_order", 
               "doc": {
                  "headline": "Gets the search order for a location.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.mapping.LocationSearchOrder) - the location search\n                order", 
               "error_doc": "        raise:  Unimplemented - ``supports_location_search_order()`` is\n                ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the location search order\n        :rtype: ``osid.mapping.LocationSearchOrder``", 
               "sphinx_error_doc": "        :raise: ``Unimplemented`` -- ``supports_location_search_order()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_location_search_order()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.mapping.LocationSearchOrder", 
               "errors": {
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_offset_event_search_order_record", 
               "doc": {
                  "headline": "Gets the offset event search order record corresponding to the given offset event record ``Type``.", 
                  "body": "        Multiple retrievals return the same underlying object."
               }, 
               "arg_doc": "        arg:    offset_event_record_type (osid.type.Type): an offset\n                event record type\n", 
               "return_doc": "        return: (osid.calendaring.records.OffsetEventSearchOrderRecord)\n                - the offset event search order record", 
               "error_doc": "        raise:  NullArgument - ``offset_event_record_type`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unsupported -\n                ``has_record_type(offset_event_record_type)`` is\n                ``false``", 
               "sphinx_param_doc": "        :param offset_event_record_type: an offset event record type\n        :type offset_event_record_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "        :return: the offset event search order record\n        :rtype: ``osid.calendaring.records.OffsetEventSearchOrderRecord``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``offset_event_record_type`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unsupported`` -- ``has_record_type(offset_event_record_type)`` is ``false``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "offset_event_record_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "osid.calendaring.records.OffsetEventSearchOrderRecord", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.calendaring.records.OffsetEventSearchOrderRecord", 
         "shortname": "OffsetEventSearchOrderRecord", 
         "category": "records", 
         "doc": {
            "headline": "A record for an ``OffsetEventSearchOrder``.", 
            "body": "    The methods specified by the record type are available through the\n    underlying object."
         }, 
         "inherit_fullnames": [
            "osid.OsidRecord"
         ], 
         "inherit_shortnames": [
            "OsidRecord"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidRecord"
            }
         ], 
         "method_names": [], 
         "methods": []
      }, 
      {
         "fullname": "osid.calendaring.OffsetEventSearch", 
         "shortname": "OffsetEventSearch", 
         "category": "searches", 
         "doc": {
            "headline": "``OffsetEventSearch`` defines the interface for specifying offset event search options.", 
            "body": ""
         }, 
         "inherit_fullnames": [
            "osid.OsidSearch"
         ], 
         "inherit_shortnames": [
            "OsidSearch"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidSearch"
            }
         ], 
         "method_names": [
            "search_among_offset_events", 
            "order_offset_event_results", 
            "get_offset_event_search_record"
         ], 
         "methods": [
            {
               "name": "search_among_offset_events", 
               "doc": {
                  "headline": "Execute this search among the given list of offset events.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    offset_event_ids (osid.id.IdList): list of offset events\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``offset_event_ids`` is ``null``", 
               "sphinx_param_doc": "        :param offset_event_ids: list of offset events\n        :type offset_event_ids: ``osid.id.IdList``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``offset_event_ids`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.IdList", 
                     "var_name": "offset_event_ids", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.IdList"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "order_offset_event_results", 
               "doc": {
                  "headline": "Specify an ordering to the search results.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    offset_event_search_order\n                (osid.calendaring.OffsetEventSearchOrder): offset event\n                search order\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``offset_event_search_order`` is ``null``\n        raise:  Unsupported - ``offset_event_search_order`` is not of\n                this service", 
               "sphinx_param_doc": "        :param offset_event_search_order: offset event search order\n        :type offset_event_search_order: ``osid.calendaring.OffsetEventSearchOrder``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``offset_event_search_order`` is ``null``\n        :raise: ``Unsupported`` -- ``offset_event_search_order`` is not of this service", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.calendaring.OffsetEventSearchOrder", 
                     "var_name": "offset_event_search_order", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.calendaring.OffsetEventSearchOrder"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_offset_event_search_record", 
               "doc": {
                  "headline": "Gets the offset event search record corresponding to the given offset event search record ``Type``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    offset_event_search_record_type (osid.type.Type): an\n                offset event search record type\n", 
               "return_doc": "        return: (osid.calendaring.records.OffsetEventSearchRecord) - the\n                offset event search record", 
               "error_doc": "        raise:  NullArgument - ``offset_event_search_record_type`` is\n                ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unsupported -\n                ``has_record_type(offset_event_search_record_type)`` is\n                ``false``", 
               "sphinx_param_doc": "        :param offset_event_search_record_type: an offset event search record type\n        :type offset_event_search_record_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "        :return: the offset event search record\n        :rtype: ``osid.calendaring.records.OffsetEventSearchRecord``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``offset_event_search_record_type`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unsupported`` -- ``has_record_type(offset_event_search_record_type)`` is ``false``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "offset_event_search_record_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "osid.calendaring.records.OffsetEventSearchRecord", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.calendaring.records.OffsetEventSearchRecord", 
         "shortname": "OffsetEventSearchRecord", 
         "category": "records", 
         "doc": {
            "headline": "A record for an ``OffsetEventSearch``.", 
            "body": "    The methods specified by the record type are available through the\n    underlying object."
         }, 
         "inherit_fullnames": [
            "osid.OsidRecord"
         ], 
         "inherit_shortnames": [
            "OsidRecord"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidRecord"
            }
         ], 
         "method_names": [], 
         "methods": []
      }, 
      {
         "fullname": "osid.calendaring.OffsetEventSearchResults", 
         "shortname": "OffsetEventSearchResults", 
         "category": "searches", 
         "doc": {
            "headline": "This interface provides a means to capture results of a search.", 
            "body": ""
         }, 
         "inherit_fullnames": [
            "osid.OsidSearchResults"
         ], 
         "inherit_shortnames": [
            "OsidSearchResults"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidSearchResults"
            }
         ], 
         "method_names": [
            "get_offset_events", 
            "get_offset_event_query_inspector", 
            "get_offset_event_search_results_record"
         ], 
         "methods": [
            {
               "name": "get_offset_events", 
               "doc": {
                  "headline": "Gets the offset event list resulting from the search.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.OffsetEventList) - the offset event\n                list", 
               "error_doc": "        raise:  IllegalState - list already retrieved", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the offset event list\n        :rtype: ``osid.calendaring.OffsetEventList``", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- list already retrieved", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.OffsetEventList", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract"
               }
            }, 
            {
               "name": "get_offset_event_query_inspector", 
               "doc": {
                  "headline": "Gets the inspector for the query to examine the terms used in the search.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.OffsetEventQueryInspector) - the query\n                inspector", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the query inspector\n        :rtype: ``osid.calendaring.OffsetEventQueryInspector``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.OffsetEventQueryInspector", 
               "errors": {}
            }, 
            {
               "name": "get_offset_event_search_results_record", 
               "doc": {
                  "headline": "Gets the offset event search results record corresponding to the given offset event search record ``Type``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    offset_event_search_record_type (osid.type.Type): an\n                offset event search record type\n", 
               "return_doc": "        return:\n                (osid.calendaring.records.OffsetEventSearchResultsRecord\n                ) - the offset event search results record", 
               "error_doc": "        raise:  NullArgument - ``offset_event_search_record_type`` is\n                ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unsupported -\n                ``has_record_type(offset_event_search_record_type)`` is\n                ``false``", 
               "sphinx_param_doc": "        :param offset_event_search_record_type: an offset event search record type\n        :type offset_event_search_record_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "        :return: the offset event search results record\n        :rtype: ``osid.calendaring.records.OffsetEventSearchResultsRecord``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``offset_event_search_record_type`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unsupported`` -- ``has_record_type(offset_event_search_record_type)`` is ``false``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "offset_event_search_record_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "osid.calendaring.records.OffsetEventSearchResultsRecord", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.calendaring.records.OffsetEventSearchResultsRecord", 
         "shortname": "OffsetEventSearchResultsRecord", 
         "category": "records", 
         "doc": {
            "headline": "A record for an ``OffsetEventSearchResults``.", 
            "body": "    The methods specified by the record type are available through the\n    underlying object."
         }, 
         "inherit_fullnames": [
            "osid.OsidRecord"
         ], 
         "inherit_shortnames": [
            "OsidRecord"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidRecord"
            }
         ], 
         "method_names": [], 
         "methods": []
      }, 
      {
         "fullname": "osid.calendaring.OffsetEventReceiver", 
         "shortname": "OffsetEventReceiver", 
         "category": "receivers", 
         "doc": {
            "headline": "The event receiver is the consumer supplied interface for receiving notifications pertaining to new, updated or deleted ``OffsetEvents``.", 
            "body": ""
         }, 
         "inherit_fullnames": [
            "osid.OsidReceiver"
         ], 
         "inherit_shortnames": [
            "OsidReceiver"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidReceiver"
            }
         ], 
         "method_names": [
            "new_offset_event", 
            "changed_offset_event", 
            "deleted_offset_event"
         ], 
         "methods": [
            {
               "name": "new_offset_event", 
               "doc": {
                  "headline": "The callback for notifications of new offset events.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    offset_event_id (osid.id.Id): the ``Id`` of the new\n                ``OffsetEvent``\n", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "        :param offset_event_id: the ``Id`` of the new ``OffsetEvent``\n        :type offset_event_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "offset_event_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "changed_offset_event", 
               "doc": {
                  "headline": "The callback for notification of updated offset events.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    offset_event_id (osid.id.Id): the ``Id`` of the updated\n                ``OffsetEvent``\n", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "        :param offset_event_id: the ``Id`` of the updated ``OffsetEvent``\n        :type offset_event_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "offset_event_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "deleted_offset_event", 
               "doc": {
                  "headline": "The callback for notification of deleted offset events.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    offset_event_id (osid.id.Id): the ``Id`` of the deleted\n                ``OffsetEvent``\n", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "        :param offset_event_id: the ``Id`` of the deleted ``OffsetEvent``\n        :type offset_event_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "offset_event_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {}
            }
         ]
      }, 
      {
         "fullname": "osid.calendaring.OffsetEventList", 
         "shortname": "OffsetEventList", 
         "category": "objects", 
         "doc": {
            "headline": "Like all ``OsidLists,``  ``OffsetEventList`` provides a means for accessing ``OffsetEvent`` elements sequentially either one at a time or many at a time.", 
            "body": "    Examples: while (oel.hasNext()) { OffsetEvent event =\n    oel.getNextOffsetEvent(); }\n\n    or\n      while (oel.hasNext()) {\n           OffsetEvent[] events = oel.getNextOffsetEvents(oel.available());\n      }\n    \n"
         }, 
         "inherit_fullnames": [
            "osid.OsidList"
         ], 
         "inherit_shortnames": [
            "OsidList"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidList"
            }
         ], 
         "method_names": [
            "get_next_offset_event", 
            "get_next_offset_events"
         ], 
         "methods": [
            {
               "name": "get_next_offset_event", 
               "doc": {
                  "headline": "Gets the next ``OffsetEvent`` in this list.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.OffsetEvent) - the next\n                ``OffsetEvent`` in this list. The ``has_next()`` method\n                should be used to test that a next ``OffsetEvent`` is\n                available before calling this method.", 
               "error_doc": "        raise:  IllegalState - no more elements available in this list\n        raise:  OperationFailed - unable to complete request", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the next ``OffsetEvent`` in this list. The ``has_next()`` method should be used to test that a next ``OffsetEvent`` is available before calling this method.\n        :rtype: ``osid.calendaring.OffsetEvent``", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- no more elements available in this list\n        :raise: ``OperationFailed`` -- unable to complete request", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.OffsetEvent", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational"
               }
            }, 
            {
               "name": "get_next_offset_events", 
               "doc": {
                  "headline": "Gets the next set of ``OffsetEvent`` elements in this list which must be less than or equal to the number returned from ``available()``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    n (cardinal): the number of ``OffsetEvent`` elements\n                requested which should be less than or equal to\n                ``available()``\n", 
               "return_doc": "        return: (osid.calendaring.OffsetEvent) - an array of\n                ``OffsetEvent`` elements.The length of the array is less\n                than or equal to the number specified.", 
               "error_doc": "        raise:  IllegalState - no more elements available in this list\n        raise:  OperationFailed - unable to complete request", 
               "sphinx_param_doc": "        :param n: the number of ``OffsetEvent`` elements requested which should be less than or equal to ``available()``\n        :type n: ``cardinal``\n", 
               "sphinx_return_doc": "        :return: an array of ``OffsetEvent`` elements.The length of the array is less than or equal to the number specified.\n        :rtype: ``osid.calendaring.OffsetEvent``", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- no more elements available in this list\n        :raise: ``OperationFailed`` -- unable to complete request", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "cardinal", 
                     "var_name": "n", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "cardinal"
               ], 
               "return_type": "osid.calendaring.OffsetEvent", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.calendaring.Schedule", 
         "shortname": "Schedule", 
         "category": "objects", 
         "doc": {
            "headline": "A ``Schedule`` is a scheduled time slot offered within a time interval at a location.", 
            "body": "    The time interval may be inferred from an associated ``TimePeriod``\n    or managed explicitly without a ``TimePeriod``."
         }, 
         "inherit_fullnames": [
            "osid.OsidObject"
         ], 
         "inherit_shortnames": [
            "OsidObject"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidObject"
            }
         ], 
         "method_names": [
            "get_schedule_slot_id", 
            "get_schedule_slot", 
            "has_time_period", 
            "get_time_period_id", 
            "get_time_period", 
            "get_schedule_start", 
            "get_schedule_end", 
            "has_limit", 
            "get_limit", 
            "get_location_description", 
            "has_location", 
            "get_location_id", 
            "get_location", 
            "get_total_duration", 
            "get_schedule_record"
         ], 
         "methods": [
            {
               "name": "get_schedule_slot_id", 
               "doc": {
                  "headline": "Gets the ``Id`` of the schedule slot.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.id.Id) - the schedule slot ``Id``", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the schedule slot ``Id``\n        :rtype: ``osid.id.Id``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.id.Id", 
               "errors": {}
            }, 
            {
               "name": "get_schedule_slot", 
               "doc": {
                  "headline": "Gets the schedule slot included inside this one.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.ScheduleSlot) - the schedule slot", 
               "error_doc": "        raise:  OperationFailed - unable to complete request", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the schedule slot\n        :rtype: ``osid.calendaring.ScheduleSlot``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.ScheduleSlot", 
               "errors": {
                  "OPERATION_FAILED": "Operational"
               }
            }, 
            {
               "name": "has_time_period", 
               "doc": {
                  "headline": "Tests if a ``TimePeriod`` is associated with this schedule.", 
                  "body": "        The time period determines the start and end time of the\n        recurring series."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if there is an associated\n                ``TimePeriod,``  ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if there is an associated ``TimePeriod,``  ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "get_time_period_id", 
               "doc": {
                  "headline": "Gets the ``TimePeriod Id`` for this recurring event.", 
                  "body": "        A ``Schedule`` with an associated ``TimePeriod`` overrides any\n        start or end date set."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.id.Id) - the time period ``Id``", 
               "error_doc": "        raise:  IllegalState - ``has_time_period()`` is ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the time period ``Id``\n        :rtype: ``osid.id.Id``", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- ``has_time_period()`` is ``false``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.id.Id", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract"
               }
            }, 
            {
               "name": "get_time_period", 
               "doc": {
                  "headline": "Gets the ``TimePeriod`` for this recurring event.", 
                  "body": "        A ``Schedule`` with an associated ``TimePeriod`` overrides any\n        start or end date set."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.TimePeriod) - the time period", 
               "error_doc": "        raise:  IllegalState - ``has_time_period()`` is ``false``\n        raise:  OperationFailed - unable to complete request", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the time period\n        :rtype: ``osid.calendaring.TimePeriod``", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- ``has_time_period()`` is ``false``\n        :raise: ``OperationFailed`` -- unable to complete request", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.TimePeriod", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational"
               }
            }, 
            {
               "name": "get_schedule_start", 
               "doc": {
                  "headline": "Gets the start date of this schedule.", 
                  "body": "        If ``has_time_period()`` is ``true,`` the start date is the\n        start date of the associated ``TimePeriod``."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.DateTime) - the start date", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the start date\n        :rtype: ``osid.calendaring.DateTime``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.DateTime", 
               "errors": {}
            }, 
            {
               "name": "get_schedule_end", 
               "doc": {
                  "headline": "Gets the end date of this schedule.", 
                  "body": "        If ``has_time_period()`` is ``true,`` the end date is the end\n        date of the associated ``TimePeriod``."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.DateTime) - the end date", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the end date\n        :rtype: ``osid.calendaring.DateTime``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.DateTime", 
               "errors": {}
            }, 
            {
               "name": "has_limit", 
               "doc": {
                  "headline": "Tests if this schedule has a limit on the number of occurrences.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if there is a limit ``false``\n                otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if there is a limit ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "get_limit", 
               "doc": {
                  "headline": "Gets the limit of the number of occurences of this schedule.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (cardinal) - the limit", 
               "error_doc": "        raise:  IllegalState - ``has_limitl()`` is ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the limit\n        :rtype: ``cardinal``", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- ``has_limitl()`` is ``false``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "cardinal", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract"
               }
            }, 
            {
               "name": "get_location_description", 
               "doc": {
                  "headline": "Gets a descriptive location.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.locale.DisplayText) - the location", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the location\n        :rtype: ``osid.locale.DisplayText``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.locale.DisplayText", 
               "errors": {}
            }, 
            {
               "name": "has_location", 
               "doc": {
                  "headline": "Tests if a location is associated with this event.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if there is an associated location,\n                ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if there is an associated location, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "get_location_id", 
               "doc": {
                  "headline": "Gets the location ``Id``.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.id.Id) - a location ``Id``", 
               "error_doc": "        raise:  IllegalState - ``has_location()`` is ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: a location ``Id``\n        :rtype: ``osid.id.Id``", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- ``has_location()`` is ``false``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.id.Id", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract"
               }
            }, 
            {
               "name": "get_location", 
               "doc": {
                  "headline": "Gets the ``Location``.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.mapping.Location) - a location", 
               "error_doc": "        raise:  IllegalState - ``has_location()`` is ``false``\n        raise:  OperationFailed - unable to complete request", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: a location\n        :rtype: ``osid.mapping.Location``", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- ``has_location()`` is ``false``\n        :raise: ``OperationFailed`` -- unable to complete request", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.mapping.Location", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational"
               }
            }, 
            {
               "name": "get_total_duration", 
               "doc": {
                  "headline": "Gets a total duration for the entire schedule based on the duration of schedule slots and span of the schedule.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.Duration) - the total duration", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the total duration\n        :rtype: ``osid.calendaring.Duration``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.Duration", 
               "errors": {}
            }, 
            {
               "name": "get_schedule_record", 
               "doc": {
                  "headline": "Gets the schedule record corresponding to the given ``Schedule`` record ``Type``.", 
                  "body": "        This method is used to retrieve an object implementing the\n        requested record. The ``schedule_record_type`` may be the\n        ``Type`` returned in ``get_record_types()`` or any of its\n        parents in a ``Type`` hierarchy where\n        ``has_record_type(schedule_record_type)`` is ``true`` ."
               }, 
               "arg_doc": "        arg:    schedule_record_type (osid.type.Type): the type of the\n                record to retrieve\n", 
               "return_doc": "        return: (osid.calendaring.records.ScheduleRecord) - the schedule\n                record", 
               "error_doc": "        raise:  NullArgument - ``schedule_record_type`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unsupported - ``has_record_type(schedule_record_type)``\n                is ``false``", 
               "sphinx_param_doc": "        :param schedule_record_type: the type of the record to retrieve\n        :type schedule_record_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "        :return: the schedule record\n        :rtype: ``osid.calendaring.records.ScheduleRecord``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``schedule_record_type`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unsupported`` -- ``has_record_type(schedule_record_type)`` is ``false``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "schedule_record_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "osid.calendaring.records.ScheduleRecord", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.calendaring.records.ScheduleRecord", 
         "shortname": "ScheduleRecord", 
         "category": "records", 
         "doc": {
            "headline": "A record for a ``Schedule``.", 
            "body": "    The methods specified by the record type are available through the\n    underlying object."
         }, 
         "inherit_fullnames": [
            "osid.OsidRecord"
         ], 
         "inherit_shortnames": [
            "OsidRecord"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidRecord"
            }
         ], 
         "method_names": [], 
         "methods": []
      }, 
      {
         "fullname": "osid.calendaring.ScheduleQuery", 
         "shortname": "ScheduleQuery", 
         "category": "queries", 
         "doc": {
            "headline": "This is the query for searching schedules.", 
            "body": "    Each method match request produces an ``AND`` term while multiple\n    invocations of a method produces a nested ``OR``."
         }, 
         "inherit_fullnames": [
            "osid.OsidObjectQuery"
         ], 
         "inherit_shortnames": [
            "OsidObjectQuery"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidObjectQuery"
            }
         ], 
         "method_names": [
            "match_schedule_slot_id", 
            "clear_schedule_slot_id_terms", 
            "supports_schedule_slot_query", 
            "get_schedule_slot_query", 
            "match_any_schedule_slot", 
            "clear_schedule_slot_terms", 
            "match_time_period_id", 
            "clear_time_period_id_terms", 
            "supports_time_period_query", 
            "get_time_period_query", 
            "match_any_time_period", 
            "clear_time_period_terms", 
            "match_schedule_start", 
            "match_any_schedule_start", 
            "clear_schedule_start_terms", 
            "match_schedule_end", 
            "match_any_schedule_end", 
            "clear_schedule_end_terms", 
            "match_schedule_time", 
            "match_any_schedule_time", 
            "clear_schedule_time_terms", 
            "match_schedule_time_inclusive", 
            "clear_schedule_time_inclusive_terms", 
            "match_limit", 
            "match_any_limit", 
            "clear_limit_terms", 
            "match_location_description", 
            "match_any_location_description", 
            "clear_location_description_terms", 
            "match_location_id", 
            "clear_location_id_terms", 
            "supports_location_query", 
            "get_location_query", 
            "match_any_location", 
            "clear_location_terms", 
            "match_total_duration", 
            "clear_total_duration_terms", 
            "match_calendar_id", 
            "clear_calendar_id_terms", 
            "supports_calendar_query", 
            "get_calendar_query", 
            "clear_calendar_terms", 
            "get_schedule_query_record"
         ], 
         "methods": [
            {
               "name": "match_schedule_slot_id", 
               "doc": {
                  "headline": "Sets the schedule ``Id`` for this query for matching nested schedule slots.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    schedule_slot_id (osid.id.Id): a schedule slot ``Id``\n        arg:    match (boolean): ``true`` for a positive match,\n                ``false`` for a negative match\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``schedule_slot_id`` is ``null``", 
               "sphinx_param_doc": "        :param schedule_slot_id: a schedule slot ``Id``\n        :type schedule_slot_id: ``osid.id.Id``\n        :param match: ``true`` for a positive match, ``false`` for a negative match\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``schedule_slot_id`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "schedule_slot_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "clear_schedule_slot_id_terms", 
               "doc": {
                  "headline": "Clears the schedule slot ``Id`` terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "supports_schedule_slot_query", 
               "doc": {
                  "headline": "Tests if a ``ScheduleSlotQuery`` is available for querying sechedule slots.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if a schedule slot query is\n                available, ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if a schedule slot query is available, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "get_schedule_slot_query", 
               "doc": {
                  "headline": "Gets the query for a schedul slot.", 
                  "body": "        Multiple retrievals produce a nested ``OR`` term."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.ScheduleSlotQuery) - the schedule slot\n                query", 
               "error_doc": "        raise:  Unimplemented - ``supports_schedule_slot_query()`` is\n                ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the schedule slot query\n        :rtype: ``osid.calendaring.ScheduleSlotQuery``", 
               "sphinx_error_doc": "        :raise: ``Unimplemented`` -- ``supports_schedule_slot_query()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_schedule_slot_query()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.ScheduleSlotQuery", 
               "errors": {
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "match_any_schedule_slot", 
               "doc": {
                  "headline": "Matches a schedule that has any schedule slot assigned.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    match (boolean): ``true`` to match schedule with any\n                schedule slots, ``false`` to match schedules with no\n                schedule slots\n", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "        :param match: ``true`` to match schedule with any schedule slots, ``false`` to match schedules with no schedule slots\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "clear_schedule_slot_terms", 
               "doc": {
                  "headline": "Clears the schedule slot terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "match_time_period_id", 
               "doc": {
                  "headline": "Sets the time period ``Id`` for this query.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    time_period_id (osid.id.Id): a time period ``Id``\n        arg:    match (boolean): ``true`` for a positive match,\n                ``false`` for a negative match\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``time_period_id`` is ``null``", 
               "sphinx_param_doc": "        :param time_period_id: a time period ``Id``\n        :type time_period_id: ``osid.id.Id``\n        :param match: ``true`` for a positive match, ``false`` for a negative match\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``time_period_id`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "time_period_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "clear_time_period_id_terms", 
               "doc": {
                  "headline": "Clears the time period ``Id`` terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "supports_time_period_query", 
               "doc": {
                  "headline": "Tests if a ``TimePeriodQuery`` is available.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if a time period query is\n                available, ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if a time period query is available, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "get_time_period_query", 
               "doc": {
                  "headline": "Gets the query for a time period.", 
                  "body": "        Multiple retrievals produce a nested ``OR`` term."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.TimePeriodQuery) - the time period\n                query", 
               "error_doc": "        raise:  Unimplemented - ``supports_time_period_query()`` is\n                ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the time period query\n        :rtype: ``osid.calendaring.TimePeriodQuery``", 
               "sphinx_error_doc": "        :raise: ``Unimplemented`` -- ``supports_time_period_query()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_time_period_query()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.TimePeriodQuery", 
               "errors": {
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "match_any_time_period", 
               "doc": {
                  "headline": "Matches a schedule that has any time period assigned.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    match (boolean): ``true`` to match schedules with any\n                time periods, ``false`` to match schedules with no time\n                periods\n", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "        :param match: ``true`` to match schedules with any time periods, ``false`` to match schedules with no time periods\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "clear_time_period_terms", 
               "doc": {
                  "headline": "Clears the time period terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "match_schedule_start", 
               "doc": {
                  "headline": "Matches the schedule start time between the given range inclusive.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    low (osid.calendaring.DateTime): low time range\n        arg:    high (osid.calendaring.DateTime): high time range\n        arg:    match (boolean): ``true`` for a positive match,\n                ``false`` for a negative match\n", 
               "return_doc": "", 
               "error_doc": "        raise:  InvalidArgument - ``high`` is less than ``low``\n        raise:  NullArgument - ``high`` or ``low`` is ``null``", 
               "sphinx_param_doc": "        :param low: low time range\n        :type low: ``osid.calendaring.DateTime``\n        :param high: high time range\n        :type high: ``osid.calendaring.DateTime``\n        :param match: ``true`` for a positive match, ``false`` for a negative match\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``InvalidArgument`` -- ``high`` is less than ``low``\n        :raise: ``NullArgument`` -- ``high`` or ``low`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.calendaring.DateTime", 
                     "var_name": "low", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.calendaring.DateTime", 
                     "var_name": "high", 
                     "array": false
                  }, 
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.calendaring.DateTime", 
                  "osid.calendaring.DateTime", 
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {
                  "INVALID_ARGUMENT": "ConsumerContract", 
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "match_any_schedule_start", 
               "doc": {
                  "headline": "Matches a schedule that has any start time assigned.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    match (boolean): ``true`` to match schedules with any\n                start time, ``false`` to match schedules with no start\n                time\n", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "        :param match: ``true`` to match schedules with any start time, ``false`` to match schedules with no start time\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "clear_schedule_start_terms", 
               "doc": {
                  "headline": "Clears the schedule start terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "match_schedule_end", 
               "doc": {
                  "headline": "Matches the schedule end time between the given range inclusive.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    low (osid.calendaring.DateTime): low time range\n        arg:    high (osid.calendaring.DateTime): high time range\n        arg:    match (boolean): ``true`` for a positive match,\n                ``false`` for a negative match\n", 
               "return_doc": "", 
               "error_doc": "        raise:  InvalidArgument - ``high`` is less than ``low``\n        raise:  NullArgument - ``high`` or ``low`` is ``null``", 
               "sphinx_param_doc": "        :param low: low time range\n        :type low: ``osid.calendaring.DateTime``\n        :param high: high time range\n        :type high: ``osid.calendaring.DateTime``\n        :param match: ``true`` for a positive match, ``false`` for a negative match\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``InvalidArgument`` -- ``high`` is less than ``low``\n        :raise: ``NullArgument`` -- ``high`` or ``low`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.calendaring.DateTime", 
                     "var_name": "low", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.calendaring.DateTime", 
                     "var_name": "high", 
                     "array": false
                  }, 
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.calendaring.DateTime", 
                  "osid.calendaring.DateTime", 
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {
                  "INVALID_ARGUMENT": "ConsumerContract", 
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "match_any_schedule_end", 
               "doc": {
                  "headline": "Matches a schedule that has any end time assigned.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    match (boolean): ``true`` to match schedules with any\n                end time, ``false`` to match schedules with no start\n                time\n", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "        :param match: ``true`` to match schedules with any end time, ``false`` to match schedules with no start time\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "clear_schedule_end_terms", 
               "doc": {
                  "headline": "Clears the schedule end terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "match_schedule_time", 
               "doc": {
                  "headline": "Matches schedules with start and end times between the given range inclusive.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    date (osid.calendaring.DateTime): a date\n        arg:    match (boolean): ``true`` for a positive match,\n                ``false`` for a negative match\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``date`` is ``null``", 
               "sphinx_param_doc": "        :param date: a date\n        :type date: ``osid.calendaring.DateTime``\n        :param match: ``true`` for a positive match, ``false`` for a negative match\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``date`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.calendaring.DateTime", 
                     "var_name": "date", 
                     "array": false
                  }, 
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.calendaring.DateTime", 
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "match_any_schedule_time", 
               "doc": {
                  "headline": "Matches schedules that has any time assigned.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    match (boolean): ``true`` to match schedules with any\n                time, ``false`` to match schedules with no time\n", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "        :param match: ``true`` to match schedules with any time, ``false`` to match schedules with no time\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "clear_schedule_time_terms", 
               "doc": {
                  "headline": "Clears the schedule time terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "match_schedule_time_inclusive", 
               "doc": {
                  "headline": "Matches schedules with start and end times between the given range inclusive.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    start (osid.calendaring.DateTime): start date\n        arg:    end (osid.calendaring.DateTime): end date\n        arg:    match (boolean): ``true`` for a positive match,\n                ``false`` for a negative match\n", 
               "return_doc": "", 
               "error_doc": "        raise:  InvalidArgument - ``end`` is less than ``start``\n        raise:  NullArgument - ``end`` or ``start`` is ``null``", 
               "sphinx_param_doc": "        :param start: start date\n        :type start: ``osid.calendaring.DateTime``\n        :param end: end date\n        :type end: ``osid.calendaring.DateTime``\n        :param match: ``true`` for a positive match, ``false`` for a negative match\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``InvalidArgument`` -- ``end`` is less than ``start``\n        :raise: ``NullArgument`` -- ``end`` or ``start`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.calendaring.DateTime", 
                     "var_name": "start", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.calendaring.DateTime", 
                     "var_name": "end", 
                     "array": false
                  }, 
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.calendaring.DateTime", 
                  "osid.calendaring.DateTime", 
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {
                  "INVALID_ARGUMENT": "ConsumerContract", 
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "clear_schedule_time_inclusive_terms", 
               "doc": {
                  "headline": "Clears the schedule time inclusive terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "match_limit", 
               "doc": {
                  "headline": "Matches schedules that have the given limit in the given range inclusive.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    from (integer): start range\n        arg:    to (integer): end range\n        arg:    match (boolean): ``true`` for a positive match,\n                ``false`` for a negative match\n", 
               "return_doc": "", 
               "error_doc": "        raise:  InvalidArgument - ``to`` is less than ``from``", 
               "sphinx_param_doc": "        :param from: start range\n        :type from: ``integer``\n        :param to: end range\n        :type to: ``integer``\n        :param match: ``true`` for a positive match, ``false`` for a negative match\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``InvalidArgument`` -- ``to`` is less than ``from``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "integer", 
                     "var_name": "from_", 
                     "array": false
                  }, 
                  {
                     "arg_type": "integer", 
                     "var_name": "to", 
                     "array": false
                  }, 
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "integer", 
                  "integer", 
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {
                  "INVALID_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "match_any_limit", 
               "doc": {
                  "headline": "Matches schedules with any occurrence limit.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    match (boolean): ``true`` to match schedules with any\n                limit, to match schedules with no limit\n", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "        :param match: ``true`` to match schedules with any limit, to match schedules with no limit\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "clear_limit_terms", 
               "doc": {
                  "headline": "Clears the limit terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "match_location_description", 
               "doc": {
                  "headline": "Matches the location description string.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    location (string): location string\n        arg:    string_match_type (osid.type.Type): string match type\n        arg:    match (boolean): ``true`` for a positive match,\n                ``false`` for a negative match\n", 
               "return_doc": "", 
               "error_doc": "        raise:  InvalidArgument - ``location`` is not of\n                ``string_match_type``\n        raise:  NullArgument - ``location`` or ``string_match_type`` is\n                ``null``\n        raise:  Unsupported -\n                ``supports_string_match_type(string_match_type)`` is\n                ``false``", 
               "sphinx_param_doc": "        :param location: location string\n        :type location: ``string``\n        :param string_match_type: string match type\n        :type string_match_type: ``osid.type.Type``\n        :param match: ``true`` for a positive match, ``false`` for a negative match\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``InvalidArgument`` -- ``location`` is not of ``string_match_type``\n        :raise: ``NullArgument`` -- ``location`` or ``string_match_type`` is ``null``\n        :raise: ``Unsupported`` -- ``supports_string_match_type(string_match_type)`` is ``false``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "string", 
                     "var_name": "location", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "string_match_type", 
                     "array": false
                  }, 
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "string", 
                  "osid.type.Type", 
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {
                  "INVALID_ARGUMENT": "ConsumerContract", 
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }, 
            {
               "name": "match_any_location_description", 
               "doc": {
                  "headline": "Matches a schedule that has any location description assigned.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    match (boolean): ``true`` to match schedules with any\n                location description, ``false`` to match schedules with\n                no location description\n", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "        :param match: ``true`` to match schedules with any location description, ``false`` to match schedules with no location description\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "clear_location_description_terms", 
               "doc": {
                  "headline": "Clears the location description terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "match_location_id", 
               "doc": {
                  "headline": "Sets the location ``Id`` for this query.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    location_id (osid.id.Id): a location ``Id``\n        arg:    match (boolean): ``true`` for a positive match,\n                ``false`` for a negative match\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``location_id`` is ``null``", 
               "sphinx_param_doc": "        :param location_id: a location ``Id``\n        :type location_id: ``osid.id.Id``\n        :param match: ``true`` for a positive match, ``false`` for a negative match\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``location_id`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "location_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "clear_location_id_terms", 
               "doc": {
                  "headline": "Clears the location ``Id`` terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "supports_location_query", 
               "doc": {
                  "headline": "Tests if a ``LocationQuery`` is available for querying locations.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if a location query is available,\n                ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if a location query is available, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "get_location_query", 
               "doc": {
                  "headline": "Gets the query for a location.", 
                  "body": "        Multiple retrievals produce a nested ``OR`` term."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.mapping.LocationQuery) - the location query", 
               "error_doc": "        raise:  Unimplemented - ``supports_location_query()`` is\n                ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the location query\n        :rtype: ``osid.mapping.LocationQuery``", 
               "sphinx_error_doc": "        :raise: ``Unimplemented`` -- ``supports_location_query()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_location_query()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.mapping.LocationQuery", 
               "errors": {
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "match_any_location", 
               "doc": {
                  "headline": "Matches a schedule that has any location assigned.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    match (boolean): ``true`` to match schedules with any\n                location, ``false`` to match schedules with no location\n", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "        :param match: ``true`` to match schedules with any location, ``false`` to match schedules with no location\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "clear_location_terms", 
               "doc": {
                  "headline": "Clears the location terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "match_total_duration", 
               "doc": {
                  "headline": "Matches the total duration between the given range inclusive.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    low (osid.calendaring.Duration): low duration range\n        arg:    high (osid.calendaring.Duration): high duration range\n        arg:    match (boolean): ``true`` for a positive match,\n                ``false`` for a negative match\n", 
               "return_doc": "", 
               "error_doc": "        raise:  InvalidArgument - ``high`` is less than ``low``\n        raise:  NullArgument - ``high`` or ``low`` is ``null``", 
               "sphinx_param_doc": "        :param low: low duration range\n        :type low: ``osid.calendaring.Duration``\n        :param high: high duration range\n        :type high: ``osid.calendaring.Duration``\n        :param match: ``true`` for a positive match, ``false`` for a negative match\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``InvalidArgument`` -- ``high`` is less than ``low``\n        :raise: ``NullArgument`` -- ``high`` or ``low`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.calendaring.Duration", 
                     "var_name": "low", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.calendaring.Duration", 
                     "var_name": "high", 
                     "array": false
                  }, 
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.calendaring.Duration", 
                  "osid.calendaring.Duration", 
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {
                  "INVALID_ARGUMENT": "ConsumerContract", 
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "clear_total_duration_terms", 
               "doc": {
                  "headline": "Clears the total duration terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "match_calendar_id", 
               "doc": {
                  "headline": "Sets the calendar ``Id`` for this query.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    calendar_id (osid.id.Id): a calendar ``Id``\n        arg:    match (boolean): ``true`` for a positive match,\n                ``false`` for a negative match\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``calendar_id`` is ``null``", 
               "sphinx_param_doc": "        :param calendar_id: a calendar ``Id``\n        :type calendar_id: ``osid.id.Id``\n        :param match: ``true`` for a positive match, ``false`` for a negative match\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``calendar_id`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "calendar_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "clear_calendar_id_terms", 
               "doc": {
                  "headline": "Clears the calendar ``Id`` terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "supports_calendar_query", 
               "doc": {
                  "headline": "Tests if a ``CalendarQuery`` is available for querying calendars.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if a calendar query is available,\n                ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if a calendar query is available, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "get_calendar_query", 
               "doc": {
                  "headline": "Gets the query for a calendar.", 
                  "body": "        Multiple retrievals produce a nested ``OR`` term."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.CalendarQuery) - the calendar query", 
               "error_doc": "        raise:  Unimplemented - ``supports_calendar_query()`` is\n                ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the calendar query\n        :rtype: ``osid.calendaring.CalendarQuery``", 
               "sphinx_error_doc": "        :raise: ``Unimplemented`` -- ``supports_calendar_query()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_calendar_query()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.CalendarQuery", 
               "errors": {
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "clear_calendar_terms", 
               "doc": {
                  "headline": "Clears the calendar terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "get_schedule_query_record", 
               "doc": {
                  "headline": "Gets the schedule query record corresponding to the given ``Schedule`` record ``Type``.", 
                  "body": "        Multiple retrievals produce a nested ``OR`` term."
               }, 
               "arg_doc": "        arg:    schedule_record_type (osid.type.Type): a schedule query\n                record type\n", 
               "return_doc": "        return: (osid.calendaring.records.ScheduleQueryRecord) - the\n                schedule query record", 
               "error_doc": "        raise:  NullArgument - ``schedule_record_type`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unsupported - ``has_record_type(schedule_record_type)``\n                is ``false``", 
               "sphinx_param_doc": "        :param schedule_record_type: a schedule query record type\n        :type schedule_record_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "        :return: the schedule query record\n        :rtype: ``osid.calendaring.records.ScheduleQueryRecord``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``schedule_record_type`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unsupported`` -- ``has_record_type(schedule_record_type)`` is ``false``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "schedule_record_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "osid.calendaring.records.ScheduleQueryRecord", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.calendaring.records.ScheduleQueryRecord", 
         "shortname": "ScheduleQueryRecord", 
         "category": "records", 
         "doc": {
            "headline": "A record for a ``ScheduleQuery``.", 
            "body": "    The methods specified by the record type are available through the\n    underlying object."
         }, 
         "inherit_fullnames": [
            "osid.OsidRecord"
         ], 
         "inherit_shortnames": [
            "OsidRecord"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidRecord"
            }
         ], 
         "method_names": [], 
         "methods": []
      }, 
      {
         "fullname": "osid.calendaring.ScheduleQueryInspector", 
         "shortname": "ScheduleQueryInspector", 
         "category": "query_inspectors", 
         "doc": {
            "headline": "This is the query inspector for examining schedule queries.", 
            "body": ""
         }, 
         "inherit_fullnames": [
            "osid.OsidObjectQueryInspector"
         ], 
         "inherit_shortnames": [
            "OsidObjectQueryInspector"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidObjectQueryInspector"
            }
         ], 
         "method_names": [
            "get_schedule_slot_id_terms", 
            "get_schedule_slot_terms", 
            "get_time_period_id_terms", 
            "get_time_period_terms", 
            "get_schedule_start_terms", 
            "get_schedule_end_terms", 
            "get_schedule_time_terms", 
            "get_schedule_time_inclusive_terms", 
            "get_limit_terms", 
            "get_location_description_terms", 
            "get_location_id_terms", 
            "get_location_terms", 
            "get_total_duration_terms", 
            "get_calendar_id_terms", 
            "get_calendar_terms", 
            "get_schedule_query_inspector_record"
         ], 
         "methods": [
            {
               "name": "get_schedule_slot_id_terms", 
               "doc": {
                  "headline": "Gets the schedule slot ``Id`` terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.search.terms.IdTerm) - the schedule slot ``Id``\n                terms", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the schedule slot ``Id`` terms\n        :rtype: ``osid.search.terms.IdTerm``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.search.terms.IdTerm", 
               "errors": {}
            }, 
            {
               "name": "get_schedule_slot_terms", 
               "doc": {
                  "headline": "Gets the schedule slot terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.ScheduleSlotQueryInspector) - the\n                schedule slot terms", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the schedule slot terms\n        :rtype: ``osid.calendaring.ScheduleSlotQueryInspector``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.ScheduleSlotQueryInspector", 
               "errors": {}
            }, 
            {
               "name": "get_time_period_id_terms", 
               "doc": {
                  "headline": "Gets the time period ``Id`` terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.search.terms.IdTerm) - the time period ``Id``\n                terms", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the time period ``Id`` terms\n        :rtype: ``osid.search.terms.IdTerm``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.search.terms.IdTerm", 
               "errors": {}
            }, 
            {
               "name": "get_time_period_terms", 
               "doc": {
                  "headline": "Gets the time period terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.TimePeriodQueryInspector) - the time\n                period terms", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the time period terms\n        :rtype: ``osid.calendaring.TimePeriodQueryInspector``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.TimePeriodQueryInspector", 
               "errors": {}
            }, 
            {
               "name": "get_schedule_start_terms", 
               "doc": {
                  "headline": "Gets the schedule start terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.search.terms.DateTimeRangeTerm) - the schedule\n                start terms", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the schedule start terms\n        :rtype: ``osid.search.terms.DateTimeRangeTerm``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.search.terms.DateTimeRangeTerm", 
               "errors": {}
            }, 
            {
               "name": "get_schedule_end_terms", 
               "doc": {
                  "headline": "Gets the schedule end terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.search.terms.DateTimeRangeTerm) - the schedule end\n                terms", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the schedule end terms\n        :rtype: ``osid.search.terms.DateTimeRangeTerm``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.search.terms.DateTimeRangeTerm", 
               "errors": {}
            }, 
            {
               "name": "get_schedule_time_terms", 
               "doc": {
                  "headline": "Gets the schedule time terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.search.terms.DateTimeTerm) - the schedule time\n                terms", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the schedule time terms\n        :rtype: ``osid.search.terms.DateTimeTerm``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.search.terms.DateTimeTerm", 
               "errors": {}
            }, 
            {
               "name": "get_schedule_time_inclusive_terms", 
               "doc": {
                  "headline": "Gets the schedule inclusive time terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.search.terms.DateTimeRangeTerm) - the schedule\n                time range terms", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the schedule time range terms\n        :rtype: ``osid.search.terms.DateTimeRangeTerm``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.search.terms.DateTimeRangeTerm", 
               "errors": {}
            }, 
            {
               "name": "get_limit_terms", 
               "doc": {
                  "headline": "Gets the limit terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.search.terms.CardinalTerm) - the limit terms", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the limit terms\n        :rtype: ``osid.search.terms.CardinalTerm``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.search.terms.CardinalTerm", 
               "errors": {}
            }, 
            {
               "name": "get_location_description_terms", 
               "doc": {
                  "headline": "Gets the location description terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.search.terms.StringTerm) - the location\n                description terms", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the location description terms\n        :rtype: ``osid.search.terms.StringTerm``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.search.terms.StringTerm", 
               "errors": {}
            }, 
            {
               "name": "get_location_id_terms", 
               "doc": {
                  "headline": "Gets the location ``Id`` terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.search.terms.IdTerm) - the location ``Id`` terms", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the location ``Id`` terms\n        :rtype: ``osid.search.terms.IdTerm``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.search.terms.IdTerm", 
               "errors": {}
            }, 
            {
               "name": "get_location_terms", 
               "doc": {
                  "headline": "Gets the location terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.mapping.LocationQueryInspector) - the location\n                terms", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the location terms\n        :rtype: ``osid.mapping.LocationQueryInspector``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.mapping.LocationQueryInspector", 
               "errors": {}
            }, 
            {
               "name": "get_total_duration_terms", 
               "doc": {
                  "headline": "Gets the total duration terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.search.terms.DurationRangeTerm) - the duration\n                terms", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the duration terms\n        :rtype: ``osid.search.terms.DurationRangeTerm``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.search.terms.DurationRangeTerm", 
               "errors": {}
            }, 
            {
               "name": "get_calendar_id_terms", 
               "doc": {
                  "headline": "Gets the calendar ``Id`` terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.search.terms.IdTerm) - the calendar ``Id`` terms", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the calendar ``Id`` terms\n        :rtype: ``osid.search.terms.IdTerm``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.search.terms.IdTerm", 
               "errors": {}
            }, 
            {
               "name": "get_calendar_terms", 
               "doc": {
                  "headline": "Gets the calendar terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.CalendarQueryInspector) - the calendar\n                terms", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the calendar terms\n        :rtype: ``osid.calendaring.CalendarQueryInspector``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.CalendarQueryInspector", 
               "errors": {}
            }, 
            {
               "name": "get_schedule_query_inspector_record", 
               "doc": {
                  "headline": "Gets the schedule query inspector record corresponding to the given ``Schedule`` record ``Type``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    schedule_record_type (osid.type.Type): a schedule query\n                record type\n", 
               "return_doc": "        return: (osid.calendaring.records.ScheduleQueryInspectorRecord)\n                - the schedule query inspector record", 
               "error_doc": "        raise:  NullArgument - ``schedule_record_type`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unsupported - ``has_record_type(schedule_record_type)``\n                is ``false``", 
               "sphinx_param_doc": "        :param schedule_record_type: a schedule query record type\n        :type schedule_record_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "        :return: the schedule query inspector record\n        :rtype: ``osid.calendaring.records.ScheduleQueryInspectorRecord``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``schedule_record_type`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unsupported`` -- ``has_record_type(schedule_record_type)`` is ``false``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "schedule_record_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "osid.calendaring.records.ScheduleQueryInspectorRecord", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.calendaring.records.ScheduleQueryInspectorRecord", 
         "shortname": "ScheduleQueryInspectorRecord", 
         "category": "records", 
         "doc": {
            "headline": "A record for a ``ScheduleQueryInspector``.", 
            "body": "    The methods specified by the record type are available through the\n    underlying object."
         }, 
         "inherit_fullnames": [
            "osid.OsidRecord"
         ], 
         "inherit_shortnames": [
            "OsidRecord"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidRecord"
            }
         ], 
         "method_names": [], 
         "methods": []
      }, 
      {
         "fullname": "osid.calendaring.ScheduleForm", 
         "shortname": "ScheduleForm", 
         "category": "objects", 
         "doc": {
            "headline": "This is the form for creating and updating ``Schedules``.", 
            "body": "    Like all ``OsidForm`` objects, various data elements may be set here\n    for use in the create and update methods in the\n    ``ScheduleAdminSession``. For each data element that may be set,\n    metadata may be examined to provide display hints or data\n    constraints."
         }, 
         "inherit_fullnames": [
            "osid.OsidObjectForm"
         ], 
         "inherit_shortnames": [
            "OsidObjectForm"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidObjectForm"
            }
         ], 
         "method_names": [
            "get_schedule_slot_metadata", 
            "set_schedule_slot", 
            "clear_schedule_slot", 
            "get_time_period_metadata", 
            "set_time_period", 
            "clear_time_period", 
            "get_schedule_start_metadata", 
            "set_schedule_start", 
            "clear_schedule_start", 
            "get_schedule_end_metadata", 
            "set_schedule_end", 
            "clear_schedule_end", 
            "get_limit_metadata", 
            "set_limit", 
            "clear_limit", 
            "set_location_description", 
            "clear_location_description", 
            "get_location_metadata", 
            "set_location", 
            "clear_location", 
            "get_schedule_slot_form_record"
         ], 
         "methods": [
            {
               "name": "get_schedule_slot_metadata", 
               "doc": {
                  "headline": "Gets the metadata for the schedule slot.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.Metadata) - metadata for the schedule slot", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: metadata for the schedule slot\n        :rtype: ``osid.Metadata``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.Metadata", 
               "errors": {}
            }, 
            {
               "name": "set_schedule_slot", 
               "doc": {
                  "headline": "Sets the schedule slot.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    schedule_slot_id (osid.id.Id): the new schedule slot\n                ``Id``\n", 
               "return_doc": "", 
               "error_doc": "        raise:  InvalidArgument - ``schedule_slot_id`` is invalid\n        raise:  NoAccess - ``schedule_slot_id`` cannot be modified\n        raise:  NullArgument - ``schedule_slot_id`` is ``null``", 
               "sphinx_param_doc": "        :param schedule_slot_id: the new schedule slot ``Id``\n        :type schedule_slot_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``InvalidArgument`` -- ``schedule_slot_id`` is invalid\n        :raise: ``NoAccess`` -- ``schedule_slot_id`` cannot be modified\n        :raise: ``NullArgument`` -- ``schedule_slot_id`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "schedule_slot_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {
                  "INVALID_ARGUMENT": "ConsumerContract", 
                  "NO_ACCESS": "ConsumerContract", 
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "clear_schedule_slot", 
               "doc": {
                  "headline": "Clears the schedule slot.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "        raise:  NoAccess - ``Metadata.isRequired()`` or\n                ``Metadata.isReadOnly()`` is ``true``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NoAccess`` -- ``Metadata.isRequired()`` or ``Metadata.isReadOnly()`` is ``true``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {
                  "NO_ACCESS": "ConsumerContract"
               }
            }, 
            {
               "name": "get_time_period_metadata", 
               "doc": {
                  "headline": "Gets the metadata for the time period.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.Metadata) - metadata for the time period", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: metadata for the time period\n        :rtype: ``osid.Metadata``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.Metadata", 
               "errors": {}
            }, 
            {
               "name": "set_time_period", 
               "doc": {
                  "headline": "Sets the time period.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    time_period_id (osid.id.Id): the new time period ``Id``\n", 
               "return_doc": "", 
               "error_doc": "        raise:  InvalidArgument - ``time_period_id`` is invalid\n        raise:  NoAccess - ``time_period_id`` cannot be modified\n        raise:  NullArgument - ``time_period_id`` is ``null``", 
               "sphinx_param_doc": "        :param time_period_id: the new time period ``Id``\n        :type time_period_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``InvalidArgument`` -- ``time_period_id`` is invalid\n        :raise: ``NoAccess`` -- ``time_period_id`` cannot be modified\n        :raise: ``NullArgument`` -- ``time_period_id`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "time_period_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {
                  "INVALID_ARGUMENT": "ConsumerContract", 
                  "NO_ACCESS": "ConsumerContract", 
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "clear_time_period", 
               "doc": {
                  "headline": "Clears the time period.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "        raise:  NoAccess - ``Metadata.isRequired()`` or\n                ``Metadata.isReadOnly()`` is ``true``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NoAccess`` -- ``Metadata.isRequired()`` or ``Metadata.isReadOnly()`` is ``true``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {
                  "NO_ACCESS": "ConsumerContract"
               }
            }, 
            {
               "name": "get_schedule_start_metadata", 
               "doc": {
                  "headline": "Gets the metadata for the schedule start date.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.Metadata) - metadata for the schedule start", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: metadata for the schedule start\n        :rtype: ``osid.Metadata``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.Metadata", 
               "errors": {}
            }, 
            {
               "name": "set_schedule_start", 
               "doc": {
                  "headline": "Sets the schedule start date.", 
                  "body": "        This may be set in lieu of a time period to set a specific date\n        range."
               }, 
               "arg_doc": "        arg:    start (osid.calendaring.DateTime): the new start date\n", 
               "return_doc": "", 
               "error_doc": "        raise:  InvalidArgument - ``start`` is invalid\n        raise:  NoAccess - ``start`` cannot be modified\n        raise:  NullArgument - ``start`` is ``null``", 
               "sphinx_param_doc": "        :param start: the new start date\n        :type start: ``osid.calendaring.DateTime``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``InvalidArgument`` -- ``start`` is invalid\n        :raise: ``NoAccess`` -- ``start`` cannot be modified\n        :raise: ``NullArgument`` -- ``start`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.calendaring.DateTime", 
                     "var_name": "start", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.calendaring.DateTime"
               ], 
               "return_type": "", 
               "errors": {
                  "INVALID_ARGUMENT": "ConsumerContract", 
                  "NO_ACCESS": "ConsumerContract", 
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "clear_schedule_start", 
               "doc": {
                  "headline": "Clears the schedule start.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "        raise:  NoAccess - ``Metadata.isRequired()`` or\n                ``Metadata.isReadOnly()`` is ``true``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NoAccess`` -- ``Metadata.isRequired()`` or ``Metadata.isReadOnly()`` is ``true``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {
                  "NO_ACCESS": "ConsumerContract"
               }
            }, 
            {
               "name": "get_schedule_end_metadata", 
               "doc": {
                  "headline": "Gets the metadata for the schedule end date.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.Metadata) - metadata for the schedule end", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: metadata for the schedule end\n        :rtype: ``osid.Metadata``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.Metadata", 
               "errors": {}
            }, 
            {
               "name": "set_schedule_end", 
               "doc": {
                  "headline": "Sets the schedule end date.", 
                  "body": "        This may be set in lieu of a time period to set a specific date\n        range."
               }, 
               "arg_doc": "        arg:    start (osid.calendaring.DateTime): the new end date\n", 
               "return_doc": "", 
               "error_doc": "        raise:  InvalidArgument - ``end`` is invalid\n        raise:  NoAccess - ``end`` cannot be modified\n        raise:  NullArgument - ``end`` is ``null``", 
               "sphinx_param_doc": "        :param start: the new end date\n        :type start: ``osid.calendaring.DateTime``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``InvalidArgument`` -- ``end`` is invalid\n        :raise: ``NoAccess`` -- ``end`` cannot be modified\n        :raise: ``NullArgument`` -- ``end`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.calendaring.DateTime", 
                     "var_name": "start", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.calendaring.DateTime"
               ], 
               "return_type": "", 
               "errors": {
                  "INVALID_ARGUMENT": "ConsumerContract", 
                  "NO_ACCESS": "ConsumerContract", 
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "clear_schedule_end", 
               "doc": {
                  "headline": "Clears the schedule end.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "        raise:  NoAccess - ``Metadata.isRequired()`` or\n                ``Metadata.isReadOnly()`` is ``true``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NoAccess`` -- ``Metadata.isRequired()`` or ``Metadata.isReadOnly()`` is ``true``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {
                  "NO_ACCESS": "ConsumerContract"
               }
            }, 
            {
               "name": "get_limit_metadata", 
               "doc": {
                  "headline": "Gets the metadata for the weekdays of a weekly schedule.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.Metadata) - metadata for the weekday", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: metadata for the weekday\n        :rtype: ``osid.Metadata``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.Metadata", 
               "errors": {}
            }, 
            {
               "name": "set_limit", 
               "doc": {
                  "headline": "Sets the weekdays of a weekly schedule.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    weekdays (cardinal[]): the new weekday set\n", 
               "return_doc": "", 
               "error_doc": "        raise:  InvalidArgument - ``weekdays`` is invalid\n        raise:  NoAccess - ``weekdays`` cannot be modified\n        raise:  NullArgument - ``weekdays`` is ``null``", 
               "sphinx_param_doc": "        :param weekdays: the new weekday set\n        :type weekdays: ``cardinal[]``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``InvalidArgument`` -- ``weekdays`` is invalid\n        :raise: ``NoAccess`` -- ``weekdays`` cannot be modified\n        :raise: ``NullArgument`` -- ``weekdays`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "cardinal[]", 
                     "var_name": "weekdays", 
                     "array": true
                  }
               ], 
               "arg_types": [
                  "cardinal[]"
               ], 
               "return_type": "", 
               "errors": {
                  "INVALID_ARGUMENT": "ConsumerContract", 
                  "NO_ACCESS": "ConsumerContract", 
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "clear_limit", 
               "doc": {
                  "headline": "Clears the limit.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "        raise:  NoAccess - ``Metadata.isRequired()`` or\n                ``Metadata.isReadOnly()`` is ``true``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NoAccess`` -- ``Metadata.isRequired()`` or ``Metadata.isReadOnly()`` is ``true``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {
                  "NO_ACCESS": "ConsumerContract"
               }
            }, 
            {
               "name": "set_location_description", 
               "doc": {
                  "headline": "Sets the location description.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    location (string): the new location description\n", 
               "return_doc": "", 
               "error_doc": "        raise:  InvalidArgument - ``location`` is invalid\n        raise:  NoAccess - ``location`` cannot be modified\n        raise:  NullArgument - ``location`` is ``null``", 
               "sphinx_param_doc": "        :param location: the new location description\n        :type location: ``string``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``InvalidArgument`` -- ``location`` is invalid\n        :raise: ``NoAccess`` -- ``location`` cannot be modified\n        :raise: ``NullArgument`` -- ``location`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "string", 
                     "var_name": "location", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "string"
               ], 
               "return_type": "", 
               "errors": {
                  "INVALID_ARGUMENT": "ConsumerContract", 
                  "NO_ACCESS": "ConsumerContract", 
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "clear_location_description", 
               "doc": {
                  "headline": "Clears the location description.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "        raise:  NoAccess - ``Metadata.isRequired()`` or\n                ``Metadata.isReadOnly()`` is ``true``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NoAccess`` -- ``Metadata.isRequired()`` or ``Metadata.isReadOnly()`` is ``true``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {
                  "NO_ACCESS": "ConsumerContract"
               }
            }, 
            {
               "name": "get_location_metadata", 
               "doc": {
                  "headline": "Gets the metadata for a location.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.Metadata) - metadata for the location", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: metadata for the location\n        :rtype: ``osid.Metadata``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.Metadata", 
               "errors": {}
            }, 
            {
               "name": "set_location", 
               "doc": {
                  "headline": "Sets the location.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    location_id (osid.id.Id): the new location\n", 
               "return_doc": "", 
               "error_doc": "        raise:  InvalidArgument - ``location_id`` is invalid\n        raise:  NoAccess - ``location_id`` cannot be modified\n        raise:  NullArgument - ``location_id`` is ``null``", 
               "sphinx_param_doc": "        :param location_id: the new location\n        :type location_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``InvalidArgument`` -- ``location_id`` is invalid\n        :raise: ``NoAccess`` -- ``location_id`` cannot be modified\n        :raise: ``NullArgument`` -- ``location_id`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "location_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {
                  "INVALID_ARGUMENT": "ConsumerContract", 
                  "NO_ACCESS": "ConsumerContract", 
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "clear_location", 
               "doc": {
                  "headline": "Clears the location.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "        raise:  NoAccess - ``Metadata.isRequired()`` or\n                ``Metadata.isReadOnly()`` is ``true``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NoAccess`` -- ``Metadata.isRequired()`` or ``Metadata.isReadOnly()`` is ``true``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {
                  "NO_ACCESS": "ConsumerContract"
               }
            }, 
            {
               "name": "get_schedule_slot_form_record", 
               "doc": {
                  "headline": "Gets the ``ScheduleFormRecord`` corresponding to the given schedule record ``Type``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    schedule_record_type (osid.type.Type): the schedule\n                record type\n", 
               "return_doc": "        return: (osid.calendaring.records.ScheduleFormRecord) - the\n                schedule form record", 
               "error_doc": "        raise:  NullArgument - ``schedule_record_type`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unsupported - ``has_record_type(schedule_record_type)``\n                is ``false``", 
               "sphinx_param_doc": "        :param schedule_record_type: the schedule record type\n        :type schedule_record_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "        :return: the schedule form record\n        :rtype: ``osid.calendaring.records.ScheduleFormRecord``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``schedule_record_type`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unsupported`` -- ``has_record_type(schedule_record_type)`` is ``false``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "schedule_record_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "osid.calendaring.records.ScheduleFormRecord", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.calendaring.records.ScheduleFormRecord", 
         "shortname": "ScheduleFormRecord", 
         "category": "records", 
         "doc": {
            "headline": "A record for a ``ScheduleForm``.", 
            "body": "    The methods specified by the record type are available through the\n    underlying object."
         }, 
         "inherit_fullnames": [
            "osid.OsidRecord"
         ], 
         "inherit_shortnames": [
            "OsidRecord"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidRecord"
            }
         ], 
         "method_names": [], 
         "methods": []
      }, 
      {
         "fullname": "osid.calendaring.ScheduleSearchOrder", 
         "shortname": "ScheduleSearchOrder", 
         "category": "search_orders", 
         "doc": {
            "headline": "An interface for specifying the ordering of search results.", 
            "body": ""
         }, 
         "inherit_fullnames": [
            "osid.OsidObjectSearchOrder"
         ], 
         "inherit_shortnames": [
            "OsidObjectSearchOrder"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidObjectSearchOrder"
            }
         ], 
         "method_names": [
            "order_by_schedule_slot", 
            "supports_schedule_slot_search_order", 
            "get_schedule_slot_search_order", 
            "order_by_time_period", 
            "supports_time_period_search_order", 
            "get_time_period_search_order", 
            "order_by_schedule_start", 
            "order_by_schedule_end", 
            "order_by_total_duration", 
            "order_by_limit", 
            "order_by_location_description", 
            "order_by_location", 
            "supports_location_search_order", 
            "get_location_search_order", 
            "get_schedule_search_order_record"
         ], 
         "methods": [
            {
               "name": "order_by_schedule_slot", 
               "doc": {
                  "headline": "Specified a preference for ordering results by the schedule slot.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    style (osid.SearchOrderStyle): a search order style\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``style`` is ``null``", 
               "sphinx_param_doc": "        :param style: a search order style\n        :type style: ``osid.SearchOrderStyle``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``style`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.SearchOrderStyle", 
                     "var_name": "style", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.SearchOrderStyle"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "supports_schedule_slot_search_order", 
               "doc": {
                  "headline": "Tests if a ``ScheduleSlotSearchOrder`` is available.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if a schedule slot search order is\n                available, ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if a schedule slot search order is available, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "get_schedule_slot_search_order", 
               "doc": {
                  "headline": "Gets the search order for the schedule slot.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.ScheduleSlotSearchOrder) - the\n                schdeule slot search order", 
               "error_doc": "        raise:  Unimplemented -\n                ``supports_schedule_slot_search_order()`` is ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the schdeule slot search order\n        :rtype: ``osid.calendaring.ScheduleSlotSearchOrder``", 
               "sphinx_error_doc": "        :raise: ``Unimplemented`` -- ``supports_schedule_slot_search_order()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_schedule_slot_search_order()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.ScheduleSlotSearchOrder", 
               "errors": {
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "order_by_time_period", 
               "doc": {
                  "headline": "Specified a preference for ordering results by the time period.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    style (osid.SearchOrderStyle): a search order style\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``style`` is ``null``", 
               "sphinx_param_doc": "        :param style: a search order style\n        :type style: ``osid.SearchOrderStyle``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``style`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.SearchOrderStyle", 
                     "var_name": "style", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.SearchOrderStyle"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "supports_time_period_search_order", 
               "doc": {
                  "headline": "Tests if a ``TimePeriodSearchOrder`` is available.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if a time period search order is\n                available, ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if a time period search order is available, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "get_time_period_search_order", 
               "doc": {
                  "headline": "Gets the search order for the time period.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.TimePeriodSearchOrder) - the time\n                period search order", 
               "error_doc": "        raise:  Unimplemented - ``supports_time_period_search_order()``\n                is ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the time period search order\n        :rtype: ``osid.calendaring.TimePeriodSearchOrder``", 
               "sphinx_error_doc": "        :raise: ``Unimplemented`` -- ``supports_time_period_search_order()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_time_period_search_order()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.TimePeriodSearchOrder", 
               "errors": {
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "order_by_schedule_start", 
               "doc": {
                  "headline": "Specified a preference for ordering results by the schedule start.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    style (osid.SearchOrderStyle): a search order style\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``style`` is ``null``", 
               "sphinx_param_doc": "        :param style: a search order style\n        :type style: ``osid.SearchOrderStyle``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``style`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.SearchOrderStyle", 
                     "var_name": "style", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.SearchOrderStyle"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "order_by_schedule_end", 
               "doc": {
                  "headline": "Specified a preference for ordering results by the schedule end.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    style (osid.SearchOrderStyle): a search order style\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``style`` is ``null``", 
               "sphinx_param_doc": "        :param style: a search order style\n        :type style: ``osid.SearchOrderStyle``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``style`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.SearchOrderStyle", 
                     "var_name": "style", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.SearchOrderStyle"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "order_by_total_duration", 
               "doc": {
                  "headline": "Specified a preference for ordering results by the schedule duration.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    style (osid.SearchOrderStyle): a search order style\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``style`` is ``null``", 
               "sphinx_param_doc": "        :param style: a search order style\n        :type style: ``osid.SearchOrderStyle``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``style`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.SearchOrderStyle", 
                     "var_name": "style", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.SearchOrderStyle"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "order_by_limit", 
               "doc": {
                  "headline": "Specified a preference for ordering results by the occurrence limit.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    style (osid.SearchOrderStyle): a search order style\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``style`` is ``null``", 
               "sphinx_param_doc": "        :param style: a search order style\n        :type style: ``osid.SearchOrderStyle``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``style`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.SearchOrderStyle", 
                     "var_name": "style", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.SearchOrderStyle"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "order_by_location_description", 
               "doc": {
                  "headline": "Specified a preference for ordering results by the location description.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    style (osid.SearchOrderStyle): a search order style\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``style`` is ``null``", 
               "sphinx_param_doc": "        :param style: a search order style\n        :type style: ``osid.SearchOrderStyle``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``style`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.SearchOrderStyle", 
                     "var_name": "style", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.SearchOrderStyle"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "order_by_location", 
               "doc": {
                  "headline": "Specified a preference for ordering results by the location.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    style (osid.SearchOrderStyle): a search order style\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``style`` is ``null``", 
               "sphinx_param_doc": "        :param style: a search order style\n        :type style: ``osid.SearchOrderStyle``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``style`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.SearchOrderStyle", 
                     "var_name": "style", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.SearchOrderStyle"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "supports_location_search_order", 
               "doc": {
                  "headline": "Tests if a ``LocationSearchOrder`` is available.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if a location search order is\n                available, ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if a location search order is available, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "get_location_search_order", 
               "doc": {
                  "headline": "Gets the search order for a location.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.mapping.LocationSearchOrder) - the location search\n                order", 
               "error_doc": "        raise:  Unimplemented - ``supports_location_search_order()`` is\n                ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the location search order\n        :rtype: ``osid.mapping.LocationSearchOrder``", 
               "sphinx_error_doc": "        :raise: ``Unimplemented`` -- ``supports_location_search_order()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_location_search_order()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.mapping.LocationSearchOrder", 
               "errors": {
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_schedule_search_order_record", 
               "doc": {
                  "headline": "Gets the schedule search order record corresponding to the given schedule record ``Type``.", 
                  "body": "        Multiple retrievals return the same underlying object."
               }, 
               "arg_doc": "        arg:    schedule_record_type (osid.type.Type): a schedule record\n                type\n", 
               "return_doc": "        return: (osid.calendaring.records.ScheduleSearchOrderRecord) -\n                the schedule search order record", 
               "error_doc": "        raise:  NullArgument - ``schedule_record_type`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unsupported - ``has_record_type(schedule_record_type)``\n                is ``false``", 
               "sphinx_param_doc": "        :param schedule_record_type: a schedule record type\n        :type schedule_record_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "        :return: the schedule search order record\n        :rtype: ``osid.calendaring.records.ScheduleSearchOrderRecord``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``schedule_record_type`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unsupported`` -- ``has_record_type(schedule_record_type)`` is ``false``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "schedule_record_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "osid.calendaring.records.ScheduleSearchOrderRecord", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.calendaring.records.ScheduleSearchOrderRecord", 
         "shortname": "ScheduleSearchOrderRecord", 
         "category": "records", 
         "doc": {
            "headline": "A record for a ``ScheduleSearchOrder``.", 
            "body": "    The methods specified by the record type are available through the\n    underlying object."
         }, 
         "inherit_fullnames": [
            "osid.OsidRecord"
         ], 
         "inherit_shortnames": [
            "OsidRecord"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidRecord"
            }
         ], 
         "method_names": [], 
         "methods": []
      }, 
      {
         "fullname": "osid.calendaring.ScheduleSearch", 
         "shortname": "ScheduleSearch", 
         "category": "searches", 
         "doc": {
            "headline": "``ScheduleSearch`` defines the interface for specifying schedule search options.", 
            "body": ""
         }, 
         "inherit_fullnames": [
            "osid.OsidSearch"
         ], 
         "inherit_shortnames": [
            "OsidSearch"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidSearch"
            }
         ], 
         "method_names": [
            "search_among_schedules", 
            "order_schedule_results", 
            "get_schedule_search_record"
         ], 
         "methods": [
            {
               "name": "search_among_schedules", 
               "doc": {
                  "headline": "Execute this search among the given list of schedules.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    schedule_ids (osid.id.IdList): list of schedules\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``schedule_ids`` is ``null``", 
               "sphinx_param_doc": "        :param schedule_ids: list of schedules\n        :type schedule_ids: ``osid.id.IdList``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``schedule_ids`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.IdList", 
                     "var_name": "schedule_ids", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.IdList"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "order_schedule_results", 
               "doc": {
                  "headline": "Specify an ordering to the search results.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    schedule_search_order\n                (osid.calendaring.ScheduleSearchOrder): schedule search\n                order\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``schedule_search_order`` is ``null``\n        raise:  Unsupported - ``schedule_search_order`` is not of this\n                service", 
               "sphinx_param_doc": "        :param schedule_search_order: schedule search order\n        :type schedule_search_order: ``osid.calendaring.ScheduleSearchOrder``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``schedule_search_order`` is ``null``\n        :raise: ``Unsupported`` -- ``schedule_search_order`` is not of this service", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.calendaring.ScheduleSearchOrder", 
                     "var_name": "schedule_search_order", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.calendaring.ScheduleSearchOrder"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_schedule_search_record", 
               "doc": {
                  "headline": "Gets the schedule search record corresponding to the given schedule search record ``Type``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    schedule_search_record_type (osid.type.Type): a schedule\n                search record type\n", 
               "return_doc": "        return: (osid.calendaring.records.ScheduleSearchRecord) - the\n                schedule search record", 
               "error_doc": "        raise:  NullArgument - ``schedule_search_record_type`` is\n                ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unsupported -\n                ``has_record_type(schedule_search_record_type)`` is\n                ``false``", 
               "sphinx_param_doc": "        :param schedule_search_record_type: a schedule search record type\n        :type schedule_search_record_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "        :return: the schedule search record\n        :rtype: ``osid.calendaring.records.ScheduleSearchRecord``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``schedule_search_record_type`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unsupported`` -- ``has_record_type(schedule_search_record_type)`` is ``false``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "schedule_search_record_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "osid.calendaring.records.ScheduleSearchRecord", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.calendaring.records.ScheduleSearchRecord", 
         "shortname": "ScheduleSearchRecord", 
         "category": "records", 
         "doc": {
            "headline": "A record for a ``ScheduleSearch``.", 
            "body": "    The methods specified by the record type are available through the\n    underlying object."
         }, 
         "inherit_fullnames": [
            "osid.OsidRecord"
         ], 
         "inherit_shortnames": [
            "OsidRecord"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidRecord"
            }
         ], 
         "method_names": [], 
         "methods": []
      }, 
      {
         "fullname": "osid.calendaring.ScheduleSearchResults", 
         "shortname": "ScheduleSearchResults", 
         "category": "searches", 
         "doc": {
            "headline": "This interface provides a means to capture results of a search.", 
            "body": ""
         }, 
         "inherit_fullnames": [
            "osid.OsidSearchResults"
         ], 
         "inherit_shortnames": [
            "OsidSearchResults"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidSearchResults"
            }
         ], 
         "method_names": [
            "get_schedules", 
            "get_schedule_query_inspector", 
            "get_schedule_search_results_record"
         ], 
         "methods": [
            {
               "name": "get_schedules", 
               "doc": {
                  "headline": "Gets the schedule list resulting from the search.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.ScheduleList) - the schedule list", 
               "error_doc": "        raise:  IllegalState - list already retrieved", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the schedule list\n        :rtype: ``osid.calendaring.ScheduleList``", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- list already retrieved", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.ScheduleList", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract"
               }
            }, 
            {
               "name": "get_schedule_query_inspector", 
               "doc": {
                  "headline": "Gets the inspector for the query to examine the terms used in the search.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.ScheduleQueryInspector) - the query\n                inspector", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the query inspector\n        :rtype: ``osid.calendaring.ScheduleQueryInspector``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.ScheduleQueryInspector", 
               "errors": {}
            }, 
            {
               "name": "get_schedule_search_results_record", 
               "doc": {
                  "headline": "Gets the schedule search results record corresponding to the given schedule search record ``Type``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    schedule_search_record_type (osid.type.Type): a schedule\n                search record type\n", 
               "return_doc": "        return: (osid.calendaring.records.ScheduleSearchResultsRecord) -\n                the schedule search results record", 
               "error_doc": "        raise:  NullArgument - ``schedule_search_record_type`` is\n                ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unsupported -\n                ``has_record_type(schedule_search_record_type)`` is\n                ``false``", 
               "sphinx_param_doc": "        :param schedule_search_record_type: a schedule search record type\n        :type schedule_search_record_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "        :return: the schedule search results record\n        :rtype: ``osid.calendaring.records.ScheduleSearchResultsRecord``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``schedule_search_record_type`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unsupported`` -- ``has_record_type(schedule_search_record_type)`` is ``false``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "schedule_search_record_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "osid.calendaring.records.ScheduleSearchResultsRecord", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.calendaring.records.ScheduleSearchResultsRecord", 
         "shortname": "ScheduleSearchResultsRecord", 
         "category": "records", 
         "doc": {
            "headline": "A record for a ``ScheduleSearchResults``.", 
            "body": "    The methods specified by the record type are available through the\n    underlying object."
         }, 
         "inherit_fullnames": [
            "osid.OsidRecord"
         ], 
         "inherit_shortnames": [
            "OsidRecord"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidRecord"
            }
         ], 
         "method_names": [], 
         "methods": []
      }, 
      {
         "fullname": "osid.calendaring.ScheduleReceiver", 
         "shortname": "ScheduleReceiver", 
         "category": "receivers", 
         "doc": {
            "headline": "The schedule receiver is the consumer supplied interface for receiving notifications pertaining to new, updated or deleted ``Schedules``.", 
            "body": ""
         }, 
         "inherit_fullnames": [
            "osid.OsidReceiver"
         ], 
         "inherit_shortnames": [
            "OsidReceiver"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidReceiver"
            }
         ], 
         "method_names": [
            "new_schedule", 
            "changed_schedule", 
            "deleted_schedule"
         ], 
         "methods": [
            {
               "name": "new_schedule", 
               "doc": {
                  "headline": "The callback for notifications of new schedules.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    schedule_id (osid.id.Id): the ``Id`` of the new\n                ``Schedule``\n", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "        :param schedule_id: the ``Id`` of the new ``Schedule``\n        :type schedule_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "schedule_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "changed_schedule", 
               "doc": {
                  "headline": "The callback for notification of updated schedules.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    schedule_id (osid.id.Id): the ``Id`` of the updated\n                ``Schedule``\n", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "        :param schedule_id: the ``Id`` of the updated ``Schedule``\n        :type schedule_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "schedule_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "deleted_schedule", 
               "doc": {
                  "headline": "The callback for notification of deleted schedules.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    schedule_id (osid.id.Id): the ``Id`` of the deleted\n                ``Schedule``\n", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "        :param schedule_id: the ``Id`` of the deleted ``Schedule``\n        :type schedule_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "schedule_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {}
            }
         ]
      }, 
      {
         "fullname": "osid.calendaring.ScheduleList", 
         "shortname": "ScheduleList", 
         "category": "objects", 
         "doc": {
            "headline": "Like all ``OsidLists,``  ``ScheduleList`` provides a means for accessing ``Schedule`` elements sequentially either one at a time or many at a time.", 
            "body": "    Examples: while (sl.hasNext()) { Schedule schedule =\n    sl.getNextSchedule(); }\n\n    or\n      while (sl.hasNext()) {\n           Schedule[] schedules = sl.getNextSchedules(sl.available());\n      }\n    \n"
         }, 
         "inherit_fullnames": [
            "osid.OsidList"
         ], 
         "inherit_shortnames": [
            "OsidList"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidList"
            }
         ], 
         "method_names": [
            "get_next_schedule", 
            "get_next_schedules"
         ], 
         "methods": [
            {
               "name": "get_next_schedule", 
               "doc": {
                  "headline": "Gets the next ``Schedule`` in this list.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.Schedule) - the next ``Schedule`` in\n                this list. The ``has_next()`` method should be used to\n                test that a next ``Schedule`` is available before\n                calling this method.", 
               "error_doc": "        raise:  IllegalState - no more elements available in this list\n        raise:  OperationFailed - unable to complete request", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the next ``Schedule`` in this list. The ``has_next()`` method should be used to test that a next ``Schedule`` is available before calling this method.\n        :rtype: ``osid.calendaring.Schedule``", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- no more elements available in this list\n        :raise: ``OperationFailed`` -- unable to complete request", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.Schedule", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational"
               }
            }, 
            {
               "name": "get_next_schedules", 
               "doc": {
                  "headline": "Gets the next set of ``Schedule`` elements in this list which must be less than or equal to the number returned from ``available()``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    n (cardinal): the number of ``Schedule`` elements\n                requested which should be less than or equal to\n                ``available()``\n", 
               "return_doc": "        return: (osid.calendaring.Schedule) - an array of ``Schedule``\n                elements.The length of the array is less than or equal\n                to the number specified.", 
               "error_doc": "        raise:  IllegalState - no more elements available in this list\n        raise:  OperationFailed - unable to complete request", 
               "sphinx_param_doc": "        :param n: the number of ``Schedule`` elements requested which should be less than or equal to ``available()``\n        :type n: ``cardinal``\n", 
               "sphinx_return_doc": "        :return: an array of ``Schedule`` elements.The length of the array is less than or equal to the number specified.\n        :rtype: ``osid.calendaring.Schedule``", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- no more elements available in this list\n        :raise: ``OperationFailed`` -- unable to complete request", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "cardinal", 
                     "var_name": "n", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "cardinal"
               ], 
               "return_type": "osid.calendaring.Schedule", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.calendaring.ScheduleSlot", 
         "shortname": "ScheduleSlot", 
         "category": "objects", 
         "doc": {
            "headline": "A ``ScheduleSlot`` describes a repeating time slot.", 
            "body": "    The time slot can be defined as a fixed time interval or be defined\n    on a weekly interval specifying the days of the week."
         }, 
         "inherit_fullnames": [
            "osid.OsidObject", 
            "osid.Containable"
         ], 
         "inherit_shortnames": [
            "OsidObject", 
            "Containable"
         ], 
         "inherit_pkg_names": [
            "osid", 
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidObject"
            }, 
            {
               "pkg_name": "osid", 
               "name": "Containable"
            }
         ], 
         "method_names": [
            "get_schedule_slot_ids", 
            "get_schedule_slots", 
            "has_weekly_interval", 
            "get_weekdays", 
            "has_week_of_month_interval", 
            "get_weekly_interval", 
            "get_week_of_month", 
            "get_weekday_time", 
            "has_fixed_interval", 
            "get_fixed_interval", 
            "get_duration", 
            "get_schedule_slot_record"
         ], 
         "methods": [
            {
               "name": "get_schedule_slot_ids", 
               "doc": {
                  "headline": "Gets the ``Ids`` of the schedule slots included inside this one.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.id.IdList) - the schedules slot ``Ids``", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the schedules slot ``Ids``\n        :rtype: ``osid.id.IdList``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.id.IdList", 
               "errors": {}
            }, 
            {
               "name": "get_schedule_slots", 
               "doc": {
                  "headline": "Gets the schedule slots included inside this one.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.ScheduleSlotList) - the schedule slots", 
               "error_doc": "        raise:  OperationFailed - unable to complete request", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the schedule slots\n        :rtype: ``osid.calendaring.ScheduleSlotList``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.ScheduleSlotList", 
               "errors": {
                  "OPERATION_FAILED": "Operational"
               }
            }, 
            {
               "name": "has_weekly_interval", 
               "doc": {
                  "headline": "Tests if this schedule has a weekly interval.", 
                  "body": "        If ``true,`` ``has_fixed_interval()`` must be ``false``."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if there is a weekly interval,\n                ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if there is a weekly interval, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "get_weekdays", 
               "doc": {
                  "headline": "Gets the weekdays of the schedule.", 
                  "body": "        On a Gregorian calendar, Sunday is zero."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (cardinal) - the weekdays", 
               "error_doc": "        raise:  IllegalState - ``has_weekly_interval()`` is ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the weekdays\n        :rtype: ``cardinal``", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- ``has_weekly_interval()`` is ``false``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "cardinal", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract"
               }
            }, 
            {
               "name": "has_week_of_month_interval", 
               "doc": {
                  "headline": "Tests if this schedule has a weekly interval based on the week of the month.", 
                  "body": "        This method must be ``false`` if ``has_weekly_interval()`` is\n        ``false``."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if there is a week of month\n                specified, ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if there is a week of month specified, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "get_weekly_interval", 
               "doc": {
                  "headline": "Gets the number of weeks of the interval.", 
                  "body": "        1 is every week. 2 is every other week. -1 is every week back in\n        time."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (integer) - ``the week interval``", 
               "error_doc": "        raise:  IllegalState - ``has_weekdly_interval()`` is ``false``\n                or ``has_weekof_month_interval()`` is ``true``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``the week interval``\n        :rtype: ``integer``", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- ``has_weekdly_interval()`` is ``false`` or ``has_weekof_month_interval()`` is ``true``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "integer", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract"
               }
            }, 
            {
               "name": "get_week_of_month", 
               "doc": {
                  "headline": "Gets the week of the month for the interval.", 
                  "body": "        1 is the first week of the month. -1 is the last week of the\n        month. 0 is invalid."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (integer) - ``the week interval``", 
               "error_doc": "        raise:  IllegalState - ``has_weekly_interval()`` is ``false`` or\n                ``has_weekof_month_interval()`` is ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``the week interval``\n        :rtype: ``integer``", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- ``has_weekly_interval()`` is ``false`` or ``has_weekof_month_interval()`` is ``false``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "integer", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract"
               }
            }, 
            {
               "name": "get_weekday_time", 
               "doc": {
                  "headline": "Gets the time of this recurring schedule.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.Time) - the time", 
               "error_doc": "        raise:  IllegalState - ``has_weekly_interval()`` is ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the time\n        :rtype: ``osid.calendaring.Time``", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- ``has_weekly_interval()`` is ``false``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.Time", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract"
               }
            }, 
            {
               "name": "has_fixed_interval", 
               "doc": {
                  "headline": "Tests if this schedule has a fixed time interval.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if there is a fixed time interval,\n                ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if there is a fixed time interval, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "get_fixed_interval", 
               "doc": {
                  "headline": "Gets the repeating interval.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.Duration) - the interval", 
               "error_doc": "        raise:  IllegalState - ``has_fixed_interval()`` is ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the interval\n        :rtype: ``osid.calendaring.Duration``", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- ``has_fixed_interval()`` is ``false``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.Duration", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract"
               }
            }, 
            {
               "name": "get_duration", 
               "doc": {
                  "headline": "Gets the duration of the schedule slot.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.Duration) - the duration", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the duration\n        :rtype: ``osid.calendaring.Duration``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.Duration", 
               "errors": {}
            }, 
            {
               "name": "get_schedule_slot_record", 
               "doc": {
                  "headline": "Gets the schedule slot record corresponding to the given ``ScheduleSlot`` record ``Type``.", 
                  "body": "        This method is used to retrieve an object implementing the\n        requested record. The ``schedule_slot_record_type`` may be the\n        ``Type`` returned in ``get_record_types()`` or any of its\n        parents in a ``Type`` hierarchy where\n        ``has_record_type(schedule_slot_record_type)`` is ``true`` ."
               }, 
               "arg_doc": "        arg:    schedule_slot_record_type (osid.type.Type): the type of\n                the record to retrieve\n", 
               "return_doc": "        return: (osid.calendaring.records.ScheduleSlotRecord) - the\n                schedule slot record", 
               "error_doc": "        raise:  NullArgument - ``schedule_slot_record_type`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unsupported -\n                ``has_record_type(schedule_slot_record_type)`` is\n                ``false``", 
               "sphinx_param_doc": "        :param schedule_slot_record_type: the type of the record to retrieve\n        :type schedule_slot_record_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "        :return: the schedule slot record\n        :rtype: ``osid.calendaring.records.ScheduleSlotRecord``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``schedule_slot_record_type`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unsupported`` -- ``has_record_type(schedule_slot_record_type)`` is ``false``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "schedule_slot_record_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "osid.calendaring.records.ScheduleSlotRecord", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.calendaring.records.ScheduleSlotRecord", 
         "shortname": "ScheduleSlotRecord", 
         "category": "records", 
         "doc": {
            "headline": "A record for a ``ScheduleSlot``.", 
            "body": "    The methods specified by the record type are available through the\n    underlying object."
         }, 
         "inherit_fullnames": [
            "osid.OsidRecord"
         ], 
         "inherit_shortnames": [
            "OsidRecord"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidRecord"
            }
         ], 
         "method_names": [], 
         "methods": []
      }, 
      {
         "fullname": "osid.calendaring.ScheduleSlotQuery", 
         "shortname": "ScheduleSlotQuery", 
         "category": "queries", 
         "doc": {
            "headline": "This is the query for searching schedule slots.", 
            "body": "    Each method match request produces an ``AND`` term while multiple\n    invocations of a method produces a nested ``OR``."
         }, 
         "inherit_fullnames": [
            "osid.OsidObjectQuery", 
            "osid.OsidContainableQuery"
         ], 
         "inherit_shortnames": [
            "OsidObjectQuery", 
            "OsidContainableQuery"
         ], 
         "inherit_pkg_names": [
            "osid", 
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidObjectQuery"
            }, 
            {
               "pkg_name": "osid", 
               "name": "OsidContainableQuery"
            }
         ], 
         "method_names": [
            "match_schedule_slot_id", 
            "clear_schedule_slot_id_terms", 
            "supports_schedule_slot_query", 
            "get_schedule_slot_query", 
            "match_any_schedule_slot", 
            "clear_schedule_slot_terms", 
            "match_weekday", 
            "match_any_weekday", 
            "clear_weekday_terms", 
            "match_weekly_interval", 
            "match_any_weekly_interval", 
            "clear_weekly_interval_terms", 
            "match_week_of_month", 
            "match_any_week_of_month", 
            "clear_week_of_month_terms", 
            "match_weekday_time", 
            "match_any_weekday_time", 
            "clear_weekday_time_terms", 
            "match_fixed_interval", 
            "match_any_fixed_interval", 
            "clear_fixed_interval_terms", 
            "match_duration", 
            "match_any_duration", 
            "clear_duration_terms", 
            "match_calendar_id", 
            "clear_calendar_id_terms", 
            "supports_calendar_query", 
            "get_calendar_query", 
            "clear_calendar_terms", 
            "get_schedule_slot_query_record"
         ], 
         "methods": [
            {
               "name": "match_schedule_slot_id", 
               "doc": {
                  "headline": "Sets the schedule ``Id`` for this query for matching nested schedule slots.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    schedule_slot_id (osid.id.Id): a schedule slot ``Id``\n        arg:    match (boolean): ``true`` for a positive match,\n                ``false`` for a negative match\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``schedule_slot_id`` is ``null``", 
               "sphinx_param_doc": "        :param schedule_slot_id: a schedule slot ``Id``\n        :type schedule_slot_id: ``osid.id.Id``\n        :param match: ``true`` for a positive match, ``false`` for a negative match\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``schedule_slot_id`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "schedule_slot_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "clear_schedule_slot_id_terms", 
               "doc": {
                  "headline": "Clears the schedule slot ``Id`` terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "supports_schedule_slot_query", 
               "doc": {
                  "headline": "Tests if a ``ScheduleSlotQuery`` is available for querying sechedule slots.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if a schedule slot query is\n                available, ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if a schedule slot query is available, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "get_schedule_slot_query", 
               "doc": {
                  "headline": "Gets the query for a schedul slot.", 
                  "body": "        Multiple retrievals produce a nested ``OR`` term."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.ScheduleSlotQuery) - the schedule slot\n                query", 
               "error_doc": "        raise:  Unimplemented - ``supports_schedule_slot_query()`` is\n                ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the schedule slot query\n        :rtype: ``osid.calendaring.ScheduleSlotQuery``", 
               "sphinx_error_doc": "        :raise: ``Unimplemented`` -- ``supports_schedule_slot_query()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_schedule_slot_query()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.ScheduleSlotQuery", 
               "errors": {
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "match_any_schedule_slot", 
               "doc": {
                  "headline": "Matches a schedule that has any schedule slot assigned.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    match (boolean): ``true`` to match schedule with any\n                schedule slots, ``false`` to match schedules with no\n                schedule slots\n", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "        :param match: ``true`` to match schedule with any schedule slots, ``false`` to match schedules with no schedule slots\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "clear_schedule_slot_terms", 
               "doc": {
                  "headline": "Clears the schedule slot terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "match_weekday", 
               "doc": {
                  "headline": "Matches schedules that have the given weekday.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    weekday (cardinal): a weekday\n        arg:    match (boolean): ``true`` for a positive match,\n                ``false`` for a negative match\n", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "        :param weekday: a weekday\n        :type weekday: ``cardinal``\n        :param match: ``true`` for a positive match, ``false`` for a negative match\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "cardinal", 
                     "var_name": "weekday", 
                     "array": false
                  }, 
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "cardinal", 
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "match_any_weekday", 
               "doc": {
                  "headline": "Matches schedules with any weekday set.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    match (boolean): ``true`` to match schedules with any\n                weekday, ``false`` to match schedules with no weekday\n", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "        :param match: ``true`` to match schedules with any weekday, ``false`` to match schedules with no weekday\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "clear_weekday_terms", 
               "doc": {
                  "headline": "Clears the weekday terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "match_weekly_interval", 
               "doc": {
                  "headline": "Matches schedules that have the given weekly interval in the given range inclusive.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    from (integer): start range\n        arg:    to (integer): end range\n        arg:    match (boolean): ``true`` for a positive match,\n                ``false`` for a negative match\n", 
               "return_doc": "", 
               "error_doc": "        raise:  InvalidArgument - ``to`` is less than ``from``", 
               "sphinx_param_doc": "        :param from: start range\n        :type from: ``integer``\n        :param to: end range\n        :type to: ``integer``\n        :param match: ``true`` for a positive match, ``false`` for a negative match\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``InvalidArgument`` -- ``to`` is less than ``from``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "integer", 
                     "var_name": "from_", 
                     "array": false
                  }, 
                  {
                     "arg_type": "integer", 
                     "var_name": "to", 
                     "array": false
                  }, 
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "integer", 
                  "integer", 
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {
                  "INVALID_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "match_any_weekly_interval", 
               "doc": {
                  "headline": "Matches schedules with any weekly interval set.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    match (boolean): ``true`` to match schedules with any\n                weekly interval, ``false`` to match schedules with no\n                weekly interval\n", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "        :param match: ``true`` to match schedules with any weekly interval, ``false`` to match schedules with no weekly interval\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "clear_weekly_interval_terms", 
               "doc": {
                  "headline": "Clears the weekly interval terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "match_week_of_month", 
               "doc": {
                  "headline": "Matches schedules that have a week of month in the given range inclusive.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    from (integer): start range\n        arg:    to (integer): end range\n        arg:    match (boolean): ``true`` for a positive match,\n                ``false`` for a negative match\n", 
               "return_doc": "", 
               "error_doc": "        raise:  InvalidArgument - ``to`` is less than ``from``", 
               "sphinx_param_doc": "        :param from: start range\n        :type from: ``integer``\n        :param to: end range\n        :type to: ``integer``\n        :param match: ``true`` for a positive match, ``false`` for a negative match\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``InvalidArgument`` -- ``to`` is less than ``from``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "integer", 
                     "var_name": "from_", 
                     "array": false
                  }, 
                  {
                     "arg_type": "integer", 
                     "var_name": "to", 
                     "array": false
                  }, 
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "integer", 
                  "integer", 
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {
                  "INVALID_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "match_any_week_of_month", 
               "doc": {
                  "headline": "Matches schedules with any month week set.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    match (boolean): ``true`` to match schedules with any\n                week of month, ``false`` to match schedules with no\n                month week\n", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "        :param match: ``true`` to match schedules with any week of month, ``false`` to match schedules with no month week\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "clear_week_of_month_terms", 
               "doc": {
                  "headline": "Clears the week of month terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "match_weekday_time", 
               "doc": {
                  "headline": "Matches schedules that have a weekday time in the given range inclusive.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    from (osid.calendaring.Time): start range\n        arg:    to (osid.calendaring.Time): end range\n        arg:    match (boolean): ``true`` for a positive match,\n                ``false`` for a negative match\n", 
               "return_doc": "", 
               "error_doc": "        raise:  InvalidArgument - ``to`` is less than ``from``\n        raise:  NullArgument - ``from`` or ``to``  ``null``", 
               "sphinx_param_doc": "        :param from: start range\n        :type from: ``osid.calendaring.Time``\n        :param to: end range\n        :type to: ``osid.calendaring.Time``\n        :param match: ``true`` for a positive match, ``false`` for a negative match\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``InvalidArgument`` -- ``to`` is less than ``from``\n        :raise: ``NullArgument`` -- ``from`` or ``to``  ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.calendaring.Time", 
                     "var_name": "from_", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.calendaring.Time", 
                     "var_name": "to", 
                     "array": false
                  }, 
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.calendaring.Time", 
                  "osid.calendaring.Time", 
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {
                  "INVALID_ARGUMENT": "ConsumerContract", 
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "match_any_weekday_time", 
               "doc": {
                  "headline": "Matches schedules with any weekday time.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    match (boolean): ``true`` to match schedules with any\n                weekday time, ``false`` to match schedules with no\n                weekday time\n", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "        :param match: ``true`` to match schedules with any weekday time, ``false`` to match schedules with no weekday time\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "clear_weekday_time_terms", 
               "doc": {
                  "headline": "Clears the weekday time terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "match_fixed_interval", 
               "doc": {
                  "headline": "Matches schedules that have the given fixed interval in the given range inclusive.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    from (osid.calendaring.Duration): start range\n        arg:    to (osid.calendaring.Duration): end range\n        arg:    match (boolean): ``true`` for a positive match,\n                ``false`` for a negative match\n", 
               "return_doc": "", 
               "error_doc": "        raise:  InvalidArgument - ``to`` is less than ``from``\n        raise:  NullArgument - ``from`` or ``to``  ``null``", 
               "sphinx_param_doc": "        :param from: start range\n        :type from: ``osid.calendaring.Duration``\n        :param to: end range\n        :type to: ``osid.calendaring.Duration``\n        :param match: ``true`` for a positive match, ``false`` for a negative match\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``InvalidArgument`` -- ``to`` is less than ``from``\n        :raise: ``NullArgument`` -- ``from`` or ``to``  ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.calendaring.Duration", 
                     "var_name": "from_", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.calendaring.Duration", 
                     "var_name": "to", 
                     "array": false
                  }, 
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.calendaring.Duration", 
                  "osid.calendaring.Duration", 
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {
                  "INVALID_ARGUMENT": "ConsumerContract", 
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "match_any_fixed_interval", 
               "doc": {
                  "headline": "Matches schedules with any fixed interval.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    match (boolean): ``true`` to match schedules with any\n                fixed interval, ``false`` to match schedules with no\n                fixed interval\n", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "        :param match: ``true`` to match schedules with any fixed interval, ``false`` to match schedules with no fixed interval\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "clear_fixed_interval_terms", 
               "doc": {
                  "headline": "Clears the fixed interval terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "match_duration", 
               "doc": {
                  "headline": "Matches the duration between the given range inclusive.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    low (osid.calendaring.Duration): low duration range\n        arg:    high (osid.calendaring.Duration): high duration range\n        arg:    match (boolean): ``true`` for a positive match,\n                ``false`` for a negative match\n", 
               "return_doc": "", 
               "error_doc": "        raise:  InvalidArgument - ``high`` is less than ``low``\n        raise:  NullArgument - ``high`` or ``low`` is ``null``", 
               "sphinx_param_doc": "        :param low: low duration range\n        :type low: ``osid.calendaring.Duration``\n        :param high: high duration range\n        :type high: ``osid.calendaring.Duration``\n        :param match: ``true`` for a positive match, ``false`` for a negative match\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``InvalidArgument`` -- ``high`` is less than ``low``\n        :raise: ``NullArgument`` -- ``high`` or ``low`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.calendaring.Duration", 
                     "var_name": "low", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.calendaring.Duration", 
                     "var_name": "high", 
                     "array": false
                  }, 
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.calendaring.Duration", 
                  "osid.calendaring.Duration", 
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {
                  "INVALID_ARGUMENT": "ConsumerContract", 
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "match_any_duration", 
               "doc": {
                  "headline": "Matches a schedule slot that has any duration.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    match (boolean): ``true`` to match schedules with any\n                duration, ``false`` to match schedules with no start\n                time\n", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "        :param match: ``true`` to match schedules with any duration, ``false`` to match schedules with no start time\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "clear_duration_terms", 
               "doc": {
                  "headline": "Clears the duration terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "match_calendar_id", 
               "doc": {
                  "headline": "Sets the calendar ``Id`` for this query.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    calendar_id (osid.id.Id): a calendar ``Id``\n        arg:    match (boolean): ``true`` for a positive match,\n                ``false`` for a negative match\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``calendar_id`` is ``null``", 
               "sphinx_param_doc": "        :param calendar_id: a calendar ``Id``\n        :type calendar_id: ``osid.id.Id``\n        :param match: ``true`` for a positive match, ``false`` for a negative match\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``calendar_id`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "calendar_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "clear_calendar_id_terms", 
               "doc": {
                  "headline": "Clears the calendar ``Id`` terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "supports_calendar_query", 
               "doc": {
                  "headline": "Tests if a ``CalendarQuery`` is available for querying calendars.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if a calendar query is available,\n                ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if a calendar query is available, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "get_calendar_query", 
               "doc": {
                  "headline": "Gets the query for a calendar.", 
                  "body": "        Multiple retrievals produce a nested ``OR`` term."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.CalendarQuery) - the calendar query", 
               "error_doc": "        raise:  Unimplemented - ``supports_calendar_query()`` is\n                ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the calendar query\n        :rtype: ``osid.calendaring.CalendarQuery``", 
               "sphinx_error_doc": "        :raise: ``Unimplemented`` -- ``supports_calendar_query()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_calendar_query()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.CalendarQuery", 
               "errors": {
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "clear_calendar_terms", 
               "doc": {
                  "headline": "Clears the calendar terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "get_schedule_slot_query_record", 
               "doc": {
                  "headline": "Gets the schedule slot query record corresponding to the given ``ScheduleSlot`` record ``Type``.", 
                  "body": "        Multiple retrievals produce a nested ``OR`` term."
               }, 
               "arg_doc": "        arg:    schedule_slot_record_type (osid.type.Type): a schedule\n                slot query record type\n", 
               "return_doc": "        return: (osid.calendaring.records.ScheduleSlotQueryRecord) - the\n                schedule slot query record", 
               "error_doc": "        raise:  NullArgument - ``schedule_slot_record_type`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unsupported -\n                ``has_record_type(schedule_slot_record_type)`` is\n                ``false``", 
               "sphinx_param_doc": "        :param schedule_slot_record_type: a schedule slot query record type\n        :type schedule_slot_record_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "        :return: the schedule slot query record\n        :rtype: ``osid.calendaring.records.ScheduleSlotQueryRecord``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``schedule_slot_record_type`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unsupported`` -- ``has_record_type(schedule_slot_record_type)`` is ``false``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "schedule_slot_record_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "osid.calendaring.records.ScheduleSlotQueryRecord", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.calendaring.records.ScheduleSlotQueryRecord", 
         "shortname": "ScheduleSlotQueryRecord", 
         "category": "records", 
         "doc": {
            "headline": "A record for a ``ScheduleSlotQuery``.", 
            "body": "    The methods specified by the record type are available through the\n    underlying object."
         }, 
         "inherit_fullnames": [
            "osid.OsidRecord"
         ], 
         "inherit_shortnames": [
            "OsidRecord"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidRecord"
            }
         ], 
         "method_names": [], 
         "methods": []
      }, 
      {
         "fullname": "osid.calendaring.ScheduleSlotQueryInspector", 
         "shortname": "ScheduleSlotQueryInspector", 
         "category": "query_inspectors", 
         "doc": {
            "headline": "This is the query inspector for examining schedule queries.", 
            "body": ""
         }, 
         "inherit_fullnames": [
            "osid.OsidObjectQueryInspector", 
            "osid.OsidContainableQueryInspector"
         ], 
         "inherit_shortnames": [
            "OsidObjectQueryInspector", 
            "OsidContainableQueryInspector"
         ], 
         "inherit_pkg_names": [
            "osid", 
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidObjectQueryInspector"
            }, 
            {
               "pkg_name": "osid", 
               "name": "OsidContainableQueryInspector"
            }
         ], 
         "method_names": [
            "get_schedule_slot_id_terms", 
            "get_schedule_slot_terms", 
            "get_weekday_terms", 
            "get_weekly_interval_terms", 
            "get_week_of_month_terms", 
            "get_weekday_time_terms", 
            "get_fixed_interval_terms", 
            "get_duration_terms", 
            "get_calendar_id_terms", 
            "get_calendar_terms", 
            "get_schedule_slot_query_inspector_record"
         ], 
         "methods": [
            {
               "name": "get_schedule_slot_id_terms", 
               "doc": {
                  "headline": "Gets the schedule slot ``Id`` terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.search.terms.IdTerm) - the schedule ``Id`` terms", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the schedule ``Id`` terms\n        :rtype: ``osid.search.terms.IdTerm``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.search.terms.IdTerm", 
               "errors": {}
            }, 
            {
               "name": "get_schedule_slot_terms", 
               "doc": {
                  "headline": "Gets the schedule slot terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.ScheduleSlotQueryInspector) - the\n                schedule slot terms", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the schedule slot terms\n        :rtype: ``osid.calendaring.ScheduleSlotQueryInspector``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.ScheduleSlotQueryInspector", 
               "errors": {}
            }, 
            {
               "name": "get_weekday_terms", 
               "doc": {
                  "headline": "Gets the weekday terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.search.terms.CardinalTerm) - the weekday terms", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the weekday terms\n        :rtype: ``osid.search.terms.CardinalTerm``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.search.terms.CardinalTerm", 
               "errors": {}
            }, 
            {
               "name": "get_weekly_interval_terms", 
               "doc": {
                  "headline": "Gets the weekly interval terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.search.terms.IntegerTerm) - the weekly interval\n                terms", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the weekly interval terms\n        :rtype: ``osid.search.terms.IntegerTerm``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.search.terms.IntegerTerm", 
               "errors": {}
            }, 
            {
               "name": "get_week_of_month_terms", 
               "doc": {
                  "headline": "Gets the week of month terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.search.terms.IntegerTerm) - the week of month\n                terms", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the week of month terms\n        :rtype: ``osid.search.terms.IntegerTerm``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.search.terms.IntegerTerm", 
               "errors": {}
            }, 
            {
               "name": "get_weekday_time_terms", 
               "doc": {
                  "headline": "Gets the weekday time terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.search.terms.TimeRangeTerm) - the fixed interval\n                terms", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the fixed interval terms\n        :rtype: ``osid.search.terms.TimeRangeTerm``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.search.terms.TimeRangeTerm", 
               "errors": {}
            }, 
            {
               "name": "get_fixed_interval_terms", 
               "doc": {
                  "headline": "Gets the fixed interval terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.search.terms.DurationRangeTerm) - the fixed\n                interval terms", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the fixed interval terms\n        :rtype: ``osid.search.terms.DurationRangeTerm``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.search.terms.DurationRangeTerm", 
               "errors": {}
            }, 
            {
               "name": "get_duration_terms", 
               "doc": {
                  "headline": "Gets the duration terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.search.terms.DurationTerm) - the duration terms", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the duration terms\n        :rtype: ``osid.search.terms.DurationTerm``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.search.terms.DurationTerm", 
               "errors": {}
            }, 
            {
               "name": "get_calendar_id_terms", 
               "doc": {
                  "headline": "Gets the calendar ``Id`` terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.search.terms.IdTerm) - the calendar ``Id`` terms", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the calendar ``Id`` terms\n        :rtype: ``osid.search.terms.IdTerm``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.search.terms.IdTerm", 
               "errors": {}
            }, 
            {
               "name": "get_calendar_terms", 
               "doc": {
                  "headline": "Gets the calendar terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.CalendarQueryInspector) - the calendar\n                terms", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the calendar terms\n        :rtype: ``osid.calendaring.CalendarQueryInspector``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.CalendarQueryInspector", 
               "errors": {}
            }, 
            {
               "name": "get_schedule_slot_query_inspector_record", 
               "doc": {
                  "headline": "Gets the schedule slot query inspector record corresponding to the given ``ScheduleSlot`` record ``Type``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    schedule_slot_record_type (osid.type.Type): a schedule\n                slot query record type\n", 
               "return_doc": "        return:\n                (osid.calendaring.records.ScheduleSlotQueryInspectorReco\n                rd) - the schedule slot query inspector record", 
               "error_doc": "        raise:  NullArgument - ``schedule_slot_record_type`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unsupported -\n                ``has_record_type(schedule_slot_record_type)`` is\n                ``false``", 
               "sphinx_param_doc": "        :param schedule_slot_record_type: a schedule slot query record type\n        :type schedule_slot_record_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "        :return: the schedule slot query inspector record\n        :rtype: ``osid.calendaring.records.ScheduleSlotQueryInspectorRecord``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``schedule_slot_record_type`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unsupported`` -- ``has_record_type(schedule_slot_record_type)`` is ``false``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "schedule_slot_record_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "osid.calendaring.records.ScheduleSlotQueryInspectorRecord", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.calendaring.records.ScheduleSlotQueryInspectorRecord", 
         "shortname": "ScheduleSlotQueryInspectorRecord", 
         "category": "records", 
         "doc": {
            "headline": "A record for a ``ScheduleSlotQueryInspector``.", 
            "body": "    The methods specified by the record type are available through the\n    underlying object."
         }, 
         "inherit_fullnames": [
            "osid.OsidRecord"
         ], 
         "inherit_shortnames": [
            "OsidRecord"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidRecord"
            }
         ], 
         "method_names": [], 
         "methods": []
      }, 
      {
         "fullname": "osid.calendaring.ScheduleSlotForm", 
         "shortname": "ScheduleSlotForm", 
         "category": "objects", 
         "doc": {
            "headline": "This is the form for creating and updating ``ScheduleSlots``.", 
            "body": "    Like all ``OsidForm`` objects, various data elements may be set here\n    for use in the create and update methods in the\n    ``ScheduleSlotAdminSession``. For each data element that may be set,\n    metadata may be examined to provide display hints or data\n    constraints."
         }, 
         "inherit_fullnames": [
            "osid.OsidObjectForm", 
            "osid.OsidContainableForm"
         ], 
         "inherit_shortnames": [
            "OsidObjectForm", 
            "OsidContainableForm"
         ], 
         "inherit_pkg_names": [
            "osid", 
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidObjectForm"
            }, 
            {
               "pkg_name": "osid", 
               "name": "OsidContainableForm"
            }
         ], 
         "method_names": [
            "get_weekday_metadata", 
            "set_weekdays", 
            "get_weekly_interval_metadata", 
            "set_weekly_interval", 
            "get_week_of_month_metadata", 
            "set_week_of_month", 
            "get_weekday_time_metadata", 
            "set_weekday_time", 
            "clear_weekday_schedule", 
            "get_fixed_interval_metadata", 
            "set_fixed_interval", 
            "clear_fixed_interval", 
            "get_duration_metadata", 
            "set_duration", 
            "clear_duration", 
            "get_schedule_slot_form_record"
         ], 
         "methods": [
            {
               "name": "get_weekday_metadata", 
               "doc": {
                  "headline": "Gets the metadata for the weekdays of a weekly schedule.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.Metadata) - metadata for the weekday", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: metadata for the weekday\n        :rtype: ``osid.Metadata``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.Metadata", 
               "errors": {}
            }, 
            {
               "name": "set_weekdays", 
               "doc": {
                  "headline": "Sets the weekdays of a weekly schedule.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    weekdays (cardinal[]): the new weekday set\n", 
               "return_doc": "", 
               "error_doc": "        raise:  InvalidArgument - ``weekdays`` is invalid\n        raise:  NoAccess - ``weekdays`` cannot be modified\n        raise:  NullArgument - ``weekdays`` is ``null``", 
               "sphinx_param_doc": "        :param weekdays: the new weekday set\n        :type weekdays: ``cardinal[]``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``InvalidArgument`` -- ``weekdays`` is invalid\n        :raise: ``NoAccess`` -- ``weekdays`` cannot be modified\n        :raise: ``NullArgument`` -- ``weekdays`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "cardinal[]", 
                     "var_name": "weekdays", 
                     "array": true
                  }
               ], 
               "arg_types": [
                  "cardinal[]"
               ], 
               "return_type": "", 
               "errors": {
                  "INVALID_ARGUMENT": "ConsumerContract", 
                  "NO_ACCESS": "ConsumerContract", 
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "get_weekly_interval_metadata", 
               "doc": {
                  "headline": "Gets the metadata for the interval of a weekly schedule.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.Metadata) - metadata for the weekly interval", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: metadata for the weekly interval\n        :rtype: ``osid.Metadata``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.Metadata", 
               "errors": {}
            }, 
            {
               "name": "set_weekly_interval", 
               "doc": {
                  "headline": "Sets the interval of a weekly schedule.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    interval (integer): the new weekly interval\n", 
               "return_doc": "", 
               "error_doc": "        raise:  InvalidArgument - ``interval`` is invalid\n        raise:  NoAccess - ``interval`` cannot be modified", 
               "sphinx_param_doc": "        :param interval: the new weekly interval\n        :type interval: ``integer``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``InvalidArgument`` -- ``interval`` is invalid\n        :raise: ``NoAccess`` -- ``interval`` cannot be modified", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "integer", 
                     "var_name": "interval", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "integer"
               ], 
               "return_type": "", 
               "errors": {
                  "INVALID_ARGUMENT": "ConsumerContract", 
                  "NO_ACCESS": "ConsumerContract"
               }
            }, 
            {
               "name": "get_week_of_month_metadata", 
               "doc": {
                  "headline": "Gets the metadata for the week of the month of a weekly schedule.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.Metadata) - metadata for the week of the month", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: metadata for the week of the month\n        :rtype: ``osid.Metadata``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.Metadata", 
               "errors": {}
            }, 
            {
               "name": "set_week_of_month", 
               "doc": {
                  "headline": "Sets the week of the month of a weekly schedule.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    week (integer): the new week of the month\n", 
               "return_doc": "", 
               "error_doc": "        raise:  InvalidArgument - ``week`` is invalid\n        raise:  NoAccess - ``week`` cannot be modified", 
               "sphinx_param_doc": "        :param week: the new week of the month\n        :type week: ``integer``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``InvalidArgument`` -- ``week`` is invalid\n        :raise: ``NoAccess`` -- ``week`` cannot be modified", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "integer", 
                     "var_name": "week", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "integer"
               ], 
               "return_type": "", 
               "errors": {
                  "INVALID_ARGUMENT": "ConsumerContract", 
                  "NO_ACCESS": "ConsumerContract"
               }
            }, 
            {
               "name": "get_weekday_time_metadata", 
               "doc": {
                  "headline": "Gets the metadata for the weekday time of a weekly schedule.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.Metadata) - metadata for the weekday time", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: metadata for the weekday time\n        :rtype: ``osid.Metadata``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.Metadata", 
               "errors": {}
            }, 
            {
               "name": "set_weekday_time", 
               "doc": {
                  "headline": "Sets the weekday time of a weekly schedule.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    time (osid.calendaring.Time): the new time\n", 
               "return_doc": "", 
               "error_doc": "        raise:  InvalidArgument - ``time`` is invalid\n        raise:  NoAccess - ``time`` cannot be modified\n        raise:  NullArgument - ``time`` is ``null``", 
               "sphinx_param_doc": "        :param time: the new time\n        :type time: ``osid.calendaring.Time``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``InvalidArgument`` -- ``time`` is invalid\n        :raise: ``NoAccess`` -- ``time`` cannot be modified\n        :raise: ``NullArgument`` -- ``time`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.calendaring.Time", 
                     "var_name": "time", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.calendaring.Time"
               ], 
               "return_type": "", 
               "errors": {
                  "INVALID_ARGUMENT": "ConsumerContract", 
                  "NO_ACCESS": "ConsumerContract", 
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "clear_weekday_schedule", 
               "doc": {
                  "headline": "Clears the weekday schedule items.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "        raise:  NoAccess - ``Metadata.isRequired()`` or\n                ``Metadata.isReadOnly()`` is ``true``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NoAccess`` -- ``Metadata.isRequired()`` or ``Metadata.isReadOnly()`` is ``true``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {
                  "NO_ACCESS": "ConsumerContract"
               }
            }, 
            {
               "name": "get_fixed_interval_metadata", 
               "doc": {
                  "headline": "Gets the metadata for the fixed interval.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.Metadata) - metadata for the fixed interval.", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: metadata for the fixed interval.\n        :rtype: ``osid.Metadata``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.Metadata", 
               "errors": {}
            }, 
            {
               "name": "set_fixed_interval", 
               "doc": {
                  "headline": "Sets the fixed interval.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    interval (osid.calendaring.Duration): the new fixed\n                interval\n", 
               "return_doc": "", 
               "error_doc": "        raise:  InvalidArgument - ``interval`` is invalid\n        raise:  NoAccess - ``interval`` cannot be modified\n        raise:  NullArgument - ``interval`` is ``null``", 
               "sphinx_param_doc": "        :param interval: the new fixed interval\n        :type interval: ``osid.calendaring.Duration``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``InvalidArgument`` -- ``interval`` is invalid\n        :raise: ``NoAccess`` -- ``interval`` cannot be modified\n        :raise: ``NullArgument`` -- ``interval`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.calendaring.Duration", 
                     "var_name": "interval", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.calendaring.Duration"
               ], 
               "return_type": "", 
               "errors": {
                  "INVALID_ARGUMENT": "ConsumerContract", 
                  "NO_ACCESS": "ConsumerContract", 
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "clear_fixed_interval", 
               "doc": {
                  "headline": "Clears the fixed interval items.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "        raise:  NoAccess - ``Metadata.isRequired()`` or\n                ``Metadata.isReadOnly()`` is ``true``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NoAccess`` -- ``Metadata.isRequired()`` or ``Metadata.isReadOnly()`` is ``true``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {
                  "NO_ACCESS": "ConsumerContract"
               }
            }, 
            {
               "name": "get_duration_metadata", 
               "doc": {
                  "headline": "Gets the metadata for the duration of the slot.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.Metadata) - metadata for the duration", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: metadata for the duration\n        :rtype: ``osid.Metadata``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.Metadata", 
               "errors": {}
            }, 
            {
               "name": "set_duration", 
               "doc": {
                  "headline": "Sets the duration.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    duration (osid.calendaring.Duration): the new duration\n", 
               "return_doc": "", 
               "error_doc": "        raise:  InvalidArgument - ``duration`` is invalid\n        raise:  NoAccess - ``duration`` cannot be modified\n        raise:  NullArgument - ``duration`` is ``null``", 
               "sphinx_param_doc": "        :param duration: the new duration\n        :type duration: ``osid.calendaring.Duration``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``InvalidArgument`` -- ``duration`` is invalid\n        :raise: ``NoAccess`` -- ``duration`` cannot be modified\n        :raise: ``NullArgument`` -- ``duration`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.calendaring.Duration", 
                     "var_name": "duration", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.calendaring.Duration"
               ], 
               "return_type": "", 
               "errors": {
                  "INVALID_ARGUMENT": "ConsumerContract", 
                  "NO_ACCESS": "ConsumerContract", 
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "clear_duration", 
               "doc": {
                  "headline": "Clears the duration terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "        raise:  NoAccess - ``Metadata.isRequired()`` or\n                ``Metadata.isReadOnly()`` is ``true``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NoAccess`` -- ``Metadata.isRequired()`` or ``Metadata.isReadOnly()`` is ``true``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {
                  "NO_ACCESS": "ConsumerContract"
               }
            }, 
            {
               "name": "get_schedule_slot_form_record", 
               "doc": {
                  "headline": "Gets the ``ScheduleSlotFormRecord`` corresponding to the given schedule record ``Type``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    schedule_slot_record_type (osid.type.Type): the schedule\n                slot record type\n", 
               "return_doc": "        return: (osid.calendaring.records.ScheduleSlotFormRecord) - the\n                schedule slot form record", 
               "error_doc": "        raise:  NullArgument - ``schedule_slot_record_type`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unsupported -\n                ``has_record_type(schedule_slot_record_type)`` is\n                ``false``", 
               "sphinx_param_doc": "        :param schedule_slot_record_type: the schedule slot record type\n        :type schedule_slot_record_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "        :return: the schedule slot form record\n        :rtype: ``osid.calendaring.records.ScheduleSlotFormRecord``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``schedule_slot_record_type`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unsupported`` -- ``has_record_type(schedule_slot_record_type)`` is ``false``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "schedule_slot_record_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "osid.calendaring.records.ScheduleSlotFormRecord", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.calendaring.records.ScheduleSlotFormRecord", 
         "shortname": "ScheduleSlotFormRecord", 
         "category": "records", 
         "doc": {
            "headline": "A record for a ``ScheduleSlotForm``.", 
            "body": "    The methods specified by the record type are available through the\n    underlying object."
         }, 
         "inherit_fullnames": [
            "osid.OsidRecord"
         ], 
         "inherit_shortnames": [
            "OsidRecord"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidRecord"
            }
         ], 
         "method_names": [], 
         "methods": []
      }, 
      {
         "fullname": "osid.calendaring.ScheduleSlotSearchOrder", 
         "shortname": "ScheduleSlotSearchOrder", 
         "category": "search_orders", 
         "doc": {
            "headline": "An interface for specifying the ordering of search results.", 
            "body": ""
         }, 
         "inherit_fullnames": [
            "osid.OsidObjectSearchOrder", 
            "osid.OsidContainableSearchOrder"
         ], 
         "inherit_shortnames": [
            "OsidObjectSearchOrder", 
            "OsidContainableSearchOrder"
         ], 
         "inherit_pkg_names": [
            "osid", 
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidObjectSearchOrder"
            }, 
            {
               "pkg_name": "osid", 
               "name": "OsidContainableSearchOrder"
            }
         ], 
         "method_names": [
            "order_by_weekday_start", 
            "order_by_weekly_interval", 
            "order_by_week_of_month", 
            "order_by_weekday_time", 
            "order_by_fixed_interval", 
            "order_by_duration", 
            "get_schedule_slot_search_order_record"
         ], 
         "methods": [
            {
               "name": "order_by_weekday_start", 
               "doc": {
                  "headline": "Specified a preference for ordering results by the starting weekday.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    style (osid.SearchOrderStyle): a search order style\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``style`` is ``null``", 
               "sphinx_param_doc": "        :param style: a search order style\n        :type style: ``osid.SearchOrderStyle``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``style`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.SearchOrderStyle", 
                     "var_name": "style", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.SearchOrderStyle"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "order_by_weekly_interval", 
               "doc": {
                  "headline": "Specified a preference for ordering results by the weekly interval.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    style (osid.SearchOrderStyle): a search order style\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``style`` is ``null``", 
               "sphinx_param_doc": "        :param style: a search order style\n        :type style: ``osid.SearchOrderStyle``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``style`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.SearchOrderStyle", 
                     "var_name": "style", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.SearchOrderStyle"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "order_by_week_of_month", 
               "doc": {
                  "headline": "Specified a preference for ordering results by the week of the month.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    style (osid.SearchOrderStyle): a search order style\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``style`` is ``null``", 
               "sphinx_param_doc": "        :param style: a search order style\n        :type style: ``osid.SearchOrderStyle``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``style`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.SearchOrderStyle", 
                     "var_name": "style", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.SearchOrderStyle"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "order_by_weekday_time", 
               "doc": {
                  "headline": "Specified a preference for ordering results by the weekday time.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    style (osid.SearchOrderStyle): a search order style\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``style`` is ``null``", 
               "sphinx_param_doc": "        :param style: a search order style\n        :type style: ``osid.SearchOrderStyle``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``style`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.SearchOrderStyle", 
                     "var_name": "style", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.SearchOrderStyle"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "order_by_fixed_interval", 
               "doc": {
                  "headline": "Specified a preference for ordering results by the fixed interval.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    style (osid.SearchOrderStyle): a search order style\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``style`` is ``null``", 
               "sphinx_param_doc": "        :param style: a search order style\n        :type style: ``osid.SearchOrderStyle``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``style`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.SearchOrderStyle", 
                     "var_name": "style", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.SearchOrderStyle"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "order_by_duration", 
               "doc": {
                  "headline": "Specified a preference for ordering results by the duration.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    style (osid.SearchOrderStyle): a search order style\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``style`` is ``null``", 
               "sphinx_param_doc": "        :param style: a search order style\n        :type style: ``osid.SearchOrderStyle``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``style`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.SearchOrderStyle", 
                     "var_name": "style", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.SearchOrderStyle"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "get_schedule_slot_search_order_record", 
               "doc": {
                  "headline": "Gets the schedule slot search order record corresponding to the given schedule record ``Type``.", 
                  "body": "        Multiple retrievals return the same underlying object."
               }, 
               "arg_doc": "        arg:    schedule_slot_record_type (osid.type.Type): a schedule\n                slot record type\n", 
               "return_doc": "        return: (osid.calendaring.records.ScheduleSlotSearchOrderRecord)\n                - the schedule slot search order record", 
               "error_doc": "        raise:  NullArgument - ``schedule_slot_record_type`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unsupported -\n                ``has_record_type(schedule_slot_record_type)`` is\n                ``false``", 
               "sphinx_param_doc": "        :param schedule_slot_record_type: a schedule slot record type\n        :type schedule_slot_record_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "        :return: the schedule slot search order record\n        :rtype: ``osid.calendaring.records.ScheduleSlotSearchOrderRecord``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``schedule_slot_record_type`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unsupported`` -- ``has_record_type(schedule_slot_record_type)`` is ``false``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "schedule_slot_record_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "osid.calendaring.records.ScheduleSlotSearchOrderRecord", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.calendaring.records.ScheduleSlotSearchOrderRecord", 
         "shortname": "ScheduleSlotSearchOrderRecord", 
         "category": "records", 
         "doc": {
            "headline": "A record for a ``ScheduleSlotSearchOrder``.", 
            "body": "    The methods specified by the record type are available through the\n    underlying object."
         }, 
         "inherit_fullnames": [
            "osid.OsidRecord"
         ], 
         "inherit_shortnames": [
            "OsidRecord"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidRecord"
            }
         ], 
         "method_names": [], 
         "methods": []
      }, 
      {
         "fullname": "osid.calendaring.ScheduleSlotSearch", 
         "shortname": "ScheduleSlotSearch", 
         "category": "searches", 
         "doc": {
            "headline": "``ScheduleSlotSearch`` defines the interface for specifying schedule slot search options.", 
            "body": ""
         }, 
         "inherit_fullnames": [
            "osid.OsidSearch"
         ], 
         "inherit_shortnames": [
            "OsidSearch"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidSearch"
            }
         ], 
         "method_names": [
            "search_among_schedule_slots", 
            "order_schedule_slot_results", 
            "get_schedule_slot_search_record"
         ], 
         "methods": [
            {
               "name": "search_among_schedule_slots", 
               "doc": {
                  "headline": "Execute this search among the given list of schedule slots.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    schedule_slot_ids (osid.id.IdList): list of schedule\n                slots\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``schedule_slot_ids`` is ``null``", 
               "sphinx_param_doc": "        :param schedule_slot_ids: list of schedule slots\n        :type schedule_slot_ids: ``osid.id.IdList``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``schedule_slot_ids`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.IdList", 
                     "var_name": "schedule_slot_ids", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.IdList"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "order_schedule_slot_results", 
               "doc": {
                  "headline": "Specify an ordering to the search results.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    schedule_slot_search_order\n                (osid.calendaring.ScheduleSlotSearchOrder): schedule\n                slot search order\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``schedule_slot_search_order`` is\n                ``null``\n        raise:  Unsupported - ``schedule_slot_search_order`` is not of\n                this service", 
               "sphinx_param_doc": "        :param schedule_slot_search_order: schedule slot search order\n        :type schedule_slot_search_order: ``osid.calendaring.ScheduleSlotSearchOrder``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``schedule_slot_search_order`` is ``null``\n        :raise: ``Unsupported`` -- ``schedule_slot_search_order`` is not of this service", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.calendaring.ScheduleSlotSearchOrder", 
                     "var_name": "schedule_slot_search_order", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.calendaring.ScheduleSlotSearchOrder"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_schedule_slot_search_record", 
               "doc": {
                  "headline": "Gets the schedule slot search record corresponding to the given schedule slot search record ``Type``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    schedule_slot_search_record_type (osid.type.Type): a\n                schedule slot search record type\n", 
               "return_doc": "        return: (osid.calendaring.records.ScheduleSlotSearchRecord) -\n                the schedule slot search record", 
               "error_doc": "        raise:  NullArgument - ``schedule_slot_search_record_type`` is\n                ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unsupported -\n                ``has_record_type(schedule_slot_search_record_type)`` is\n                ``false``", 
               "sphinx_param_doc": "        :param schedule_slot_search_record_type: a schedule slot search record type\n        :type schedule_slot_search_record_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "        :return: the schedule slot search record\n        :rtype: ``osid.calendaring.records.ScheduleSlotSearchRecord``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``schedule_slot_search_record_type`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unsupported`` -- ``has_record_type(schedule_slot_search_record_type)`` is ``false``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "schedule_slot_search_record_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "osid.calendaring.records.ScheduleSlotSearchRecord", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.calendaring.records.ScheduleSlotSearchRecord", 
         "shortname": "ScheduleSlotSearchRecord", 
         "category": "records", 
         "doc": {
            "headline": "A record for a ``ScheduleSlotSearch``.", 
            "body": "    The methods specified by the record type are available through the\n    underlying object."
         }, 
         "inherit_fullnames": [
            "osid.OsidRecord"
         ], 
         "inherit_shortnames": [
            "OsidRecord"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidRecord"
            }
         ], 
         "method_names": [], 
         "methods": []
      }, 
      {
         "fullname": "osid.calendaring.ScheduleSlotSearchResults", 
         "shortname": "ScheduleSlotSearchResults", 
         "category": "searches", 
         "doc": {
            "headline": "This interface provides a means to capture results of a search.", 
            "body": ""
         }, 
         "inherit_fullnames": [
            "osid.OsidSearchResults"
         ], 
         "inherit_shortnames": [
            "OsidSearchResults"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidSearchResults"
            }
         ], 
         "method_names": [
            "get_schedule_slots", 
            "get_schedule_slot_query_inspector", 
            "get_schedule_slot_search_results_record"
         ], 
         "methods": [
            {
               "name": "get_schedule_slots", 
               "doc": {
                  "headline": "Gets the schedule list resulting from the search.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.ScheduleSlotList) - the schedule slot\n                list", 
               "error_doc": "        raise:  IllegalState - list already retrieved", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the schedule slot list\n        :rtype: ``osid.calendaring.ScheduleSlotList``", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- list already retrieved", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.ScheduleSlotList", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract"
               }
            }, 
            {
               "name": "get_schedule_slot_query_inspector", 
               "doc": {
                  "headline": "Gets the inspector for the query to examine the terms used in the search.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.ScheduleSlotQueryInspector) - the\n                query inspector", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the query inspector\n        :rtype: ``osid.calendaring.ScheduleSlotQueryInspector``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.ScheduleSlotQueryInspector", 
               "errors": {}
            }, 
            {
               "name": "get_schedule_slot_search_results_record", 
               "doc": {
                  "headline": "Gets the schedule slot record corresponding to the given schedule slot search record ``Type``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    schedule_slot_search_record_type (osid.type.Type): a\n                schedule slot search record type\n", 
               "return_doc": "        return:\n                (osid.calendaring.records.ScheduleSlotSearchResultsRecor\n                d) - the schedule slot search results record", 
               "error_doc": "        raise:  NullArgument - ``schedule_slot_search_record_type`` is\n                ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unsupported -\n                ``has_record_type(schedule_slot_search_record_type)`` is\n                ``false``", 
               "sphinx_param_doc": "        :param schedule_slot_search_record_type: a schedule slot search record type\n        :type schedule_slot_search_record_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "        :return: the schedule slot search results record\n        :rtype: ``osid.calendaring.records.ScheduleSlotSearchResultsRecord``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``schedule_slot_search_record_type`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unsupported`` -- ``has_record_type(schedule_slot_search_record_type)`` is ``false``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "schedule_slot_search_record_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "osid.calendaring.records.ScheduleSlotSearchResultsRecord", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.calendaring.records.ScheduleSlotSearchResultsRecord", 
         "shortname": "ScheduleSlotSearchResultsRecord", 
         "category": "records", 
         "doc": {
            "headline": "A record for a ``ScheduleSlotSearchResults``.", 
            "body": "    The methods specified by the record type are available through the\n    underlying object."
         }, 
         "inherit_fullnames": [
            "osid.OsidRecord"
         ], 
         "inherit_shortnames": [
            "OsidRecord"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidRecord"
            }
         ], 
         "method_names": [], 
         "methods": []
      }, 
      {
         "fullname": "osid.calendaring.ScheduleSlotReceiver", 
         "shortname": "ScheduleSlotReceiver", 
         "category": "receivers", 
         "doc": {
            "headline": "The schedule slot receiver is the consumer supplied interface for receiving notifications pertaining to new, updated or deleted ``ScheduleSlots``.", 
            "body": ""
         }, 
         "inherit_fullnames": [
            "osid.OsidReceiver"
         ], 
         "inherit_shortnames": [
            "OsidReceiver"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidReceiver"
            }
         ], 
         "method_names": [
            "new_schedule_slot", 
            "new_schedule_slot_ancestor", 
            "new_schedule_slot_descendant", 
            "changed_schedule_slot", 
            "deleted_schedule_slot", 
            "deleted_schedule_slot_descendant", 
            "deleted_schedule_slot_ancestor"
         ], 
         "methods": [
            {
               "name": "new_schedule_slot", 
               "doc": {
                  "headline": "The callback for notifications of new schedule slots.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    schedule_slot_id (osid.id.Id): the ``Id`` of the new\n                ``ScheduleSlot``\n", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "        :param schedule_slot_id: the ``Id`` of the new ``ScheduleSlot``\n        :type schedule_slot_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "schedule_slot_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "new_schedule_slot_ancestor", 
               "doc": {
                  "headline": "The callback for notifications of new schedule slot ancestors.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    schedule_slot_id (osid.id.Id): the ``Id`` of the\n                ``ScheduleSlot``\n        arg:    ancestor_id (osid.id.Id): the ``Id`` of the new\n                ``ScheduleSlot`` ancestor\n", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "        :param schedule_slot_id: the ``Id`` of the ``ScheduleSlot``\n        :type schedule_slot_id: ``osid.id.Id``\n        :param ancestor_id: the ``Id`` of the new ``ScheduleSlot`` ancestor\n        :type ancestor_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "schedule_slot_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "ancestor_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "new_schedule_slot_descendant", 
               "doc": {
                  "headline": "The callback for notifications of new schedule slot descendants.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    schedule_slot_id (osid.id.Id): the ``Id`` of the\n                ``ScheduleSlot``\n        arg:    descendant_id (osid.id.Id): the ``Id`` of the new\n                ``ScheduleSlot`` descendant\n", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "        :param schedule_slot_id: the ``Id`` of the ``ScheduleSlot``\n        :type schedule_slot_id: ``osid.id.Id``\n        :param descendant_id: the ``Id`` of the new ``ScheduleSlot`` descendant\n        :type descendant_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "schedule_slot_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "descendant_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "changed_schedule_slot", 
               "doc": {
                  "headline": "The callback for notification of updated schedule slots.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    schedule_slot_id (osid.id.Id): the ``Id`` of the updated\n                ``ScheduleSlot``\n", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "        :param schedule_slot_id: the ``Id`` of the updated ``ScheduleSlot``\n        :type schedule_slot_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "schedule_slot_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "deleted_schedule_slot", 
               "doc": {
                  "headline": "The callback for notification of deleted schedule slots.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    schedule_slot_id (osid.id.Id): the ``Id`` of the deleted\n                ``ScheduleSlot``\n", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "        :param schedule_slot_id: the ``Id`` of the deleted ``ScheduleSlot``\n        :type schedule_slot_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "schedule_slot_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "deleted_schedule_slot_descendant", 
               "doc": {
                  "headline": "The callback for notifications of deleted schedule slot descendants.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    schedule_slot_id (osid.id.Id): the ``Id`` of the\n                ``ScheduleSlot``\n        arg:    ancestor_id (osid.id.Id): the ``Id`` of the removed\n                ``ScheduleSlot`` descendant\n", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "        :param schedule_slot_id: the ``Id`` of the ``ScheduleSlot``\n        :type schedule_slot_id: ``osid.id.Id``\n        :param ancestor_id: the ``Id`` of the removed ``ScheduleSlot`` descendant\n        :type ancestor_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "schedule_slot_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "ancestor_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "deleted_schedule_slot_ancestor", 
               "doc": {
                  "headline": "The callback for notifications of deleted schedule slot ancestors.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    schedule_slot_id (osid.id.Id): the ``Id`` of the\n                ``ScheduleSlot``\n        arg:    descendant_id (osid.id.Id): the ``Id`` of the removed\n                ``ScheduleSlot`` ancestor\n", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "        :param schedule_slot_id: the ``Id`` of the ``ScheduleSlot``\n        :type schedule_slot_id: ``osid.id.Id``\n        :param descendant_id: the ``Id`` of the removed ``ScheduleSlot`` ancestor\n        :type descendant_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "schedule_slot_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "descendant_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {}
            }
         ]
      }, 
      {
         "fullname": "osid.calendaring.ScheduleSlotList", 
         "shortname": "ScheduleSlotList", 
         "category": "objects", 
         "doc": {
            "headline": "Like all ``OsidLists,``  ``ScheduleSlotList`` provides a means for accessing ``ScheduleSlot`` elements sequentially either one at a time or many at a time.", 
            "body": "    Examples: while (ssl.hasNext()) { ScheduleSlot slot =\n    ssl.getNextSchedulSlote(); }\n\n    or\n      while (ssl.hasNext()) {\n           ScheduleSlot[] slots = ssl.getNextScheduleSlots(ssl.available());\n      }\n    \n"
         }, 
         "inherit_fullnames": [
            "osid.OsidList"
         ], 
         "inherit_shortnames": [
            "OsidList"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidList"
            }
         ], 
         "method_names": [
            "get_next_schedule_slot", 
            "get_next_schedule_slots"
         ], 
         "methods": [
            {
               "name": "get_next_schedule_slot", 
               "doc": {
                  "headline": "Gets the next ``ScheduleSlot`` in this list.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.ScheduleSlot) - the next\n                ``ScheduleSlot`` in this list. The ``has_next()`` method\n                should be used to test that a next ``ScheduleSlot`` is\n                available before calling this method.", 
               "error_doc": "        raise:  IllegalState - no more elements available in this list\n        raise:  OperationFailed - unable to complete request", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the next ``ScheduleSlot`` in this list. The ``has_next()`` method should be used to test that a next ``ScheduleSlot`` is available before calling this method.\n        :rtype: ``osid.calendaring.ScheduleSlot``", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- no more elements available in this list\n        :raise: ``OperationFailed`` -- unable to complete request", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.ScheduleSlot", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational"
               }
            }, 
            {
               "name": "get_next_schedule_slots", 
               "doc": {
                  "headline": "Gets the next set of ``ScheduleSlot`` elements in this list which must be less than or equal to the number returned from ``available()``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    n (cardinal): the number of ``ScheduleSlot`` elements\n                requested which should be less than or equal to\n                ``available()``\n", 
               "return_doc": "        return: (osid.calendaring.ScheduleSlot) - an array of\n                ``ScheduleSlot`` elements.The length of the array is\n                less than or equal to the number specified.", 
               "error_doc": "        raise:  IllegalState - no more elements available in this list\n        raise:  OperationFailed - unable to complete request", 
               "sphinx_param_doc": "        :param n: the number of ``ScheduleSlot`` elements requested which should be less than or equal to ``available()``\n        :type n: ``cardinal``\n", 
               "sphinx_return_doc": "        :return: an array of ``ScheduleSlot`` elements.The length of the array is less than or equal to the number specified.\n        :rtype: ``osid.calendaring.ScheduleSlot``", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- no more elements available in this list\n        :raise: ``OperationFailed`` -- unable to complete request", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "cardinal", 
                     "var_name": "n", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "cardinal"
               ], 
               "return_type": "osid.calendaring.ScheduleSlot", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.calendaring.TimePeriod", 
         "shortname": "TimePeriod", 
         "category": "objects", 
         "doc": {
            "headline": "A ``TimePeriod`` represents a span of time in which recurring events are expanded.", 
            "body": ""
         }, 
         "inherit_fullnames": [
            "osid.OsidObject"
         ], 
         "inherit_shortnames": [
            "OsidObject"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidObject"
            }
         ], 
         "method_names": [
            "get_start", 
            "get_end", 
            "get_exception_ids", 
            "get_exceptions", 
            "get_time_period_record"
         ], 
         "methods": [
            {
               "name": "get_start", 
               "doc": {
                  "headline": "Gets the start time of the time period.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.DateTime) - the start time", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the start time\n        :rtype: ``osid.calendaring.DateTime``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.DateTime", 
               "errors": {}
            }, 
            {
               "name": "get_end", 
               "doc": {
                  "headline": "Gets the end time of the time period.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.DateTime) - the end time", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the end time\n        :rtype: ``osid.calendaring.DateTime``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.DateTime", 
               "errors": {}
            }, 
            {
               "name": "get_exception_ids", 
               "doc": {
                  "headline": "Gets the exception ``Ids`` to this time period.", 
                  "body": "        Recurring events overlapping with these events do not appear in\n        any recurring event for this time period."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.id.IdList) - list of exception event ``Ids``", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: list of exception event ``Ids``\n        :rtype: ``osid.id.IdList``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.id.IdList", 
               "errors": {}
            }, 
            {
               "name": "get_exceptions", 
               "doc": {
                  "headline": "Gets the exceptions to this time period.", 
                  "body": "        Recurring events overlapping with these events do not appear in\n        any recurring event for this time period."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.EventList) - event exceptions", 
               "error_doc": "        raise:  OperationFailed - unable to complete request", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: event exceptions\n        :rtype: ``osid.calendaring.EventList``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.EventList", 
               "errors": {
                  "OPERATION_FAILED": "Operational"
               }
            }, 
            {
               "name": "get_time_period_record", 
               "doc": {
                  "headline": "Gets the time period record corresponding to the given ``TimePeriod`` record ``Type``.", 
                  "body": "        This method is used to retrieve an object implementing the\n        requested record. The ``time_period_record_type`` may be the\n        ``Type`` returned in ``get_record_types()`` or any of its\n        parents in a ``Type`` hierarchy where\n        ``has_record_type(time_period_record_type)`` is ``true`` ."
               }, 
               "arg_doc": "        arg:    time_period_record_type (osid.type.Type): the type of\n                the record to retrieve\n", 
               "return_doc": "        return: (osid.calendaring.records.TimePeriodRecord) - the time\n                period record", 
               "error_doc": "        raise:  NullArgument - ``time_period_record_type`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unsupported -\n                ``has_record_type(time_period_record_type)`` is\n                ``false``", 
               "sphinx_param_doc": "        :param time_period_record_type: the type of the record to retrieve\n        :type time_period_record_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "        :return: the time period record\n        :rtype: ``osid.calendaring.records.TimePeriodRecord``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``time_period_record_type`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unsupported`` -- ``has_record_type(time_period_record_type)`` is ``false``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "time_period_record_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "osid.calendaring.records.TimePeriodRecord", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.calendaring.records.TimePeriodRecord", 
         "shortname": "TimePeriodRecord", 
         "category": "records", 
         "doc": {
            "headline": "A record for a ``TimePeriod``.", 
            "body": "    The methods specified by the record type are available through the\n    underlying object."
         }, 
         "inherit_fullnames": [
            "osid.OsidRecord"
         ], 
         "inherit_shortnames": [
            "OsidRecord"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidRecord"
            }
         ], 
         "method_names": [], 
         "methods": []
      }, 
      {
         "fullname": "osid.calendaring.TimePeriodQuery", 
         "shortname": "TimePeriodQuery", 
         "category": "queries", 
         "doc": {
            "headline": "This is the query for searching time periods.", 
            "body": "    Each method match request produces an ``AND`` term while multiple\n    invocations of a method produces a nested ``OR``."
         }, 
         "inherit_fullnames": [
            "osid.OsidObjectQuery"
         ], 
         "inherit_shortnames": [
            "OsidObjectQuery"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidObjectQuery"
            }
         ], 
         "method_names": [
            "match_start", 
            "match_any_start", 
            "clear_start_terms", 
            "match_end", 
            "match_any_end", 
            "clear_end_terms", 
            "match_time", 
            "match_any_time", 
            "clear_time_terms", 
            "match_time_inclusive", 
            "clear_time_inclusive_terms", 
            "match_duration", 
            "clear_duration_terms", 
            "match_exception_id", 
            "clear_exception_id_terms", 
            "supports_exception_query", 
            "get_exception_query", 
            "match_any_exception", 
            "clear_exception_terms", 
            "match_event_id", 
            "clear_event_id_terms", 
            "supports_event_query", 
            "get_event_query", 
            "match_any_event", 
            "clear_event_terms", 
            "match_calendar_id", 
            "clear_calendar_id_terms", 
            "supports_calendar_query", 
            "get_calendar_query", 
            "clear_calendar_terms", 
            "get_time_period_query_record"
         ], 
         "methods": [
            {
               "name": "match_start", 
               "doc": {
                  "headline": "Matches the time period start time between the given range inclusive.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    low (osid.calendaring.DateTime): low time range\n        arg:    high (osid.calendaring.DateTime): high time range\n        arg:    match (boolean): ``true`` for a positive match,\n                ``false`` for a negative match\n", 
               "return_doc": "", 
               "error_doc": "        raise:  InvalidArgument - ``high`` is less than ``low``\n        raise:  NullArgument - ``high`` or ``low`` is ``zero``", 
               "sphinx_param_doc": "        :param low: low time range\n        :type low: ``osid.calendaring.DateTime``\n        :param high: high time range\n        :type high: ``osid.calendaring.DateTime``\n        :param match: ``true`` for a positive match, ``false`` for a negative match\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``InvalidArgument`` -- ``high`` is less than ``low``\n        :raise: ``NullArgument`` -- ``high`` or ``low`` is ``zero``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.calendaring.DateTime", 
                     "var_name": "low", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.calendaring.DateTime", 
                     "var_name": "high", 
                     "array": false
                  }, 
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.calendaring.DateTime", 
                  "osid.calendaring.DateTime", 
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {
                  "INVALID_ARGUMENT": "ConsumerContract", 
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "match_any_start", 
               "doc": {
                  "headline": "Matches a time period that has any start time assigned.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    match (boolean): ``true`` to match time periods with any\n                start time, ``false`` to match time periods with no\n                start time\n", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "        :param match: ``true`` to match time periods with any start time, ``false`` to match time periods with no start time\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "clear_start_terms", 
               "doc": {
                  "headline": "Clears the time period start terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "match_end", 
               "doc": {
                  "headline": "Matches the time period end time between the given range inclusive.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    low (osid.calendaring.DateTime): low time range\n        arg:    high (osid.calendaring.DateTime): high time range\n        arg:    match (boolean): ``true`` for a positive match,\n                ``false`` for a negative match\n", 
               "return_doc": "", 
               "error_doc": "        raise:  InvalidArgument - ``high`` is less than ``low``\n        raise:  NullArgument - ``high`` or ``low`` is ``zero``", 
               "sphinx_param_doc": "        :param low: low time range\n        :type low: ``osid.calendaring.DateTime``\n        :param high: high time range\n        :type high: ``osid.calendaring.DateTime``\n        :param match: ``true`` for a positive match, ``false`` for a negative match\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``InvalidArgument`` -- ``high`` is less than ``low``\n        :raise: ``NullArgument`` -- ``high`` or ``low`` is ``zero``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.calendaring.DateTime", 
                     "var_name": "low", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.calendaring.DateTime", 
                     "var_name": "high", 
                     "array": false
                  }, 
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.calendaring.DateTime", 
                  "osid.calendaring.DateTime", 
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {
                  "INVALID_ARGUMENT": "ConsumerContract", 
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "match_any_end", 
               "doc": {
                  "headline": "Matches a time period that has any end time assigned.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    match (boolean): ``true`` to match time periods with any\n                end time, ``false`` to match time periods with no end\n                time\n", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "        :param match: ``true`` to match time periods with any end time, ``false`` to match time periods with no end time\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "clear_end_terms", 
               "doc": {
                  "headline": "Clears the time period end terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "match_time", 
               "doc": {
                  "headline": "Matches time periods that include the given time.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    time (osid.calendaring.DateTime): date\n        arg:    match (boolean): ``true`` for a positive match,\n                ``false`` for a negative match\n", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "        :param time: date\n        :type time: ``osid.calendaring.DateTime``\n        :param match: ``true`` for a positive match, ``false`` for a negative match\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.calendaring.DateTime", 
                     "var_name": "time", 
                     "array": false
                  }, 
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.calendaring.DateTime", 
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "match_any_time", 
               "doc": {
                  "headline": "Matches a time period that has any time assigned.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    match (boolean): ``true`` to match time periods with any\n                time, ``false`` to match time periods with no time\n", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "        :param match: ``true`` to match time periods with any time, ``false`` to match time periods with no time\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "clear_time_terms", 
               "doc": {
                  "headline": "Clears the time terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "match_time_inclusive", 
               "doc": {
                  "headline": "Matches time periods with start and end times between the given range inclusive.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    start (osid.calendaring.DateTime): start date\n        arg:    end (osid.calendaring.DateTime): end date\n        arg:    match (boolean): ``true`` for a positive match,\n                ``false`` for a negative match\n", 
               "return_doc": "", 
               "error_doc": "        raise:  InvalidArgument - ``end`` is less than ``start``\n        raise:  NullArgument - ``start`` or ``end`` is ``zero``", 
               "sphinx_param_doc": "        :param start: start date\n        :type start: ``osid.calendaring.DateTime``\n        :param end: end date\n        :type end: ``osid.calendaring.DateTime``\n        :param match: ``true`` for a positive match, ``false`` for a negative match\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``InvalidArgument`` -- ``end`` is less than ``start``\n        :raise: ``NullArgument`` -- ``start`` or ``end`` is ``zero``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.calendaring.DateTime", 
                     "var_name": "start", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.calendaring.DateTime", 
                     "var_name": "end", 
                     "array": false
                  }, 
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.calendaring.DateTime", 
                  "osid.calendaring.DateTime", 
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {
                  "INVALID_ARGUMENT": "ConsumerContract", 
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "clear_time_inclusive_terms", 
               "doc": {
                  "headline": "Clears the time inclusive terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "match_duration", 
               "doc": {
                  "headline": "Matches the time period duration between the given range inclusive.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    low (osid.calendaring.Duration): low duration range\n        arg:    high (osid.calendaring.Duration): high duration range\n        arg:    match (boolean): ``true`` for a positive match,\n                ``false`` for a negative match\n", 
               "return_doc": "", 
               "error_doc": "        raise:  InvalidArgument - ``high`` is less than ``low``\n        raise:  NullArgument - ``high`` or ``low`` is ``null``", 
               "sphinx_param_doc": "        :param low: low duration range\n        :type low: ``osid.calendaring.Duration``\n        :param high: high duration range\n        :type high: ``osid.calendaring.Duration``\n        :param match: ``true`` for a positive match, ``false`` for a negative match\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``InvalidArgument`` -- ``high`` is less than ``low``\n        :raise: ``NullArgument`` -- ``high`` or ``low`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.calendaring.Duration", 
                     "var_name": "low", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.calendaring.Duration", 
                     "var_name": "high", 
                     "array": false
                  }, 
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.calendaring.Duration", 
                  "osid.calendaring.Duration", 
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {
                  "INVALID_ARGUMENT": "ConsumerContract", 
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "clear_duration_terms", 
               "doc": {
                  "headline": "Clears the duration terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "match_exception_id", 
               "doc": {
                  "headline": "Sets the event ``Id`` for this query to match exceptions.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    event_id (osid.id.Id): an exception event ``Id``\n        arg:    match (boolean): ``true`` for a positive match,\n                ``false`` for a negative match\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``event_id`` is ``null``", 
               "sphinx_param_doc": "        :param event_id: an exception event ``Id``\n        :type event_id: ``osid.id.Id``\n        :param match: ``true`` for a positive match, ``false`` for a negative match\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``event_id`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "event_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "clear_exception_id_terms", 
               "doc": {
                  "headline": "Clears the exception event ``Id`` terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "supports_exception_query", 
               "doc": {
                  "headline": "Tests if an ``EventQuery`` is available for querying exception events.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if a exception query is available,\n                ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if a exception query is available, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "get_exception_query", 
               "doc": {
                  "headline": "Gets the query for an exception event.", 
                  "body": "        Multiple retrievals produce a nested ``OR`` term."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.EventQuery) - the event query", 
               "error_doc": "        raise:  Unimplemented - ``supports_exception_query()`` is\n                ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the event query\n        :rtype: ``osid.calendaring.EventQuery``", 
               "sphinx_error_doc": "        :raise: ``Unimplemented`` -- ``supports_exception_query()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_exception_query()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.EventQuery", 
               "errors": {
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "match_any_exception", 
               "doc": {
                  "headline": "Matches a time period that has any exception event assigned.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    match (boolean): ``true`` to match time periods with any\n                exception, ``false`` to match time periods with no\n                exception\n", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "        :param match: ``true`` to match time periods with any exception, ``false`` to match time periods with no exception\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "clear_exception_terms", 
               "doc": {
                  "headline": "Clears the exception event terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "match_event_id", 
               "doc": {
                  "headline": "Sets the event ``Id`` for this query.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    event_id (osid.id.Id): an event or recurring event\n                ``Id``\n        arg:    match (boolean): ``true`` for a positive match,\n                ``false`` for a negative match\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``event_id`` is ``null``", 
               "sphinx_param_doc": "        :param event_id: an event or recurring event ``Id``\n        :type event_id: ``osid.id.Id``\n        :param match: ``true`` for a positive match, ``false`` for a negative match\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``event_id`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "event_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "clear_event_id_terms", 
               "doc": {
                  "headline": "Clears the event ``Id`` terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "supports_event_query", 
               "doc": {
                  "headline": "Tests if an ``EventQuery`` is available for querying events.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if an event query is available,\n                ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if an event query is available, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "get_event_query", 
               "doc": {
                  "headline": "Gets the query for an event or recurring event.", 
                  "body": "        Multiple retrievals produce a nested ``OR`` term."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.EventQuery) - the event query", 
               "error_doc": "        raise:  Unimplemented - ``supports_event_query()`` is ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the event query\n        :rtype: ``osid.calendaring.EventQuery``", 
               "sphinx_error_doc": "        :raise: ``Unimplemented`` -- ``supports_event_query()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_event_query()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.EventQuery", 
               "errors": {
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "match_any_event", 
               "doc": {
                  "headline": "Matches a time period that has any event assigned.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    match (boolean): ``true`` to match time periods with any\n                event, ``false`` to match time periods with no events\n", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "        :param match: ``true`` to match time periods with any event, ``false`` to match time periods with no events\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "clear_event_terms", 
               "doc": {
                  "headline": "Clears the event terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "match_calendar_id", 
               "doc": {
                  "headline": "Sets the calendar ``Id`` for this query.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    calendar_id (osid.id.Id): a calendar ``Id``\n        arg:    match (boolean): ``true`` for a positive match,\n                ``false`` for a negative match\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``calendar_id`` is ``null``", 
               "sphinx_param_doc": "        :param calendar_id: a calendar ``Id``\n        :type calendar_id: ``osid.id.Id``\n        :param match: ``true`` for a positive match, ``false`` for a negative match\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``calendar_id`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "calendar_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "clear_calendar_id_terms", 
               "doc": {
                  "headline": "Clears the calendar ``Id`` terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "supports_calendar_query", 
               "doc": {
                  "headline": "Tests if a ``CalendarQuery`` is available for querying resources.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if a calendar query is available,\n                ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if a calendar query is available, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "get_calendar_query", 
               "doc": {
                  "headline": "Gets the query for a calendar.", 
                  "body": "        Multiple retrievals produce a nested ``OR`` term."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.CalendarQuery) - the calendar query", 
               "error_doc": "        raise:  Unimplemented - ``supports_calendar_query()`` is\n                ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the calendar query\n        :rtype: ``osid.calendaring.CalendarQuery``", 
               "sphinx_error_doc": "        :raise: ``Unimplemented`` -- ``supports_calendar_query()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_calendar_query()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.CalendarQuery", 
               "errors": {
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "clear_calendar_terms", 
               "doc": {
                  "headline": "Clears the calendar terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "get_time_period_query_record", 
               "doc": {
                  "headline": "Gets the time period query record corresponding to the given ``TimePeriod`` record ``Type``.", 
                  "body": "        Multiple retrievals produce a nested ``OR`` term."
               }, 
               "arg_doc": "        arg:    time_period_record_type (osid.type.Type): a time period\n                query record type\n", 
               "return_doc": "        return: (osid.calendaring.records.TimePeriodQueryRecord) - the\n                time period query record", 
               "error_doc": "        raise:  NullArgument - ``time_period_record_type`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unsupported -\n                ``has_record_type(time_period_record_type)`` is\n                ``false``", 
               "sphinx_param_doc": "        :param time_period_record_type: a time period query record type\n        :type time_period_record_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "        :return: the time period query record\n        :rtype: ``osid.calendaring.records.TimePeriodQueryRecord``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``time_period_record_type`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unsupported`` -- ``has_record_type(time_period_record_type)`` is ``false``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "time_period_record_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "osid.calendaring.records.TimePeriodQueryRecord", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.calendaring.records.TimePeriodQueryRecord", 
         "shortname": "TimePeriodQueryRecord", 
         "category": "records", 
         "doc": {
            "headline": "A record for a ``TimePeriodQuery``.", 
            "body": "    The methods specified by the record type are available through the\n    underlying object."
         }, 
         "inherit_fullnames": [
            "osid.OsidRecord"
         ], 
         "inherit_shortnames": [
            "OsidRecord"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidRecord"
            }
         ], 
         "method_names": [], 
         "methods": []
      }, 
      {
         "fullname": "osid.calendaring.TimePeriodQueryInspector", 
         "shortname": "TimePeriodQueryInspector", 
         "category": "query_inspectors", 
         "doc": {
            "headline": "This is the query inspector for examining time period queries.", 
            "body": ""
         }, 
         "inherit_fullnames": [
            "osid.OsidObjectQueryInspector"
         ], 
         "inherit_shortnames": [
            "OsidObjectQueryInspector"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidObjectQueryInspector"
            }
         ], 
         "method_names": [
            "get_start_terms", 
            "get_end_terms", 
            "get_time_terms", 
            "get_time_inclusive_terms", 
            "get_duration_terms", 
            "get_exception_id_terms", 
            "get_exception_terms", 
            "get_event_id_terms", 
            "get_event_terms", 
            "get_calendar_id_terms", 
            "get_calendar_terms", 
            "get_time_period_query_inspector_record"
         ], 
         "methods": [
            {
               "name": "get_start_terms", 
               "doc": {
                  "headline": "Gets the start terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.search.terms.DateTimeTerm) - the start terms", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the start terms\n        :rtype: ``osid.search.terms.DateTimeTerm``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.search.terms.DateTimeTerm", 
               "errors": {}
            }, 
            {
               "name": "get_end_terms", 
               "doc": {
                  "headline": "Gets the end terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.search.terms.DateTimeTerm) - the end terms", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the end terms\n        :rtype: ``osid.search.terms.DateTimeTerm``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.search.terms.DateTimeTerm", 
               "errors": {}
            }, 
            {
               "name": "get_time_terms", 
               "doc": {
                  "headline": "Gets the time terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.search.terms.DateTimeTerm) - the time terms", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the time terms\n        :rtype: ``osid.search.terms.DateTimeTerm``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.search.terms.DateTimeTerm", 
               "errors": {}
            }, 
            {
               "name": "get_time_inclusive_terms", 
               "doc": {
                  "headline": "Gets the inclusive time terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.search.terms.DateTimeRangeTerm) - the time range\n                terms", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the time range terms\n        :rtype: ``osid.search.terms.DateTimeRangeTerm``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.search.terms.DateTimeRangeTerm", 
               "errors": {}
            }, 
            {
               "name": "get_duration_terms", 
               "doc": {
                  "headline": "Gets the duration terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.search.terms.DurationTerm) - the duration terms", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the duration terms\n        :rtype: ``osid.search.terms.DurationTerm``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.search.terms.DurationTerm", 
               "errors": {}
            }, 
            {
               "name": "get_exception_id_terms", 
               "doc": {
                  "headline": "Gets the exception event ``Id`` terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.search.terms.IdTerm) - the exception event ``Id``\n                terms", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the exception event ``Id`` terms\n        :rtype: ``osid.search.terms.IdTerm``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.search.terms.IdTerm", 
               "errors": {}
            }, 
            {
               "name": "get_exception_terms", 
               "doc": {
                  "headline": "Gets the exception event terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.EventQueryInspector) - the exception\n                event terms", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the exception event terms\n        :rtype: ``osid.calendaring.EventQueryInspector``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.EventQueryInspector", 
               "errors": {}
            }, 
            {
               "name": "get_event_id_terms", 
               "doc": {
                  "headline": "Gets the event ``Id`` terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.search.terms.IdTerm) - the event ``Id`` terms", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the event ``Id`` terms\n        :rtype: ``osid.search.terms.IdTerm``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.search.terms.IdTerm", 
               "errors": {}
            }, 
            {
               "name": "get_event_terms", 
               "doc": {
                  "headline": "Gets the event terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.EventQueryInspector) - the event terms", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the event terms\n        :rtype: ``osid.calendaring.EventQueryInspector``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.EventQueryInspector", 
               "errors": {}
            }, 
            {
               "name": "get_calendar_id_terms", 
               "doc": {
                  "headline": "Gets the calendar ``Id`` terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.search.terms.IdTerm) - the calendar ``Id`` terms", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the calendar ``Id`` terms\n        :rtype: ``osid.search.terms.IdTerm``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.search.terms.IdTerm", 
               "errors": {}
            }, 
            {
               "name": "get_calendar_terms", 
               "doc": {
                  "headline": "Gets the calendar terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.CalendarQueryInspector) - the calendar\n                terms", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the calendar terms\n        :rtype: ``osid.calendaring.CalendarQueryInspector``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.CalendarQueryInspector", 
               "errors": {}
            }, 
            {
               "name": "get_time_period_query_inspector_record", 
               "doc": {
                  "headline": "Gets the time period query record interface corresponding to the given ``TimePeriod`` record ``Type``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    time_period_record_type (osid.type.Type): a time period\n                query record type\n", 
               "return_doc": "        return:\n                (osid.calendaring.records.TimePeriodQueryInspectorRecord\n                ) - the time period query inspector record", 
               "error_doc": "        raise:  NullArgument - ``time_period_record_type`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unsupported -\n                ``has_record_type(time_period_record_type)`` is\n                ``false``", 
               "sphinx_param_doc": "        :param time_period_record_type: a time period query record type\n        :type time_period_record_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "        :return: the time period query inspector record\n        :rtype: ``osid.calendaring.records.TimePeriodQueryInspectorRecord``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``time_period_record_type`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unsupported`` -- ``has_record_type(time_period_record_type)`` is ``false``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "time_period_record_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "osid.calendaring.records.TimePeriodQueryInspectorRecord", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.calendaring.records.TimePeriodQueryInspectorRecord", 
         "shortname": "TimePeriodQueryInspectorRecord", 
         "category": "records", 
         "doc": {
            "headline": "A record for a ``TimePeriodQueryInspector``.", 
            "body": "    The methods specified by the record type are available through the\n    underlying object."
         }, 
         "inherit_fullnames": [
            "osid.OsidRecord"
         ], 
         "inherit_shortnames": [
            "OsidRecord"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidRecord"
            }
         ], 
         "method_names": [], 
         "methods": []
      }, 
      {
         "fullname": "osid.calendaring.TimePeriodForm", 
         "shortname": "TimePeriodForm", 
         "category": "objects", 
         "doc": {
            "headline": "This is the form for creating and updating ``TimePeriods``.", 
            "body": "    Like all ``OsidForm`` objects, various data elements may be set here\n    for use in the create and update methods in the\n    ``TimePeriodAdminSession``. For each data element that may be set,\n    metadata may be examined to provide display hints or data\n    constraints."
         }, 
         "inherit_fullnames": [
            "osid.OsidObjectForm"
         ], 
         "inherit_shortnames": [
            "OsidObjectForm"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidObjectForm"
            }
         ], 
         "method_names": [
            "get_start_metadata", 
            "set_start", 
            "clear_start", 
            "get_end_metadata", 
            "set_end", 
            "clear_end", 
            "get_time_period_form_record"
         ], 
         "methods": [
            {
               "name": "get_start_metadata", 
               "doc": {
                  "headline": "Gets the metadata for a start time.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.Metadata) - metadata for the start time", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: metadata for the start time\n        :rtype: ``osid.Metadata``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.Metadata", 
               "errors": {}
            }, 
            {
               "name": "set_start", 
               "doc": {
                  "headline": "Sets the start time.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    start (osid.calendaring.DateTime): the new start time\n", 
               "return_doc": "", 
               "error_doc": "        raise:  InvalidArgument - ``start`` is invalid\n        raise:  NoAccess - ``start`` cannot be modified\n        raise:  NullArgument - ``start`` is ``null``", 
               "sphinx_param_doc": "        :param start: the new start time\n        :type start: ``osid.calendaring.DateTime``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``InvalidArgument`` -- ``start`` is invalid\n        :raise: ``NoAccess`` -- ``start`` cannot be modified\n        :raise: ``NullArgument`` -- ``start`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.calendaring.DateTime", 
                     "var_name": "start", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.calendaring.DateTime"
               ], 
               "return_type": "", 
               "errors": {
                  "INVALID_ARGUMENT": "ConsumerContract", 
                  "NO_ACCESS": "ConsumerContract", 
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "clear_start", 
               "doc": {
                  "headline": "Clears the start time.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "        raise:  NoAccess - ``Metadata.isRequired()`` or\n                ``Metadata.isReadOnly()`` is ``true``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NoAccess`` -- ``Metadata.isRequired()`` or ``Metadata.isReadOnly()`` is ``true``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {
                  "NO_ACCESS": "ConsumerContract"
               }
            }, 
            {
               "name": "get_end_metadata", 
               "doc": {
                  "headline": "Gets the metadata for an end time.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.Metadata) - metadata for the end time", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: metadata for the end time\n        :rtype: ``osid.Metadata``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.Metadata", 
               "errors": {}
            }, 
            {
               "name": "set_end", 
               "doc": {
                  "headline": "Sets the end time.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    end (osid.calendaring.DateTime): the new end time\n", 
               "return_doc": "", 
               "error_doc": "        raise:  InvalidArgument - ``end`` is invalid\n        raise:  NoAccess - ``end`` cannot be modified\n        raise:  NullArgument - ``end`` is ``null``", 
               "sphinx_param_doc": "        :param end: the new end time\n        :type end: ``osid.calendaring.DateTime``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``InvalidArgument`` -- ``end`` is invalid\n        :raise: ``NoAccess`` -- ``end`` cannot be modified\n        :raise: ``NullArgument`` -- ``end`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.calendaring.DateTime", 
                     "var_name": "end", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.calendaring.DateTime"
               ], 
               "return_type": "", 
               "errors": {
                  "INVALID_ARGUMENT": "ConsumerContract", 
                  "NO_ACCESS": "ConsumerContract", 
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "clear_end", 
               "doc": {
                  "headline": "Clears the time period end.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "        raise:  NoAccess - ``Metadata.isRequired()`` or\n                ``Metadata.isReadOnly()`` is ``true``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NoAccess`` -- ``Metadata.isRequired()`` or ``Metadata.isReadOnly()`` is ``true``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {
                  "NO_ACCESS": "ConsumerContract"
               }
            }, 
            {
               "name": "get_time_period_form_record", 
               "doc": {
                  "headline": "Gets the ``TimePeriodFormRecord`` corresponding to the given time period record ``Type``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    time_period_record_type (osid.type.Type): the time\n                period record type\n", 
               "return_doc": "        return: (osid.calendaring.records.TimePeriodFormRecord) - the\n                time period form record", 
               "error_doc": "        raise:  NullArgument - ``time_period_record_type`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unsupported -\n                ``has_record_type(time_period_record_type)`` is\n                ``false``", 
               "sphinx_param_doc": "        :param time_period_record_type: the time period record type\n        :type time_period_record_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "        :return: the time period form record\n        :rtype: ``osid.calendaring.records.TimePeriodFormRecord``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``time_period_record_type`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unsupported`` -- ``has_record_type(time_period_record_type)`` is ``false``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "time_period_record_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "osid.calendaring.records.TimePeriodFormRecord", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.calendaring.records.TimePeriodFormRecord", 
         "shortname": "TimePeriodFormRecord", 
         "category": "records", 
         "doc": {
            "headline": "A record for a ``TimePeriodForm``.", 
            "body": "    The methods specified by the record type are available through the\n    underlying object."
         }, 
         "inherit_fullnames": [
            "osid.OsidRecord"
         ], 
         "inherit_shortnames": [
            "OsidRecord"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidRecord"
            }
         ], 
         "method_names": [], 
         "methods": []
      }, 
      {
         "fullname": "osid.calendaring.TimePeriodSearchOrder", 
         "shortname": "TimePeriodSearchOrder", 
         "category": "search_orders", 
         "doc": {
            "headline": "An interface for specifying the ordering of search results.", 
            "body": ""
         }, 
         "inherit_fullnames": [
            "osid.OsidObjectSearchOrder"
         ], 
         "inherit_shortnames": [
            "OsidObjectSearchOrder"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidObjectSearchOrder"
            }
         ], 
         "method_names": [
            "order_by_start", 
            "order_by_end", 
            "order_by_duration", 
            "get_time_period_search_order_record"
         ], 
         "methods": [
            {
               "name": "order_by_start", 
               "doc": {
                  "headline": "Specified a preference for ordering results by the start time.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    style (osid.SearchOrderStyle): a search order style\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``style`` is ``null``", 
               "sphinx_param_doc": "        :param style: a search order style\n        :type style: ``osid.SearchOrderStyle``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``style`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.SearchOrderStyle", 
                     "var_name": "style", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.SearchOrderStyle"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "order_by_end", 
               "doc": {
                  "headline": "Specified a preference for ordering results by the end time.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    style (osid.SearchOrderStyle): a search order style\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``style`` is ``null``", 
               "sphinx_param_doc": "        :param style: a search order style\n        :type style: ``osid.SearchOrderStyle``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``style`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.SearchOrderStyle", 
                     "var_name": "style", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.SearchOrderStyle"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "order_by_duration", 
               "doc": {
                  "headline": "Specified a preference for ordering results by the time period duration.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    style (osid.SearchOrderStyle): a search order style\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``style`` is ``null``", 
               "sphinx_param_doc": "        :param style: a search order style\n        :type style: ``osid.SearchOrderStyle``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``style`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.SearchOrderStyle", 
                     "var_name": "style", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.SearchOrderStyle"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "get_time_period_search_order_record", 
               "doc": {
                  "headline": "Gets the time period search order record corresponding to the given time period record ``Type``.", 
                  "body": "        Multiple retrievals return the same underlying object."
               }, 
               "arg_doc": "        arg:    time_period_record_type (osid.type.Type): a time period\n                record type\n", 
               "return_doc": "        return: (osid.calendaring.records.TimePeriodSearchOrderRecord) -\n                the time period search order record", 
               "error_doc": "        raise:  NullArgument - ``time_period_record_type`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unsupported -\n                ``has_record_type(time_period_record_type)`` is\n                ``false``", 
               "sphinx_param_doc": "        :param time_period_record_type: a time period record type\n        :type time_period_record_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "        :return: the time period search order record\n        :rtype: ``osid.calendaring.records.TimePeriodSearchOrderRecord``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``time_period_record_type`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unsupported`` -- ``has_record_type(time_period_record_type)`` is ``false``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "time_period_record_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "osid.calendaring.records.TimePeriodSearchOrderRecord", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.calendaring.records.TimePeriodSearchOrderRecord", 
         "shortname": "TimePeriodSearchOrderRecord", 
         "category": "records", 
         "doc": {
            "headline": "A record for a ``TimePeriodSearchOrder``.", 
            "body": "    The methods specified by the record type are available through the\n    underlying object."
         }, 
         "inherit_fullnames": [
            "osid.OsidRecord"
         ], 
         "inherit_shortnames": [
            "OsidRecord"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidRecord"
            }
         ], 
         "method_names": [], 
         "methods": []
      }, 
      {
         "fullname": "osid.calendaring.TimePeriodSearch", 
         "shortname": "TimePeriodSearch", 
         "category": "searches", 
         "doc": {
            "headline": "``TimePeriodSearch`` defines the interface for specifying time period search options.", 
            "body": ""
         }, 
         "inherit_fullnames": [
            "osid.OsidSearch"
         ], 
         "inherit_shortnames": [
            "OsidSearch"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidSearch"
            }
         ], 
         "method_names": [
            "search_among_time_periods", 
            "order_time_period_results", 
            "get_time_period_search_record"
         ], 
         "methods": [
            {
               "name": "search_among_time_periods", 
               "doc": {
                  "headline": "Execute this search among the given list of time periods.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    time_period_ids (osid.id.IdList): list of time periods\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``time_period_ids`` is ``null``", 
               "sphinx_param_doc": "        :param time_period_ids: list of time periods\n        :type time_period_ids: ``osid.id.IdList``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``time_period_ids`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.IdList", 
                     "var_name": "time_period_ids", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.IdList"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "order_time_period_results", 
               "doc": {
                  "headline": "Specify an ordering to the search results.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    time_period_search_order\n                (osid.calendaring.TimePeriodSearchOrder): time period\n                search order\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``time_period_search_order`` is ``null``\n        raise:  Unsupported - ``time_period_search_order`` is not of\n                this service", 
               "sphinx_param_doc": "        :param time_period_search_order: time period search order\n        :type time_period_search_order: ``osid.calendaring.TimePeriodSearchOrder``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``time_period_search_order`` is ``null``\n        :raise: ``Unsupported`` -- ``time_period_search_order`` is not of this service", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.calendaring.TimePeriodSearchOrder", 
                     "var_name": "time_period_search_order", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.calendaring.TimePeriodSearchOrder"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_time_period_search_record", 
               "doc": {
                  "headline": "Gets the time period search record corresponding to the given time period search record ``Type``.", 
                  "body": "        This method is used to retrieve an object implementing the\n        requested record."
               }, 
               "arg_doc": "        arg:    time_period_search_record_type (osid.type.Type): a time\n                period search record type\n", 
               "return_doc": "        return: (osid.calendaring.records.TimePeriodSearchRecord) - the\n                time period search record", 
               "error_doc": "        raise:  NullArgument - ``time_period_search_record_type`` is\n                ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unsupported -\n                ``has_record_type(time_period_search_record_type)`` is\n                ``false``", 
               "sphinx_param_doc": "        :param time_period_search_record_type: a time period search record type\n        :type time_period_search_record_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "        :return: the time period search record\n        :rtype: ``osid.calendaring.records.TimePeriodSearchRecord``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``time_period_search_record_type`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unsupported`` -- ``has_record_type(time_period_search_record_type)`` is ``false``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "time_period_search_record_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "osid.calendaring.records.TimePeriodSearchRecord", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.calendaring.records.TimePeriodSearchRecord", 
         "shortname": "TimePeriodSearchRecord", 
         "category": "records", 
         "doc": {
            "headline": "A record for a ``TimePeriodSearch``.", 
            "body": "    The methods specified by the record type are available through the\n    underlying object."
         }, 
         "inherit_fullnames": [
            "osid.OsidRecord"
         ], 
         "inherit_shortnames": [
            "OsidRecord"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidRecord"
            }
         ], 
         "method_names": [], 
         "methods": []
      }, 
      {
         "fullname": "osid.calendaring.TimePeriodSearchResults", 
         "shortname": "TimePeriodSearchResults", 
         "category": "searches", 
         "doc": {
            "headline": "This interface provides a means to capture results of a search.", 
            "body": ""
         }, 
         "inherit_fullnames": [
            "osid.OsidSearchResults"
         ], 
         "inherit_shortnames": [
            "OsidSearchResults"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidSearchResults"
            }
         ], 
         "method_names": [
            "get_time_periods", 
            "get_time_period_query_inspector", 
            "get_time_period_search_results_record"
         ], 
         "methods": [
            {
               "name": "get_time_periods", 
               "doc": {
                  "headline": "Gets the time period list resulting from the search.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.TimePeriodList) - the time period list", 
               "error_doc": "        raise:  IllegalState - list already retrieved", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the time period list\n        :rtype: ``osid.calendaring.TimePeriodList``", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- list already retrieved", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.TimePeriodList", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract"
               }
            }, 
            {
               "name": "get_time_period_query_inspector", 
               "doc": {
                  "headline": "Gets the inspector for the query to examine the time periods used in the search.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.TimePeriodQueryInspector) - the query\n                inspector", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the query inspector\n        :rtype: ``osid.calendaring.TimePeriodQueryInspector``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.TimePeriodQueryInspector", 
               "errors": {}
            }, 
            {
               "name": "get_time_period_search_results_record", 
               "doc": {
                  "headline": "Gets the time period search results record corresponding to the given time period search record ``Type``.", 
                  "body": "        This method is used to retrieve an object implementing the\n        requested record."
               }, 
               "arg_doc": "        arg:    time_period_search_record_type (osid.type.Type): a time\n                period search record type\n", 
               "return_doc": "        return: (osid.calendaring.records.TimePeriodSearchResultsRecord)\n                - the time period search results record", 
               "error_doc": "        raise:  NullArgument - ``time_period_search_record_type`` is\n                ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unsupported -\n                ``has_record_type(time_period_search_record_type)`` is\n                ``false``", 
               "sphinx_param_doc": "        :param time_period_search_record_type: a time period search record type\n        :type time_period_search_record_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "        :return: the time period search results record\n        :rtype: ``osid.calendaring.records.TimePeriodSearchResultsRecord``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``time_period_search_record_type`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unsupported`` -- ``has_record_type(time_period_search_record_type)`` is ``false``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "time_period_search_record_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "osid.calendaring.records.TimePeriodSearchResultsRecord", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.calendaring.records.TimePeriodSearchResultsRecord", 
         "shortname": "TimePeriodSearchResultsRecord", 
         "category": "records", 
         "doc": {
            "headline": "A record for a ``TimePeriodSearchResults``.", 
            "body": "    The methods specified by the record type are available through the\n    underlying object."
         }, 
         "inherit_fullnames": [
            "osid.OsidRecord"
         ], 
         "inherit_shortnames": [
            "OsidRecord"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidRecord"
            }
         ], 
         "method_names": [], 
         "methods": []
      }, 
      {
         "fullname": "osid.calendaring.TimePeriodReceiver", 
         "shortname": "TimePeriodReceiver", 
         "category": "receivers", 
         "doc": {
            "headline": "The time period receiver is the consumer supplied interface for receiving notifications pertaining to new, updated or deleted ``TimePeriods``.", 
            "body": ""
         }, 
         "inherit_fullnames": [
            "osid.OsidReceiver"
         ], 
         "inherit_shortnames": [
            "OsidReceiver"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidReceiver"
            }
         ], 
         "method_names": [
            "new_time_period", 
            "changed_time_period", 
            "deleted_time_period"
         ], 
         "methods": [
            {
               "name": "new_time_period", 
               "doc": {
                  "headline": "The callback for notifications of new time periods.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    time_period_id (osid.id.Id): the ``Id`` of the new\n                ``TimePeriod``\n", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "        :param time_period_id: the ``Id`` of the new ``TimePeriod``\n        :type time_period_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "time_period_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "changed_time_period", 
               "doc": {
                  "headline": "The callback for notification of updated time periods.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    time_period_id (osid.id.Id): the ``Id`` of the updated\n                ``TimePeriod``\n", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "        :param time_period_id: the ``Id`` of the updated ``TimePeriod``\n        :type time_period_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "time_period_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "deleted_time_period", 
               "doc": {
                  "headline": "The callback for notification of deleted time periods.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    time_period_id (osid.id.Id): the ``Id`` of the deleted\n                ``TimePeriod``\n", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "        :param time_period_id: the ``Id`` of the deleted ``TimePeriod``\n        :type time_period_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "time_period_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {}
            }
         ]
      }, 
      {
         "fullname": "osid.calendaring.TimePeriodList", 
         "shortname": "TimePeriodList", 
         "category": "objects", 
         "doc": {
            "headline": "Like all ``OsidLists,``  ``TimePeriodList`` provides a means for accessing ``TimePeriod`` elements sequentially either one at a time or many at a time.", 
            "body": "    Examples: while (tp.hasNext()) { TimePeriod period =\n    tp.getNextTimePeriod(); }\n\n    or\n      while (tp.hasNext()) {\n           TimePeriod[] periods = tp.getNextTimePeriods(tp.available());\n      }\n    \n"
         }, 
         "inherit_fullnames": [
            "osid.OsidList"
         ], 
         "inherit_shortnames": [
            "OsidList"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidList"
            }
         ], 
         "method_names": [
            "get_next_time_period", 
            "get_next_time_periods"
         ], 
         "methods": [
            {
               "name": "get_next_time_period", 
               "doc": {
                  "headline": "Gets the next ``TimePeriod`` in this list.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.TimePeriod) - the next ``TimePeriod``\n                in this list. The ``has_next()`` method should be used\n                to test that a next ``TimePeriod`` is available before\n                calling this method.", 
               "error_doc": "        raise:  IllegalState - no more elements available in this list\n        raise:  OperationFailed - unable to complete request", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the next ``TimePeriod`` in this list. The ``has_next()`` method should be used to test that a next ``TimePeriod`` is available before calling this method.\n        :rtype: ``osid.calendaring.TimePeriod``", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- no more elements available in this list\n        :raise: ``OperationFailed`` -- unable to complete request", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.TimePeriod", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational"
               }
            }, 
            {
               "name": "get_next_time_periods", 
               "doc": {
                  "headline": "Gets the next set of ``TimePeriod`` elements in this list which must be less than or equal to the number returned from ``available()``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    n (cardinal): the number of ``TimePeriod`` elements\n                requested which should be less than or equal to\n                ``available()``\n", 
               "return_doc": "        return: (osid.calendaring.TimePeriod) - an array of\n                ``TimePeriod`` elements.The length of the array is less\n                than or equal to the number specified.", 
               "error_doc": "        raise:  IllegalState - no more elements available in this list\n        raise:  OperationFailed - unable to complete request", 
               "sphinx_param_doc": "        :param n: the number of ``TimePeriod`` elements requested which should be less than or equal to ``available()``\n        :type n: ``cardinal``\n", 
               "sphinx_return_doc": "        :return: an array of ``TimePeriod`` elements.The length of the array is less than or equal to the number specified.\n        :rtype: ``osid.calendaring.TimePeriod``", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- no more elements available in this list\n        :raise: ``OperationFailed`` -- unable to complete request", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "cardinal", 
                     "var_name": "n", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "cardinal"
               ], 
               "return_type": "osid.calendaring.TimePeriod", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.calendaring.Commitment", 
         "shortname": "Commitment", 
         "category": "objects", 
         "doc": {
            "headline": "A ``Commitment`` maps a ``Resource`` to an ``Event``.", 
            "body": ""
         }, 
         "inherit_fullnames": [
            "osid.OsidRelationship"
         ], 
         "inherit_shortnames": [
            "OsidRelationship"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidRelationship"
            }
         ], 
         "method_names": [
            "get_event_id", 
            "get_event", 
            "get_resource_id", 
            "get_resource", 
            "get_commitment_record"
         ], 
         "methods": [
            {
               "name": "get_event_id", 
               "doc": {
                  "headline": "Gets the event ``Id``.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.id.Id) - the event ``Id``", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the event ``Id``\n        :rtype: ``osid.id.Id``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.id.Id", 
               "errors": {}
            }, 
            {
               "name": "get_event", 
               "doc": {
                  "headline": "Gets the ``Event``.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.Event) - the event", 
               "error_doc": "        raise:  OperationFailed - unable to complete request", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the event\n        :rtype: ``osid.calendaring.Event``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.Event", 
               "errors": {
                  "OPERATION_FAILED": "Operational"
               }
            }, 
            {
               "name": "get_resource_id", 
               "doc": {
                  "headline": "Gets the resource ``Id``.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.id.Id) - a resource ``Id``", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: a resource ``Id``\n        :rtype: ``osid.id.Id``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.id.Id", 
               "errors": {}
            }, 
            {
               "name": "get_resource", 
               "doc": {
                  "headline": "Gets the ``Resource``.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.resource.Resource) - the resource", 
               "error_doc": "        raise:  OperationFailed - unable to complete request", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the resource\n        :rtype: ``osid.resource.Resource``", 
               "sphinx_error_doc": "        :raise: ``OperationFailed`` -- unable to complete request", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.resource.Resource", 
               "errors": {
                  "OPERATION_FAILED": "Operational"
               }
            }, 
            {
               "name": "get_commitment_record", 
               "doc": {
                  "headline": "Gets the record corresponding to the given ``Commitment`` record ``Type``.", 
                  "body": "        This method is used to retrieve an object implementing the\n        requested record. The ``commitment_record_type`` may be the\n        ``Type`` returned in ``get_record_types()`` or any of its\n        parents in a ``Type`` hierarchy where\n        ``has_record_type(commitment_record_type)`` is ``true`` ."
               }, 
               "arg_doc": "        arg:    commitment_record_type (osid.type.Type): the type of the\n                record to retrieve\n", 
               "return_doc": "        return: (osid.calendaring.records.CommitmentRecord) - the\n                commitment record", 
               "error_doc": "        raise:  NullArgument - ``commitment_record_type`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unsupported -\n                ``has_record_type(commitment_record_type)`` is ``false``", 
               "sphinx_param_doc": "        :param commitment_record_type: the type of the record to retrieve\n        :type commitment_record_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "        :return: the commitment record\n        :rtype: ``osid.calendaring.records.CommitmentRecord``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``commitment_record_type`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unsupported`` -- ``has_record_type(commitment_record_type)`` is ``false``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "commitment_record_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "osid.calendaring.records.CommitmentRecord", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.calendaring.records.CommitmentRecord", 
         "shortname": "CommitmentRecord", 
         "category": "records", 
         "doc": {
            "headline": "A record for a ``Commitment``.", 
            "body": "    The methods specified by the record type are available through the\n    underlying object."
         }, 
         "inherit_fullnames": [
            "osid.OsidRecord"
         ], 
         "inherit_shortnames": [
            "OsidRecord"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidRecord"
            }
         ], 
         "method_names": [], 
         "methods": []
      }, 
      {
         "fullname": "osid.calendaring.CommitmentQuery", 
         "shortname": "CommitmentQuery", 
         "category": "queries", 
         "doc": {
            "headline": "This is the query for searching commitments.", 
            "body": "    Each method match request produces an ``AND`` term while multiple\n    invocations of a method produces a nested ``OR``."
         }, 
         "inherit_fullnames": [
            "osid.OsidRelationshipQuery"
         ], 
         "inherit_shortnames": [
            "OsidRelationshipQuery"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidRelationshipQuery"
            }
         ], 
         "method_names": [
            "match_event_id", 
            "clear_event_id_terms", 
            "supports_event_query", 
            "get_event_query", 
            "clear_event_terms", 
            "match_resource_id", 
            "clear_resource_id_terms", 
            "supports_resource_query", 
            "get_resource_query", 
            "clear_resource_terms", 
            "match_calendar_id", 
            "clear_calendar_id_terms", 
            "supports_calendar_query", 
            "get_calendar_query", 
            "clear_calendar_terms", 
            "get_commitment_query_record"
         ], 
         "methods": [
            {
               "name": "match_event_id", 
               "doc": {
                  "headline": "Sets the event ``Id`` for this query.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    event_id (osid.id.Id): an event ``Id``\n        arg:    match (boolean): ``true`` for a positive match,\n                ``false`` for a negative match\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``event_id`` is ``null``", 
               "sphinx_param_doc": "        :param event_id: an event ``Id``\n        :type event_id: ``osid.id.Id``\n        :param match: ``true`` for a positive match, ``false`` for a negative match\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``event_id`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "event_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "clear_event_id_terms", 
               "doc": {
                  "headline": "Clears the event ``Id`` terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "supports_event_query", 
               "doc": {
                  "headline": "Tests if an ``EventQuery`` is available.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if an event query is available,\n                ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if an event query is available, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "get_event_query", 
               "doc": {
                  "headline": "Gets the query for an event.", 
                  "body": "        Multiple retrievals produce a nested ``OR`` term."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.EventQuery) - the event query", 
               "error_doc": "        raise:  Unimplemented - ``supports_event_query()`` is ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the event query\n        :rtype: ``osid.calendaring.EventQuery``", 
               "sphinx_error_doc": "        :raise: ``Unimplemented`` -- ``supports_event_query()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_event_query()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.EventQuery", 
               "errors": {
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "clear_event_terms", 
               "doc": {
                  "headline": "Clears the event terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "match_resource_id", 
               "doc": {
                  "headline": "Sets the resource ``Id`` for this query.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    resource_id (osid.id.Id): a resource ``Id``\n        arg:    match (boolean): ``true`` for a positive match,\n                ``false`` for a negative match\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``resource_id`` is ``null``", 
               "sphinx_param_doc": "        :param resource_id: a resource ``Id``\n        :type resource_id: ``osid.id.Id``\n        :param match: ``true`` for a positive match, ``false`` for a negative match\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``resource_id`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "resource_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "clear_resource_id_terms", 
               "doc": {
                  "headline": "Clears the resource ``Id`` terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "supports_resource_query", 
               "doc": {
                  "headline": "Tests if a ``ResourceQuery`` is available for querying resources.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if a resource query is available,\n                ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if a resource query is available, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "get_resource_query", 
               "doc": {
                  "headline": "Gets the query for a resource.", 
                  "body": "        Multiple retrievals produce a nested ``OR`` term."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.resource.ResourceQuery) - the resource query", 
               "error_doc": "        raise:  Unimplemented - ``supports_resource_query()`` is\n                ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the resource query\n        :rtype: ``osid.resource.ResourceQuery``", 
               "sphinx_error_doc": "        :raise: ``Unimplemented`` -- ``supports_resource_query()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_resource_query()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.resource.ResourceQuery", 
               "errors": {
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "clear_resource_terms", 
               "doc": {
                  "headline": "Clears the resource terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "match_calendar_id", 
               "doc": {
                  "headline": "Sets the calendar ``Id`` for this query.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    calendar_id (osid.id.Id): a calendar ``Id``\n        arg:    match (boolean): ``true`` for a positive match,\n                ``false`` for a negative match\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``calendar_id`` is ``null``", 
               "sphinx_param_doc": "        :param calendar_id: a calendar ``Id``\n        :type calendar_id: ``osid.id.Id``\n        :param match: ``true`` for a positive match, ``false`` for a negative match\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``calendar_id`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "calendar_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "clear_calendar_id_terms", 
               "doc": {
                  "headline": "Clears the calendar ``Id`` terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "supports_calendar_query", 
               "doc": {
                  "headline": "Tests if a ``CalendarQuery`` is available for querying resources.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if a calendar query is available,\n                ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if a calendar query is available, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "get_calendar_query", 
               "doc": {
                  "headline": "Gets the query for a calendar.", 
                  "body": "        Multiple retrievals produce a nested ``OR`` term."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.CalendarQuery) - the calendar query", 
               "error_doc": "        raise:  Unimplemented - ``supports_calendar_query()`` is\n                ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the calendar query\n        :rtype: ``osid.calendaring.CalendarQuery``", 
               "sphinx_error_doc": "        :raise: ``Unimplemented`` -- ``supports_calendar_query()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_calendar_query()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.CalendarQuery", 
               "errors": {
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "clear_calendar_terms", 
               "doc": {
                  "headline": "Clears the calendar terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "get_commitment_query_record", 
               "doc": {
                  "headline": "Gets the commitment query record corresponding to the given ``Commitment`` record ``Type``.", 
                  "body": "        Multiple retrievals produce a nested ``OR`` term."
               }, 
               "arg_doc": "        arg:    commitment_record_type (osid.type.Type): a commitment\n                query record type\n", 
               "return_doc": "        return: (osid.calendaring.records.CommitmentQueryRecord) - the\n                commitment query record", 
               "error_doc": "        raise:  NullArgument - ``commitment_record_type`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unsupported -\n                ``has_record_type(commitment_record_type)`` is ``false``", 
               "sphinx_param_doc": "        :param commitment_record_type: a commitment query record type\n        :type commitment_record_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "        :return: the commitment query record\n        :rtype: ``osid.calendaring.records.CommitmentQueryRecord``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``commitment_record_type`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unsupported`` -- ``has_record_type(commitment_record_type)`` is ``false``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "commitment_record_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "osid.calendaring.records.CommitmentQueryRecord", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.calendaring.records.CommitmentQueryRecord", 
         "shortname": "CommitmentQueryRecord", 
         "category": "records", 
         "doc": {
            "headline": "A record for a ``CommitmentQuery``.", 
            "body": "    The methods specified by the record type are available through the\n    underlying object."
         }, 
         "inherit_fullnames": [
            "osid.OsidRecord"
         ], 
         "inherit_shortnames": [
            "OsidRecord"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidRecord"
            }
         ], 
         "method_names": [], 
         "methods": []
      }, 
      {
         "fullname": "osid.calendaring.CommitmentQueryInspector", 
         "shortname": "CommitmentQueryInspector", 
         "category": "query_inspectors", 
         "doc": {
            "headline": "This is the query inspector for examining commitment queries.", 
            "body": ""
         }, 
         "inherit_fullnames": [
            "osid.OsidRelationshipQueryInspector"
         ], 
         "inherit_shortnames": [
            "OsidRelationshipQueryInspector"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidRelationshipQueryInspector"
            }
         ], 
         "method_names": [
            "get_event_id_terms", 
            "get_event_terms", 
            "get_resource_id_terms", 
            "get_resource_terms", 
            "get_calendar_id_terms", 
            "get_calendar_terms", 
            "get_commitment_query_inspector_record"
         ], 
         "methods": [
            {
               "name": "get_event_id_terms", 
               "doc": {
                  "headline": "Gets the event ``Id`` terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.search.terms.IdTerm) - the event ``Id`` terms", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the event ``Id`` terms\n        :rtype: ``osid.search.terms.IdTerm``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.search.terms.IdTerm", 
               "errors": {}
            }, 
            {
               "name": "get_event_terms", 
               "doc": {
                  "headline": "Gets the event terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.EventQueryInspector) - the event terms", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the event terms\n        :rtype: ``osid.calendaring.EventQueryInspector``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.EventQueryInspector", 
               "errors": {}
            }, 
            {
               "name": "get_resource_id_terms", 
               "doc": {
                  "headline": "Gets the resource ``Id`` terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.search.terms.IdTerm) - the resource ``Id`` terms", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the resource ``Id`` terms\n        :rtype: ``osid.search.terms.IdTerm``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.search.terms.IdTerm", 
               "errors": {}
            }, 
            {
               "name": "get_resource_terms", 
               "doc": {
                  "headline": "Gets the resource terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.resource.ResourceQueryInspector) - the resource\n                terms", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the resource terms\n        :rtype: ``osid.resource.ResourceQueryInspector``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.resource.ResourceQueryInspector", 
               "errors": {}
            }, 
            {
               "name": "get_calendar_id_terms", 
               "doc": {
                  "headline": "Gets the calendar ``Id`` terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.search.terms.IdTerm) - the calendar ``Id`` terms", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the calendar ``Id`` terms\n        :rtype: ``osid.search.terms.IdTerm``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.search.terms.IdTerm", 
               "errors": {}
            }, 
            {
               "name": "get_calendar_terms", 
               "doc": {
                  "headline": "Gets the calendar terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.CalendarQueryInspector) - the calendar\n                terms", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the calendar terms\n        :rtype: ``osid.calendaring.CalendarQueryInspector``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.CalendarQueryInspector", 
               "errors": {}
            }, 
            {
               "name": "get_commitment_query_inspector_record", 
               "doc": {
                  "headline": "Gets the commitment query inspector record corresponding to the given ``Commitment`` record ``Type``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    commitment_record_type (osid.type.Type): a commitment\n                query record type\n", 
               "return_doc": "        return:\n                (osid.calendaring.records.CommitmentQueryInspectorRecord\n                ) - the commitment query inspector record", 
               "error_doc": "        raise:  NullArgument - ``commitment_record_type`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unsupported -\n                ``has_record_type(commitment_record_type)`` is ``false``", 
               "sphinx_param_doc": "        :param commitment_record_type: a commitment query record type\n        :type commitment_record_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "        :return: the commitment query inspector record\n        :rtype: ``osid.calendaring.records.CommitmentQueryInspectorRecord``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``commitment_record_type`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unsupported`` -- ``has_record_type(commitment_record_type)`` is ``false``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "commitment_record_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "osid.calendaring.records.CommitmentQueryInspectorRecord", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.calendaring.records.CommitmentQueryInspectorRecord", 
         "shortname": "CommitmentQueryInspectorRecord", 
         "category": "records", 
         "doc": {
            "headline": "A record for a ``CommitmentQueryInspector``.", 
            "body": "    The methods specified by the record type are available through the\n    underlying object."
         }, 
         "inherit_fullnames": [
            "osid.OsidRecord"
         ], 
         "inherit_shortnames": [
            "OsidRecord"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidRecord"
            }
         ], 
         "method_names": [], 
         "methods": []
      }, 
      {
         "fullname": "osid.calendaring.CommitmentForm", 
         "shortname": "CommitmentForm", 
         "category": "objects", 
         "doc": {
            "headline": "This is the form for creating and updating ``Commitments``.", 
            "body": ""
         }, 
         "inherit_fullnames": [
            "osid.OsidRelationshipForm"
         ], 
         "inherit_shortnames": [
            "OsidRelationshipForm"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidRelationshipForm"
            }
         ], 
         "method_names": [
            "get_commitment_form_record"
         ], 
         "methods": [
            {
               "name": "get_commitment_form_record", 
               "doc": {
                  "headline": "Gets the ``CommitmentFormRecord`` corresponding to the given event record ``Type``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    commitment_record_type (osid.type.Type): the commitment\n                record type\n", 
               "return_doc": "        return: (osid.calendaring.records.CommitmentFormRecord) - the\n                commitment form record", 
               "error_doc": "        raise:  NullArgument - ``commitment_record_type`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unsupported -\n                ``has_record_type(commitment_record_type)`` is ``false``", 
               "sphinx_param_doc": "        :param commitment_record_type: the commitment record type\n        :type commitment_record_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "        :return: the commitment form record\n        :rtype: ``osid.calendaring.records.CommitmentFormRecord``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``commitment_record_type`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unsupported`` -- ``has_record_type(commitment_record_type)`` is ``false``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "commitment_record_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "osid.calendaring.records.CommitmentFormRecord", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.calendaring.records.CommitmentFormRecord", 
         "shortname": "CommitmentFormRecord", 
         "category": "records", 
         "doc": {
            "headline": "A record for a ``CommitmentForm``.", 
            "body": "    The methods specified by the record type are available through the\n    underlying object."
         }, 
         "inherit_fullnames": [
            "osid.OsidRecord"
         ], 
         "inherit_shortnames": [
            "OsidRecord"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidRecord"
            }
         ], 
         "method_names": [], 
         "methods": []
      }, 
      {
         "fullname": "osid.calendaring.CommitmentSearchOrder", 
         "shortname": "CommitmentSearchOrder", 
         "category": "search_orders", 
         "doc": {
            "headline": "An interface for specifying the ordering of search results.", 
            "body": ""
         }, 
         "inherit_fullnames": [
            "osid.OsidRelationshipSearchOrder"
         ], 
         "inherit_shortnames": [
            "OsidRelationshipSearchOrder"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidRelationshipSearchOrder"
            }
         ], 
         "method_names": [
            "order_by_event", 
            "supports_event_search_order", 
            "get_event_search_order", 
            "order_by_resource", 
            "supports_resource_search_order", 
            "get_resource_search_order", 
            "get_commitment_search_order_record"
         ], 
         "methods": [
            {
               "name": "order_by_event", 
               "doc": {
                  "headline": "Specified a preference for ordering results by the event.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    style (osid.SearchOrderStyle): a search order style\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``style`` is ``null``", 
               "sphinx_param_doc": "        :param style: a search order style\n        :type style: ``osid.SearchOrderStyle``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``style`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.SearchOrderStyle", 
                     "var_name": "style", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.SearchOrderStyle"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "supports_event_search_order", 
               "doc": {
                  "headline": "Tests if an ``EventSearchOrder`` is available.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if an event search order is\n                available, ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if an event search order is available, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "get_event_search_order", 
               "doc": {
                  "headline": "Gets the search order for an event.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.EventSearchOrder) - the event search\n                order", 
               "error_doc": "        raise:  Unimplemented - ``supports_event_search_order()`` is\n                ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the event search order\n        :rtype: ``osid.calendaring.EventSearchOrder``", 
               "sphinx_error_doc": "        :raise: ``Unimplemented`` -- ``supports_event_search_order()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_event_search_order()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.EventSearchOrder", 
               "errors": {
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "order_by_resource", 
               "doc": {
                  "headline": "Specified a preference for ordering results by the resource.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    style (osid.SearchOrderStyle): a search order style\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``style`` is ``null``", 
               "sphinx_param_doc": "        :param style: a search order style\n        :type style: ``osid.SearchOrderStyle``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``style`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.SearchOrderStyle", 
                     "var_name": "style", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.SearchOrderStyle"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "supports_resource_search_order", 
               "doc": {
                  "headline": "Tests if a ``ResourceSearchOrder`` is available.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if a resource search order is\n                available, ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if a resource search order is available, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "get_resource_search_order", 
               "doc": {
                  "headline": "Gets the search order for a resource.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.resource.ResourceSearchOrder) - the resource\n                search order", 
               "error_doc": "        raise:  Unimplemented - ``supports_resource_search_order()`` is\n                ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the resource search order\n        :rtype: ``osid.resource.ResourceSearchOrder``", 
               "sphinx_error_doc": "        :raise: ``Unimplemented`` -- ``supports_resource_search_order()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_resource_search_order()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.resource.ResourceSearchOrder", 
               "errors": {
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_commitment_search_order_record", 
               "doc": {
                  "headline": "Gets the commitment search order record corresponding to the given commitment record ``Type``.", 
                  "body": "        Multiple retrievals return the same underlying object."
               }, 
               "arg_doc": "        arg:    commitment_record_type (osid.type.Type): a commitment\n                record type\n", 
               "return_doc": "        return: (osid.calendaring.records.CommitmentSearchOrderRecord) -\n                the commitment search order record", 
               "error_doc": "        raise:  NullArgument - ``commitment_record_type`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unsupported -\n                ``has_record_type(commitment_record_type)`` is ``false``", 
               "sphinx_param_doc": "        :param commitment_record_type: a commitment record type\n        :type commitment_record_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "        :return: the commitment search order record\n        :rtype: ``osid.calendaring.records.CommitmentSearchOrderRecord``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``commitment_record_type`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unsupported`` -- ``has_record_type(commitment_record_type)`` is ``false``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "commitment_record_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "osid.calendaring.records.CommitmentSearchOrderRecord", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.calendaring.records.CommitmentSearchOrderRecord", 
         "shortname": "CommitmentSearchOrderRecord", 
         "category": "records", 
         "doc": {
            "headline": "A record for a ``CommitmentSearchOrder``.", 
            "body": "    The methods specified by the record type are available through the\n    underlying object."
         }, 
         "inherit_fullnames": [
            "osid.OsidRecord"
         ], 
         "inherit_shortnames": [
            "OsidRecord"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidRecord"
            }
         ], 
         "method_names": [], 
         "methods": []
      }, 
      {
         "fullname": "osid.calendaring.CommitmentSearch", 
         "shortname": "CommitmentSearch", 
         "category": "searches", 
         "doc": {
            "headline": "``CommitmentSearch`` defines the interface for specifying commitment search options.", 
            "body": ""
         }, 
         "inherit_fullnames": [
            "osid.OsidSearch"
         ], 
         "inherit_shortnames": [
            "OsidSearch"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidSearch"
            }
         ], 
         "method_names": [
            "search_among_commitments", 
            "order_commitment_results", 
            "get_commitment_search_record"
         ], 
         "methods": [
            {
               "name": "search_among_commitments", 
               "doc": {
                  "headline": "Execute this search among the given list of commitments.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    commitment_ids (osid.id.IdList): list of commitments\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``commitment_ids`` is ``null``", 
               "sphinx_param_doc": "        :param commitment_ids: list of commitments\n        :type commitment_ids: ``osid.id.IdList``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``commitment_ids`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.IdList", 
                     "var_name": "commitment_ids", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.IdList"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "order_commitment_results", 
               "doc": {
                  "headline": "Specify an ordering to the search results.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    commitment_search_order\n                (osid.calendaring.CommitmentSearchOrder): commitment\n                search order\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``commitment_search_order`` is ``null``\n        raise:  Unsupported - ``commitment_search_order`` is not of this\n                service", 
               "sphinx_param_doc": "        :param commitment_search_order: commitment search order\n        :type commitment_search_order: ``osid.calendaring.CommitmentSearchOrder``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``commitment_search_order`` is ``null``\n        :raise: ``Unsupported`` -- ``commitment_search_order`` is not of this service", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.calendaring.CommitmentSearchOrder", 
                     "var_name": "commitment_search_order", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.calendaring.CommitmentSearchOrder"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_commitment_search_record", 
               "doc": {
                  "headline": "Gets the commitment seaqrch record corresponding to the given commitment search record ``Type``.", 
                  "body": "        This method is used to retrieve an object implementing the\n        requested record."
               }, 
               "arg_doc": "        arg:    commitment_search_record_type (osid.type.Type): a\n                commitment search record type\n", 
               "return_doc": "        return: (osid.calendaring.records.CommitmentSearchRecord) - the\n                commitment search record", 
               "error_doc": "        raise:  NullArgument - ``commitment_record_type`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unsupported -\n                ``has_record_type(commitment_search_record_type)`` is\n                ``false``", 
               "sphinx_param_doc": "        :param commitment_search_record_type: a commitment search record type\n        :type commitment_search_record_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "        :return: the commitment search record\n        :rtype: ``osid.calendaring.records.CommitmentSearchRecord``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``commitment_record_type`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unsupported`` -- ``has_record_type(commitment_search_record_type)`` is ``false``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "commitment_search_record_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "osid.calendaring.records.CommitmentSearchRecord", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.calendaring.records.CommitmentSearchRecord", 
         "shortname": "CommitmentSearchRecord", 
         "category": "records", 
         "doc": {
            "headline": "A record for a ``CommitmentSearch``.", 
            "body": "    The methods specified by the record type are available through the\n    underlying object."
         }, 
         "inherit_fullnames": [
            "osid.OsidRecord"
         ], 
         "inherit_shortnames": [
            "OsidRecord"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidRecord"
            }
         ], 
         "method_names": [], 
         "methods": []
      }, 
      {
         "fullname": "osid.calendaring.CommitmentSearchResults", 
         "shortname": "CommitmentSearchResults", 
         "category": "searches", 
         "doc": {
            "headline": "This interface provides a means to capture results of a search.", 
            "body": ""
         }, 
         "inherit_fullnames": [
            "osid.OsidSearchResults"
         ], 
         "inherit_shortnames": [
            "OsidSearchResults"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidSearchResults"
            }
         ], 
         "method_names": [
            "get_commitments", 
            "get_commitment_query_inspector", 
            "get_commitment_search_results_record"
         ], 
         "methods": [
            {
               "name": "get_commitments", 
               "doc": {
                  "headline": "Gets the commitment list resulting from the search.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.CommitmentList) - the commitment list", 
               "error_doc": "        raise:  IllegalState - list already retrieved", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the commitment list\n        :rtype: ``osid.calendaring.CommitmentList``", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- list already retrieved", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.CommitmentList", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract"
               }
            }, 
            {
               "name": "get_commitment_query_inspector", 
               "doc": {
                  "headline": "Gets the inspector for the query to examine the terms used in the search.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.CommitmentQueryInspector) - the query\n                inspector", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the query inspector\n        :rtype: ``osid.calendaring.CommitmentQueryInspector``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.CommitmentQueryInspector", 
               "errors": {}
            }, 
            {
               "name": "get_commitment_search_results_record", 
               "doc": {
                  "headline": "Gets the commitment search results record corresponding to the given commitment search record ``Type``.", 
                  "body": "        This method is used to retrieve an object implementing the\n        requested record."
               }, 
               "arg_doc": "        arg:    commitment_search_record_type (osid.type.Type): a\n                commitment search record type\n", 
               "return_doc": "        return: (osid.calendaring.records.CommitmentSearchResultsRecord)\n                - the commitment search results record", 
               "error_doc": "        raise:  NullArgument - ``commitment_search_record_type`` is\n                ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unsupported -\n                ``has_record_type(commitment_search_record_type)`` is\n                ``false``", 
               "sphinx_param_doc": "        :param commitment_search_record_type: a commitment search record type\n        :type commitment_search_record_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "        :return: the commitment search results record\n        :rtype: ``osid.calendaring.records.CommitmentSearchResultsRecord``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``commitment_search_record_type`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unsupported`` -- ``has_record_type(commitment_search_record_type)`` is ``false``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "commitment_search_record_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "osid.calendaring.records.CommitmentSearchResultsRecord", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.calendaring.records.CommitmentSearchResultsRecord", 
         "shortname": "CommitmentSearchResultsRecord", 
         "category": "records", 
         "doc": {
            "headline": "A record for a ``CommitmentSearchResults``.", 
            "body": "    The methods specified by the record type are available through the\n    underlying object."
         }, 
         "inherit_fullnames": [
            "osid.OsidRecord"
         ], 
         "inherit_shortnames": [
            "OsidRecord"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidRecord"
            }
         ], 
         "method_names": [], 
         "methods": []
      }, 
      {
         "fullname": "osid.calendaring.CommitmentReceiver", 
         "shortname": "CommitmentReceiver", 
         "category": "receivers", 
         "doc": {
            "headline": "The event receiver is the consumer supplied interface for receiving notifications pertaining to new, updated or deleted ``Commitments``.", 
            "body": ""
         }, 
         "inherit_fullnames": [
            "osid.OsidReceiver"
         ], 
         "inherit_shortnames": [
            "OsidReceiver"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidReceiver"
            }
         ], 
         "method_names": [
            "new_commitment", 
            "new_commitment_for_event", 
            "new_commitment_for_resource", 
            "changed_commitment", 
            "changed_commitment_for_event", 
            "changed_commitment_for_resource", 
            "changed_commitment_state", 
            "deleted_commitment", 
            "deleted_commitment_for_event", 
            "deleted_commitment_for_resource"
         ], 
         "methods": [
            {
               "name": "new_commitment", 
               "doc": {
                  "headline": "The callback for notifications of new commitments.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    commitment_id (osid.id.Id): the ``Id`` of the new\n                ``Commitment``\n", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "        :param commitment_id: the ``Id`` of the new ``Commitment``\n        :type commitment_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "commitment_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "new_commitment_for_event", 
               "doc": {
                  "headline": "The callback for notifications of new commitments.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    commitment_id (osid.id.Id): the ``Id`` of the new\n                ``Commitment``\n        arg:    event_id (osid.id.Id): the ``Id`` of the ``Event``\n", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "        :param commitment_id: the ``Id`` of the new ``Commitment``\n        :type commitment_id: ``osid.id.Id``\n        :param event_id: the ``Id`` of the ``Event``\n        :type event_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "commitment_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "event_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "new_commitment_for_resource", 
               "doc": {
                  "headline": "The callback for notifications of new commitments.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    commitment_id (osid.id.Id): the ``Id`` of the new\n                ``Commitment``\n        arg:    resource_id (osid.id.Id): the ``Id`` of the ``Resource``\n", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "        :param commitment_id: the ``Id`` of the new ``Commitment``\n        :type commitment_id: ``osid.id.Id``\n        :param resource_id: the ``Id`` of the ``Resource``\n        :type resource_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "commitment_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "resource_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "changed_commitment", 
               "doc": {
                  "headline": "The callback for notification of updated commitments.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    commitment_id (osid.id.Id): the ``Id`` of the updated\n                ``Commitment``\n", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "        :param commitment_id: the ``Id`` of the updated ``Commitment``\n        :type commitment_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "commitment_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "changed_commitment_for_event", 
               "doc": {
                  "headline": "The callback for notifications of updated commitments.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    commitment_id (osid.id.Id): the ``Id`` of the updated\n                ``Commitment``\n        arg:    event_id (osid.id.Id): the ``Id`` of the ``Event``\n", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "        :param commitment_id: the ``Id`` of the updated ``Commitment``\n        :type commitment_id: ``osid.id.Id``\n        :param event_id: the ``Id`` of the ``Event``\n        :type event_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "commitment_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "event_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "changed_commitment_for_resource", 
               "doc": {
                  "headline": "The callback for notifications of updated commitments.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    commitment_id (osid.id.Id): the ``Id`` of the updated\n                ``Commitment``\n        arg:    resource_id (osid.id.Id): the ``Id`` of the ``Resource``\n", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "        :param commitment_id: the ``Id`` of the updated ``Commitment``\n        :type commitment_id: ``osid.id.Id``\n        :param resource_id: the ``Id`` of the ``Resource``\n        :type resource_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "commitment_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "resource_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "changed_commitment_state", 
               "doc": {
                  "headline": "The callback for notification of changed commitment states.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    commitment_id (osid.id.Id): the ``Id`` of the\n                ``Commitment``\n        arg:    process_id (osid.id.Id): the ``Id`` of the ``process``\n", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "        :param commitment_id: the ``Id`` of the ``Commitment``\n        :type commitment_id: ``osid.id.Id``\n        :param process_id: the ``Id`` of the ``process``\n        :type process_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "commitment_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "process_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "deleted_commitment", 
               "doc": {
                  "headline": "The callback for notification of deleted commitments.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    commitment_id (osid.id.Id): the ``Id`` of the deleted\n                ``Commitment``\n", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "        :param commitment_id: the ``Id`` of the deleted ``Commitment``\n        :type commitment_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "commitment_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "deleted_commitment_for_event", 
               "doc": {
                  "headline": "The callback for notifications of deleted commitments.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    commitment_id (osid.id.Id): the ``Id`` of the deleted\n                ``Commitment``\n        arg:    event_id (osid.id.Id): the ``Id`` of the ``Event``\n", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "        :param commitment_id: the ``Id`` of the deleted ``Commitment``\n        :type commitment_id: ``osid.id.Id``\n        :param event_id: the ``Id`` of the ``Event``\n        :type event_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "commitment_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "event_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "deleted_commitment_for_resource", 
               "doc": {
                  "headline": "The callback for notifications of deleted commitments.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    commitment_id (osid.id.Id): the ``Id`` of the deleted\n                ``Commitment``\n        arg:    resource_id (osid.id.Id): the ``Id`` of the ``Resource``\n", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "        :param commitment_id: the ``Id`` of the deleted ``Commitment``\n        :type commitment_id: ``osid.id.Id``\n        :param resource_id: the ``Id`` of the ``Resource``\n        :type resource_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "commitment_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "resource_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {}
            }
         ]
      }, 
      {
         "fullname": "osid.calendaring.CommitmentList", 
         "shortname": "CommitmentList", 
         "category": "objects", 
         "doc": {
            "headline": "Like all ``OsidLists,``  ``CommitmentList`` provides a means for accessing ``Commitment`` elements sequentially either one at a time or many at a time.", 
            "body": "    Examples: while (cl.hasNext()) { Commitment commitment =\n    cl.getNextCommitment(); }\n\n    or\n      while (cl.hasNext()) {\n           Commitment[] commitments = cl.getNextCommitment(cl.available());\n      }\n    \n"
         }, 
         "inherit_fullnames": [
            "osid.OsidList"
         ], 
         "inherit_shortnames": [
            "OsidList"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidList"
            }
         ], 
         "method_names": [
            "get_next_commitment", 
            "get_next_commitments"
         ], 
         "methods": [
            {
               "name": "get_next_commitment", 
               "doc": {
                  "headline": "Gets the next ``Commitment`` in this list.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.Commitment) - the next ``Commitment``\n                in this list. The ``has_next()`` method should be used\n                to test that a next ``Commitment`` is available before\n                calling this method.", 
               "error_doc": "        raise:  IllegalState - no more elements available in this list\n        raise:  OperationFailed - unable to complete request", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the next ``Commitment`` in this list. The ``has_next()`` method should be used to test that a next ``Commitment`` is available before calling this method.\n        :rtype: ``osid.calendaring.Commitment``", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- no more elements available in this list\n        :raise: ``OperationFailed`` -- unable to complete request", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.Commitment", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational"
               }
            }, 
            {
               "name": "get_next_commitments", 
               "doc": {
                  "headline": "Gets the next set of ``Commitment`` elements in this list which must be less than or equal to the number returned from ``available()``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    n (cardinal): the number of ``Commitment`` elements\n                requested which should be less than or equal to\n                ``available()``\n", 
               "return_doc": "        return: (osid.calendaring.Commitment) - an array of\n                ``Commitment`` elements.The length of the array is less\n                than or equal to the number specified.", 
               "error_doc": "        raise:  IllegalState - no more elements available in this list\n        raise:  OperationFailed - unable to complete request", 
               "sphinx_param_doc": "        :param n: the number of ``Commitment`` elements requested which should be less than or equal to ``available()``\n        :type n: ``cardinal``\n", 
               "sphinx_return_doc": "        :return: an array of ``Commitment`` elements.The length of the array is less than or equal to the number specified.\n        :rtype: ``osid.calendaring.Commitment``", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- no more elements available in this list\n        :raise: ``OperationFailed`` -- unable to complete request", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "cardinal", 
                     "var_name": "n", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "cardinal"
               ], 
               "return_type": "osid.calendaring.Commitment", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.calendaring.Calendar", 
         "shortname": "Calendar", 
         "category": "objects", 
         "doc": {
            "headline": "A calendar defines a collection of events.", 
            "body": ""
         }, 
         "inherit_fullnames": [
            "osid.OsidCatalog"
         ], 
         "inherit_shortnames": [
            "OsidCatalog"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidCatalog"
            }
         ], 
         "method_names": [
            "get_calendar_record"
         ], 
         "methods": [
            {
               "name": "get_calendar_record", 
               "doc": {
                  "headline": "Gets the record corresponding to the given ``Calendar`` record ``Type``.", 
                  "body": "        This method is used to retrieve an object implementing the\n        requested record. The ``calendar_record_type`` may be the\n        ``Type`` returned in ``get_record_types()`` or any of its\n        parents in a ``Type`` hierarchy where\n        ``has_record_type(calendar_record_type)`` is ``true`` ."
               }, 
               "arg_doc": "        arg:    calendar_record_type (osid.type.Type): a calendar record\n                type\n", 
               "return_doc": "        return: (osid.calendaring.records.CalendarRecord) - the calendar\n                record", 
               "error_doc": "        raise:  NullArgument - ``calendar_record_type`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unsupported - ``has_record_type(calendar_record_type)``\n                is ``false``", 
               "sphinx_param_doc": "        :param calendar_record_type: a calendar record type\n        :type calendar_record_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "        :return: the calendar record\n        :rtype: ``osid.calendaring.records.CalendarRecord``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``calendar_record_type`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unsupported`` -- ``has_record_type(calendar_record_type)`` is ``false``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "calendar_record_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "osid.calendaring.records.CalendarRecord", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.calendaring.records.CalendarRecord", 
         "shortname": "CalendarRecord", 
         "category": "records", 
         "doc": {
            "headline": "A record for a ``Calendar``.", 
            "body": "    The methods specified by the record type are available through the\n    underlying object."
         }, 
         "inherit_fullnames": [
            "osid.OsidRecord"
         ], 
         "inherit_shortnames": [
            "OsidRecord"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidRecord"
            }
         ], 
         "method_names": [], 
         "methods": []
      }, 
      {
         "fullname": "osid.calendaring.CalendarQuery", 
         "shortname": "CalendarQuery", 
         "category": "queries", 
         "doc": {
            "headline": "This is the query for searching calendars.", 
            "body": "    Each method specifies an ``AND`` term while multiple invocations of\n    the same method produce a nested ``OR``."
         }, 
         "inherit_fullnames": [
            "osid.OsidCatalogQuery"
         ], 
         "inherit_shortnames": [
            "OsidCatalogQuery"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidCatalogQuery"
            }
         ], 
         "method_names": [
            "match_event_id", 
            "clear_event_id_terms", 
            "supports_event_query", 
            "get_event_query", 
            "match_any_event", 
            "clear_event_terms", 
            "match_time_period_id", 
            "clear_time_period_id_terms", 
            "supports_time_period_query", 
            "get_time_period_query", 
            "match_any_time_period", 
            "clear_time_period_terms", 
            "match_commitment_id", 
            "clear_commitment_id_terms", 
            "supports_commitment_query", 
            "get_commitment_query", 
            "match_any_commitment", 
            "clear_commitment_terms", 
            "match_ancestor_calendar_id", 
            "clear_ancestor_calendar_id_terms", 
            "supports_ancestor_calendar_query", 
            "get_ancestor_calendar_query", 
            "match_any_ancestor_calendar", 
            "clear_ancestor_calendar_terms", 
            "match_descendant_calendar_id", 
            "clear_descendant_calendar_id_terms", 
            "supports_descendant_calendar_query", 
            "get_descendant_calendar_query", 
            "match_any_descendant_calendar", 
            "clear_descendant_calendar_terms", 
            "get_calendar_query_record"
         ], 
         "methods": [
            {
               "name": "match_event_id", 
               "doc": {
                  "headline": "Sets the event ``Id`` for this query.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    event_id (osid.id.Id): an event ``Id``\n        arg:    match (boolean): ``true`` for a positive match,\n                ``false`` for a negative match\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``event_id`` is ``null``", 
               "sphinx_param_doc": "        :param event_id: an event ``Id``\n        :type event_id: ``osid.id.Id``\n        :param match: ``true`` for a positive match, ``false`` for a negative match\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``event_id`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "event_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "clear_event_id_terms", 
               "doc": {
                  "headline": "Clears the event ``Id`` terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "supports_event_query", 
               "doc": {
                  "headline": "Tests if an ``EventQuery`` is available.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if an event query is available,\n                ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if an event query is available, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "get_event_query", 
               "doc": {
                  "headline": "Gets the query for an event.", 
                  "body": "        Multiple retrievals produce a nested ``OR`` term."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.EventQuery) - the event query", 
               "error_doc": "        raise:  Unimplemented - ``supports_event_query()`` is ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the event query\n        :rtype: ``osid.calendaring.EventQuery``", 
               "sphinx_error_doc": "        :raise: ``Unimplemented`` -- ``supports_event_query()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_event_query()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.EventQuery", 
               "errors": {
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "match_any_event", 
               "doc": {
                  "headline": "Matches a calendar that has any event assigned.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    match (boolean): ``true`` to match calendars with any\n                event, ``false`` to match calendars with no events\n", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "        :param match: ``true`` to match calendars with any event, ``false`` to match calendars with no events\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "clear_event_terms", 
               "doc": {
                  "headline": "Clears the event terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "match_time_period_id", 
               "doc": {
                  "headline": "Sets the time period ``Id`` for this query.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    time_period_id (osid.id.Id): a time period ``Id``\n        arg:    match (boolean): ``true`` for a positive match,\n                ``false`` for a negative match\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``time_period_id`` is ``null``", 
               "sphinx_param_doc": "        :param time_period_id: a time period ``Id``\n        :type time_period_id: ``osid.id.Id``\n        :param match: ``true`` for a positive match, ``false`` for a negative match\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``time_period_id`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "time_period_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "clear_time_period_id_terms", 
               "doc": {
                  "headline": "Clears the time period ``Id`` terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "supports_time_period_query", 
               "doc": {
                  "headline": "Tests if a ``TimePeriodQuery`` is available.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if a time period query is\n                available, ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if a time period query is available, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "get_time_period_query", 
               "doc": {
                  "headline": "Gets the query for a time period.", 
                  "body": "        Multiple retrievals produce a nested ``OR`` term."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.TimePeriodQuery) - the tiem period\n                query", 
               "error_doc": "        raise:  Unimplemented - ``supports_time_period_query()`` is\n                ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the tiem period query\n        :rtype: ``osid.calendaring.TimePeriodQuery``", 
               "sphinx_error_doc": "        :raise: ``Unimplemented`` -- ``supports_time_period_query()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_time_period_query()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.TimePeriodQuery", 
               "errors": {
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "match_any_time_period", 
               "doc": {
                  "headline": "Matches a calendar that has any time period assigned.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    match (boolean): ``true`` to match calendars with any\n                time period, ``false`` to match calendars with no time\n                periods\n", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "        :param match: ``true`` to match calendars with any time period, ``false`` to match calendars with no time periods\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "clear_time_period_terms", 
               "doc": {
                  "headline": "Clears the time period terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "match_commitment_id", 
               "doc": {
                  "headline": "Sets the commitment ``Id`` for this query.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    commitment_id (osid.id.Id): a commitment ``Id``\n        arg:    match (boolean): ``true`` for a positive match,\n                ``false`` for a negative match\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``commitment_id`` is ``null``", 
               "sphinx_param_doc": "        :param commitment_id: a commitment ``Id``\n        :type commitment_id: ``osid.id.Id``\n        :param match: ``true`` for a positive match, ``false`` for a negative match\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``commitment_id`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "commitment_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "clear_commitment_id_terms", 
               "doc": {
                  "headline": "Clears the commitment ``Id`` terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "supports_commitment_query", 
               "doc": {
                  "headline": "Tests if a ``CommitmentQuery`` is available.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if a commitment query is available,\n                ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if a commitment query is available, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "get_commitment_query", 
               "doc": {
                  "headline": "Gets the query for a commitment.", 
                  "body": "        Multiple retrievals produce a nested ``OR`` term."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.CommitmentQuery) - the commitment\n                query", 
               "error_doc": "        raise:  Unimplemented - ``supports_commitment_query()`` is\n                ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the commitment query\n        :rtype: ``osid.calendaring.CommitmentQuery``", 
               "sphinx_error_doc": "        :raise: ``Unimplemented`` -- ``supports_commitment_query()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_commitment_query()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.CommitmentQuery", 
               "errors": {
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "match_any_commitment", 
               "doc": {
                  "headline": "Matches a calendar that has any event commitment.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    match (boolean): ``true`` to match calendars with any\n                commitment, ``false`` to match calendars with no\n                commitments\n", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "        :param match: ``true`` to match calendars with any commitment, ``false`` to match calendars with no commitments\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "clear_commitment_terms", 
               "doc": {
                  "headline": "Clears the commitment terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "match_ancestor_calendar_id", 
               "doc": {
                  "headline": "Sets the calendar ``Id`` for this query to match calendars that have the specified calendar as an ancestor.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    calendar_id (osid.id.Id): a calendar ``Id``\n        arg:    match (boolean): ``true`` for a positive match,\n                ``false`` for a negative match\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``calendar_id`` is ``null``", 
               "sphinx_param_doc": "        :param calendar_id: a calendar ``Id``\n        :type calendar_id: ``osid.id.Id``\n        :param match: ``true`` for a positive match, ``false`` for a negative match\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``calendar_id`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "calendar_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "clear_ancestor_calendar_id_terms", 
               "doc": {
                  "headline": "Clears the ancestor calendar ``Id`` terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "supports_ancestor_calendar_query", 
               "doc": {
                  "headline": "Tests if a ``CalendarQuery`` is available.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if a calendar query is available,\n                ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if a calendar query is available, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "get_ancestor_calendar_query", 
               "doc": {
                  "headline": "Gets the query for a calendar.", 
                  "body": "        Multiple retrievals produce a nested ``OR`` term."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.CalendarQuery) - the calendar query", 
               "error_doc": "        raise:  Unimplemented - ``supports_ancestor_calendar_query()``\n                is ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the calendar query\n        :rtype: ``osid.calendaring.CalendarQuery``", 
               "sphinx_error_doc": "        :raise: ``Unimplemented`` -- ``supports_ancestor_calendar_query()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_ancestor_calndar_query()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.CalendarQuery", 
               "errors": {
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "match_any_ancestor_calendar", 
               "doc": {
                  "headline": "Matches a calendar that has any ancestor.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    match (boolean): ``true`` to match calendars with any\n                ancestor, ``false`` to match root calendars\n", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "        :param match: ``true`` to match calendars with any ancestor, ``false`` to match root calendars\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "clear_ancestor_calendar_terms", 
               "doc": {
                  "headline": "Clears the ancestor calendar terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "match_descendant_calendar_id", 
               "doc": {
                  "headline": "Sets the calendar ``Id`` for this query to match calendars that have the specified calendar as a descendant.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    calendar_id (osid.id.Id): a calendar ``Id``\n        arg:    match (boolean): ``true`` for a positive match,\n                ``false`` for a negative match\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``calendar_id`` is ``null``", 
               "sphinx_param_doc": "        :param calendar_id: a calendar ``Id``\n        :type calendar_id: ``osid.id.Id``\n        :param match: ``true`` for a positive match, ``false`` for a negative match\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``calendar_id`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "calendar_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "clear_descendant_calendar_id_terms", 
               "doc": {
                  "headline": "Clears the descendant calendar ``Id`` terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "supports_descendant_calendar_query", 
               "doc": {
                  "headline": "Tests if a ``CalendarQuery``.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if a calendar query is available,\n                ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if a calendar query is available, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "get_descendant_calendar_query", 
               "doc": {
                  "headline": "Gets the query for a calendar.", 
                  "body": "        Multiple retrievals produce a nested ``OR`` term."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.CalendarQuery) - the calendar query", 
               "error_doc": "        raise:  Unimplemented - ``supports_descendant_calendar_query()``\n                is ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the calendar query\n        :rtype: ``osid.calendaring.CalendarQuery``", 
               "sphinx_error_doc": "        :raise: ``Unimplemented`` -- ``supports_descendant_calendar_query()`` is ``false``", 
               "compliance_doc": "        *compliance: optional -- This method must be implemented if ``supports_descendant_calndar_query()`` is ``true``.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.CalendarQuery", 
               "errors": {
                  "UNIMPLEMENTED": "ConsumerContract"
               }
            }, 
            {
               "name": "match_any_descendant_calendar", 
               "doc": {
                  "headline": "Matches a calendar that has any descendant.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    match (boolean): ``true`` to match calendars with any\n                descendant, ``false`` to match leaf calendars\n", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "        :param match: ``true`` to match calendars with any descendant, ``false`` to match leaf calendars\n        :type match: ``boolean``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "boolean", 
                     "var_name": "match", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "boolean"
               ], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "clear_descendant_calendar_terms", 
               "doc": {
                  "headline": "Clears the descendant calendar terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "get_calendar_query_record", 
               "doc": {
                  "headline": "Gets the calendar query record corresponding to the given ``Calendar`` record ``Type``.", 
                  "body": "        Multiple record retrievals produce a nested ``OR`` term."
               }, 
               "arg_doc": "        arg:    calendar_record_type (osid.type.Type): a calendar record\n                type\n", 
               "return_doc": "        return: (osid.calendaring.records.CalendarQueryRecord) - the\n                calendar query record", 
               "error_doc": "        raise:  NullArgument - ``calendar_record_type`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unsupported - ``has_record_type(calendar_record_type)``\n                is ``false``", 
               "sphinx_param_doc": "        :param calendar_record_type: a calendar record type\n        :type calendar_record_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "        :return: the calendar query record\n        :rtype: ``osid.calendaring.records.CalendarQueryRecord``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``calendar_record_type`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unsupported`` -- ``has_record_type(calendar_record_type)`` is ``false``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "calendar_record_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "osid.calendaring.records.CalendarQueryRecord", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.calendaring.records.CalendarQueryRecord", 
         "shortname": "CalendarQueryRecord", 
         "category": "records", 
         "doc": {
            "headline": "A record for a ``CalendarQuery``.", 
            "body": "    The methods specified by the record type are available through the\n    underlying object."
         }, 
         "inherit_fullnames": [
            "osid.OsidRecord"
         ], 
         "inherit_shortnames": [
            "OsidRecord"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidRecord"
            }
         ], 
         "method_names": [], 
         "methods": []
      }, 
      {
         "fullname": "osid.calendaring.CalendarQueryInspector", 
         "shortname": "CalendarQueryInspector", 
         "category": "query_inspectors", 
         "doc": {
            "headline": "This is the query inspector for examining calendar queries.", 
            "body": ""
         }, 
         "inherit_fullnames": [
            "osid.OsidCatalogQueryInspector"
         ], 
         "inherit_shortnames": [
            "OsidCatalogQueryInspector"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidCatalogQueryInspector"
            }
         ], 
         "method_names": [
            "get_event_id_terms", 
            "get_event_terms", 
            "get_time_period_id_terms", 
            "get_time_period_terms", 
            "get_commitment_id_terms", 
            "get_commitment_terms", 
            "get_ancestor_calendar_id_terms", 
            "get_ancestor_calendar_terms", 
            "get_descendant_calendar_id_terms", 
            "get_descendant_calendar_terms", 
            "get_calendar_query_inspector_record"
         ], 
         "methods": [
            {
               "name": "get_event_id_terms", 
               "doc": {
                  "headline": "Gets the event ``Id`` terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.search.terms.IdTerm) - the event ``Id`` terms", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the event ``Id`` terms\n        :rtype: ``osid.search.terms.IdTerm``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.search.terms.IdTerm", 
               "errors": {}
            }, 
            {
               "name": "get_event_terms", 
               "doc": {
                  "headline": "Gets the event terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.EventQueryInspector) - the event terms", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the event terms\n        :rtype: ``osid.calendaring.EventQueryInspector``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.EventQueryInspector", 
               "errors": {}
            }, 
            {
               "name": "get_time_period_id_terms", 
               "doc": {
                  "headline": "Gets the time period ``Id`` terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.search.terms.IdTerm) - the time period ``Id``\n                terms", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the time period ``Id`` terms\n        :rtype: ``osid.search.terms.IdTerm``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.search.terms.IdTerm", 
               "errors": {}
            }, 
            {
               "name": "get_time_period_terms", 
               "doc": {
                  "headline": "Gets the time period terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.TimePeriodQueryInspector) - the time\n                period terms", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the time period terms\n        :rtype: ``osid.calendaring.TimePeriodQueryInspector``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.TimePeriodQueryInspector", 
               "errors": {}
            }, 
            {
               "name": "get_commitment_id_terms", 
               "doc": {
                  "headline": "Gets the commitment ``Id`` terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.search.terms.IdTerm) - the commitment ``Id`` terms", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the commitment ``Id`` terms\n        :rtype: ``osid.search.terms.IdTerm``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.search.terms.IdTerm", 
               "errors": {}
            }, 
            {
               "name": "get_commitment_terms", 
               "doc": {
                  "headline": "Gets the commitment terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.CommitmentQueryInspector) - the\n                commitment terms", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the commitment terms\n        :rtype: ``osid.calendaring.CommitmentQueryInspector``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.CommitmentQueryInspector", 
               "errors": {}
            }, 
            {
               "name": "get_ancestor_calendar_id_terms", 
               "doc": {
                  "headline": "Gets the ancestor calendar ``Id`` terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.search.terms.IdTerm) - the ancestor calendar\n                ``Id`` terms", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the ancestor calendar ``Id`` terms\n        :rtype: ``osid.search.terms.IdTerm``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.search.terms.IdTerm", 
               "errors": {}
            }, 
            {
               "name": "get_ancestor_calendar_terms", 
               "doc": {
                  "headline": "Gets the ancestor calendar terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.CalendarQueryInspector) - the ancestor\n                calendar terms", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the ancestor calendar terms\n        :rtype: ``osid.calendaring.CalendarQueryInspector``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.CalendarQueryInspector", 
               "errors": {}
            }, 
            {
               "name": "get_descendant_calendar_id_terms", 
               "doc": {
                  "headline": "Gets the descendant calendar ``Id`` terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.search.terms.IdTerm) - the descendant calendar\n                ``Id`` terms", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the descendant calendar ``Id`` terms\n        :rtype: ``osid.search.terms.IdTerm``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.search.terms.IdTerm", 
               "errors": {}
            }, 
            {
               "name": "get_descendant_calendar_terms", 
               "doc": {
                  "headline": "Gets the descendant calendar terms.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.CalendarQueryInspector) - the\n                descendant calendar terms", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the descendant calendar terms\n        :rtype: ``osid.calendaring.CalendarQueryInspector``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.CalendarQueryInspector", 
               "errors": {}
            }, 
            {
               "name": "get_calendar_query_inspector_record", 
               "doc": {
                  "headline": "Gets the calendar query inspector record corresponding to the given ``Calendar`` record ``Type``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    calendar_record_type (osid.type.Type): a calendar record\n                type\n", 
               "return_doc": "        return: (osid.calendaring.records.CalendarQueryInspectorRecord)\n                - the calendar query inspector record", 
               "error_doc": "        raise:  NullArgument - ``calendar_record_type`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unsupported - ``has_record_type(calendar_record_type)``\n                is ``false``", 
               "sphinx_param_doc": "        :param calendar_record_type: a calendar record type\n        :type calendar_record_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "        :return: the calendar query inspector record\n        :rtype: ``osid.calendaring.records.CalendarQueryInspectorRecord``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``calendar_record_type`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unsupported`` -- ``has_record_type(calendar_record_type)`` is ``false``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "calendar_record_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "osid.calendaring.records.CalendarQueryInspectorRecord", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.calendaring.records.CalendarQueryInspectorRecord", 
         "shortname": "CalendarQueryInspectorRecord", 
         "category": "records", 
         "doc": {
            "headline": "A record for a ``CalendarQueryInspector``.", 
            "body": "    The methods specified by the record type are available through the\n    underlying object."
         }, 
         "inherit_fullnames": [
            "osid.OsidRecord"
         ], 
         "inherit_shortnames": [
            "OsidRecord"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidRecord"
            }
         ], 
         "method_names": [], 
         "methods": []
      }, 
      {
         "fullname": "osid.calendaring.CalendarForm", 
         "shortname": "CalendarForm", 
         "category": "objects", 
         "doc": {
            "headline": "This is the form for creating and updating calendars.", 
            "body": "    Like all ``OsidForm`` objects, various data elements may be set here\n    for use in the create and update methods in the\n    ``CalendarAdminSession``. For each data element that may be set,\n    metadata may be examined to provide display hints or data\n    constraints."
         }, 
         "inherit_fullnames": [
            "osid.OsidCatalogForm"
         ], 
         "inherit_shortnames": [
            "OsidCatalogForm"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidCatalogForm"
            }
         ], 
         "method_names": [
            "get_calendar_form_record"
         ], 
         "methods": [
            {
               "name": "get_calendar_form_record", 
               "doc": {
                  "headline": "Gets the ``CalendarFormRecord`` corresponding to the given calendar record ``Type``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    calendar_record_type (osid.type.Type): a calendar record\n                type\n", 
               "return_doc": "        return: (osid.calendaring.records.CalendarFormRecord) - the\n                calendar form record", 
               "error_doc": "        raise:  NullArgument - ``calendar_record_type`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unsupported - ``has_record_type(calendar_record_type)``\n                is ``false``", 
               "sphinx_param_doc": "        :param calendar_record_type: a calendar record type\n        :type calendar_record_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "        :return: the calendar form record\n        :rtype: ``osid.calendaring.records.CalendarFormRecord``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``calendar_record_type`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unsupported`` -- ``has_record_type(calendar_record_type)`` is ``false``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "calendar_record_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "osid.calendaring.records.CalendarFormRecord", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.calendaring.records.CalendarFormRecord", 
         "shortname": "CalendarFormRecord", 
         "category": "records", 
         "doc": {
            "headline": "A record for a ``CalendarForm``.", 
            "body": "    The methods specified by the record type are available through the\n    underlying object."
         }, 
         "inherit_fullnames": [
            "osid.OsidRecord"
         ], 
         "inherit_shortnames": [
            "OsidRecord"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidRecord"
            }
         ], 
         "method_names": [], 
         "methods": []
      }, 
      {
         "fullname": "osid.calendaring.CalendarSearchOrder", 
         "shortname": "CalendarSearchOrder", 
         "category": "search_orders", 
         "doc": {
            "headline": "An interface for specifying the ordering of search results.", 
            "body": ""
         }, 
         "inherit_fullnames": [
            "osid.OsidCatalogSearchOrder"
         ], 
         "inherit_shortnames": [
            "OsidCatalogSearchOrder"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidCatalogSearchOrder"
            }
         ], 
         "method_names": [
            "get_calendar_search_order_record"
         ], 
         "methods": [
            {
               "name": "get_calendar_search_order_record", 
               "doc": {
                  "headline": "Gets the calendar search order record corresponding to the given calendar record ``Type``.", 
                  "body": "        Multiple retrievals return the same underlying object."
               }, 
               "arg_doc": "        arg:    calendar_record_type (osid.type.Type): a calendar record\n                type\n", 
               "return_doc": "        return: (osid.calendaring.records.CalendarSearchOrderRecord) -\n                the calendar search order record", 
               "error_doc": "        raise:  NullArgument - ``calendar_record_type`` is ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unsupported - ``has_record_type(calendar_record_type)``\n                is ``false``", 
               "sphinx_param_doc": "        :param calendar_record_type: a calendar record type\n        :type calendar_record_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "        :return: the calendar search order record\n        :rtype: ``osid.calendaring.records.CalendarSearchOrderRecord``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``calendar_record_type`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unsupported`` -- ``has_record_type(calendar_record_type)`` is ``false``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "calendar_record_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "osid.calendaring.records.CalendarSearchOrderRecord", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.calendaring.records.CalendarSearchOrderRecord", 
         "shortname": "CalendarSearchOrderRecord", 
         "category": "records", 
         "doc": {
            "headline": "A record for a ``CalendarSearchOrder``.", 
            "body": "    The methods specified by the record type are available through the\n    underlying object."
         }, 
         "inherit_fullnames": [
            "osid.OsidRecord"
         ], 
         "inherit_shortnames": [
            "OsidRecord"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidRecord"
            }
         ], 
         "method_names": [], 
         "methods": []
      }, 
      {
         "fullname": "osid.calendaring.CalendarSearch", 
         "shortname": "CalendarSearch", 
         "category": "searches", 
         "doc": {
            "headline": "The interface for governing calendar searches.", 
            "body": ""
         }, 
         "inherit_fullnames": [
            "osid.OsidSearch"
         ], 
         "inherit_shortnames": [
            "OsidSearch"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidSearch"
            }
         ], 
         "method_names": [
            "search_among_calendars", 
            "order_calendar_results", 
            "get_calendar_search_record"
         ], 
         "methods": [
            {
               "name": "search_among_calendars", 
               "doc": {
                  "headline": "Execute this search among the given list of calendars.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    calendar_ids (osid.id.IdList): list of calendars\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``calendar_ids`` is ``null``", 
               "sphinx_param_doc": "        :param calendar_ids: list of calendars\n        :type calendar_ids: ``osid.id.IdList``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``calendar_ids`` is ``null``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.IdList", 
                     "var_name": "calendar_ids", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.IdList"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract"
               }
            }, 
            {
               "name": "order_calendar_results", 
               "doc": {
                  "headline": "Specify an ordering to the search results.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    calendar_search_order\n                (osid.calendaring.CalendarSearchOrder): calendar search\n                order\n", 
               "return_doc": "", 
               "error_doc": "        raise:  NullArgument - ``calendar_search_order`` is ``null``\n        raise:  Unsupported - ``calendar_search_order`` is not of this\n                service", 
               "sphinx_param_doc": "        :param calendar_search_order: calendar search order\n        :type calendar_search_order: ``osid.calendaring.CalendarSearchOrder``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``calendar_search_order`` is ``null``\n        :raise: ``Unsupported`` -- ``calendar_search_order`` is not of this service", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.calendaring.CalendarSearchOrder", 
                     "var_name": "calendar_search_order", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.calendaring.CalendarSearchOrder"
               ], 
               "return_type": "", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }, 
            {
               "name": "get_calendar_search_record", 
               "doc": {
                  "headline": "Gets the calendar search record corresponding to the given calendar search record ``Type``.", 
                  "body": "        This method is used to retrieve an object implementing the\n        requested record."
               }, 
               "arg_doc": "        arg:    calendar_search_record_type (osid.type.Type): a calendar\n                search record type\n", 
               "return_doc": "        return: (osid.calendaring.records.CalendarSearchRecord) - the\n                calendar search interface", 
               "error_doc": "        raise:  NullArgument - ``calendar_search_record_type`` is\n                ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unsupported -\n                ``has_record_type(calendar_search_record_type)`` is\n                ``false``", 
               "sphinx_param_doc": "        :param calendar_search_record_type: a calendar search record type\n        :type calendar_search_record_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "        :return: the calendar search interface\n        :rtype: ``osid.calendaring.records.CalendarSearchRecord``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``calendar_search_record_type`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unsupported`` -- ``has_record_type(calendar_search_record_type)`` is ``false``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "calendar_search_record_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "osid.calendaring.records.CalendarSearchRecord", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.calendaring.records.CalendarSearchRecord", 
         "shortname": "CalendarSearchRecord", 
         "category": "records", 
         "doc": {
            "headline": "A record for a ``CalendarSearch``.", 
            "body": "    The methods specified by the record type are available through the\n    underlying object."
         }, 
         "inherit_fullnames": [
            "osid.OsidRecord"
         ], 
         "inherit_shortnames": [
            "OsidRecord"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidRecord"
            }
         ], 
         "method_names": [], 
         "methods": []
      }, 
      {
         "fullname": "osid.calendaring.CalendarSearchResults", 
         "shortname": "CalendarSearchResults", 
         "category": "searches", 
         "doc": {
            "headline": "This interface provides a means to capture results of a search.", 
            "body": ""
         }, 
         "inherit_fullnames": [
            "osid.OsidSearchResults"
         ], 
         "inherit_shortnames": [
            "OsidSearchResults"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidSearchResults"
            }
         ], 
         "method_names": [
            "get_calendars", 
            "get_calendar_query_inspector", 
            "get_calendar_search_results_record"
         ], 
         "methods": [
            {
               "name": "get_calendars", 
               "doc": {
                  "headline": "Gets the calendar list resulting from the search.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.CalendarList) - the calendar list", 
               "error_doc": "        raise:  IllegalState - list already retrieved", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the calendar list\n        :rtype: ``osid.calendaring.CalendarList``", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- list already retrieved", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.CalendarList", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract"
               }
            }, 
            {
               "name": "get_calendar_query_inspector", 
               "doc": {
                  "headline": "Gets the inspector for the query to examine the terms used in the search.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.CalendarQueryInspector) - the calendar\n                query inspector", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the calendar query inspector\n        :rtype: ``osid.calendaring.CalendarQueryInspector``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.CalendarQueryInspector", 
               "errors": {}
            }, 
            {
               "name": "get_calendar_search_results_record", 
               "doc": {
                  "headline": "Gets the calendar search results record corresponding to the given calendar search record ``Type``.", 
                  "body": "        This method is used to retrieve an object implementing the\n        requested record."
               }, 
               "arg_doc": "        arg:    calendar_search_record_type (osid.type.Type): a calendar\n                search record type\n", 
               "return_doc": "        return: (osid.calendaring.records.CalendarSearchResultsRecord) -\n                the calendar search results record", 
               "error_doc": "        raise:  NullArgument - ``calendar_search_record_type`` is\n                ``null``\n        raise:  OperationFailed - unable to complete request\n        raise:  Unsupported -\n                ``has_record_type(calendar_search_record_type)`` is\n                ``false``", 
               "sphinx_param_doc": "        :param calendar_search_record_type: a calendar search record type\n        :type calendar_search_record_type: ``osid.type.Type``\n", 
               "sphinx_return_doc": "        :return: the calendar search results record\n        :rtype: ``osid.calendaring.records.CalendarSearchResultsRecord``", 
               "sphinx_error_doc": "        :raise: ``NullArgument`` -- ``calendar_search_record_type`` is ``null``\n        :raise: ``OperationFailed`` -- unable to complete request\n        :raise: ``Unsupported`` -- ``has_record_type(calendar_search_record_type)`` is ``false``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.type.Type", 
                     "var_name": "calendar_search_record_type", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.type.Type"
               ], 
               "return_type": "osid.calendaring.records.CalendarSearchResultsRecord", 
               "errors": {
                  "NULL_ARGUMENT": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational", 
                  "UNSUPPORTED": "ConsumerContract"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.calendaring.records.CalendarSearchResultsRecord", 
         "shortname": "CalendarSearchResultsRecord", 
         "category": "records", 
         "doc": {
            "headline": "A record for a ``CalendarSearchResults``.", 
            "body": "    The methods specified by the record type are available through the\n    underlying object."
         }, 
         "inherit_fullnames": [
            "osid.OsidRecord"
         ], 
         "inherit_shortnames": [
            "OsidRecord"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidRecord"
            }
         ], 
         "method_names": [], 
         "methods": []
      }, 
      {
         "fullname": "osid.calendaring.CalendarReceiver", 
         "shortname": "CalendarReceiver", 
         "category": "receivers", 
         "doc": {
            "headline": "The vault receiver is the consumer supplied interface for receiving notifications pertaining to new, updated or deleted ``Calendar`` objects.", 
            "body": ""
         }, 
         "inherit_fullnames": [
            "osid.OsidReceiver"
         ], 
         "inherit_shortnames": [
            "OsidReceiver"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidReceiver"
            }
         ], 
         "method_names": [
            "new_calendar", 
            "new_ancestor_calendar", 
            "new_descendant_calendar", 
            "changed_calendar", 
            "deleted_calendar", 
            "deleted_ancestor_calendar", 
            "deleted_descendant_calendar"
         ], 
         "methods": [
            {
               "name": "new_calendar", 
               "doc": {
                  "headline": "The callback for notifications of new calendars.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    calendar_id (osid.id.Id): the ``Id`` of the new\n                ``Calendar``\n", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "        :param calendar_id: the ``Id`` of the new ``Calendar``\n        :type calendar_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "calendar_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "new_ancestor_calendar", 
               "doc": {
                  "headline": "The callback for notifications of new calendar ancestors.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    calendar_id (osid.id.Id): the ``Id`` of the ``Calendar``\n        arg:    ancestor_id (osid.id.Id):\n                ``has_record_type(calendar_record_type) is false``\n", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "        :param calendar_id: the ``Id`` of the ``Calendar``\n        :type calendar_id: ``osid.id.Id``\n        :param ancestor_id: ``has_record_type(calendar_record_type) is false``\n        :type ancestor_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "calendar_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "ancestor_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "new_descendant_calendar", 
               "doc": {
                  "headline": "The callback for notifications of new calendar descendants.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    calendar_id (osid.id.Id): the ``Id`` of the ``Calendar``\n        arg:    descendant_id (osid.id.Id): the ``Id`` of the new\n                ``Calendar`` descendant\n", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "        :param calendar_id: the ``Id`` of the ``Calendar``\n        :type calendar_id: ``osid.id.Id``\n        :param descendant_id: the ``Id`` of the new ``Calendar`` descendant\n        :type descendant_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "calendar_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "descendant_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "changed_calendar", 
               "doc": {
                  "headline": "The callback for notification of updated calendars.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    calendar_id (osid.id.Id): the ``Id`` of the updated\n                ``Calendar``\n", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "        :param calendar_id: the ``Id`` of the updated ``Calendar``\n        :type calendar_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "calendar_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "deleted_calendar", 
               "doc": {
                  "headline": "The callback for notification of deleted calendars.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    calendar_id (osid.id.Id): the ``Id`` of the deleted\n                ``Calendar``\n", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "        :param calendar_id: the ``Id`` of the deleted ``Calendar``\n        :type calendar_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "calendar_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "deleted_ancestor_calendar", 
               "doc": {
                  "headline": "The callback for notifications of deleted calendar ancestors.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    calendar_id (osid.id.Id): the ``Id`` of the ``Calendar``\n        arg:    ancestor_id (osid.id.Id): the ``Id`` of the removed\n                ``Calendar`` ancestor\n", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "        :param calendar_id: the ``Id`` of the ``Calendar``\n        :type calendar_id: ``osid.id.Id``\n        :param ancestor_id: the ``Id`` of the removed ``Calendar`` ancestor\n        :type ancestor_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "calendar_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "ancestor_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {}
            }, 
            {
               "name": "deleted_descendant_calendar", 
               "doc": {
                  "headline": "The callback for notifications of deleted calendar descendants.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    calendar_id (osid.id.Id): the ``Id`` of the ``Calendar``\n        arg:    descendant_id (osid.id.Id): the ``Id`` of the removed\n                ``Calendar`` descendant\n", 
               "return_doc": "", 
               "error_doc": "", 
               "sphinx_param_doc": "        :param calendar_id: the ``Id`` of the ``Calendar``\n        :type calendar_id: ``osid.id.Id``\n        :param descendant_id: the ``Id`` of the removed ``Calendar`` descendant\n        :type descendant_id: ``osid.id.Id``\n", 
               "sphinx_return_doc": "", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "calendar_id", 
                     "array": false
                  }, 
                  {
                     "arg_type": "osid.id.Id", 
                     "var_name": "descendant_id", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "osid.id.Id", 
                  "osid.id.Id"
               ], 
               "return_type": "", 
               "errors": {}
            }
         ]
      }, 
      {
         "fullname": "osid.calendaring.CalendarList", 
         "shortname": "CalendarList", 
         "category": "objects", 
         "doc": {
            "headline": "Like all ``OsidLists,``  ``CalendarList`` provides a means for accessing ``Calendar`` elements sequentially either one at a time or many at a time.", 
            "body": "    Examples: while (cl.hasNext()) { Calendar calendar =\n    cl.getNextCalendar(); }\n\n    or\n      while (cl.hasNext()) {\n           Calendar[] calendars = cl.getNextCalendars(cl.available());\n      }\n    \n"
         }, 
         "inherit_fullnames": [
            "osid.OsidList"
         ], 
         "inherit_shortnames": [
            "OsidList"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidList"
            }
         ], 
         "method_names": [
            "get_next_calendar", 
            "get_next_calendars"
         ], 
         "methods": [
            {
               "name": "get_next_calendar", 
               "doc": {
                  "headline": "Gets the next ``Calendar`` in this list.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.Calendar) - the next ``Calendar`` in\n                this list. The ``has_next()`` method should be used to\n                test that a next ``Calendar`` is available before\n                calling this method.", 
               "error_doc": "        raise:  IllegalState - no more elements available in this list\n        raise:  OperationFailed - unable to complete request", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the next ``Calendar`` in this list. The ``has_next()`` method should be used to test that a next ``Calendar`` is available before calling this method.\n        :rtype: ``osid.calendaring.Calendar``", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- no more elements available in this list\n        :raise: ``OperationFailed`` -- unable to complete request", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.Calendar", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational"
               }
            }, 
            {
               "name": "get_next_calendars", 
               "doc": {
                  "headline": "Gets the next set of ``Calendar`` elements in this list which must be less than or equal to the return from ``available()``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    n (cardinal): the number of ``Calendar`` elements\n                requested which must be less than or equal to\n                ``available()``\n", 
               "return_doc": "        return: (osid.calendaring.Calendar) - an array of ``Calendar``\n                elements.The length of the array is less than or equal\n                to the number specified.", 
               "error_doc": "        raise:  IllegalState - no more elements available in this list\n        raise:  OperationFailed - unable to complete request", 
               "sphinx_param_doc": "        :param n: the number of ``Calendar`` elements requested which must be less than or equal to ``available()``\n        :type n: ``cardinal``\n", 
               "sphinx_return_doc": "        :return: an array of ``Calendar`` elements.The length of the array is less than or equal to the number specified.\n        :rtype: ``osid.calendaring.Calendar``", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- no more elements available in this list\n        :raise: ``OperationFailed`` -- unable to complete request", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "cardinal", 
                     "var_name": "n", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "cardinal"
               ], 
               "return_type": "osid.calendaring.Calendar", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.calendaring.CalendarNode", 
         "shortname": "CalendarNode", 
         "category": "objects", 
         "doc": {
            "headline": "This interface is a container for a partial hierarchy retrieval.", 
            "body": "    The number of hierarchy levels traversable through this interface\n    depend on the number of levels requested in the\n    ``CalendarHierarchySession``."
         }, 
         "inherit_fullnames": [
            "osid.OsidNode"
         ], 
         "inherit_shortnames": [
            "OsidNode"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidNode"
            }
         ], 
         "method_names": [
            "get_calendar", 
            "get_parent_calendar_nodes", 
            "get_child_calendar_nodes"
         ], 
         "methods": [
            {
               "name": "get_calendar", 
               "doc": {
                  "headline": "Gets the ``Calendar`` at this node.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.Calendar) - the calendar represented\n                by this node", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the calendar represented by this node\n        :rtype: ``osid.calendaring.Calendar``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.Calendar", 
               "errors": {}
            }, 
            {
               "name": "get_parent_calendar_nodes", 
               "doc": {
                  "headline": "Gets the parents of this calendar.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.CalendarNodeList) - the parents of the\n                ``id``", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the parents of the ``id``\n        :rtype: ``osid.calendaring.CalendarNodeList``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.CalendarNodeList", 
               "errors": {}
            }, 
            {
               "name": "get_child_calendar_nodes", 
               "doc": {
                  "headline": "Gets the children of this calendar.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.CalendarNodeList) - the children of\n                this calendar", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the children of this calendar\n        :rtype: ``osid.calendaring.CalendarNodeList``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.CalendarNodeList", 
               "errors": {}
            }
         ]
      }, 
      {
         "fullname": "osid.calendaring.CalendarNodeList", 
         "shortname": "CalendarNodeList", 
         "category": "objects", 
         "doc": {
            "headline": "Like all ``OsidLists,``  ``CalendarNodeList`` provides a means for accessing ``CalendarNode`` elements sequentially either one at a time or many at a time.", 
            "body": "    Examples: while (cnl.hasNext()) { CalendarNode node =\n    cnl.getNextCalendarNode(); }\n\n    or\n      while (cnl.hasNext()) {\n           CalendarNode[] nodes = cnl.getNextCalendarNodes(cnl.available());\n      }\n    \n"
         }, 
         "inherit_fullnames": [
            "osid.OsidList"
         ], 
         "inherit_shortnames": [
            "OsidList"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidList"
            }
         ], 
         "method_names": [
            "get_next_calendar_node", 
            "get_next_calendar_nodes"
         ], 
         "methods": [
            {
               "name": "get_next_calendar_node", 
               "doc": {
                  "headline": "Gets the next ``CalendarNode`` in this list.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.CalendarNode) - the next\n                ``CalendarNode`` in this list. The ``has_next()`` method\n                should be used to test that a next ``CalendarNode`` is\n                available before calling this method.", 
               "error_doc": "        raise:  IllegalState - no more elements available in this list\n        raise:  OperationFailed - unable to complete request", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the next ``CalendarNode`` in this list. The ``has_next()`` method should be used to test that a next ``CalendarNode`` is available before calling this method.\n        :rtype: ``osid.calendaring.CalendarNode``", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- no more elements available in this list\n        :raise: ``OperationFailed`` -- unable to complete request", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.CalendarNode", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational"
               }
            }, 
            {
               "name": "get_next_calendar_nodes", 
               "doc": {
                  "headline": "Gets the next set of ``CalendarNode`` elements in this list which must be less than or equal to the return from ``available()``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    n (cardinal): the number of ``CalendarNode`` elements\n                requested which must be less than or equal to\n                ``available()``\n", 
               "return_doc": "        return: (osid.calendaring.CalendarNode) - an array of\n                ``CalendarNode`` elements.The length of the array is\n                less than or equal to the number specified.", 
               "error_doc": "        raise:  IllegalState - no more elements available in this list\n        raise:  OperationFailed - unable to complete request", 
               "sphinx_param_doc": "        :param n: the number of ``CalendarNode`` elements requested which must be less than or equal to ``available()``\n        :type n: ``cardinal``\n", 
               "sphinx_return_doc": "        :return: an array of ``CalendarNode`` elements.The length of the array is less than or equal to the number specified.\n        :rtype: ``osid.calendaring.CalendarNode``", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- no more elements available in this list\n        :raise: ``OperationFailed`` -- unable to complete request", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "cardinal", 
                     "var_name": "n", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "cardinal"
               ], 
               "return_type": "osid.calendaring.CalendarNode", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.calendaring.MeetingTime", 
         "shortname": "MeetingTime", 
         "category": "objects", 
         "doc": {
            "headline": "An individual meeting time.", 
            "body": ""
         }, 
         "inherit_fullnames": [
            "osid.OsidCapsule"
         ], 
         "inherit_shortnames": [
            "OsidCapsule"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidCapsule"
            }
         ], 
         "method_names": [
            "get_date", 
            "get_location_description", 
            "has_location", 
            "get_location_id", 
            "get_location"
         ], 
         "methods": [
            {
               "name": "get_date", 
               "doc": {
                  "headline": "Gets the date.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.DateTime) - the date", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the date\n        :rtype: ``osid.calendaring.DateTime``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.DateTime", 
               "errors": {}
            }, 
            {
               "name": "get_location_description", 
               "doc": {
                  "headline": "Gets a descriptive text for the location.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.locale.DisplayText) - a location description", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: a location description\n        :rtype: ``osid.locale.DisplayText``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.locale.DisplayText", 
               "errors": {}
            }, 
            {
               "name": "has_location", 
               "doc": {
                  "headline": "Tests if a location is available.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if a location is available,\n                ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if a location is available, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "get_location_id", 
               "doc": {
                  "headline": "Gets the location ``Id``.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.id.Id) - a location ``Id``", 
               "error_doc": "        raise:  IllegalState - ``has_location()`` is ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: a location ``Id``\n        :rtype: ``osid.id.Id``", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- ``has_location()`` is ``false``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.id.Id", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract"
               }
            }, 
            {
               "name": "get_location", 
               "doc": {
                  "headline": "Gets the ``Location``.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.mapping.Location) - a location", 
               "error_doc": "        raise:  IllegalState - ``has_location()`` is ``false``\n        raise:  OperationFailed - unable to complete request", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: a location\n        :rtype: ``osid.mapping.Location``", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- ``has_location()`` is ``false``\n        :raise: ``OperationFailed`` -- unable to complete request", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.mapping.Location", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.calendaring.MeetingTimeList", 
         "shortname": "MeetingTimeList", 
         "category": "objects", 
         "doc": {
            "headline": "Like all ``OsidLists,``  ``MeetingTimeList`` provides a means for accessing ``MeetingTime`` elements sequentially either one at a time or many at a time.", 
            "body": "    Examples: while (mtl.hasNext()) { MeetingTime time =\n    mtl.getNextMeetingTime(); }\n\n    or\n      while (mtl.hasNext()) {\n           MeetingTime[] times = mtl.getNextMeetingTimes(mtl.available());\n      }\n    \n"
         }, 
         "inherit_fullnames": [
            "osid.OsidList"
         ], 
         "inherit_shortnames": [
            "OsidList"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidList"
            }
         ], 
         "method_names": [
            "get_next_meeting_time", 
            "get_next_meeting_times"
         ], 
         "methods": [
            {
               "name": "get_next_meeting_time", 
               "doc": {
                  "headline": "Gets the next ``MeetingTime`` in this list.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.MeetingTime) - the next\n                ``MeetingTime`` in this list. The ``has_next()`` method\n                should be used to test that a next ``MeetingTime`` is\n                available before calling this method.", 
               "error_doc": "        raise:  IllegalState - no more elements available in this list\n        raise:  OperationFailed - unable to complete request", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the next ``MeetingTime`` in this list. The ``has_next()`` method should be used to test that a next ``MeetingTime`` is available before calling this method.\n        :rtype: ``osid.calendaring.MeetingTime``", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- no more elements available in this list\n        :raise: ``OperationFailed`` -- unable to complete request", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.MeetingTime", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational"
               }
            }, 
            {
               "name": "get_next_meeting_times", 
               "doc": {
                  "headline": "Gets the next set of ``MeetingTime`` elements in this list which must be less than or equal to the number returned from ``available()``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    n (cardinal): the number of ``MeetingTime`` elements\n                requested which should be less than or equal to\n                ``available()``\n", 
               "return_doc": "        return: (osid.calendaring.MeetingTime) - an array of\n                ``MeetingTime`` elements.The length of the array is less\n                than or equal to the number specified.", 
               "error_doc": "        raise:  IllegalState - no more elements available in this list\n        raise:  OperationFailed - unable to complete request", 
               "sphinx_param_doc": "        :param n: the number of ``MeetingTime`` elements requested which should be less than or equal to ``available()``\n        :type n: ``cardinal``\n", 
               "sphinx_return_doc": "        :return: an array of ``MeetingTime`` elements.The length of the array is less than or equal to the number specified.\n        :rtype: ``osid.calendaring.MeetingTime``", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- no more elements available in this list\n        :raise: ``OperationFailed`` -- unable to complete request", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "cardinal", 
                     "var_name": "n", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "cardinal"
               ], 
               "return_type": "osid.calendaring.MeetingTime", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.calendaring.Time", 
         "shortname": "Time", 
         "category": "primitives", 
         "doc": {
            "headline": "The ``Time`` interface defines a time.", 
            "body": ""
         }, 
         "inherit_fullnames": [
            "osid.OsidPrimitive"
         ], 
         "inherit_shortnames": [
            "OsidPrimitive"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidPrimitive"
            }
         ], 
         "method_names": [
            "get_time_type", 
            "get_hour", 
            "get_minute", 
            "get_second", 
            "get_milliseconds", 
            "get_microseconds", 
            "get_nanoseconds", 
            "get_picoseconds", 
            "get_femtoseconds", 
            "get_attoseconds", 
            "get_zeptoseconds", 
            "get_yoctoseconds", 
            "get_xoxxoseconds", 
            "get_weebleseconds", 
            "get_vatoseconds", 
            "get_undaseconds", 
            "get_planck_seconds", 
            "get_granularity", 
            "get_granularity_multiplier"
         ], 
         "methods": [
            {
               "name": "get_time_type", 
               "doc": {
                  "headline": "Gets the time type.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.type.Type) - the time type", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the time type\n        :rtype: ``osid.type.Type``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.type.Type", 
               "errors": {}
            }, 
            {
               "name": "get_hour", 
               "doc": {
                  "headline": "Gets the hour of the day 0-23.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (cardinal) - the hour of the day", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the hour of the day\n        :rtype: ``cardinal``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "cardinal", 
               "errors": {}
            }, 
            {
               "name": "get_minute", 
               "doc": {
                  "headline": "Gets the minute of the hour 0-59.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (cardinal) - the minute of the hour", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the minute of the hour\n        :rtype: ``cardinal``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "cardinal", 
               "errors": {}
            }, 
            {
               "name": "get_second", 
               "doc": {
                  "headline": "Gets the second of the minute 0-59.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (cardinal) - the second of the minute", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the second of the minute\n        :rtype: ``cardinal``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "cardinal", 
               "errors": {}
            }, 
            {
               "name": "get_milliseconds", 
               "doc": {
                  "headline": "Gets the number of milliseconds in this second 0-999.", 
                  "body": "        A millisecond is one thousandth of a second."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (cardinal) - the milliseconds of the second", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the milliseconds of the second\n        :rtype: ``cardinal``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "cardinal", 
               "errors": {}
            }, 
            {
               "name": "get_microseconds", 
               "doc": {
                  "headline": "Gets the number of microseconds of the second 0-999.", 
                  "body": "        A microsecond is one millionth of a second."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (cardinal) - the micrseconds of the millisecond", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the micrseconds of the millisecond\n        :rtype: ``cardinal``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "cardinal", 
               "errors": {}
            }, 
            {
               "name": "get_nanoseconds", 
               "doc": {
                  "headline": "Gets the number of nanoseconds of the microsecond 0-999.", 
                  "body": "        A nanosecond is one billionth of a second."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (cardinal) - the nanoseconds of the microsecond", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the nanoseconds of the microsecond\n        :rtype: ``cardinal``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "cardinal", 
               "errors": {}
            }, 
            {
               "name": "get_picoseconds", 
               "doc": {
                  "headline": "Gets the number of picoseconds of the nanosecond 0-999.", 
                  "body": "        A picosecond is one trillionth of a second."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (cardinal) - the picoseconds of the nanosecond", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the picoseconds of the nanosecond\n        :rtype: ``cardinal``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "cardinal", 
               "errors": {}
            }, 
            {
               "name": "get_femtoseconds", 
               "doc": {
                  "headline": "Gets the number of femtoseconds of the picosecond 0-999.", 
                  "body": "        A femtosecond is one quadrillionth of a second."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (cardinal) - the femtoseconds of the picosecond", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the femtoseconds of the picosecond\n        :rtype: ``cardinal``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "cardinal", 
               "errors": {}
            }, 
            {
               "name": "get_attoseconds", 
               "doc": {
                  "headline": "Gets the number of attoseconds of the femtoseconds 0-999.", 
                  "body": "        An attosecond is one quintillionth of a second."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (cardinal) - the attoseconds of the femtosecond", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the attoseconds of the femtosecond\n        :rtype: ``cardinal``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "cardinal", 
               "errors": {}
            }, 
            {
               "name": "get_zeptoseconds", 
               "doc": {
                  "headline": "Gets the number of zeptoseconds of the attosecond 0-999.", 
                  "body": "        A zeptosecond is one sextillionth of a second."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (cardinal) - the zeptoseconds of the attosecond", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the zeptoseconds of the attosecond\n        :rtype: ``cardinal``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "cardinal", 
               "errors": {}
            }, 
            {
               "name": "get_yoctoseconds", 
               "doc": {
                  "headline": "Gets the number of yoctoseconds of the picosecond 0-999.", 
                  "body": "        A yoctosecond is one septillionth of a second. This is getting\n        quite small."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (cardinal) - the yoctoseconds of the picosecond", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the yoctoseconds of the picosecond\n        :rtype: ``cardinal``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "cardinal", 
               "errors": {}
            }, 
            {
               "name": "get_xoxxoseconds", 
               "doc": {
                  "headline": "Gets the number of xoxxoseconds of the yoctosecond 0-999.", 
                  "body": "        A xoxxosecond is one octillionth of a second. We're going with\n        Rudy Rucker here."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (cardinal) - the xoxxoseconds of the yoctosecond", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the xoxxoseconds of the yoctosecond\n        :rtype: ``cardinal``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "cardinal", 
               "errors": {}
            }, 
            {
               "name": "get_weebleseconds", 
               "doc": {
                  "headline": "Gets the number of weebleseconds of the xoxxosecond 0-999.", 
                  "body": "        A weeblesecond is one nonillionth of a second."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (cardinal) - the weebleseconds of the xoxxoseconds", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the weebleseconds of the xoxxoseconds\n        :rtype: ``cardinal``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "cardinal", 
               "errors": {}
            }, 
            {
               "name": "get_vatoseconds", 
               "doc": {
                  "headline": "Gets the number of vatoseconds of the xoxxosecond 0-999.", 
                  "body": "        A vatosecond is one decillionth of a second."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (cardinal) - the vatoseconds of the weeblesecond", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the vatoseconds of the weeblesecond\n        :rtype: ``cardinal``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "cardinal", 
               "errors": {}
            }, 
            {
               "name": "get_undaseconds", 
               "doc": {
                  "headline": "Gets the number of undaseconds of the vatosecond 0-999.", 
                  "body": "        An undasecond is one unadecillionth of a second."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (cardinal) - the undaseconds of the vatosecond", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the undaseconds of the vatosecond\n        :rtype: ``cardinal``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "cardinal", 
               "errors": {}
            }, 
            {
               "name": "get_planck_seconds", 
               "doc": {
                  "headline": "Gets the number of Plancks of the vatoseconds.", 
                  "body": "        A Planck is 10 quattuordecillionths of a second."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (cardinal) - the plancks of the undasecond", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the plancks of the undasecond\n        :rtype: ``cardinal``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "cardinal", 
               "errors": {}
            }, 
            {
               "name": "get_granularity", 
               "doc": {
                  "headline": "Gets the granularity of this time.", 
                  "body": "        The granularity indicates the resolution of the clock. More\n        precision than what is specified in this method cannot be\n        inferred from the available data."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.DateTimeResolution) - granularity", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: granularity\n        :rtype: ``osid.calendaring.DateTimeResolution``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.DateTimeResolution", 
               "errors": {}
            }, 
            {
               "name": "get_granularity_multiplier", 
               "doc": {
                  "headline": "If the granularity of the time equals ``get_granularity(),`` then the multiplier is 1.", 
                  "body": "        This method may return a different number when the granularity\n        differs from one of the defined resolutions."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (cardinal) - granularity multiplier", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: granularity multiplier\n        :rtype: ``cardinal``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "cardinal", 
               "errors": {}
            }
         ]
      }, 
      {
         "fullname": "osid.calendaring.TimeList", 
         "shortname": "TimeList", 
         "category": "objects", 
         "doc": {
            "headline": "Like all ``OsidLists,``  ``TimeList`` provides a means for accessing ``Time`` elements sequentially either one at a time or many at a time.", 
            "body": "    Examples: while (tl.hasNext()) { Time time = tl.getNextTime(); }\n\n    or\n      while (tl.hasNext()) {\n           Time[] times = tl.getNextTimes(tl.available());\n      }\n    \n"
         }, 
         "inherit_fullnames": [
            "osid.OsidList"
         ], 
         "inherit_shortnames": [
            "OsidList"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidList"
            }
         ], 
         "method_names": [
            "get_next_time", 
            "get_next_times"
         ], 
         "methods": [
            {
               "name": "get_next_time", 
               "doc": {
                  "headline": "Gets the next ``Time`` in this list.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.Time) - the next ``Time`` in this\n                list. The ``has_next()`` method should be used to test\n                that a next ``Time`` is available before calling this\n                method.", 
               "error_doc": "        raise:  IllegalState - no more elements available in this list\n        raise:  OperationFailed - unable to complete request", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the next ``Time`` in this list. The ``has_next()`` method should be used to test that a next ``Time`` is available before calling this method.\n        :rtype: ``osid.calendaring.Time``", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- no more elements available in this list\n        :raise: ``OperationFailed`` -- unable to complete request", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.Time", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational"
               }
            }, 
            {
               "name": "get_next_times", 
               "doc": {
                  "headline": "Gets the next set of ``Time`` elements in this list which must be less than or equal to the number returned from ``available()``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    n (cardinal): the number of ``Time`` elements requested\n                which should be less than or equal to ``available()``\n", 
               "return_doc": "        return: (osid.calendaring.Time) - an array of ``Time``\n                elements.The length of the array is less than or equal\n                to the number specified.", 
               "error_doc": "        raise:  IllegalState - no more elements available in this list\n        raise:  OperationFailed - unable to complete request", 
               "sphinx_param_doc": "        :param n: the number of ``Time`` elements requested which should be less than or equal to ``available()``\n        :type n: ``cardinal``\n", 
               "sphinx_return_doc": "        :return: an array of ``Time`` elements.The length of the array is less than or equal to the number specified.\n        :rtype: ``osid.calendaring.Time``", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- no more elements available in this list\n        :raise: ``OperationFailed`` -- unable to complete request", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "cardinal", 
                     "var_name": "n", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "cardinal"
               ], 
               "return_type": "osid.calendaring.Time", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.calendaring.DateTime", 
         "shortname": "DateTime", 
         "category": "primitives", 
         "doc": {
            "headline": "The DateTime interface defines a date and/or time.", 
            "body": "    This interface provides a very broad range of dates, describes more\n    or less precision, and/or conveys an uncertainty. A number of\n    convenience methods for retrieving time elements are available but\n    only those methods covered by the specified granularity are valid.\n\n    A typical example is describing a day where the time isn't known,\n    and the event did not occur at midnight.\n      getMillennium() == 2\n      getCentury() == 18\n      getYear() == 1776\n      getMonth() == 7\n      getDay() == 4\n      getHour() == 0\n      getGranularity() == DateTimeResolution.DAY\n      definesUncertainty() == false\n    \n\n    \n    Another example showing that the time is probably 1pm but could have\n    been as late as 3pm or early as noon.\n      getMillennium() == 3\n      getCentury() == 21\n      getYear() == 2008\n      getMonth() == 3\n      getDay() == 17\n      getHour() == 13\n      getMinute() == 0\n      getGranularity() == TimeResolution.MINUTE\n      definesUncertainty() == true\n      getUncertaintyGranularity() == DateTimeResolution.HOUR\n      getUncertaintyMinus() == 1\n      getUncertaintyPlus == 2\n    \n\n    \n    An example marking the birth of the universe. 13.73 billion years\n    +/- 120 million years. The granularity suggests that no more\n    resolution than one million years can be inferred from the \"clock\",\n    making errors in the exact number of millennia insignificant.\n      getEpoch() == -13,730\n      getMillennium() == 0\n      getCentury() == 0\n      getYear() == 0\n      getGranularity() == TimeResolution.EPOCH\n      definesUncertainty() == true\n      getUncertaintyGranularity() == DateTimeResolution.EPOCH\n      getUncertaintyMinus() == 120\n      getUncertaintyPlus == 120\n    \n"
         }, 
         "inherit_fullnames": [
            "osid.OsidPrimitive"
         ], 
         "inherit_shortnames": [
            "OsidPrimitive"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidPrimitive"
            }
         ], 
         "method_names": [
            "get_calendar_type", 
            "get_aeon", 
            "get_epoch", 
            "get_millennium", 
            "get_century", 
            "get_year", 
            "get_month", 
            "get_day", 
            "get_time_type", 
            "get_hour", 
            "get_minute", 
            "get_second", 
            "get_milliseconds", 
            "get_microseconds", 
            "get_nanoseconds", 
            "get_picoseconds", 
            "get_femtoseconds", 
            "get_attoseconds", 
            "get_zeptoseconds", 
            "get_yoctoseconds", 
            "get_xoxxoseconds", 
            "get_weebleseconds", 
            "get_vatoseconds", 
            "get_undaseconds", 
            "get_planck_seconds", 
            "get_granularity", 
            "get_granularity_multiplier", 
            "defines_uncertainty", 
            "get_uncertainty_units", 
            "get_uncertainty_minus", 
            "get_uncertainty_plus", 
            "is_uncertainty_date_inclusive", 
            "is_uncertainty_time_inclusive"
         ], 
         "methods": [
            {
               "name": "get_calendar_type", 
               "doc": {
                  "headline": "Gets the calendar type.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.type.Type) - the calendar type", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the calendar type\n        :rtype: ``osid.type.Type``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.type.Type", 
               "errors": {}
            }, 
            {
               "name": "get_aeon", 
               "doc": {
                  "headline": "Gets the aeon starting from 1.", 
                  "body": "        An aeon is 1B years."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (integer) - the aeon", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the aeon\n        :rtype: ``integer``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "integer", 
               "errors": {}
            }, 
            {
               "name": "get_epoch", 
               "doc": {
                  "headline": "Gets the epoch starting from 1.", 
                  "body": "        An epoch is 1M years."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (integer) - the eposh", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the eposh\n        :rtype: ``integer``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "integer", 
               "errors": {}
            }, 
            {
               "name": "get_millennium", 
               "doc": {
                  "headline": "Gets the millennium starting from 1.", 
                  "body": "        A millenium is 1,000 years."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (integer) - the millennium", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the millennium\n        :rtype: ``integer``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "integer", 
               "errors": {}
            }, 
            {
               "name": "get_century", 
               "doc": {
                  "headline": "Gets the century starting from 1.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (integer) - the century", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the century\n        :rtype: ``integer``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "integer", 
               "errors": {}
            }, 
            {
               "name": "get_year", 
               "doc": {
                  "headline": "Gets the year starting from 1.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (integer) - the year", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the year\n        :rtype: ``integer``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "integer", 
               "errors": {}
            }, 
            {
               "name": "get_month", 
               "doc": {
                  "headline": "Gets the month number starting from 1.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (cardinal) - the month", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the month\n        :rtype: ``cardinal``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "cardinal", 
               "errors": {}
            }, 
            {
               "name": "get_day", 
               "doc": {
                  "headline": "Gets the day of the month starting from 1.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (cardinal) - the day of the month", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the day of the month\n        :rtype: ``cardinal``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "cardinal", 
               "errors": {}
            }, 
            {
               "name": "get_time_type", 
               "doc": {
                  "headline": "Gets the time type.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.type.Type) - the time type", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the time type\n        :rtype: ``osid.type.Type``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.type.Type", 
               "errors": {}
            }, 
            {
               "name": "get_hour", 
               "doc": {
                  "headline": "Gets the hour of the day 0-23.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (cardinal) - the hour of the day", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the hour of the day\n        :rtype: ``cardinal``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "cardinal", 
               "errors": {}
            }, 
            {
               "name": "get_minute", 
               "doc": {
                  "headline": "Gets the minute of the hour 0-59.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (cardinal) - the minute of the hour", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the minute of the hour\n        :rtype: ``cardinal``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "cardinal", 
               "errors": {}
            }, 
            {
               "name": "get_second", 
               "doc": {
                  "headline": "Gets the second of the minute 0-59.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (cardinal) - the second of the minute", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the second of the minute\n        :rtype: ``cardinal``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "cardinal", 
               "errors": {}
            }, 
            {
               "name": "get_milliseconds", 
               "doc": {
                  "headline": "Gets the number of milliseconds in this second 0-999.", 
                  "body": "        A millisecond is one thousandth of a second."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (cardinal) - the milliseconds of the second", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the milliseconds of the second\n        :rtype: ``cardinal``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "cardinal", 
               "errors": {}
            }, 
            {
               "name": "get_microseconds", 
               "doc": {
                  "headline": "Gets the number of microseconds of the second 0-999.", 
                  "body": "        A microsecond is one millionth of a second."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (cardinal) - the micrseconds of the millisecond", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the micrseconds of the millisecond\n        :rtype: ``cardinal``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "cardinal", 
               "errors": {}
            }, 
            {
               "name": "get_nanoseconds", 
               "doc": {
                  "headline": "Gets the number of nanoseconds of the microsecond 0-999.", 
                  "body": "        A nanosecond is one billionth of a second."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (cardinal) - the nanoseconds of the microsecond", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the nanoseconds of the microsecond\n        :rtype: ``cardinal``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "cardinal", 
               "errors": {}
            }, 
            {
               "name": "get_picoseconds", 
               "doc": {
                  "headline": "Gets the number of picoseconds of the nanosecond 0-999.", 
                  "body": "        A picosecond is one trillionth of a second."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (cardinal) - the picoseconds of the nanosecond", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the picoseconds of the nanosecond\n        :rtype: ``cardinal``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "cardinal", 
               "errors": {}
            }, 
            {
               "name": "get_femtoseconds", 
               "doc": {
                  "headline": "Gets the number of femtoseconds of the picosecond 0-999.", 
                  "body": "        A femtosecond is one quadrillionth of a second."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (cardinal) - the femtoseconds of the picosecond", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the femtoseconds of the picosecond\n        :rtype: ``cardinal``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "cardinal", 
               "errors": {}
            }, 
            {
               "name": "get_attoseconds", 
               "doc": {
                  "headline": "Gets the number of attoseconds of the femtoseconds 0-999.", 
                  "body": "        An attosecond is one quintillionth of a second."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (cardinal) - the attoseconds of the femtosecond", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the attoseconds of the femtosecond\n        :rtype: ``cardinal``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "cardinal", 
               "errors": {}
            }, 
            {
               "name": "get_zeptoseconds", 
               "doc": {
                  "headline": "Gets the number of zeptoseconds of the attosecond 0-999.", 
                  "body": "        A zeptosecond is one sextillionth of a second."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (cardinal) - the zeptoseconds of the attosecond", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the zeptoseconds of the attosecond\n        :rtype: ``cardinal``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "cardinal", 
               "errors": {}
            }, 
            {
               "name": "get_yoctoseconds", 
               "doc": {
                  "headline": "Gets the number of yoctoseconds of the picosecond 0-999.", 
                  "body": "        A yoctosecond is one septillionth of a second. This is getting\n        quite small."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (cardinal) - the yoctoseconds of the picosecond", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the yoctoseconds of the picosecond\n        :rtype: ``cardinal``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "cardinal", 
               "errors": {}
            }, 
            {
               "name": "get_xoxxoseconds", 
               "doc": {
                  "headline": "Gets the number of xoxxoseconds of the yoctosecond 0-999.", 
                  "body": "        A xoxxosecond is one octillionth of a second. We're going with\n        Rudy Rucker here."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (cardinal) - the xoxxoseconds of the yoctosecond", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the xoxxoseconds of the yoctosecond\n        :rtype: ``cardinal``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "cardinal", 
               "errors": {}
            }, 
            {
               "name": "get_weebleseconds", 
               "doc": {
                  "headline": "Gets the number of weebleseconds of the xoxxosecond 0-999.", 
                  "body": "        A weeblesecond is one nonillionth of a second."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (cardinal) - the weebleseconds of the xoxxoseconds", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the weebleseconds of the xoxxoseconds\n        :rtype: ``cardinal``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "cardinal", 
               "errors": {}
            }, 
            {
               "name": "get_vatoseconds", 
               "doc": {
                  "headline": "Gets the number of vatoseconds of the xoxxosecond 0-999.", 
                  "body": "        A vatosecond is one decillionth of a second."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (cardinal) - the vatoseconds of the weeblesecond", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the vatoseconds of the weeblesecond\n        :rtype: ``cardinal``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "cardinal", 
               "errors": {}
            }, 
            {
               "name": "get_undaseconds", 
               "doc": {
                  "headline": "Gets the number of undaseconds of the vatosecond 0-999.", 
                  "body": "        An undasecond is one unadecillionth of a second."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (cardinal) - the undaseconds of the vatosecond", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the undaseconds of the vatosecond\n        :rtype: ``cardinal``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "cardinal", 
               "errors": {}
            }, 
            {
               "name": "get_planck_seconds", 
               "doc": {
                  "headline": "Gets the number of Plancks of the vatoseconds.", 
                  "body": "        A Planck is 10 quattuordecillionths of a second."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (cardinal) - the plancks of the undasecond", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the plancks of the undasecond\n        :rtype: ``cardinal``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "cardinal", 
               "errors": {}
            }, 
            {
               "name": "get_granularity", 
               "doc": {
                  "headline": "Gets the granularity of this time.", 
                  "body": "        The granularity indicates the resolution of the clock. More\n        precision than what is specified in this method cannot be\n        inferred from the available data."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.DateTimeResolution) - granularity", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: granularity\n        :rtype: ``osid.calendaring.DateTimeResolution``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.DateTimeResolution", 
               "errors": {}
            }, 
            {
               "name": "get_granularity_multiplier", 
               "doc": {
                  "headline": "If the granularity of the time equals ``get_granularity(),`` then the multiplier is 1.", 
                  "body": "        This method may return a different number when the granularity\n        differs from one of the defined resolutions."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (cardinal) - granularity multiplier", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: granularity multiplier\n        :rtype: ``cardinal``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "cardinal", 
               "errors": {}
            }, 
            {
               "name": "defines_uncertainty", 
               "doc": {
                  "headline": "Tests if uncertainty is defined for this time.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if uncertainty is defined,\n                ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if uncertainty is defined, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "get_uncertainty_units", 
               "doc": {
                  "headline": "Gets the units of the uncertainty.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.DateTimeResolution) - units of the\n                uncertainty", 
               "error_doc": "        raise:  IllegalState - ``defines_uncertainty()`` is ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: units of the uncertainty\n        :rtype: ``osid.calendaring.DateTimeResolution``", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- ``defines_uncertainty()`` is ``false``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.DateTimeResolution", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract"
               }
            }, 
            {
               "name": "get_uncertainty_minus", 
               "doc": {
                  "headline": "Gets the uncertainty of this time in the negative direction.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (cardinal) - the uncertainty under this value", 
               "error_doc": "        raise:  IllegalState - ``defines_uncertainty()`` is ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the uncertainty under this value\n        :rtype: ``cardinal``", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- ``defines_uncertainty()`` is ``false``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "cardinal", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract"
               }
            }, 
            {
               "name": "get_uncertainty_plus", 
               "doc": {
                  "headline": "Gets the uncertainty of this time in the positive direction.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (cardinal) - the uncertainty over this value", 
               "error_doc": "        raise:  IllegalState - ``defines_uncertainty()`` is ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the uncertainty over this value\n        :rtype: ``cardinal``", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- ``defines_uncertainty()`` is ``false``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "cardinal", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract"
               }
            }, 
            {
               "name": "is_uncertainty_date_inclusive", 
               "doc": {
                  "headline": "Tests if the uncertainty is inclusive of all dates.", 
                  "body": "        An inclusive uncertainty includes the entire range specified by\n        the uncertainty units e.g. +/- 1 year includes all of the months\n        and days within that interval. A non-inclusive uncertainty would\n        mean the year is uncertain but the month and day is certain."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if the uncertainty includes all\n                dates, ``false`` otherwise", 
               "error_doc": "        raise:  IllegalState - ``defines_uncertainty()`` is ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if the uncertainty includes all dates, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- ``defines_uncertainty()`` is ``false``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract"
               }
            }, 
            {
               "name": "is_uncertainty_time_inclusive", 
               "doc": {
                  "headline": "Tests if the uncertainty is time inclusive.", 
                  "body": "        An inclusive uncertainty includes the entire range specified by\n        the uncertainty units e.g. +/- 1 year includes all of the\n        seconds within that interval. A non-inclusive uncertainty would\n        mean the year is uncertain but the time is certain."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if the uncertainty includes all\n                times, ``false`` otherwise", 
               "error_doc": "        raise:  IllegalState - ``defines_uncertainty()`` is ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if the uncertainty includes all times, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- ``defines_uncertainty()`` is ``false``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.calendaring.DateTimeList", 
         "shortname": "DateTimeList", 
         "category": "objects", 
         "doc": {
            "headline": "Like all ``OsidLists,``  ``DateTimeList`` provides a means for accessing ``DateTime`` elements sequentially either one at a time or many at a time.", 
            "body": "    Examples: while (dtl.hasNext()) { DateTime time =\n    dtl.getNextDateTime(); }\n\n    or\n      while dtl.hasNext()) {\n           DateTime[] times = dtl.getNextDateTimes(dtl.available());\n      }\n    \n"
         }, 
         "inherit_fullnames": [
            "osid.OsidList"
         ], 
         "inherit_shortnames": [
            "OsidList"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidList"
            }
         ], 
         "method_names": [
            "get_next_date_time", 
            "get_next_date_times"
         ], 
         "methods": [
            {
               "name": "get_next_date_time", 
               "doc": {
                  "headline": "Gets the next ``DateTime`` in this list.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.DateTime) - the next ``DateTime`` in\n                this list. The ``has_next()`` method should be used to\n                test that a next ``DateTime`` is available before\n                calling this method.", 
               "error_doc": "        raise:  IllegalState - no more elements available in this list\n        raise:  OperationFailed - unable to complete request", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the next ``DateTime`` in this list. The ``has_next()`` method should be used to test that a next ``DateTime`` is available before calling this method.\n        :rtype: ``osid.calendaring.DateTime``", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- no more elements available in this list\n        :raise: ``OperationFailed`` -- unable to complete request", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.DateTime", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational"
               }
            }, 
            {
               "name": "get_next_date_times", 
               "doc": {
                  "headline": "Gets the next set of ``DateTime`` elements in this list which must be less than or equal to the number returned from ``available()``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    n (cardinal): the number of ``DateTime`` elements\n                requested which should be less than or equal to\n                ``available()``\n", 
               "return_doc": "        return: (osid.calendaring.DateTime) - an array of ``DateTime``\n                elements.The length of the array is less than or equal\n                to the number specified.", 
               "error_doc": "        raise:  IllegalState - no more elements available in this list\n        raise:  OperationFailed - unable to complete request", 
               "sphinx_param_doc": "        :param n: the number of ``DateTime`` elements requested which should be less than or equal to ``available()``\n        :type n: ``cardinal``\n", 
               "sphinx_return_doc": "        :return: an array of ``DateTime`` elements.The length of the array is less than or equal to the number specified.\n        :rtype: ``osid.calendaring.DateTime``", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- no more elements available in this list\n        :raise: ``OperationFailed`` -- unable to complete request", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "cardinal", 
                     "var_name": "n", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "cardinal"
               ], 
               "return_type": "osid.calendaring.DateTime", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.calendaring.Duration", 
         "shortname": "Duration", 
         "category": "primitives", 
         "doc": {
            "headline": "The ``Duration`` a length of time.", 
            "body": ""
         }, 
         "inherit_fullnames": [
            "osid.OsidPrimitive"
         ], 
         "inherit_shortnames": [
            "OsidPrimitive"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidPrimitive"
            }
         ], 
         "method_names": [
            "get_calendar_type", 
            "get_time_type", 
            "get_aeons", 
            "get_epochs", 
            "get_millennia", 
            "get_centuries", 
            "get_scores", 
            "get_bluemoons", 
            "get_years", 
            "get_months", 
            "get_weeks", 
            "get_days", 
            "get_hours", 
            "get_minutes", 
            "get_seconds", 
            "get_milliseconds", 
            "get_microseconds", 
            "get_nanoseconds", 
            "get_picoseconds", 
            "get_femtoseconds", 
            "get_attoseconds", 
            "get_zeptoseconds", 
            "get_yoctoseconds", 
            "get_xoxxoseconds", 
            "get_weebleseconds", 
            "get_vatoseconds", 
            "get_undaseconds", 
            "get_planck_seconds", 
            "get_granularity", 
            "get_granularity_multiplier", 
            "defines_uncertainty", 
            "get_uncertainty_units", 
            "get_uncertainty_minus", 
            "get_uncertainty_plus"
         ], 
         "methods": [
            {
               "name": "get_calendar_type", 
               "doc": {
                  "headline": "Gets the calendar type.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.type.Type) - the calendar type", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the calendar type\n        :rtype: ``osid.type.Type``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.type.Type", 
               "errors": {}
            }, 
            {
               "name": "get_time_type", 
               "doc": {
                  "headline": "Gets the time type.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.type.Type) - the time type", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the time type\n        :rtype: ``osid.type.Type``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.type.Type", 
               "errors": {}
            }, 
            {
               "name": "get_aeons", 
               "doc": {
                  "headline": "Gets the number of aeons.", 
                  "body": "        An aeon is 1B years."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (decimal) - the number of aeons", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the number of aeons\n        :rtype: ``decimal``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "decimal", 
               "errors": {}
            }, 
            {
               "name": "get_epochs", 
               "doc": {
                  "headline": "Gets the number of epochs.", 
                  "body": "        An epoch is 1M years."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (decimal) - the number of epochs", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the number of epochs\n        :rtype: ``decimal``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "decimal", 
               "errors": {}
            }, 
            {
               "name": "get_millennia", 
               "doc": {
                  "headline": "Gets the number of millennia.", 
                  "body": "        A millennium is 1,000 years."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (decimal) - the number of millennia", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the number of millennia\n        :rtype: ``decimal``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "decimal", 
               "errors": {}
            }, 
            {
               "name": "get_centuries", 
               "doc": {
                  "headline": "Gets the number of centuries.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (decimal) - the number of centuries", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the number of centuries\n        :rtype: ``decimal``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "decimal", 
               "errors": {}
            }, 
            {
               "name": "get_scores", 
               "doc": {
                  "headline": "Gets the number of scores.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (decimal) - the number of scores", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the number of scores\n        :rtype: ``decimal``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "decimal", 
               "errors": {}
            }, 
            {
               "name": "get_bluemoons", 
               "doc": {
                  "headline": "Gets the number of blue moons.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (decimal) - the number of blue moons", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the number of blue moons\n        :rtype: ``decimal``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "decimal", 
               "errors": {}
            }, 
            {
               "name": "get_years", 
               "doc": {
                  "headline": "Gets the number of years.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (decimal) - the number of years", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the number of years\n        :rtype: ``decimal``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "decimal", 
               "errors": {}
            }, 
            {
               "name": "get_months", 
               "doc": {
                  "headline": "Gets the number of months.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (decimal) - the number of months", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the number of months\n        :rtype: ``decimal``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "decimal", 
               "errors": {}
            }, 
            {
               "name": "get_weeks", 
               "doc": {
                  "headline": "Gets the number of weeks.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (decimal) - the number of weeks", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the number of weeks\n        :rtype: ``decimal``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "decimal", 
               "errors": {}
            }, 
            {
               "name": "get_days", 
               "doc": {
                  "headline": "Gets the number of days.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (decimal) - the number of days", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the number of days\n        :rtype: ``decimal``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "decimal", 
               "errors": {}
            }, 
            {
               "name": "get_hours", 
               "doc": {
                  "headline": "Gets the number of hours.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (decimal) - the number of hours", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the number of hours\n        :rtype: ``decimal``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "decimal", 
               "errors": {}
            }, 
            {
               "name": "get_minutes", 
               "doc": {
                  "headline": "Gets the number of minutes.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (decimal) - the number of minutes", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the number of minutes\n        :rtype: ``decimal``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "decimal", 
               "errors": {}
            }, 
            {
               "name": "get_seconds", 
               "doc": {
                  "headline": "Gets the number of seconds.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (decimal) - the number of seconds", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the number of seconds\n        :rtype: ``decimal``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "decimal", 
               "errors": {}
            }, 
            {
               "name": "get_milliseconds", 
               "doc": {
                  "headline": "Gets the number of milliseconds.", 
                  "body": "        A millisecond is one thousandth of a second."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (decimal) - the number of milliseconds", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the number of milliseconds\n        :rtype: ``decimal``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "decimal", 
               "errors": {}
            }, 
            {
               "name": "get_microseconds", 
               "doc": {
                  "headline": "Gets the number of microseconds.", 
                  "body": "        A microsecond is one millionth of a second."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (decimal) - the number of micrseconds", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the number of micrseconds\n        :rtype: ``decimal``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "decimal", 
               "errors": {}
            }, 
            {
               "name": "get_nanoseconds", 
               "doc": {
                  "headline": "Gets the number of nanoseconds.", 
                  "body": "        A nanosecond is one billionth of a second."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (decimal) - the number of nanoseconds", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the number of nanoseconds\n        :rtype: ``decimal``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "decimal", 
               "errors": {}
            }, 
            {
               "name": "get_picoseconds", 
               "doc": {
                  "headline": "Gets the number of picoseconds.", 
                  "body": "        A picosecond is one trillionth of a second."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (decimal) - the number of picoseconds", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the number of picoseconds\n        :rtype: ``decimal``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "decimal", 
               "errors": {}
            }, 
            {
               "name": "get_femtoseconds", 
               "doc": {
                  "headline": "Gets the number of femtoseconds.", 
                  "body": "        A femtosecond is one quadrillionth of a second."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (decimal) - the number of femtoseconds", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the number of femtoseconds\n        :rtype: ``decimal``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "decimal", 
               "errors": {}
            }, 
            {
               "name": "get_attoseconds", 
               "doc": {
                  "headline": "Gets the number of attoseconds.", 
                  "body": "        An attosecond is one quintillionth of a second."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (decimal) - the number of attoseconds", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the number of attoseconds\n        :rtype: ``decimal``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "decimal", 
               "errors": {}
            }, 
            {
               "name": "get_zeptoseconds", 
               "doc": {
                  "headline": "Gets the number of zeptoseconds.", 
                  "body": "        A zeptosecond is one sextillionth of a second."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (decimal) - the number of zeptoseconds", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the number of zeptoseconds\n        :rtype: ``decimal``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "decimal", 
               "errors": {}
            }, 
            {
               "name": "get_yoctoseconds", 
               "doc": {
                  "headline": "Gets the number of yoctoseconds.", 
                  "body": "        A yoctosecond is one septillionth of a second. This is getting\n        quite small."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (decimal) - the number of yoctoseconds", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the number of yoctoseconds\n        :rtype: ``decimal``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "decimal", 
               "errors": {}
            }, 
            {
               "name": "get_xoxxoseconds", 
               "doc": {
                  "headline": "Gets the number of xoxxoseconds.", 
                  "body": "        A xoxxosecond is one octillionth of a second. We're going with\n        Rudy Rucker here."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (decimal) - the number of xoxxoseconds", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the number of xoxxoseconds\n        :rtype: ``decimal``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "decimal", 
               "errors": {}
            }, 
            {
               "name": "get_weebleseconds", 
               "doc": {
                  "headline": "Gets the number of weebleseconds.", 
                  "body": "        A weeblesecond is one nonillionth of a second."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (decimal) - the number of weebleseconds", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the number of weebleseconds\n        :rtype: ``decimal``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "decimal", 
               "errors": {}
            }, 
            {
               "name": "get_vatoseconds", 
               "doc": {
                  "headline": "Gets the number of vatoseconds.", 
                  "body": "        A vatosecond is one decillionth of a second."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (decimal) - the number of vatoseconds", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the number of vatoseconds\n        :rtype: ``decimal``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "decimal", 
               "errors": {}
            }, 
            {
               "name": "get_undaseconds", 
               "doc": {
                  "headline": "Gets the number of undaseconds.", 
                  "body": "        An undasecond is one unadecillionth of a second."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (decimal) - the number of undaseconds", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the number of undaseconds\n        :rtype: ``decimal``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "decimal", 
               "errors": {}
            }, 
            {
               "name": "get_planck_seconds", 
               "doc": {
                  "headline": "Gets the number of Planck sseconds.", 
                  "body": "        A Planck is 10 quattuordecillionths of a second."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (decimal) - the number of planck seconds", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the number of planck seconds\n        :rtype: ``decimal``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "decimal", 
               "errors": {}
            }, 
            {
               "name": "get_granularity", 
               "doc": {
                  "headline": "Gets the granularity of this duration.", 
                  "body": "        The granularity indicates the resolution of the clock. More\n        precision than what is specified in this method cannot be\n        inferred from the available data."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.DateTimeResolution) - the time units", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the time units\n        :rtype: ``osid.calendaring.DateTimeResolution``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.DateTimeResolution", 
               "errors": {}
            }, 
            {
               "name": "get_granularity_multiplier", 
               "doc": {
                  "headline": "If the granularity of the time equals ``get_granularity(),`` then the multiplier is 1.", 
                  "body": "        This method may return a different number when the granularity\n        differs from one of the defined resolutions."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (cardinal) - granularity multiplier", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: granularity multiplier\n        :rtype: ``cardinal``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "cardinal", 
               "errors": {}
            }, 
            {
               "name": "defines_uncertainty", 
               "doc": {
                  "headline": "Tests if uncertainty is defined for this time.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (boolean) - ``true`` if uncertainty is defined,\n                ``false`` otherwise", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: ``true`` if uncertainty is defined, ``false`` otherwise\n        :rtype: ``boolean``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "boolean", 
               "errors": {}
            }, 
            {
               "name": "get_uncertainty_units", 
               "doc": {
                  "headline": "Gets the units of the uncertainty.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.DateTimeResolution) - units of the\n                uncertainty", 
               "error_doc": "        raise:  IllegalState - ``defines_uncertainty()`` is ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: units of the uncertainty\n        :rtype: ``osid.calendaring.DateTimeResolution``", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- ``defines_uncertainty()`` is ``false``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.DateTimeResolution", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract"
               }
            }, 
            {
               "name": "get_uncertainty_minus", 
               "doc": {
                  "headline": "Gets the uncertainty of this time in the negative direction.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (cardinal) - the uncertainty under this value", 
               "error_doc": "        raise:  IllegalState - ``defines_uncertainty()`` is ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the uncertainty under this value\n        :rtype: ``cardinal``", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- ``defines_uncertainty()`` is ``false``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "cardinal", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract"
               }
            }, 
            {
               "name": "get_uncertainty_plus", 
               "doc": {
                  "headline": "Gets the uncertainty of this time in the positive direction.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (cardinal) - the uncertainty over this value", 
               "error_doc": "        raise:  IllegalState - ``defines_uncertainty()`` is ``false``", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the uncertainty over this value\n        :rtype: ``cardinal``", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- ``defines_uncertainty()`` is ``false``", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "cardinal", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.calendaring.DurationList", 
         "shortname": "DurationList", 
         "category": "objects", 
         "doc": {
            "headline": "Like all ``OsidLists,``  ``DurationList`` provides a means for accessing ``Duration`` elements sequentially either one at a time or many at a time.", 
            "body": "    Examples: while (dl.hasNext()) { Duration duration =\n    dl.getNextDuration(); }\n\n    or\n      while dl.hasNext()) {\n           Duration[] durations = dl.getNextDurations(dl.available());\n      }\n    \n"
         }, 
         "inherit_fullnames": [
            "osid.OsidList"
         ], 
         "inherit_shortnames": [
            "OsidList"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidList"
            }
         ], 
         "method_names": [
            "get_next_duration", 
            "get_next_durations"
         ], 
         "methods": [
            {
               "name": "get_next_duration", 
               "doc": {
                  "headline": "Gets the next ``Duration`` in this list.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.Duration) - the next ``Duration`` in\n                this list. The ``has_next()`` method should be used to\n                test that a next ``Duration`` is available before\n                calling this method.", 
               "error_doc": "        raise:  IllegalState - no more elements available in this list\n        raise:  OperationFailed - unable to complete request", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the next ``Duration`` in this list. The ``has_next()`` method should be used to test that a next ``Duration`` is available before calling this method.\n        :rtype: ``osid.calendaring.Duration``", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- no more elements available in this list\n        :raise: ``OperationFailed`` -- unable to complete request", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.Duration", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational"
               }
            }, 
            {
               "name": "get_next_durations", 
               "doc": {
                  "headline": "Gets the next set of ``Duration`` elements in this list which must be less than or equal to the number returned from ``available()``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    n (cardinal): the number of ``Duration`` elements\n                requested which should be less than or equal to\n                ``available()``\n", 
               "return_doc": "        return: (osid.calendaring.Duration) - an array of ``Duration``\n                elements.The length of the array is less than or equal\n                to the number specified.", 
               "error_doc": "        raise:  IllegalState - no more elements available in this list\n        raise:  OperationFailed - unable to complete request", 
               "sphinx_param_doc": "        :param n: the number of ``Duration`` elements requested which should be less than or equal to ``available()``\n        :type n: ``cardinal``\n", 
               "sphinx_return_doc": "        :return: an array of ``Duration`` elements.The length of the array is less than or equal to the number specified.\n        :rtype: ``osid.calendaring.Duration``", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- no more elements available in this list\n        :raise: ``OperationFailed`` -- unable to complete request", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "cardinal", 
                     "var_name": "n", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "cardinal"
               ], 
               "return_type": "osid.calendaring.Duration", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational"
               }
            }
         ]
      }, 
      {
         "fullname": "osid.calendaring.DateTimeInterval", 
         "shortname": "DateTimeInterval", 
         "category": "objects", 
         "doc": {
            "headline": "The ``DateTimeInterval`` interface defines an interval between two date times.", 
            "body": ""
         }, 
         "inherit_fullnames": [], 
         "inherit_shortnames": [], 
         "inherit_pkg_names": [], 
         "inheritance": [], 
         "method_names": [
            "get_start", 
            "get_end"
         ], 
         "methods": [
            {
               "name": "get_start", 
               "doc": {
                  "headline": "Gets the starting time for this interval.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.DateTime) - the starting time", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the starting time\n        :rtype: ``osid.calendaring.DateTime``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.DateTime", 
               "errors": {}
            }, 
            {
               "name": "get_end", 
               "doc": {
                  "headline": "Gets the ending time for this interval.", 
                  "body": "        The ending time is greater than or equal to the starting time."
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.DateTime) - the ending time", 
               "error_doc": "", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the ending time\n        :rtype: ``osid.calendaring.DateTime``", 
               "sphinx_error_doc": "", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.DateTime", 
               "errors": {}
            }
         ]
      }, 
      {
         "fullname": "osid.calendaring.DateTimeIntervalList", 
         "shortname": "DateTimeIntervalList", 
         "category": "objects", 
         "doc": {
            "headline": "Like all ``OsidLists,``  ``DateTimeIntervalList`` provides a means for accessing ``DateTimeInterval`` elements sequentially either one at a time or many at a time.", 
            "body": "    Examples: while (dtil.hasNext()) { DateTimeInterval interval =\n    dtil.getNextDateTimeInterval(); }\n\n    or\n      while (dtil.hasNext()) {\n           DateTimeInterval[] intervals = dtil.getNextDateTimeIntervals(dtil.available());\n      }\n    \n"
         }, 
         "inherit_fullnames": [
            "osid.OsidList"
         ], 
         "inherit_shortnames": [
            "OsidList"
         ], 
         "inherit_pkg_names": [
            "osid"
         ], 
         "inheritance": [
            {
               "pkg_name": "osid", 
               "name": "OsidList"
            }
         ], 
         "method_names": [
            "get_next_date_time_interval", 
            "get_next_date_time_intervals"
         ], 
         "methods": [
            {
               "name": "get_next_date_time_interval", 
               "doc": {
                  "headline": "Gets the next ``DateTimeInterval`` in this list.", 
                  "body": ""
               }, 
               "arg_doc": "", 
               "return_doc": "        return: (osid.calendaring.DateTimeInterval) - the next\n                ``DateTimeInterval`` in this list. The ``has_next()``\n                method should be used to test that a next\n                ``DateTimeInterval`` is available before calling this\n                method.", 
               "error_doc": "        raise:  IllegalState - no more elements available in this list\n        raise:  OperationFailed - unable to complete request", 
               "sphinx_param_doc": "", 
               "sphinx_return_doc": "        :return: the next ``DateTimeInterval`` in this list. The ``has_next()`` method should be used to test that a next ``DateTimeInterval`` is available before calling this method.\n        :rtype: ``osid.calendaring.DateTimeInterval``", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- no more elements available in this list\n        :raise: ``OperationFailed`` -- unable to complete request", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [], 
               "arg_types": [], 
               "return_type": "osid.calendaring.DateTimeInterval", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational"
               }
            }, 
            {
               "name": "get_next_date_time_intervals", 
               "doc": {
                  "headline": "Gets the next set of ``DateTimeInterval`` elements in this list which must be less than or equal to the number returned from ``available()``.", 
                  "body": ""
               }, 
               "arg_doc": "        arg:    n (cardinal): the number of ``DateTimeInterval``\n                elements requested which should be less than or equal to\n                ``available()``\n", 
               "return_doc": "        return: (osid.calendaring.DateTimeInterval) - an array of\n                ``DateimeInterval`` elements.The length of the array is\n                less than or equal to the number specified.", 
               "error_doc": "        raise:  IllegalState - no more elements available in this list\n        raise:  OperationFailed - unable to complete request", 
               "sphinx_param_doc": "        :param n: the number of ``DateTimeInterval`` elements requested which should be less than or equal to ``available()``\n        :type n: ``cardinal``\n", 
               "sphinx_return_doc": "        :return: an array of ``DateimeInterval`` elements.The length of the array is less than or equal to the number specified.\n        :rtype: ``osid.calendaring.DateTimeInterval``", 
               "sphinx_error_doc": "        :raise: ``IllegalState`` -- no more elements available in this list\n        :raise: ``OperationFailed`` -- unable to complete request", 
               "compliance_doc": "        *compliance: mandatory -- This method must be implemented.*\n", 
               "impl_notes_doc": "", 
               "args": [
                  {
                     "arg_type": "cardinal", 
                     "var_name": "n", 
                     "array": false
                  }
               ], 
               "arg_types": [
                  "cardinal"
               ], 
               "return_type": "osid.calendaring.DateTimeInterval", 
               "errors": {
                  "ILLEGAL_STATE": "ConsumerContract", 
                  "OPERATION_FAILED": "Operational"
               }
            }
         ]
      }
   ], 
   "full_name": "osid.calendaring"
}
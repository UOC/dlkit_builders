
class Identifiable:

    init = #"""
    _authority = 'birdland.mit.edu'
"""

    get_id = """
        from id_kit.dj_id.primitives import Id
        return Id(identifier = self.my_model.identifier,
                   namespace = self._namespace,
                   authority = self._authority)"""

    is_current = """
        # Someday I might know how to answer this
        return False"""


class Extensible:

    has_record_type = """
        # Someday I hope to have a real implementation
        return False"""

    get_record_types = """
        # Someday I, too, hope to have a real implementation
        from type_kit.dj_type.objects import TypeList
        return TypeList([])"""


class OsidObject:

    model = """
    identifier = models.AutoField(primary_key=True)
    display_name = models.CharField(max_length=256, blank=True)
    description = models.CharField(max_length=256, blank=True)
    language_type_identifier = models.CharField(max_length=64)
    script_type_identifier = models.CharField(max_length=64)
    format_type_identifier = models.CharField(max_length=64)
    genus_type_authority = models.CharField(max_length=128)
    genus_type_namespace = models.CharField(max_length=128)
    genus_type_identifier = models.CharField(max_length=64)
    
    class Meta:
        abstract = True
    
    def __unicode__(self):
        return '' + str(self.displayName) + ' (identifier:' + str(self.identifier) + ')'
"""

    init = """
    _namespace = "dj_osid.OsidObject"

    def __init__(self, osid_object_model = None):
        if osid_object_model:
            self.my_model = osid_object_model
        else:
            from osid_kit.dj_osid.models import OsidObject as osid_object_model
            self.my_model = osid_object_model()
            self._init_model() 

    def _init_model(self):
        self.my_model.display_name = ''
        self.my_model.description = ''
        
        # The following may want to be initialized in some more locale
        # agnostic way. Perhaps a configuration file would do.
        self.my_model.language_type_identifier = 'ENG'
        self.my_model.script_type_identifier = 'LATN'
        self.my_model.format_type_identifier = 'PLAIN'
        self.my_model.genus_type_authority = 'birdland@mit.edu'
        self.my_model.genus_type_namespace = 'osid.OsidObject'
        self.my_model.genus_type_identifier = 'default'
"""

    get_display_name = """
        from locale_kit.dj_locale.primitives import DisplayText
        return DisplayText(self.my_model.display_name,
               language_type_identifier = self.my_model.language_type_identifier,
               script_type_identifier = self.my_model.script_type_identifier,
               format_type_identifier = self.my_model.format_type_identifier)"""

    # Why did I make this a template too?
    get_display_name_template = """
        # Implemented from template for osid.OsidObject.getDisplayName
        from locale_kit.dj_locale.primitives import DisplayText
        return DisplayText(self.my_model.${var_name},
               language_type_identifier = self.my_model.language_type_identifier,
               script_type_identifier = self.my_model.script_type_identifier,
               format_type_identifier = self.my_model.format_type_identifier)"""

    get_description = """
        from locale_kit.dj_locale.primitives import DisplayText
        return DisplayText(self.my_model.description,
               language_type_identifier = self.my_model.language_type_identifier,
               script_type_identifier = self.my_model.script_type_identifier,
               format_type_identifier = self.my_model.format_type_identifier)"""


class OsidForm:

    init = """

    _namespace = "dj_osid.OsidForm"

    def __init__(self):
        from collections import OrderedDict
        self._form_input = OrderedDict()
        self._form_metadata = OrderedDict()
        self._form_validations = OrderedDict()
        self._init_form()

    ##
    # The _init_form method for the OsidForm appends the comment element
    # to _form_field data and appends the comment metadata and validity 
    # information to the _form_metadata and _form_validations structures.
    def _init_form(self):
        from collections import OrderedDict
        from id_kit.dj_id.primitives import Id
        from locale_kit.dj_locale.primitives import DisplayText
        self._form_input['comment'] = ''
        self._form_metadata['comment'] = {
                'element_id': Id(self._authority,
                                 self._namespace,
                                 'comment'),
                 'element_label': DisplayText('Comment for Submission'),
                 'instructions': DisplayText('Provide a brief comment if you would like.'),
                 'required': False,
                 'value': False,
                 'read_only': False,
                 'linked': False,
                 'syntax': 'STRING',
                 'array': False,
                 'minimum_string_length': 0,   # Should these values come from 
                 'maximum_string_length': 256} # a settings file somewhere?
        self._form_validations['comment'] = {'valid': True,
                                            'invalid_message': True}

    ##
    # Override get_id as implemented in Identifiable for the purpose of 
    # returning an Id unique to this form for submission purposed as 
    # recommended in the osid documentation. This implementation
    # appends a Python uuid4 identifier to the existing identifier, 
    # whatever that identifier might already be.
    def get_id(self):
        import uuid
        from id_kit.dj_id.primitives import Id
        return Id(identifier = str(self.my_model.identifier) +
                               str(uuid.uuid4()),
                   namespace = self._namespace,
                   authority = self._authority)
                  
    ##
    # The _is_valid_input method takes two arguments, the user input to 
    # be checked and the associated _form metadata structure (not an osid.Metadata
    # object) that will store the  validation requirements.
    def _is_valid_input(self, input, metadata, array, validation):
        syntax = metadata['syntax']
        
        validation['valid'] = True       # Innocent until proven guilty
        ##
        # First check if this is a required data element
        if metadata['required'] == True and not input:
            validation['invalid_message'] = 'This is a required field'
            validation['valid'] = False
            return False
        
        ##
        # Recursively run through all the elements of an array
        if array == True:
            if len(input) < metadata['minimum_elements']:
                validation['invalid_message'] = 'Minimum number of elements is ' + 'something'
                validation['valid'] = False
            elif len(input) > metadata['maximum_elements']:
                validation['invalid_message'] = 'Maximum number of elements is ' + 'something'
                validation['valid'] = False
            else:
                for element in array:
                    validation['valid'] = (validation['valid'] and 
                        self._is_valid_input(element, metadata, False, validation))
        ##
        # Run through all the possible syntax types
        elif syntax == 'ID':
            validation['valid'] = self._is_valid_id(input, validation)
        elif syntax == 'STRING':
            validation['valid'] = self._is_valid_string(input, metadata, validation)
        else:
            raise OPERATION_FAILED('no validation function available for ' + syntax)

        return validation['valid'] 

    def _is_valid_id(self, input, validation):
        from id_kit.abc_id.primitives import Id
        if isinstance(input, Id):
            return True
        else:
            validation['invalid_message'] = (str(metadata['min_string_length']) + 
                                             ' takes an osid.id.Id object.')
            return False

    def _is_valid_string(self, input, metadata, validation):
        if not isinstance(input, basestring):
            validation['invalid_message'] = (metadata['element_label'].get_text() +
                                             ' must be a string.')
            return False
        if len(input) < metadata['minimum_string_length']:
            validation['invalid_message'] = (metadata['element_label'].get_text() +
                ' must be at least ' + str(metadata['minimum_string_length']) + 
                ' characters long.')
            return False
        elif len(input) > metadata['maximum_string_length']:
            validation['invalid_message'] = (metadata['element_label'].get_text() +
                ' must be no more than ' + str(metadata['maximum_string_length']) + 
                ' characters long.')
            return False
        else:
            return True
"""

    is_for_update = """
        # Not implemented yet.
        return 'Perhaps'"""

    get_default_locale = """
        from locale_kit.dj_locale.objects import Locale
        # If no constructor arguments are given it is expected that the 
        # locale service will return the default Locale.
        return Locale()"""

    get_locales = """
        # Someday I might have a real implementation
        # For now only default Locale is supported
        return LocaleList([])"""

    set_locale = """
        # Someday I might have a real implementation
        # For now only default Locale is supported
        from osid_kit.osid_errors import UNSUPPORTED
        raise UNSUPPORTED()"""

    get_comment_metadata = """
        from osid_kit.dj_osid.metadata import Metadata
        return Metadata(**self._form_metadata['comment'])"""

    set_comment = """
        from osid_kit.osid_errors import INVALID_ARGUMENT, NULL_ARGUMENT, NO_ACCESS
        if not comment:
            raise NULL_ARGUMENT()
        if self._form_metadata['comment']['read_only']:
            raise NO_ACCESS()
        if not self._is_valid_string(comment, 
                                     self._form_metadata['comment'],
                                     self._form_validations['comment']):
            self._form_validations['comment']['valid'] = False
            raise INVALID_ARGUMENT()
        self._form_input['comment'] = comment"""

    is_valid = """
        # Note that this method has a side effect of loading the OsidForm's
        # private _form structure will validity information and is invoked
        # on every call to get_validation_message and get_validation_metadata.
        from osid_kit.osid_errors import OPERATION_FAILED
        valid = True
        for element in self._form_input:
            try:
                valid = valid and self._is_valid_input(
                                  self._form_input[element],
                                  self._form_metadata[element],
                                  self._form_metadata[element]['array'],
                                  self._form_validations[element],
                                  )
            except OPERATION_FAILED():
                raise
            self._form_validations[element]['valid'] = valid
        return valid"""

    get_validation_message = """
        messages = []
        if not self.is_valid(): # Note, this method call also assures that 
                                # the _form validation messages are up-to-date
            for element in self._form:
                if (self._form_validations[element]['valid'] and
                    self._form_validations[element]['invalid_message']):
                    messages.append(self._form_validations[element]['invalid_message'])
        return '. '.join(messages)"""

    get_invalid_metadata = """
        invalid_metadata = []
        if not self.is_valid(): # Note, this method call also assures that 
                                # all _form validation metadata is up-to-date
            for element in self._form_validations:
                if self._form_validations[element]['valid']:
                    invalid_metadata.append(self._form_metadata[element]['metadata'])
        return invalid_metadata"""

class OsidObjectForm:

    inheritance = ['OsidObject']

    ## THE FOLLOWING MAY WANT TO BE AN init_template:
    init = """

    _namespace = "dj_osid.OsidObjectForm"

    def __init__(self):
        from collections import OrderedDict
        self._form_input = OrderedDict()
        self._form_metadata = OrderedDict()
        self._form_validations = OrderedDict()
        self._init_form()

    ##
    # The _init_form method for the OsidObjectForm appends the form element
    # data to _form_input, _form_metadata and _form_validations.
    def _init_form(self):
        from osid_kit.dj_osid.object import OsidForm
        from collections import OrderedDict
        from id_kit.dj_id.primitives import Id
        from locale_kit.dj_locale.primitives import DisplayText
        ##
        # initialize the form data from the inherited object.
        OsidForm._init_form(self)

        self._form_input['comment'] = ''
        self._form_metadata['comment'] = {
                'element_id': Id(self._authority,
                                 self._namespace,
                                 'comment'),
                 'element_label': DisplayText('Comment for Submission'),
                 'instructions': DisplayText('Provide a brief comment if you would like.'),
                 'required': False,
                 'value': False,
                 'read_only': False,
                 'linked': False,
                 'syntax': 'STRING',
                 'array': False,
                 'minimum_string_length': 10,
                 'maximum_string_length': 256}
        self._form_validations['comment'] = {'valid': True,
                                            'invalid_message': True}
"""


class OsidList:

    init = """
    def __init__(self, iter_object = [], count = None):
    # If count is not provided calls to has_next and available may result in 
    # unnecessarily resolving all elements in iter_object.  This may or may
    # not be desirable from the standpoint of memory vs performance
    #
    # If performance is desired, an OsidList can be initialized with a python list
    # casting of the data, at the risk of filling up memory
    #
    # If memory management is paramount make sure to initialize with an 
    # appropriate iterable object (like a QuerySet) AND specify the count.

        self._iter_object = iter(iter_object)
        self._count = count

    def __iter__(self):
        return self

    def next(self):
        try:
            next_object = self._iter_object.next()
        except: 
            raise
        if self._count != None:
            self._count -= 1
        return next_object

    def len(self):
        return self.available()
"""

    has_next = """
        if self._count != None:
            # If count is available, use it
            return bool(self._count)
        else:
            # otherwise risk filling up memory
            return bool(len(list(self._iter_object)))"""

    available = """
        if self._count != None:
            # If count is available, use it
            return self._count
        else:
            # otherwise risk filling up memory
            return len(list(self._iter_object))
"""

class Metadata:

    init = """
    def __init__(self, element_id,
                       element_label,
                       instructions = '', 
                       required = None, 
                       value = None, # has_value boolean
                       read_only = None, 
                       linked = None, 
                       syntax = None, 
                       array = None,
                       units = None, 
                       minimum_elements = None, 
                       maximum_elements = None, 
                       min_cardinal = None, 
                       max_cardinal = None, 
                       cardinal_set = [], 
                       coordinate_set = [], 
                       coordinate_types = [], 
                       axes_for_coordinate_type = None, 
                       minimum_coordinate_values = [], 
                       maximum_coordinate_values = [], 
                       min_currency = None, 
                       max_currency = None, 
                       currency_set = [], 
                       currency_types = [], 
                       min_date_time = None, 
                       max_date_time = None, 
                       date_time_set = [], 
                       date_time_resolution = None, 
                       calendar_types = [], 
                       time_types = [], 
                       min_decimal = None, 
                       max_decimal = None, 
                       decimal_set = [], 
                       decimal_scale = None, 
                       min_duration = None, 
                       max_duration = None, 
                       duration_set = [], 
                       duration_unit_types = [], 
                       min_distance = None, 
                       max_distance = None, 
                       distance_set = [], 
                       distance_resolution = None, 
                       heading_set = [], 
                       heading_types = [], 
                       axes_for_heading_type = None, 
                       minimum_heading_values = [], 
                       maximum_heading_values = [], 
                       min_integer = None, 
                       max_integer = None, 
                       integer_set = [], 
                       spatial_unit_set = [], 
                       patial_unit_record_types = [], 
                       min_speed = None, 
                       max_speed = None, 
                       speed_set = [], 
                       minimum_string_length = None, 
                       maximum_string_length = None, 
                       string_set = [], 
                       string_match_types = [], 
                       string_format = None, 
                       min_time = None, 
                       max_time = None, 
                       time_set = [], 
                       time_resolution = None, 
                       id_set = [], 
                       type_set = [], 
                       max_version = None, 
                       min_version = None, 
                       version_set = [], 
                       object_types = []):

        self._element_id = element_id
        self._element_label = element_label
        self._instructions = instructions
        self._required = required
        self._value = value # has_value boolean
        self._read_only = read_only
        self._linked = linked
        self._syntax = syntax
        self._array = array
        self._units = units
        self._minimum_elements = minimum_elements
        self._maximum_elements = maximum_elements
        self._min_cardinal = min_cardinal
        self._max_cardinal = max_cardinal
        self._cardinal_set = cardinal_set
        self._coordinate_set = coordinate_set
        self._coordinate_types = coordinate_types
        self._axes_for_coordinate_type = axes_for_coordinate_type # This may be algorithm
        self._minimum_coordinate_values = minimum_coordinate_values 
        self._maximum_coordinate_values = maximum_coordinate_values 
        self._min_currency = min_currency
        self._max_currency = max_currency
        self._currency_set = currency_set
        self._currency_types = currency_types
        self._min_date_time = min_date_time
        self._max_date_time = max_date_time
        self._date_time_set = date_time_set
        self._date_time_resolution = date_time_resolution
        self._calendar_types = calendar_types
        self._time_types = time_types
        self._min_decimal = min_decimal
        self._max_decimal = max_decimal
        self._decimal_set = decimal_set
        self._decimal_scale = decimal_scale
        self._min_duration = min_duration
        self._max_duration = max_duration
        self._duration_set = duration_set
        self._duration_unit_types = duration_unit_types
        self._min_distance = min_distance
        self._max_distance = max_distance
        self._distance_set = distance_set
        self._distance_resolution = distance_resolution
        self._heading_set = heading_set
        self._heading_types = heading_types
        self._axes_for_heading_type = axes_for_heading_type # This may be an algorithm
        self._minimum_heading_values = minimum_heading_values
        self._maximum_heading_values = maximum_heading_values
        self._min_integer = min_integer
        self._max_integer = max_integer
        self._integer_set = integer_set
        self._spatial_unit_set = spatial_unit_set
        self._patial_unit_record_types = patial_unit_record_types
        self._min_speed = min_speed
        self._max_speed = max_speed
        self._speed_set = speed_set
        self._minimum_string_length = minimum_string_length
        self._maximum_string_length = maximum_string_length
        self._string_set = string_set
        self._string_match_types = string_match_types
        self._string_format = string_format
        self._min_time = min_time
        self._max_time = max_time
        self._time_set = time_set
        self._time_resolution = time_resolution
        self._id_set = id_set
        self._type_set = type_set
        self._max_version = max_version
        self._min_version = min_version
        self._version_set = version_set
        self._object_types = object_types
"""

    get_element_id_template = """
        # Implemented from template for osid.Metadata.get_element_id_template
        return self._${var_name}"""

    get_minimum_cardinal_template = """
        # Implemented from template for osid.Metadata.get_minimum_cardinal
        from osid_kit.osid_errors import ILLEGAL_STATE
        if self._syntax not in ${syntax_list}:
            raise ILLEGAL_STATE()
        else:
            return self._${var_name}"""

    supports_coordinate_type_template = """
        # Implemented from template for osid.Metadata.supports_coordinate_type
        from osid_kit.osid_errors import ILLEGAL_STATE, NULL_ARGUMENT
        if not ${arg0_name}:
            raise NULL_ARGUMENT('no input Type provided')
        if self._syntax not in ${syntax_list}:
            raise ILLEGAL_STATE('put more meaninful message here')

        result = False
        if self.get.${var_name} != []:
            for t in self.get.${var_name}:
                if (t.get_authority == ${arg0_name}.get_authority and
                    t.get_identifier_namespace == ${arg0_name}.get_identifier_namespace and
                    t.get_identifier == ${arg0_name}.get_identifier):
                    result = True
        return result"""
